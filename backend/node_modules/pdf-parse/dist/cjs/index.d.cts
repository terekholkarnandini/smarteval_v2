import { Metadata } from 'pdfjs-dist/types/src/display/metadata.js';
import { ImageKind } from 'pdfjs-dist/legacy/build/pdf.mjs';
import { DocumentInitParameters } from 'pdfjs-dist/types/src/display/api.js';

interface InfoResult {
    total: number;
    info?: object;
    metadata?: Metadata;
}

interface TextResult extends InfoResult {
    pages: Array<PageTextResult>;
    text: string;
    getPageText(num: number): string;
}
interface PageTextResult {
    num: number;
    text: string;
}

/**
 * ImageKindKey
 * - Represents the keys of the ImageKind enum (e.g. "GRAYSCALE_1BPP", "RGB_24BPP", "RGBA_32BPP").
 */
type ImageKindKey = keyof typeof ImageKind;
/**
 * ImageKindValue
 * - Represents the numeric values of the ImageKind enum (e.g. 1, 2, 3).
 */
type ImageKindValue = (typeof ImageKind)[ImageKindKey];
/**
 * ImageResult
 * - Main result type for image extraction.
 * - Extends InfoResult and contains an array of PageImages.
 */
interface ImageResult extends InfoResult {
    pages: PageImages[];
    getPageImage(num: number, name: string): EmbeddedImage | null;
}
/**
 * PageImages
 * - Represents all embedded images found on a single PDF page.
 * - pageNumber: 1-based page index.
 * - images: Array of EmbeddedImage objects for this page.
 */
interface PageImages {
    pageNumber: number;
    images: EmbeddedImage[];
}
/**
 * EmbeddedImage
 * - Normalized representation of an embedded image extracted from the PDF.
 * - `data`: Raw image bytes (e.g. PNG/JPEG) as Uint8Array. Use this for file writing or binary processing.
 * - `dataUrl`: Optional data URL (e.g. "data:image/png;base64,...") for directly embedding in <img> src.
 *   Storing both lets consumers choose the most convenient form; consider omitting one to save memory.
 * - `fileName`: Suggested filename or resource name for the image (used when saving to disk).
 * - `width` / `height`: Dimensions in pixels.
 * - `kind`: ImageKindValue from pdfjs-dist indicating the pixel format (e.g. GRAYSCALE_1BPP / RGB_24BPP / RGBA_32BPP).
 */
interface EmbeddedImage {
    data: Uint8Array;
    dataUrl: string;
    fileName: string;
    width: number;
    height: number;
    kind: ImageKindValue;
}

interface PageToImageResult extends InfoResult {
    pages: PageToImage[];
}
interface PageToImage {
    data: Uint8Array;
    dataUrl: string;
    pageNumber: number;
}

interface ParseOptions extends DocumentInitParameters {
    partial?: boolean;
    first?: number;
    last?: number;
}

interface TableResult extends InfoResult {
    pages: Array<PageTableResult>;
    mergedTables: Array<Array<string>>;
}
interface PageTableResult {
    num: number;
    tables: Array<Array<string>>;
}

declare class PDFParse {
    private readonly options;
    private doc;
    constructor(options: ParseOptions);
    GetText(): Promise<TextResult>;
    private load;
    private shouldParse;
    private getPageText;
    GetImage(): Promise<ImageResult>;
    private convertToRGBA;
    private resolveEmbeddedImage;
    PageToImage(): Promise<PageToImageResult>;
    GetTable(): Promise<TableResult>;
    private getPathGeometry;
    private getPageTables;
    private getPageGeometry;
    private fillPageTables;
}

type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
/**
 * The URL of the PDF.
 * -
 * Binary PDF data.
 * Use TypedArrays (Uint8Array) to improve the memory usage. If PDF data is
 * BASE64-encoded, use `atob()` to convert it to a binary string first.
 *
 * NOTE: If TypedArrays are used they will generally be transferred to the
 * worker-thread. This will help reduce main-thread memory usage, however
 * it will take ownership of the TypedArrays.
 */
declare function pdf(data: string | URL | number[] | ArrayBuffer | TypedArray): Promise<TextResult>;

export { PDFParse, pdf };
export type { TypedArray };
