'use strict';

const pdfjs = require('pdfjs-dist/legacy/build/pdf.mjs');

function _interopNamespaceDefault(e) {
    const n = Object.create(null);
    if (e) {
        for (const k in e) {
            n[k] = e[k];
        }
    }
    n.default = e;
    return n;
}

const pdfjs__namespace = /*#__PURE__*/_interopNamespaceDefault(pdfjs);

class Shape {
  static tolerance = 2;
  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }
}

class Point extends Shape {
  x;
  y;
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
  }
  equal(point) {
    return point.x === this.x && point.y === this.y;
  }
  transform(matrix) {
    const p = Shape.applyTransform([this.x, this.y], matrix);
    this.x = p[0];
    this.y = p[1];
    return this;
  }
}

var LineDirection = /* @__PURE__ */ ((LineDirection2) => {
  LineDirection2[LineDirection2["None"] = 0] = "None";
  LineDirection2[LineDirection2["Horizontal"] = 1] = "Horizontal";
  LineDirection2[LineDirection2["Vertical"] = 2] = "Vertical";
  return LineDirection2;
})(LineDirection || {});
class Line extends Shape {
  from;
  to;
  direction = 0 /* None */;
  length = 0;
  intersections = [];
  gaps = [];
  constructor(from, to) {
    super();
    this.from = from;
    this.to = to;
    this.init();
  }
  init() {
    let from = this.from;
    let to = this.to;
    if (Math.abs(from.y - to.y) < Shape.tolerance) {
      this.direction = 1 /* Horizontal */;
      to.y = from.y;
      if (from.x > to.x) {
        const temp = from;
        from = to;
        to = temp;
      }
      this.length = to.x - from.x;
    } else if (Math.abs(from.x - to.x) < Shape.tolerance) {
      this.direction = 2 /* Vertical */;
      to.x = from.x;
      if (from.y > to.y) {
        const temp = from;
        from = to;
        to = temp;
      }
      this.length = to.y - from.y;
    }
    this.from = from;
    this.to = to;
  }
  _valid = void 0;
  get valid() {
    if (this._valid === void 0) {
      this._valid = this.direction !== 0 /* None */ && this.length > Shape.tolerance;
    }
    return this._valid;
  }
  get normalized() {
    if (this.direction === 1 /* Horizontal */) {
      return new Line(new Point(this.from.x - Shape.tolerance, this.from.y), new Point(this.to.x + Shape.tolerance, this.from.y));
    } else if (this.direction === 2 /* Vertical */) {
      return new Line(new Point(this.from.x, this.from.y - Shape.tolerance), new Point(this.from.x, this.to.y + Shape.tolerance));
    }
    return this;
  }
  addGap(line) {
    this.gaps.push(line);
  }
  containsPoint(p) {
    if (this.direction === 2 /* Vertical */) {
      return this.from.x === p.x && p.y >= this.from.y && p.y <= this.to.y;
    } else if (this.direction === 1 /* Horizontal */) {
      return this.from.y === p.y && p.x >= this.from.x && p.x <= this.to.x;
    }
    return false;
  }
  // // todo implement
  // public containsLine(l:Line):boolean{
  //     if(this.direction === LineDirection.Vertical && l.direction === LineDirection.Vertical){
  //         return this.from.x === l.from.x
  //     }
  //     else if(this.direction === LineDirection.Horizontal && l.direction === LineDirection.Horizontal){
  //         return this.from.y === l.from.y
  //     }
  //     return false
  // }
  addIntersectionPoint(point) {
    for (const intPoint of this.intersections) {
      if (intPoint.equal(point)) return;
    }
    this.intersections.push(point);
  }
  intersection(line) {
    let result;
    if (!this.valid || !line.valid) {
      return result;
    }
    const thisNormalized = this.normalized;
    const lineNormalized = line.normalized;
    if (this.direction === 1 /* Horizontal */ && line.direction === 2 /* Vertical */) {
      const x = lineNormalized.from.x;
      const y = thisNormalized.from.y;
      const isOk = x > thisNormalized.from.x && x < thisNormalized.to.x && y > lineNormalized.from.y && y < lineNormalized.to.y;
      if (isOk) {
        const intPoint = new Point(x, y);
        this.addIntersectionPoint(intPoint);
        line.addIntersectionPoint(intPoint);
        result = intPoint;
      }
    } else if (this.direction === 2 /* Vertical */ && line.direction === 1 /* Horizontal */) {
      const x = thisNormalized.from.x;
      const y = lineNormalized.from.y;
      const isOk = x > lineNormalized.from.x && x < lineNormalized.to.x && y > thisNormalized.from.y && y < thisNormalized.to.y;
      if (isOk) {
        const intPoint = new Point(x, y);
        this.addIntersectionPoint(intPoint);
        line.addIntersectionPoint(intPoint);
        result = intPoint;
      }
    }
    return result;
  }
  transform(matrix) {
    const p1 = this.from.transform(matrix);
    const p2 = this.to.transform(matrix);
    const x = Math.min(p1.x, p2.x);
    const y = Math.min(p1.y, p2.y);
    const width = Math.abs(p1.x - p2.x);
    const height = Math.abs(p1.y - p2.y);
    this.from = new Point(x, y);
    this.to = new Point(x + width, y + height);
    this.init();
    return this;
  }
}

class TableData {
  minXY;
  maxXY;
  rows;
  rowPivots;
  colPivots;
  constructor(minXY, maxXY, rowPivots, colPivots) {
    this.minXY = minXY;
    this.maxXY = maxXY;
    this.rows = [];
    this.rowPivots = rowPivots;
    this.colPivots = colPivots;
  }
  findCell(x, y) {
    if (x >= this.minXY.x && y >= this.minXY.y && x <= this.maxXY.x && y <= this.maxXY.y) {
      for (const row of this.rows) {
        for (const cell of row) {
          if (cell.minXY.x <= x && cell.minXY.y <= y && cell.maxXY.x >= x && cell.maxXY.y >= y) {
            return cell;
          }
        }
      }
    }
    return void 0;
  }
  get cellCount() {
    return this.rows.reduce((acc, row) => acc + row.length, 0);
  }
  get rowCount() {
    return this.rows.length;
  }
  check() {
    const virtualCellCount = (this.colPivots.length - 1) * (this.rowPivots.length - 1);
    let allCellCount = 0;
    for (const row of this.rows) {
      for (const cell of row) {
        const count = (cell.colspan || 1) * (cell.rowspan || 1);
        allCellCount += count;
      }
    }
    if (virtualCellCount !== allCellCount) {
      return false;
    }
    return true;
  }
  toArray() {
    const tableArr = [];
    for (const row of this.rows) {
      const rowArr = [];
      for (const cell of row) {
        let text = cell.text.join("");
        text = text.replace(/^[\s]+|[\s]+$/g, "");
        text = text.trim();
        rowArr.push(text);
      }
      tableArr.push(rowArr);
    }
    return tableArr;
  }
}

class Table {
  hLines = [];
  vLines = [];
  constructor(line) {
    if (line.direction === LineDirection.Horizontal) {
      this.hLines.push(line);
    } else if (line.direction === LineDirection.Vertical) {
      this.vLines.push(line);
    }
  }
  get isValid() {
    return this.hLines.length + this.vLines.length > 4;
  }
  get rowPivots() {
    const rowSet = /* @__PURE__ */ new Set();
    for (const line of this.hLines) {
      rowSet.add(line.from.y);
    }
    return [...rowSet].sort((a, b) => a - b);
  }
  get colPivots() {
    const colSet = /* @__PURE__ */ new Set();
    for (const line of this.vLines) {
      colSet.add(line.from.x);
    }
    return [...colSet].sort((a, b) => a - b);
  }
  add(line) {
    const hasIntersection = this.intersection(line);
    if (hasIntersection) {
      if (line.direction === LineDirection.Horizontal) {
        this.hLines.push(line);
        return true;
      } else if (line.direction === LineDirection.Vertical) {
        this.vLines.push(line);
        return true;
      }
    }
    return false;
  }
  intersection(line) {
    let flag = false;
    if (!line.valid) return flag;
    if (line.direction === LineDirection.Horizontal) {
      for (const vLine of this.vLines) {
        const p = line.intersection(vLine);
        if (p) {
          flag = true;
        }
      }
    } else if (line.direction === LineDirection.Vertical) {
      for (const hLine of this.hLines) {
        const p = line.intersection(hLine);
        if (p) {
          flag = true;
        }
      }
    }
    return flag;
  }
  getSameHorizontal(line) {
    const same = [line];
    const other = [];
    while (this.hLines.length > 0) {
      const hLine = this.hLines.shift();
      if (!hLine) continue;
      if (hLine.from.y === line.from.y) {
        same.push(hLine);
      } else {
        other.push(hLine);
      }
    }
    this.hLines = other;
    return same;
  }
  getSameVertical(line) {
    const same = [line];
    const other = [];
    while (this.vLines.length > 0) {
      const vLine = this.vLines.shift();
      if (!vLine) continue;
      if (vLine.from.x === line.from.x) {
        same.push(vLine);
      } else {
        other.push(vLine);
      }
    }
    this.vLines = other;
    return same;
  }
  mergeHorizontalLines(lines) {
    lines.sort((l1, l2) => l1.from.x - l2.from.x);
    const minX = lines[0].from.x;
    const maxX = lines[lines.length - 1].to.x;
    const resultLine = new Line(new Point(minX, lines[0].from.y), new Point(maxX, lines[0].from.y));
    for (let i = 1; i < lines.length; i++) {
      const prevLine = lines[i - 1];
      const currLine = lines[i];
      if (Math.abs(prevLine.to.x - currLine.from.x) > Shape.tolerance) {
        const gapLine = new Line(new Point(prevLine.to.x, prevLine.from.y), new Point(currLine.from.x, currLine.from.y));
        resultLine.addGap(gapLine);
      }
    }
    return resultLine;
  }
  mergeVerticalLines(lines) {
    lines.sort((l1, l2) => l1.from.y - l2.from.y);
    const minY = lines[0].from.y;
    const maxY = lines[lines.length - 1].to.y;
    const resultLine = new Line(new Point(lines[0].from.x, minY), new Point(lines[0].from.x, maxY));
    for (let i = 1; i < lines.length; i++) {
      const prevLine = lines[i - 1];
      const currLine = lines[i];
      if (Math.abs(prevLine.to.y - currLine.from.y) > Shape.tolerance) {
        const gapLine = new Line(new Point(prevLine.to.x, prevLine.to.y), new Point(prevLine.to.x, currLine.from.y));
        resultLine.addGap(gapLine);
      }
    }
    return resultLine;
  }
  normalize() {
    this.hLines = this.hLines.filter((l) => l.intersections.length > 1);
    this.vLines = this.vLines.filter((l) => l.intersections.length > 1);
    this.hLines.sort((l1, l2) => l1.from.y - l2.from.y);
    this.vLines.sort((l1, l2) => l1.from.x - l2.from.x);
    const newHLines = [];
    while (this.hLines.length > 0) {
      const line = this.hLines.shift();
      if (!line) continue;
      const lines = this.getSameHorizontal(line);
      const merged = this.mergeHorizontalLines(lines);
      newHLines.push(merged);
    }
    this.hLines = newHLines;
    const newVLines = [];
    while (this.vLines.length > 0) {
      const line = this.vLines.shift();
      if (!line) continue;
      const lines = this.getSameVertical(line);
      const merged = this.mergeVerticalLines(lines);
      newVLines.push(merged);
    }
    this.vLines = newVLines;
  }
  verticalExists(line, y1, y2) {
    if (line.direction !== LineDirection.Vertical) {
      throw new Error("Line is not vertical");
    }
    if (y1 >= y2) {
      throw new Error("y1 must be less than y2");
    }
    if (line.from.y <= y1 && line.to.y >= y2) {
      for (const gap of line.gaps) {
        if (gap.from.y <= y1 && gap.to.y >= y2) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  horizontalExists(line, x1, x2) {
    if (line.direction !== LineDirection.Horizontal) {
      throw new Error("Line is not horizontal");
    }
    if (x1 >= x2) {
      throw new Error("x1 must be less than x2");
    }
    if (line.from.x <= x1 && line.to.x >= x2) {
      for (const gap of line.gaps) {
        if (gap.from.x <= x1 && gap.to.x >= x2) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  findBottomLineIndex(h2Index, xMiddle) {
    for (let i = h2Index; i < this.hLines.length; i++) {
      const hLine = this.hLines[i];
      if (hLine.from.x <= xMiddle && hLine.to.x >= xMiddle) {
        return i;
      }
    }
    return -1;
  }
  findVerticalLineIndexs(topHLine, yMiddle) {
    const result = [];
    for (let i = 0; i < this.vLines.length; i++) {
      const vLine = this.vLines[i];
      if (vLine.from.y <= yMiddle && vLine.to.y >= yMiddle && topHLine.intersection(vLine)) {
        result.push(i);
      }
    }
    return result;
  }
  getRow(h1Index, h2Index, yMiddle) {
    const tableRow = [];
    const topHLine = this.hLines[h1Index];
    const vLineIndexes = this.findVerticalLineIndexs(topHLine, yMiddle);
    for (let i = 1; i < vLineIndexes.length; i++) {
      const leftVLine = this.vLines[vLineIndexes[i - 1]];
      const rightVLine = this.vLines[vLineIndexes[i]];
      const xMiddle = (leftVLine.from.x + rightVLine.from.x) / 2;
      const bottomHLineIndex = this.findBottomLineIndex(h2Index, xMiddle);
      const bottomHLine = this.hLines[bottomHLineIndex];
      const tableCell = {
        minXY: new Point(leftVLine.from.x, topHLine.from.y),
        maxXY: new Point(rightVLine.from.x, bottomHLine.from.y),
        width: rightVLine.from.x - leftVLine.from.x,
        height: bottomHLine.from.y - topHLine.from.y,
        text: []
      };
      const colSpan = vLineIndexes[i] - vLineIndexes[i - 1];
      const rowSpan = bottomHLineIndex - h1Index;
      if (colSpan > 1) {
        tableCell.colspan = colSpan;
      }
      if (rowSpan > 1) {
        tableCell.rowspan = rowSpan;
      }
      tableRow.push(tableCell);
    }
    return tableRow;
  }
  toData() {
    const rowPivots = this.rowPivots;
    const colPivots = this.colPivots;
    const minXY = new Point(colPivots[0], rowPivots[0]);
    const maxXY = new Point(colPivots[colPivots.length - 1], rowPivots[rowPivots.length - 1]);
    const result = new TableData(minXY, maxXY, rowPivots, colPivots);
    for (let h1 = 1; h1 < this.hLines.length; h1++) {
      const prevHLine = this.hLines[h1 - 1];
      const currHLine = this.hLines[h1];
      const YMiddle = (prevHLine.from.y + currHLine.from.y) / 2;
      const rowData = this.getRow(h1 - 1, h1, YMiddle);
      result.rows.push(rowData);
    }
    return result;
  }
}

class LineStore {
  hLines = [];
  vLines = [];
  add(line) {
    if (line.valid) {
      if (line.direction === LineDirection.Horizontal) {
        this.hLines.push(line);
      } else if (line.direction === LineDirection.Vertical) {
        this.vLines.push(line);
      }
    }
  }
  addRectangle(rect) {
    for (const line of rect.getLines()) {
      this.add(line);
    }
  }
  getTableData() {
    const result = [];
    const tables = this.getTables();
    for (const table of tables) {
      const data = table.toData();
      if (data) {
        result.push(data);
      }
    }
    return result;
  }
  getTables() {
    const result = [];
    while (this.hLines.length !== 0) {
      const hLine = this.hLines.shift();
      if (!hLine) continue;
      const filled = this.tryFill(result, hLine);
      if (filled) continue;
      const table = new Table(hLine);
      this.fillTable(table);
      result.push(table);
    }
    while (this.vLines.length !== 0) {
      const vLine = this.vLines.shift();
      if (!vLine) continue;
      const filled = this.tryFill(result, vLine);
      if (filled) continue;
      const table = new Table(vLine);
      this.fillTable(table);
      result.push(table);
    }
    const validTables = result.filter((t) => t.isValid);
    for (const table of validTables) {
      table.normalize();
    }
    return validTables;
  }
  normalize() {
    this.normalizeHorizontal();
    this.normalizeVertical();
  }
  normalizeHorizontal() {
    this.hLines.sort((l1, l2) => l1.from.y - l2.from.y);
    const newLines = [];
    let sameY = [];
    for (const line of this.hLines) {
      if (sameY.length === 0) {
        sameY.push(line);
      } else if (Math.abs(sameY[0]?.from.y - line.from.y) < Shape.tolerance) {
        sameY.push(line);
      } else {
        const merged = this.margeHorizontalLines(sameY);
        newLines.push(...merged);
        sameY = [line];
      }
    }
    if (sameY.length > 0) {
      const merged = this.margeHorizontalLines(sameY);
      newLines.push(...merged);
    }
    this.hLines = newLines;
  }
  normalizeVertical() {
    this.vLines.sort((l1, l2) => l1.from.x - l2.from.x);
    const newLines = [];
    let sameX = [];
    for (const line of this.vLines) {
      if (sameX.length === 0) {
        sameX.push(line);
      } else if (Math.abs(sameX[0]?.from.x - line.from.x) < Shape.tolerance) {
        sameX.push(line);
      } else {
        const merged = this.margeVerticalLines(sameX);
        newLines.push(...merged);
        sameX = [line];
      }
    }
    if (sameX.length > 0) {
      const merged = this.margeVerticalLines(sameX);
      newLines.push(...merged);
    }
    this.vLines = newLines;
  }
  fillTable(table) {
    const newVLines = [];
    const newHLines = [];
    for (const vLine of this.vLines) {
      if (!table.add(vLine)) {
        newVLines.push(vLine);
      }
    }
    for (const hLine of this.hLines) {
      if (!table.add(hLine)) {
        newHLines.push(hLine);
      }
    }
    this.hLines = newHLines;
    this.vLines = newVLines;
  }
  tryFill(tables, line) {
    for (const table of tables) {
      if (table.add(line)) {
        this.fillTable(table);
        return true;
      }
    }
    return false;
  }
  margeHorizontalLines(sameYLines) {
    const result = [];
    sameYLines.sort((l1, l2) => l1.from.x - l2.from.x);
    const sameY = sameYLines[0]?.from.y;
    if (sameY === void 0) return result;
    let minX = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    for (const line of sameYLines) {
      if (line.from.x - maxX < Shape.tolerance) {
        if (line.from.x < minX) {
          minX = line.from.x;
        }
        if (line.to.x > maxX) {
          maxX = line.to.x;
        }
      } else {
        if (maxX > minX) {
          result.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));
        }
        minX = line.from.x;
        maxX = line.to.x;
      }
    }
    const last = result[result.length - 1];
    if (last) {
      if (last.from.x !== minX && last.to.x !== maxX) {
        result.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));
      }
    } else {
      result.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));
    }
    return result;
  }
  margeVerticalLines(sameXLines) {
    const result = [];
    sameXLines.sort((l1, l2) => l1.from.y - l2.from.y);
    const sameX = sameXLines[0]?.from.x;
    if (sameX === void 0) return result;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    for (const line of sameXLines) {
      if (line.from.y - maxY < Shape.tolerance) {
        if (line.from.y < minY) {
          minY = line.from.y;
        }
        if (line.to.y > maxY) {
          maxY = line.to.y;
        }
      } else {
        if (maxY > minY) {
          result.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));
        }
        minY = line.from.y;
        maxY = line.to.y;
      }
    }
    const last = result[result.length - 1];
    if (last) {
      if (last.from.y !== minY && last.to.y !== maxY) {
        result.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));
      }
    } else {
      result.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));
    }
    return result;
  }
}

class Rectangle extends Shape {
  from;
  width;
  height;
  constructor(from, width, height) {
    super();
    this.from = from;
    this.width = width;
    this.height = height;
  }
  get to() {
    return new Point(this.from.x + this.width, this.from.y + this.height);
  }
  getLines() {
    const to = this.to;
    const lines = [
      new Line(this.from, new Point(to.x, this.from.y)),
      new Line(this.from, new Point(this.from.x, to.y)),
      new Line(new Point(to.x, this.from.y), to),
      new Line(new Point(this.from.x, to.y), to)
    ];
    return lines.filter((l) => l.valid);
  }
  transform(matrix) {
    const p1 = Shape.applyTransform([this.from.x, this.from.y], matrix);
    const p2 = Shape.applyTransform([this.from.x + this.width, this.from.y + this.height], matrix);
    const x = Math.min(p1[0], p2[0]);
    const y = Math.min(p1[1], p2[1]);
    const width = Math.abs(p1[0] - p2[0]);
    const height = Math.abs(p1[1] - p2[1]);
    this.from = new Point(x, y);
    this.width = width;
    this.height = height;
    return this;
  }
}

const ImageResultDefault = {
  getPageImage(num, name) {
    for (const pageData of this.pages) {
      if (pageData.pageNumber === num) {
        for (const img of pageData.images) {
          if (img.fileName === name) {
            return img;
          }
        }
      }
    }
    return null;
  },
  pages: [],
  total: 0,
  info: void 0,
  metadata: void 0
};

var PathGeometry = /* @__PURE__ */ ((PathGeometry2) => {
  PathGeometry2[PathGeometry2["undefined"] = 0] = "undefined";
  PathGeometry2[PathGeometry2["hline"] = 1] = "hline";
  PathGeometry2[PathGeometry2["vline"] = 2] = "vline";
  PathGeometry2[PathGeometry2["rectangle"] = 3] = "rectangle";
  return PathGeometry2;
})(PathGeometry || {});

const TextResultDefault = {
  getPageText(num) {
    for (const pageData of this.pages) {
      if (pageData.num === num) return pageData.text;
    }
    return "";
  },
  pages: [],
  total: 0,
  text: "",
  info: void 0,
  metadata: void 0
};

if (typeof globalThis.pdfjs === "undefined") {
  globalThis.pdfjs = pdfjs__namespace;
}
if (typeof window !== "undefined" && typeof document !== "undefined") {
  let workerUrl;
  if (typeof require !== "undefined") {
    workerUrl = require("pdfjs-dist/build/pdf.worker.min.mjs");
    if (pdfjs__namespace?.GlobalWorkerOptions && !pdfjs__namespace.GlobalWorkerOptions.workerSrc) {
      pdfjs__namespace.GlobalWorkerOptions.workerSrc = workerUrl;
    }
  } else {
    (async () => {
      const workerModule = await import('pdfjs-dist/build/pdf.worker.min.mjs?url');
      workerUrl = workerModule.default || workerModule;
      if (pdfjs__namespace?.GlobalWorkerOptions && !pdfjs__namespace.GlobalWorkerOptions.workerSrc) {
        pdfjs__namespace.GlobalWorkerOptions.workerSrc = workerUrl;
      }
    })();
  }
}
class PDFParse {
  options;
  doc;
  constructor(options) {
    if (typeof options.data === "object" && "buffer" in options.data) {
      options.data = new Uint8Array(options.data);
    }
    options.verbosity = pdfjs__namespace.VerbosityLevel.ERRORS;
    this.options = options;
  }
  async GetText() {
    const result = { ...TextResultDefault };
    const infoData = await this.load();
    Object.assign(result, infoData);
    if (this.doc === void 0) {
      throw new Error("PDF document not loaded");
    }
    for (let i = 1; i <= result.total; i++) {
      if (this.shouldParse(i, result.total)) {
        const pageProxy = await this.doc.getPage(i);
        const text = await this.getPageText(pageProxy);
        result.pages.push({
          text,
          num: i
        });
        pageProxy.cleanup();
      }
    }
    await this.doc.destroy();
    this.doc = void 0;
    for (const page of result.pages) {
      result.text += `${page.text}

`;
    }
    return result;
  }
  async load() {
    const opts = { ...this.options };
    if (this.options.data instanceof Uint8Array) {
      opts.data = new Uint8Array(this.options.data);
    }
    const loadingTask = pdfjs__namespace.getDocument(opts);
    this.doc = await loadingTask.promise;
    const data = await this.doc.getMetadata();
    return {
      total: this.doc.numPages,
      info: data.info,
      metadata: data.metadata
    };
  }
  shouldParse(currentPage, totalPage) {
    let parseFlag = false;
    if (this.options.partial) {
      if (this.options.first && currentPage <= this.options.first) {
        parseFlag = true;
      }
      if (!parseFlag) {
        if (this.options.last && currentPage > totalPage - this.options.last) {
          parseFlag = true;
        }
      }
    } else {
      parseFlag = true;
    }
    return parseFlag;
  }
  async getPageText(page) {
    const textContent = await page.getTextContent({
      includeMarkedContent: false,
      disableNormalization: false
    });
    const strBuf = [];
    for (const item of textContent.items) {
      if (!("str" in item)) continue;
      strBuf.push(item.str);
      if (item.hasEOL) {
        strBuf.push("\n");
      }
    }
    return strBuf.join("");
  }
  async GetImage() {
    const result = { ...ImageResultDefault };
    const infoData = await this.load();
    Object.assign(result, infoData);
    if (this.doc === void 0) {
      throw new Error("PDF document not loaded");
    }
    for (let i = 1; i <= result.total; i++) {
      if (this.shouldParse(i, result.total)) {
        const page = await this.doc.getPage(i);
        const ops = await page.getOperatorList();
        const pageImages = { pageNumber: i, images: [] };
        result.pages.push(pageImages);
        for (let j = 0; j < ops.fnArray.length; j++) {
          if (ops.fnArray[j] === pdfjs__namespace.OPS.paintInlineImageXObject || ops.fnArray[j] === pdfjs__namespace.OPS.paintImageXObject) {
            const name = ops.argsArray[j][0];
            const isCommon = page.commonObjs.has(name);
            const imgPromise = isCommon ? this.resolveEmbeddedImage(page.commonObjs, name) : this.resolveEmbeddedImage(page.objs, name);
            const { width, height, kind, data } = await imgPromise;
            const canvasFactory = this.doc.canvasFactory;
            const canvasAndContext = canvasFactory.create(width, height);
            const context = canvasAndContext.context;
            let imgData = null;
            if (kind === pdfjs__namespace.ImageKind.RGBA_32BPP) {
              imgData = context.createImageData(width, height);
              imgData.data.set(data);
            } else {
              imgData = context.createImageData(width, height);
              this.convertToRGBA({
                src: data,
                dest: new Uint32Array(imgData.data.buffer),
                width,
                height,
                kind
              });
            }
            context.putImageData(imgData, 0, 0);
            const buff = canvasAndContext.canvas.toBuffer("image/png");
            const base64 = buff.toString("base64");
            const dataUrl = `data:image/png;base64,${base64}`;
            pageImages.images.push({
              data: buff,
              dataUrl,
              fileName: name,
              height,
              width,
              kind
            });
          }
        }
      }
    }
    await this.doc.destroy();
    this.doc = void 0;
    return result;
  }
  convertToRGBA({ src, dest, width, height, kind }) {
    if (kind === pdfjs__namespace.ImageKind.RGB_24BPP) {
      for (let i = 0, j = 0; i < src.length; i += 3, j++) {
        const r = src[i];
        const g = src[i + 1];
        const b = src[i + 2];
        dest[j] = 255 << 24 | b << 16 | g << 8 | r;
      }
    } else if (kind === pdfjs__namespace.ImageKind.GRAYSCALE_1BPP) {
      let pixelIndex = 0;
      for (let i = 0; i < src.length; i++) {
        const byte = src[i];
        for (let bit = 7; bit >= 0; bit--) {
          if (pixelIndex >= width * height) break;
          const isWhite = (byte >> bit & 1) === 1;
          const gray = isWhite ? 255 : 0;
          dest[pixelIndex++] = 255 << 24 | gray << 16 | gray << 8 | gray;
        }
      }
    } else {
      throw new Error(`convertToRGBA: Unsupported image kind: ${kind}`);
    }
  }
  resolveEmbeddedImage(pdfObjects, name) {
    return new Promise((resolve, reject) => {
      pdfObjects.get(name, (imgData) => {
        if (imgData) {
          const dataBuff = new Uint8Array(imgData.data);
          resolve({ width: imgData.width, height: imgData.height, kind: imgData.kind, data: dataBuff });
        } else {
          reject(new Error(`Image object ${name} not found`));
        }
      });
    });
  }
  async PageToImage() {
    const result = { pages: [], total: 0 };
    const infoData = await this.load();
    Object.assign(result, infoData);
    if (this.doc === void 0) {
      throw new Error("PDF document not loaded");
    }
    for (let i = 1; i <= result.total; i++) {
      if (this.shouldParse(i, result.total)) {
        const page = await this.doc.getPage(i);
        const canvasFactory = this.doc.canvasFactory;
        const viewport = page.getViewport({ scale: 1 });
        const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);
        const renderContext = {
          canvasContext: canvasAndContext.context,
          viewport,
          canvas: canvasAndContext.canvas
        };
        const renderTask = page.render(renderContext);
        await renderTask.promise;
        const data = canvasAndContext.canvas.toBuffer("image/png");
        const base64 = data.toString("base64");
        const dataUrl = `data:image/png;base64,${base64}`;
        result.pages.push({
          data,
          dataUrl,
          pageNumber: i
        });
        page.cleanup();
      }
    }
    await this.doc.destroy();
    this.doc = void 0;
    return result;
  }
  async GetTable() {
    const infoData = await this.load();
    const result = { ...infoData, pages: [], mergedTables: [] };
    if (this.doc === void 0) {
      throw new Error("PDF document not loaded");
    }
    for (let i = 1; i <= result.total; i++) {
      if (this.shouldParse(i, result.total)) {
        const page = await this.doc.getPage(i);
        page.getViewport({ scale: 1 });
        const store = await this.getPageTables(page);
        store.normalize();
        const tableDataArr = store.getTableData();
        await this.fillPageTables(page, tableDataArr);
        for (const table of tableDataArr) {
          const pageTableResult = { num: i, tables: table.toArray() };
          result.pages.push(pageTableResult);
        }
        page.cleanup();
      }
    }
    await this.doc.destroy();
    return result;
  }
  getPathGeometry(mm) {
    const width = mm[2] - mm[0];
    const height = mm[3] - mm[1];
    if (mm[0] === Infinity) {
      return PathGeometry.undefined;
    }
    if (width > 5 && height > 5) {
      return PathGeometry.rectangle;
    } else if (width > 5 && height === 0) {
      return PathGeometry.hline;
    } else if (width === 0 && height > 5) {
      return PathGeometry.vline;
    }
    return PathGeometry.undefined;
  }
  async getPageTables(page) {
    const lineStore = new LineStore();
    const viewport = page.getViewport({ scale: 1 });
    let transformMatrix = [1, 0, 0, 1, 0, 0];
    const transformStack = [];
    const opList = await page.getOperatorList();
    for (let i = 0; i < opList.fnArray.length; i++) {
      const fn = opList.fnArray[i];
      const args = opList.argsArray[i];
      const op = args?.[0] ?? 0;
      const mm = args?.[2] ?? [Infinity, Infinity, -Infinity, -Infinity];
      if (fn === pdfjs__namespace.OPS.constructPath) {
        if (op === pdfjs__namespace.OPS.fill) ;
        if (op !== pdfjs__namespace.OPS.stroke) {
          continue;
        }
        const pg = this.getPathGeometry(mm);
        if (pg === PathGeometry.rectangle) {
          const rect = new Rectangle(new Point(mm[0], mm[1]), mm[2] - mm[0], mm[3] - mm[1]);
          rect.transform(transformMatrix);
          rect.transform(viewport.transform);
          lineStore.addRectangle(rect);
        } else if (pg === PathGeometry.hline || pg === PathGeometry.vline) {
          const from = new Point(mm[0], mm[1]);
          const to = new Point(mm[2], mm[3]);
          const line = new Line(from, to);
          line.transform(transformMatrix);
          line.transform(viewport.transform);
          lineStore.add(line);
        } else {
          debugger;
        }
      } else if (fn === pdfjs__namespace.OPS.setLineWidth) {
        debugger;
      } else if (fn === pdfjs__namespace.OPS.save) {
        transformStack.push(transformMatrix);
      } else if (fn === pdfjs__namespace.OPS.restore) {
        const restoredMatrix = transformStack.pop();
        if (restoredMatrix) {
          transformMatrix = restoredMatrix;
        }
      } else if (fn === pdfjs__namespace.OPS.transform) {
        transformMatrix = pdfjs__namespace.Util.transform(transformMatrix, args);
      }
    }
    return lineStore;
  }
  async getPageGeometry(page) {
    const lineStore = new LineStore();
    const opList = await page.getOperatorList();
    const viewport = page.getViewport({ scale: 1 });
    let transformMatrix = [1, 0, 0, 1, 0, 0];
    const transformStack = [];
    let current_x = 0;
    let current_y = 0;
    for (let j = 0; j < opList.fnArray.length; j++) {
      const fn = opList.fnArray[j];
      const args = opList.argsArray[j];
      if (fn === pdfjs__namespace.OPS.constructPath) {
        while (args[0].length) {
          const op = args[0].shift();
          const combinedMatrix = pdfjs__namespace.Util.transform(viewport.transform, transformMatrix);
          if (op === pdfjs__namespace.OPS.rectangle) {
            const x = args[1].shift();
            const y = args[1].shift();
            const width = args[1].shift();
            const height = args[1].shift();
            if (Math.min(width, height) <= 2) {
              debugger;
            }
            const rect = new Rectangle(new Point(x, y), width, height);
            rect.transform(combinedMatrix);
            lineStore.addRectangle(rect);
          } else if (op === pdfjs__namespace.OPS.moveTo) {
            current_x = args[1].shift();
            current_y = args[1].shift();
          } else if (op === pdfjs__namespace.OPS.lineTo) {
            const x = args[1].shift();
            const y = args[1].shift();
            const from = new Point(current_x, current_y);
            const to = new Point(x, y);
            const line = new Line(from, to);
            line.transform(combinedMatrix);
            lineStore.add(line);
            current_x = x;
            current_y = y;
          }
        }
      } else if (fn === pdfjs__namespace.OPS.save) {
        transformStack.push(transformMatrix);
      } else if (fn === pdfjs__namespace.OPS.restore) {
        const restoredMatrix = transformStack.pop();
        if (restoredMatrix) {
          transformMatrix = restoredMatrix;
        }
      } else if (fn === pdfjs__namespace.OPS.transform) {
        transformMatrix = pdfjs__namespace.Util.transform(transformMatrix, args);
      }
    }
    return lineStore;
  }
  async fillPageTables(page, pageTables) {
    const viewport = page.getViewport({ scale: 1 });
    const textContent = await page.getTextContent({
      includeMarkedContent: false,
      disableNormalization: false
    });
    for (const textItem of textContent.items) {
      if (!("str" in textItem)) continue;
      const tx = pdfjs__namespace.Util.transform(pdfjs__namespace.Util.transform(viewport.transform, textItem.transform), [1, 0, 0, -1, 0, 0]);
      for (const pageTable of pageTables) {
        const cell = pageTable.findCell(tx[4], tx[5]);
        if (cell) {
          cell.text.push(textItem.str);
          if (textItem.hasEOL) {
            cell.text.push("\n");
          }
          break;
        }
      }
    }
  }
}

async function pdf(data) {
  let parser;
  if (data instanceof URL) {
    parser = new PDFParse({ url: data });
  } else {
    parser = new PDFParse({ data });
  }
  const text = await parser.GetText();
  return text;
}

exports.PDFParse = PDFParse;
exports.pdf = pdf;
//# sourceMappingURL=index.cjs.map
