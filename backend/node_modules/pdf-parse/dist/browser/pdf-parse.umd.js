(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.PdfParse = {}));
})(this, (function(exports2) {
  "use strict";var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

  var _capability, _messageHandler, _port, _webWorker, _fakeWorkerId, _isWorkerDisabled, _workerPorts, _PDFWorker_instances, resolve_fn, initializeFromPort_fn, initialize_fn, setupFakeWorker_fn, _PDFWorker_static, mainThreadWorkerMessageHandler_get;
  var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;
  var __webpack_modules__ = {
    /***/
    34: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isCallable = __webpack_require__2(4901);
        module2.exports = function(it) {
          return typeof it == "object" ? it !== null : isCallable(it);
        };
      })
    ),
    /***/
    81: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var call = __webpack_require__2(9565);
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var tryToString = __webpack_require__2(6823);
        var getIteratorMethod = __webpack_require__2(851);
        var $TypeError = TypeError;
        module2.exports = function(argument, usingIterator) {
          var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
          if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
          throw new $TypeError(tryToString(argument) + " is not iterable");
        };
      })
    ),
    /***/
    116: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var call = __webpack_require__2(9565);
        var iterate = __webpack_require__2(2652);
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var iteratorClose = __webpack_require__2(9539);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var findWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("find", TypeError);
        $({ target: "Iterator", proto: true, real: true, forced: findWithoutClosingOnEarlyError }, {
          find: function find(predicate) {
            anObject(this);
            try {
              aCallable(predicate);
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            if (findWithoutClosingOnEarlyError) return call(findWithoutClosingOnEarlyError, this, predicate);
            var record = getIteratorDirect(this);
            var counter = 0;
            return iterate(record, function(value, stop) {
              if (predicate(value, counter++)) return stop(value);
            }, { IS_RECORD: true, INTERRUPTED: true }).result;
          }
        });
      })
    ),
    /***/
    283: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var fails = __webpack_require__2(9039);
        var isCallable = __webpack_require__2(4901);
        var hasOwn = __webpack_require__2(9297);
        var DESCRIPTORS = __webpack_require__2(3724);
        var CONFIGURABLE_FUNCTION_NAME = __webpack_require__2(350).CONFIGURABLE;
        var inspectSource = __webpack_require__2(3706);
        var InternalStateModule = __webpack_require__2(1181);
        var enforceInternalState = InternalStateModule.enforce;
        var getInternalState = InternalStateModule.get;
        var $String = String;
        var defineProperty = Object.defineProperty;
        var stringSlice = uncurryThis("".slice);
        var replace = uncurryThis("".replace);
        var join = uncurryThis([].join);
        var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
          return defineProperty(function() {
          }, "length", { value: 8 }).length !== 8;
        });
        var TEMPLATE = String(String).split("String");
        var makeBuiltIn = module2.exports = function(value, name, options) {
          if (stringSlice($String(name), 0, 7) === "Symbol(") {
            name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
          }
          if (options && options.getter) name = "get " + name;
          if (options && options.setter) name = "set " + name;
          if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
            if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
            else value.name = name;
          }
          if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
            defineProperty(value, "length", { value: options.arity });
          }
          try {
            if (options && hasOwn(options, "constructor") && options.constructor) {
              if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
            } else if (value.prototype) value.prototype = void 0;
          } catch (error) {
          }
          var state = enforceInternalState(value);
          if (!hasOwn(state, "source")) {
            state.source = join(TEMPLATE, typeof name == "string" ? name : "");
          }
          return value;
        };
        Function.prototype.toString = makeBuiltIn(function toString() {
          return isCallable(this) && getInternalState(this).source || inspectSource(this);
        }, "toString");
      })
    ),
    /***/
    350: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var hasOwn = __webpack_require__2(9297);
        var FunctionPrototype = Function.prototype;
        var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
        var EXISTS = hasOwn(FunctionPrototype, "name");
        var PROPER = EXISTS && (function something() {
        }).name === "something";
        var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
        module2.exports = {
          EXISTS,
          PROPER,
          CONFIGURABLE
        };
      })
    ),
    /***/
    397: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var getBuiltIn = __webpack_require__2(7751);
        module2.exports = getBuiltIn("document", "documentElement");
      })
    ),
    /***/
    421: (
      /***/
      ((module2) => {
        module2.exports = {};
      })
    ),
    /***/
    456: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var globalThis2 = __webpack_require__2(4576);
        var uncurryThis = __webpack_require__2(9504);
        var anUint8Array = __webpack_require__2(4154);
        var notDetached = __webpack_require__2(5169);
        var numberToString = uncurryThis(1.1.toString);
        var Uint8Array2 = globalThis2.Uint8Array;
        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.toHex || !(function() {
          try {
            var target = new Uint8Array2([255, 255, 255, 255, 255, 255, 255, 255]);
            return target.toHex() === "ffffffffffffffff";
          } catch (error) {
            return false;
          }
        })();
        if (Uint8Array2) $({ target: "Uint8Array", proto: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
          toHex: function toHex() {
            anUint8Array(this);
            notDetached(this.buffer);
            var result = "";
            for (var i = 0, length = this.length; i < length; i++) {
              var hex = numberToString(this[i], 16);
              result += hex.length === 1 ? "0" + hex : hex;
            }
            return result;
          }
        });
      })
    ),
    /***/
    507: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var call = __webpack_require__2(9565);
        module2.exports = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {
          var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
          var next = record.next;
          var step, result;
          while (!(step = call(next, iterator)).done) {
            result = fn(step.value);
            if (result !== void 0) return result;
          }
        };
      })
    ),
    /***/
    531: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var call = __webpack_require__2(9565);
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var getIteratorFlattenable = __webpack_require__2(8646);
        var createIteratorProxy = __webpack_require__2(9462);
        var iteratorClose = __webpack_require__2(9539);
        var IS_PURE = __webpack_require__2(6395);
        var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("flatMap", function() {
        });
        var flatMapWithoutClosingOnEarlyError = !IS_PURE && !FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("flatMap", TypeError);
        var FORCED = IS_PURE || FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || flatMapWithoutClosingOnEarlyError;
        var IteratorProxy = createIteratorProxy(function() {
          var iterator = this.iterator;
          var mapper = this.mapper;
          var result, inner;
          while (true) {
            if (inner = this.inner) try {
              result = anObject(call(inner.next, inner.iterator));
              if (!result.done) return result.value;
              this.inner = null;
            } catch (error) {
              iteratorClose(iterator, "throw", error);
            }
            result = anObject(call(this.next, iterator));
            if (this.done = !!result.done) return;
            try {
              this.inner = getIteratorFlattenable(mapper(result.value, this.counter++), false);
            } catch (error) {
              iteratorClose(iterator, "throw", error);
            }
          }
        });
        $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
          flatMap: function flatMap(mapper) {
            anObject(this);
            try {
              aCallable(mapper);
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            if (flatMapWithoutClosingOnEarlyError) return call(flatMapWithoutClosingOnEarlyError, this, mapper);
            return new IteratorProxy(getIteratorDirect(this), {
              mapper,
              inner: null
            });
          }
        });
      })
    ),
    /***/
    616: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var fails = __webpack_require__2(9039);
        module2.exports = !fails(function() {
          var test = (function() {
          }).bind();
          return typeof test != "function" || test.hasOwnProperty("prototype");
        });
      })
    ),
    /***/
    655: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var classof = __webpack_require__2(6955);
        var $String = String;
        module2.exports = function(argument) {
          if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
          return $String(argument);
        };
      })
    ),
    /***/
    679: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isPrototypeOf = __webpack_require__2(1625);
        var $TypeError = TypeError;
        module2.exports = function(it, Prototype) {
          if (isPrototypeOf(Prototype, it)) return it;
          throw new $TypeError("Incorrect invocation");
        };
      })
    ),
    /***/
    684: (
      /***/
      ((module2) => {
        module2.exports = function(methodName, argument) {
          var method = typeof Iterator == "function" && Iterator.prototype[methodName];
          if (method) try {
            method.call({ next: null }, argument).next();
          } catch (error) {
            return true;
          }
        };
      })
    ),
    /***/
    741: (
      /***/
      ((module2) => {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module2.exports = Math.trunc || function trunc(x) {
          var n = +x;
          return (n > 0 ? floor : ceil)(n);
        };
      })
    ),
    /***/
    757: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var getBuiltIn = __webpack_require__2(7751);
        var isCallable = __webpack_require__2(4901);
        var isPrototypeOf = __webpack_require__2(1625);
        var USE_SYMBOL_AS_UID = __webpack_require__2(7040);
        var $Object = Object;
        module2.exports = USE_SYMBOL_AS_UID ? function(it) {
          return typeof it == "symbol";
        } : function(it) {
          var $Symbol = getBuiltIn("Symbol");
          return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
        };
      })
    ),
    /***/
    851: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var classof = __webpack_require__2(6955);
        var getMethod = __webpack_require__2(5966);
        var isNullOrUndefined = __webpack_require__2(4117);
        var Iterators = __webpack_require__2(6269);
        var wellKnownSymbol = __webpack_require__2(8227);
        var ITERATOR = wellKnownSymbol("iterator");
        module2.exports = function(it) {
          if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
        };
      })
    ),
    /***/
    944: (
      /***/
      ((module2) => {
        var $TypeError = TypeError;
        module2.exports = function(options) {
          var alphabet = options && options.alphabet;
          if (alphabet === void 0 || alphabet === "base64" || alphabet === "base64url") return alphabet || "base64";
          throw new $TypeError("Incorrect `alphabet` option");
        };
      })
    ),
    /***/
    1072: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var internalObjectKeys = __webpack_require__2(1828);
        var enumBugKeys = __webpack_require__2(8727);
        module2.exports = Object.keys || function keys(O) {
          return internalObjectKeys(O, enumBugKeys);
        };
      })
    ),
    /***/
    1103: (
      /***/
      ((module2) => {
        module2.exports = function(exec) {
          try {
            return { error: false, value: exec() };
          } catch (error) {
            return { error: true, value: error };
          }
        };
      })
    ),
    /***/
    1108: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var classof = __webpack_require__2(6955);
        module2.exports = function(it) {
          var klass = classof(it);
          return klass === "BigInt64Array" || klass === "BigUint64Array";
        };
      })
    ),
    /***/
    1148: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var call = __webpack_require__2(9565);
        var iterate = __webpack_require__2(2652);
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var iteratorClose = __webpack_require__2(9539);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("every", TypeError);
        $({ target: "Iterator", proto: true, real: true, forced: everyWithoutClosingOnEarlyError }, {
          every: function every(predicate) {
            anObject(this);
            try {
              aCallable(predicate);
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);
            var record = getIteratorDirect(this);
            var counter = 0;
            return !iterate(record, function(value, stop) {
              if (!predicate(value, counter++)) return stop();
            }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
          }
        });
      })
    ),
    /***/
    1181: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var NATIVE_WEAK_MAP = __webpack_require__2(8622);
        var globalThis2 = __webpack_require__2(4576);
        var isObject = __webpack_require__2(34);
        var createNonEnumerableProperty = __webpack_require__2(6699);
        var hasOwn = __webpack_require__2(9297);
        var shared = __webpack_require__2(7629);
        var sharedKey = __webpack_require__2(6119);
        var hiddenKeys = __webpack_require__2(421);
        var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
        var TypeError2 = globalThis2.TypeError;
        var WeakMap2 = globalThis2.WeakMap;
        var set, get, has;
        var enforce = function(it) {
          return has(it) ? get(it) : set(it, {});
        };
        var getterFor = function(TYPE) {
          return function(it) {
            var state;
            if (!isObject(it) || (state = get(it)).type !== TYPE) {
              throw new TypeError2("Incompatible receiver, " + TYPE + " required");
            }
            return state;
          };
        };
        if (NATIVE_WEAK_MAP || shared.state) {
          var store = shared.state || (shared.state = new WeakMap2());
          store.get = store.get;
          store.has = store.has;
          store.set = store.set;
          set = function(it, metadata) {
            if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            store.set(it, metadata);
            return metadata;
          };
          get = function(it) {
            return store.get(it) || {};
          };
          has = function(it) {
            return store.has(it);
          };
        } else {
          var STATE = sharedKey("state");
          hiddenKeys[STATE] = true;
          set = function(it, metadata) {
            if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            createNonEnumerableProperty(it, STATE, metadata);
            return metadata;
          };
          get = function(it) {
            return hasOwn(it, STATE) ? it[STATE] : {};
          };
          has = function(it) {
            return hasOwn(it, STATE);
          };
        }
        module2.exports = {
          set,
          get,
          has,
          enforce,
          getterFor
        };
      })
    ),
    /***/
    1291: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var trunc = __webpack_require__2(741);
        module2.exports = function(argument) {
          var number = +argument;
          return number !== number || number === 0 ? 0 : trunc(number);
        };
      })
    ),
    /***/
    1385: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var iteratorClose = __webpack_require__2(9539);
        module2.exports = function(iters, kind, value) {
          for (var i = iters.length - 1; i >= 0; i--) {
            if (iters[i] === void 0) continue;
            try {
              value = iteratorClose(iters[i].iterator, kind, value);
            } catch (error) {
              kind = "throw";
              value = error;
            }
          }
          if (kind === "throw") throw value;
          return value;
        };
      })
    ),
    /***/
    1548: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var fails = __webpack_require__2(9039);
        var V8 = __webpack_require__2(9519);
        var ENVIRONMENT = __webpack_require__2(4215);
        var structuredClone2 = globalThis2.structuredClone;
        module2.exports = !!structuredClone2 && !fails(function() {
          if (ENVIRONMENT === "DENO" && V8 > 92 || ENVIRONMENT === "NODE" && V8 > 94 || ENVIRONMENT === "BROWSER" && V8 > 97) return false;
          var buffer = new ArrayBuffer(8);
          var clone = structuredClone2(buffer, { transfer: [buffer] });
          return buffer.byteLength !== 0 || clone.byteLength !== 8;
        });
      })
    ),
    /***/
    1549: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        __webpack_require__2(6632);
      })
    ),
    /***/
    1625: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        module2.exports = uncurryThis({}.isPrototypeOf);
      })
    ),
    /***/
    1689: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var globalThis2 = __webpack_require__2(4576);
        var apply = __webpack_require__2(8745);
        var slice = __webpack_require__2(7680);
        var newPromiseCapabilityModule = __webpack_require__2(6043);
        var aCallable = __webpack_require__2(9306);
        var perform = __webpack_require__2(1103);
        var Promise2 = globalThis2.Promise;
        var ACCEPT_ARGUMENTS = false;
        var FORCED = !Promise2 || !Promise2["try"] || perform(function() {
          Promise2["try"](function(argument) {
            ACCEPT_ARGUMENTS = argument === 8;
          }, 8);
        }).error || !ACCEPT_ARGUMENTS;
        $({ target: "Promise", stat: true, forced: FORCED }, {
          "try": function(callbackfn) {
            var args = arguments.length > 1 ? slice(arguments, 1) : [];
            var promiseCapability = newPromiseCapabilityModule.f(this);
            var result = perform(function() {
              return apply(aCallable(callbackfn), void 0, args);
            });
            (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
            return promiseCapability.promise;
          }
        });
      })
    ),
    /***/
    1698: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var union = __webpack_require__2(4204);
        var setMethodGetKeysBeforeCloning = __webpack_require__2(9835);
        var setMethodAcceptSetLike = __webpack_require__2(4916);
        var FORCED = !setMethodAcceptSetLike("union") || !setMethodGetKeysBeforeCloning("union");
        $({ target: "Set", proto: true, real: true, forced: FORCED }, {
          union
        });
      })
    ),
    /***/
    1701: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var call = __webpack_require__2(9565);
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var createIteratorProxy = __webpack_require__2(9462);
        var callWithSafeIterationClosing = __webpack_require__2(6319);
        var iteratorClose = __webpack_require__2(9539);
        var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var IS_PURE = __webpack_require__2(6395);
        var MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("map", function() {
        });
        var mapWithoutClosingOnEarlyError = !IS_PURE && !MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("map", TypeError);
        var FORCED = IS_PURE || MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || mapWithoutClosingOnEarlyError;
        var IteratorProxy = createIteratorProxy(function() {
          var iterator = this.iterator;
          var result = anObject(call(this.next, iterator));
          var done = this.done = !!result.done;
          if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
        });
        $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
          map: function map(mapper) {
            anObject(this);
            try {
              aCallable(mapper);
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);
            return new IteratorProxy(getIteratorDirect(this), {
              mapper
            });
          }
        });
      })
    ),
    /***/
    1767: (
      /***/
      ((module2) => {
        module2.exports = function(obj) {
          return {
            iterator: obj,
            next: obj.next,
            done: false
          };
        };
      })
    ),
    /***/
    1828: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var hasOwn = __webpack_require__2(9297);
        var toIndexedObject = __webpack_require__2(5397);
        var indexOf = __webpack_require__2(9617).indexOf;
        var hiddenKeys = __webpack_require__2(421);
        var push = uncurryThis([].push);
        module2.exports = function(object, names) {
          var O = toIndexedObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
          while (names.length > i) if (hasOwn(O, key = names[i++])) {
            ~indexOf(result, key) || push(result, key);
          }
          return result;
        };
      })
    ),
    /***/
    2106: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var makeBuiltIn = __webpack_require__2(283);
        var defineProperty = __webpack_require__2(4913);
        module2.exports = function(target, name, descriptor) {
          if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
          if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
          return defineProperty.f(target, name, descriptor);
        };
      })
    ),
    /***/
    2140: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var wellKnownSymbol = __webpack_require__2(8227);
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var test = {};
        test[TO_STRING_TAG] = "z";
        module2.exports = String(test) === "[object z]";
      })
    ),
    /***/
    2195: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var toString = uncurryThis({}.toString);
        var stringSlice = uncurryThis("".slice);
        module2.exports = function(it) {
          return stringSlice(toString(it), 8, -1);
        };
      })
    ),
    /***/
    2211: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var fails = __webpack_require__2(9039);
        module2.exports = !fails(function() {
          function F() {
          }
          F.prototype.constructor = null;
          return Object.getPrototypeOf(new F()) !== F.prototype;
        });
      })
    ),
    /***/
    2303: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var uncurryThis = __webpack_require__2(9504);
        var Uint8Array2 = globalThis2.Uint8Array;
        var SyntaxError2 = globalThis2.SyntaxError;
        var parseInt2 = globalThis2.parseInt;
        var min = Math.min;
        var NOT_HEX = /[^\da-f]/i;
        var exec = uncurryThis(NOT_HEX.exec);
        var stringSlice = uncurryThis("".slice);
        module2.exports = function(string, into) {
          var stringLength = string.length;
          if (stringLength % 2 !== 0) throw new SyntaxError2("String should be an even number of characters");
          var maxLength = into ? min(into.length, stringLength / 2) : stringLength / 2;
          var bytes = into || new Uint8Array2(maxLength);
          var read = 0;
          var written = 0;
          while (written < maxLength) {
            var hexits = stringSlice(string, read, read += 2);
            if (exec(NOT_HEX, hexits)) throw new SyntaxError2("String should only contain hex characters");
            bytes[written++] = parseInt2(hexits, 16);
          }
          return { bytes, read };
        };
      })
    ),
    /***/
    2360: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var anObject = __webpack_require__2(8551);
        var definePropertiesModule = __webpack_require__2(6801);
        var enumBugKeys = __webpack_require__2(8727);
        var hiddenKeys = __webpack_require__2(421);
        var html = __webpack_require__2(397);
        var documentCreateElement = __webpack_require__2(4055);
        var sharedKey = __webpack_require__2(6119);
        var GT = ">";
        var LT = "<";
        var PROTOTYPE = "prototype";
        var SCRIPT = "script";
        var IE_PROTO = sharedKey("IE_PROTO");
        var EmptyConstructor = function() {
        };
        var scriptTag = function(content) {
          return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
        };
        var NullProtoObjectViaActiveX = function(activeXDocument2) {
          activeXDocument2.write(scriptTag(""));
          activeXDocument2.close();
          var temp = activeXDocument2.parentWindow.Object;
          activeXDocument2 = null;
          return temp;
        };
        var NullProtoObjectViaIFrame = function() {
          var iframe = documentCreateElement("iframe");
          var JS = "java" + SCRIPT + ":";
          var iframeDocument;
          iframe.style.display = "none";
          html.appendChild(iframe);
          iframe.src = String(JS);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(scriptTag("document.F=Object"));
          iframeDocument.close();
          return iframeDocument.F;
        };
        var activeXDocument;
        var NullProtoObject = function() {
          try {
            activeXDocument = new ActiveXObject("htmlfile");
          } catch (error) {
          }
          NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
          var length = enumBugKeys.length;
          while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
          return NullProtoObject();
        };
        hiddenKeys[IE_PROTO] = true;
        module2.exports = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            EmptyConstructor[PROTOTYPE] = anObject(O);
            result = new EmptyConstructor();
            EmptyConstructor[PROTOTYPE] = null;
            result[IE_PROTO] = O;
          } else result = NullProtoObject();
          return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
        };
      })
    ),
    /***/
    2475: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var isSupersetOf = __webpack_require__2(8527);
        var setMethodAcceptSetLike = __webpack_require__2(4916);
        var INCORRECT = !setMethodAcceptSetLike("isSupersetOf", function(result) {
          return !result;
        });
        $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
          isSupersetOf
        });
      })
    ),
    /***/
    2489: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var call = __webpack_require__2(9565);
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var createIteratorProxy = __webpack_require__2(9462);
        var callWithSafeIterationClosing = __webpack_require__2(6319);
        var IS_PURE = __webpack_require__2(6395);
        var iteratorClose = __webpack_require__2(9539);
        var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("filter", function() {
        });
        var filterWithoutClosingOnEarlyError = !IS_PURE && !FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("filter", TypeError);
        var FORCED = IS_PURE || FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR || filterWithoutClosingOnEarlyError;
        var IteratorProxy = createIteratorProxy(function() {
          var iterator = this.iterator;
          var predicate = this.predicate;
          var next = this.next;
          var result, done, value;
          while (true) {
            result = anObject(call(next, iterator));
            done = this.done = !!result.done;
            if (done) return;
            value = result.value;
            if (callWithSafeIterationClosing(iterator, predicate, [value, this.counter++], true)) return value;
          }
        });
        $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
          filter: function filter(predicate) {
            anObject(this);
            try {
              aCallable(predicate);
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);
            return new IteratorProxy(getIteratorDirect(this), {
              predicate
            });
          }
        });
      })
    ),
    /***/
    2529: (
      /***/
      ((module2) => {
        module2.exports = function(value, done) {
          return { value, done };
        };
      })
    ),
    /***/
    2603: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var toString = __webpack_require__2(655);
        module2.exports = function(argument, $default) {
          return argument === void 0 ? arguments.length < 2 ? "" : $default : toString(argument);
        };
      })
    ),
    /***/
    2652: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var bind = __webpack_require__2(6080);
        var call = __webpack_require__2(9565);
        var anObject = __webpack_require__2(8551);
        var tryToString = __webpack_require__2(6823);
        var isArrayIteratorMethod = __webpack_require__2(4209);
        var lengthOfArrayLike = __webpack_require__2(6198);
        var isPrototypeOf = __webpack_require__2(1625);
        var getIterator = __webpack_require__2(81);
        var getIteratorMethod = __webpack_require__2(851);
        var iteratorClose = __webpack_require__2(9539);
        var $TypeError = TypeError;
        var Result = function(stopped, result) {
          this.stopped = stopped;
          this.result = result;
        };
        var ResultPrototype = Result.prototype;
        module2.exports = function(iterable, unboundFunction, options) {
          var that = options && options.that;
          var AS_ENTRIES = !!(options && options.AS_ENTRIES);
          var IS_RECORD = !!(options && options.IS_RECORD);
          var IS_ITERATOR = !!(options && options.IS_ITERATOR);
          var INTERRUPTED = !!(options && options.INTERRUPTED);
          var fn = bind(unboundFunction, that);
          var iterator, iterFn, index, length, result, next, step;
          var stop = function(condition) {
            if (iterator) iteratorClose(iterator, "normal");
            return new Result(true, condition);
          };
          var callFn = function(value) {
            if (AS_ENTRIES) {
              anObject(value);
              return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
            }
            return INTERRUPTED ? fn(value, stop) : fn(value);
          };
          if (IS_RECORD) {
            iterator = iterable.iterator;
          } else if (IS_ITERATOR) {
            iterator = iterable;
          } else {
            iterFn = getIteratorMethod(iterable);
            if (!iterFn) throw new $TypeError(tryToString(iterable) + " is not iterable");
            if (isArrayIteratorMethod(iterFn)) {
              for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
                result = callFn(iterable[index]);
                if (result && isPrototypeOf(ResultPrototype, result)) return result;
              }
              return new Result(false);
            }
            iterator = getIterator(iterable, iterFn);
          }
          next = IS_RECORD ? iterable.next : iterator.next;
          while (!(step = call(next, iterator)).done) {
            try {
              result = callFn(step.value);
            } catch (error) {
              iteratorClose(iterator, "throw", error);
            }
            if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
          }
          return new Result(false);
        };
      })
    ),
    /***/
    2777: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var call = __webpack_require__2(9565);
        var isObject = __webpack_require__2(34);
        var isSymbol = __webpack_require__2(757);
        var getMethod = __webpack_require__2(5966);
        var ordinaryToPrimitive = __webpack_require__2(4270);
        var wellKnownSymbol = __webpack_require__2(8227);
        var $TypeError = TypeError;
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        module2.exports = function(input, pref) {
          if (!isObject(input) || isSymbol(input)) return input;
          var exoticToPrim = getMethod(input, TO_PRIMITIVE);
          var result;
          if (exoticToPrim) {
            if (pref === void 0) pref = "default";
            result = call(exoticToPrim, input, pref);
            if (!isObject(result) || isSymbol(result)) return result;
            throw new $TypeError("Can't convert object to primitive value");
          }
          if (pref === void 0) pref = "number";
          return ordinaryToPrimitive(input, pref);
        };
      })
    ),
    /***/
    2787: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var hasOwn = __webpack_require__2(9297);
        var isCallable = __webpack_require__2(4901);
        var toObject = __webpack_require__2(8981);
        var sharedKey = __webpack_require__2(6119);
        var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(2211);
        var IE_PROTO = sharedKey("IE_PROTO");
        var $Object = Object;
        var ObjectPrototype = $Object.prototype;
        module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
          var object = toObject(O);
          if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
          var constructor = object.constructor;
          if (isCallable(constructor) && object instanceof constructor) {
            return constructor.prototype;
          }
          return object instanceof $Object ? ObjectPrototype : null;
        };
      })
    ),
    /***/
    2796: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var fails = __webpack_require__2(9039);
        var isCallable = __webpack_require__2(4901);
        var replacement = /#|\.prototype\./;
        var isForced = function(feature, detection) {
          var value = data[normalize(feature)];
          return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
        };
        var normalize = isForced.normalize = function(string) {
          return String(string).replace(replacement, ".").toLowerCase();
        };
        var data = isForced.data = {};
        var NATIVE = isForced.NATIVE = "N";
        var POLYFILL = isForced.POLYFILL = "P";
        module2.exports = isForced;
      })
    ),
    /***/
    2804: (
      /***/
      ((module2) => {
        var commonAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        var base64Alphabet = commonAlphabet + "+/";
        var base64UrlAlphabet = commonAlphabet + "-_";
        var inverse = function(characters) {
          var result = {};
          var index = 0;
          for (; index < 64; index++) result[characters.charAt(index)] = index;
          return result;
        };
        module2.exports = {
          i2c: base64Alphabet,
          c2i: inverse(base64Alphabet),
          i2cUrl: base64UrlAlphabet,
          c2iUrl: inverse(base64UrlAlphabet)
        };
      })
    ),
    /***/
    2812: (
      /***/
      ((module2) => {
        var $TypeError = TypeError;
        module2.exports = function(passed, required) {
          if (passed < required) throw new $TypeError("Not enough arguments");
          return passed;
        };
      })
    ),
    /***/
    2839: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var navigator2 = globalThis2.navigator;
        var userAgent = navigator2 && navigator2.userAgent;
        module2.exports = userAgent ? String(userAgent) : "";
      })
    ),
    /***/
    2967: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThisAccessor = __webpack_require__2(6706);
        var isObject = __webpack_require__2(34);
        var requireObjectCoercible = __webpack_require__2(7750);
        var aPossiblePrototype = __webpack_require__2(3506);
        module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
          var CORRECT_SETTER = false;
          var test = {};
          var setter;
          try {
            setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
            setter(test, []);
            CORRECT_SETTER = test instanceof Array;
          } catch (error) {
          }
          return function setPrototypeOf(O, proto) {
            requireObjectCoercible(O);
            aPossiblePrototype(proto);
            if (!isObject(O)) return O;
            if (CORRECT_SETTER) setter(O, proto);
            else O.__proto__ = proto;
            return O;
          };
        })() : void 0);
      })
    ),
    /***/
    3068: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var uncurryThis = __webpack_require__2(9504);
        var iterate = __webpack_require__2(2652);
        var $RangeError = RangeError;
        var $TypeError = TypeError;
        var $Infinity = Infinity;
        var $NaN = NaN;
        var abs = Math.abs;
        var pow = Math.pow;
        var push = uncurryThis([].push);
        var POW_2_1023 = pow(2, 1023);
        var MAX_SAFE_INTEGER = pow(2, 53) - 1;
        var MAX_DOUBLE = Number.MAX_VALUE;
        var MAX_ULP = pow(2, 971);
        var NOT_A_NUMBER = {};
        var MINUS_INFINITY = {};
        var PLUS_INFINITY = {};
        var MINUS_ZERO = {};
        var FINITE = {};
        var twosum = function(x, y) {
          var hi = x + y;
          var lo = y - (hi - x);
          return { hi, lo };
        };
        $({ target: "Math", stat: true }, {
          // eslint-disable-next-line max-statements -- ok
          sumPrecise: function sumPrecise(items) {
            var numbers = [];
            var count = 0;
            var state = MINUS_ZERO;
            iterate(items, function(n2) {
              if (++count >= MAX_SAFE_INTEGER) throw new $RangeError("Maximum allowed index exceeded");
              if (typeof n2 != "number") throw new $TypeError("Value is not a number");
              if (state !== NOT_A_NUMBER) {
                if (n2 !== n2) state = NOT_A_NUMBER;
                else if (n2 === $Infinity) state = state === MINUS_INFINITY ? NOT_A_NUMBER : PLUS_INFINITY;
                else if (n2 === -$Infinity) state = state === PLUS_INFINITY ? NOT_A_NUMBER : MINUS_INFINITY;
                else if ((n2 !== 0 || 1 / n2 === $Infinity) && (state === MINUS_ZERO || state === FINITE)) {
                  state = FINITE;
                  push(numbers, n2);
                }
              }
            });
            switch (state) {
              case NOT_A_NUMBER:
                return $NaN;
              case MINUS_INFINITY:
                return -$Infinity;
              case PLUS_INFINITY:
                return $Infinity;
              case MINUS_ZERO:
                return -0;
            }
            var partials = [];
            var overflow = 0;
            var x, y, sum, hi, lo, tmp;
            for (var i = 0; i < numbers.length; i++) {
              x = numbers[i];
              var actuallyUsedPartials = 0;
              for (var j = 0; j < partials.length; j++) {
                y = partials[j];
                if (abs(x) < abs(y)) {
                  tmp = x;
                  x = y;
                  y = tmp;
                }
                sum = twosum(x, y);
                hi = sum.hi;
                lo = sum.lo;
                if (abs(hi) === $Infinity) {
                  var sign = hi === $Infinity ? 1 : -1;
                  overflow += sign;
                  x = x - sign * POW_2_1023 - sign * POW_2_1023;
                  if (abs(x) < abs(y)) {
                    tmp = x;
                    x = y;
                    y = tmp;
                  }
                  sum = twosum(x, y);
                  hi = sum.hi;
                  lo = sum.lo;
                }
                if (lo !== 0) partials[actuallyUsedPartials++] = lo;
                x = hi;
              }
              partials.length = actuallyUsedPartials;
              if (x !== 0) push(partials, x);
            }
            var n = partials.length - 1;
            hi = 0;
            lo = 0;
            if (overflow !== 0) {
              var next = n >= 0 ? partials[n] : 0;
              n--;
              if (abs(overflow) > 1 || overflow > 0 && next > 0 || overflow < 0 && next < 0) {
                return overflow > 0 ? $Infinity : -$Infinity;
              }
              sum = twosum(overflow * POW_2_1023, next / 2);
              hi = sum.hi;
              lo = sum.lo;
              lo *= 2;
              if (abs(2 * hi) === $Infinity) {
                if (hi > 0) {
                  return hi === POW_2_1023 && lo === -(MAX_ULP / 2) && n >= 0 && partials[n] < 0 ? MAX_DOUBLE : $Infinity;
                }
                return hi === -POW_2_1023 && lo === MAX_ULP / 2 && n >= 0 && partials[n] > 0 ? -MAX_DOUBLE : -$Infinity;
              }
              if (lo !== 0) {
                partials[++n] = lo;
                lo = 0;
              }
              hi *= 2;
            }
            while (n >= 0) {
              sum = twosum(hi, partials[n--]);
              hi = sum.hi;
              lo = sum.lo;
              if (lo !== 0) break;
            }
            if (n >= 0 && (lo < 0 && partials[n] < 0 || lo > 0 && partials[n] > 0)) {
              y = lo * 2;
              x = hi + y;
              if (y === x - hi) hi = x;
            }
            return hi;
          }
        });
      })
    ),
    /***/
    3167: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isCallable = __webpack_require__2(4901);
        var isObject = __webpack_require__2(34);
        var setPrototypeOf = __webpack_require__2(2967);
        module2.exports = function($this, dummy, Wrapper) {
          var NewTarget, NewTargetPrototype;
          if (
            // it can work only with native `setPrototypeOf`
            setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
            isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
          ) setPrototypeOf($this, NewTargetPrototype);
          return $this;
        };
      })
    ),
    /***/
    3238: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var NATIVE_ARRAY_BUFFER = __webpack_require__2(7811);
        var arrayBufferByteLength = __webpack_require__2(7394);
        var DataView2 = globalThis2.DataView;
        module2.exports = function(O) {
          if (!NATIVE_ARRAY_BUFFER || arrayBufferByteLength(O) !== 0) return false;
          try {
            new DataView2(O);
            return false;
          } catch (error) {
            return true;
          }
        };
      })
    ),
    /***/
    3392: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var id = 0;
        var postfix = Math.random();
        var toString = uncurryThis(1.1.toString);
        module2.exports = function(key) {
          return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
        };
      })
    ),
    /***/
    3440: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aSet = __webpack_require__2(7080);
        var SetHelpers = __webpack_require__2(4402);
        var clone = __webpack_require__2(9286);
        var size = __webpack_require__2(5170);
        var getSetRecord = __webpack_require__2(3789);
        var iterateSet = __webpack_require__2(8469);
        var iterateSimple = __webpack_require__2(507);
        var has = SetHelpers.has;
        var remove = SetHelpers.remove;
        module2.exports = function difference(other) {
          var O = aSet(this);
          var otherRec = getSetRecord(other);
          var result = clone(O);
          if (size(O) <= otherRec.size) iterateSet(O, function(e) {
            if (otherRec.includes(e)) remove(result, e);
          });
          else iterateSimple(otherRec.getIterator(), function(e) {
            if (has(result, e)) remove(result, e);
          });
          return result;
        };
      })
    ),
    /***/
    3463: (
      /***/
      ((module2) => {
        var $TypeError = TypeError;
        module2.exports = function(argument) {
          if (typeof argument == "string") return argument;
          throw new $TypeError("Argument is not a string");
        };
      })
    ),
    /***/
    3506: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isPossiblePrototype = __webpack_require__2(3925);
        var $String = String;
        var $TypeError = TypeError;
        module2.exports = function(argument) {
          if (isPossiblePrototype(argument)) return argument;
          throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
        };
      })
    ),
    /***/
    3579: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var call = __webpack_require__2(9565);
        var iterate = __webpack_require__2(2652);
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var iteratorClose = __webpack_require__2(9539);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var someWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("some", TypeError);
        $({ target: "Iterator", proto: true, real: true, forced: someWithoutClosingOnEarlyError }, {
          some: function some(predicate) {
            anObject(this);
            try {
              aCallable(predicate);
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            if (someWithoutClosingOnEarlyError) return call(someWithoutClosingOnEarlyError, this, predicate);
            var record = getIteratorDirect(this);
            var counter = 0;
            return iterate(record, function(value, stop) {
              if (predicate(value, counter++)) return stop();
            }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
          }
        });
      })
    ),
    /***/
    3650: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aSet = __webpack_require__2(7080);
        var SetHelpers = __webpack_require__2(4402);
        var clone = __webpack_require__2(9286);
        var getSetRecord = __webpack_require__2(3789);
        var iterateSimple = __webpack_require__2(507);
        var add = SetHelpers.add;
        var has = SetHelpers.has;
        var remove = SetHelpers.remove;
        module2.exports = function symmetricDifference(other) {
          var O = aSet(this);
          var keysIter = getSetRecord(other).getIterator();
          var result = clone(O);
          iterateSimple(keysIter, function(e) {
            if (has(O, e)) remove(result, e);
            else add(result, e);
          });
          return result;
        };
      })
    ),
    /***/
    3706: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var isCallable = __webpack_require__2(4901);
        var store = __webpack_require__2(7629);
        var functionToString = uncurryThis(Function.toString);
        if (!isCallable(store.inspectSource)) {
          store.inspectSource = function(it) {
            return functionToString(it);
          };
        }
        module2.exports = store.inspectSource;
      })
    ),
    /***/
    3717: (
      /***/
      ((__unused_webpack_module, exports3) => {
        exports3.f = Object.getOwnPropertySymbols;
      })
    ),
    /***/
    3724: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var fails = __webpack_require__2(9039);
        module2.exports = !fails(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] !== 7;
        });
      })
    ),
    /***/
    3789: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var call = __webpack_require__2(9565);
        var toIntegerOrInfinity = __webpack_require__2(1291);
        var getIteratorDirect = __webpack_require__2(1767);
        var INVALID_SIZE = "Invalid size";
        var $RangeError = RangeError;
        var $TypeError = TypeError;
        var max = Math.max;
        var SetRecord = function(set, intSize) {
          this.set = set;
          this.size = max(intSize, 0);
          this.has = aCallable(set.has);
          this.keys = aCallable(set.keys);
        };
        SetRecord.prototype = {
          getIterator: function() {
            return getIteratorDirect(anObject(call(this.keys, this.set)));
          },
          includes: function(it) {
            return call(this.has, this.set, it);
          }
        };
        module2.exports = function(obj) {
          anObject(obj);
          var numSize = +obj.size;
          if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);
          var intSize = toIntegerOrInfinity(numSize);
          if (intSize < 0) throw new $RangeError(INVALID_SIZE);
          return new SetRecord(obj, intSize);
        };
      })
    ),
    /***/
    3838: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aSet = __webpack_require__2(7080);
        var size = __webpack_require__2(5170);
        var iterate = __webpack_require__2(8469);
        var getSetRecord = __webpack_require__2(3789);
        module2.exports = function isSubsetOf(other) {
          var O = aSet(this);
          var otherRec = getSetRecord(other);
          if (size(O) > otherRec.size) return false;
          return iterate(O, function(e) {
            if (!otherRec.includes(e)) return false;
          }, true) !== false;
        };
      })
    ),
    /***/
    3853: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var isDisjointFrom = __webpack_require__2(4449);
        var setMethodAcceptSetLike = __webpack_require__2(4916);
        var INCORRECT = !setMethodAcceptSetLike("isDisjointFrom", function(result) {
          return !result;
        });
        $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
          isDisjointFrom
        });
      })
    ),
    /***/
    3925: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isObject = __webpack_require__2(34);
        module2.exports = function(argument) {
          return isObject(argument) || argument === null;
        };
      })
    ),
    /***/
    3972: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isObject = __webpack_require__2(34);
        var $String = String;
        var $TypeError = TypeError;
        module2.exports = function(argument) {
          if (argument === void 0 || isObject(argument)) return argument;
          throw new $TypeError($String(argument) + " is not an object or undefined");
        };
      })
    ),
    /***/
    4055: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var isObject = __webpack_require__2(34);
        var document2 = globalThis2.document;
        var EXISTS = isObject(document2) && isObject(document2.createElement);
        module2.exports = function(it) {
          return EXISTS ? document2.createElement(it) : {};
        };
      })
    ),
    /***/
    4114: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var toObject = __webpack_require__2(8981);
        var lengthOfArrayLike = __webpack_require__2(6198);
        var setArrayLength = __webpack_require__2(4527);
        var doesNotExceedSafeInteger = __webpack_require__2(6837);
        var fails = __webpack_require__2(9039);
        var INCORRECT_TO_LENGTH = fails(function() {
          return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
        });
        var properErrorOnNonWritableLength = function() {
          try {
            Object.defineProperty([], "length", { writable: false }).push();
          } catch (error) {
            return error instanceof TypeError;
          }
        };
        var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
        $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          push: function push(item) {
            var O = toObject(this);
            var len = lengthOfArrayLike(O);
            var argCount = arguments.length;
            doesNotExceedSafeInteger(len + argCount);
            for (var i = 0; i < argCount; i++) {
              O[len] = arguments[i];
              len++;
            }
            setArrayLength(O, len);
            return len;
          }
        });
      })
    ),
    /***/
    4117: (
      /***/
      ((module2) => {
        module2.exports = function(it) {
          return it === null || it === void 0;
        };
      })
    ),
    /***/
    4149: (
      /***/
      ((module2) => {
        var $RangeError = RangeError;
        module2.exports = function(it) {
          if (it === it) return it;
          throw new $RangeError("NaN is not allowed");
        };
      })
    ),
    /***/
    4154: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var classof = __webpack_require__2(6955);
        var $TypeError = TypeError;
        module2.exports = function(argument) {
          if (classof(argument) === "Uint8Array") return argument;
          throw new $TypeError("Argument is not an Uint8Array");
        };
      })
    ),
    /***/
    4204: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aSet = __webpack_require__2(7080);
        var add = __webpack_require__2(4402).add;
        var clone = __webpack_require__2(9286);
        var getSetRecord = __webpack_require__2(3789);
        var iterateSimple = __webpack_require__2(507);
        module2.exports = function union(other) {
          var O = aSet(this);
          var keysIter = getSetRecord(other).getIterator();
          var result = clone(O);
          iterateSimple(keysIter, function(it) {
            add(result, it);
          });
          return result;
        };
      })
    ),
    /***/
    4209: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var wellKnownSymbol = __webpack_require__2(8227);
        var Iterators = __webpack_require__2(6269);
        var ITERATOR = wellKnownSymbol("iterator");
        var ArrayPrototype = Array.prototype;
        module2.exports = function(it) {
          return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
        };
      })
    ),
    /***/
    4215: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var userAgent = __webpack_require__2(2839);
        var classof = __webpack_require__2(2195);
        var userAgentStartsWith = function(string) {
          return userAgent.slice(0, string.length) === string;
        };
        module2.exports = (function() {
          if (userAgentStartsWith("Bun/")) return "BUN";
          if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
          if (userAgentStartsWith("Deno/")) return "DENO";
          if (userAgentStartsWith("Node.js/")) return "NODE";
          if (globalThis2.Bun && typeof Bun.version == "string") return "BUN";
          if (globalThis2.Deno && typeof Deno.version == "object") return "DENO";
          if (classof(globalThis2.process) === "process") return "NODE";
          if (globalThis2.window && globalThis2.document) return "BROWSER";
          return "REST";
        })();
      })
    ),
    /***/
    4226: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var globalThis2 = __webpack_require__2(4576);
        var aString = __webpack_require__2(3463);
        var anUint8Array = __webpack_require__2(4154);
        var notDetached = __webpack_require__2(5169);
        var $fromHex = __webpack_require__2(2303);
        if (globalThis2.Uint8Array) $({ target: "Uint8Array", proto: true }, {
          setFromHex: function setFromHex(string) {
            anUint8Array(this);
            aString(string);
            notDetached(this.buffer);
            var read = $fromHex(string, this).read;
            return { read, written: read / 2 };
          }
        });
      })
    ),
    /***/
    4235: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        __webpack_require__2(3068);
      })
    ),
    /***/
    4270: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var call = __webpack_require__2(9565);
        var isCallable = __webpack_require__2(4901);
        var isObject = __webpack_require__2(34);
        var $TypeError = TypeError;
        module2.exports = function(input, pref) {
          var fn, val;
          if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
          if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
          if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
          throw new $TypeError("Can't convert object to primitive value");
        };
      })
    ),
    /***/
    4376: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var classof = __webpack_require__2(2195);
        module2.exports = Array.isArray || function isArray(argument) {
          return classof(argument) === "Array";
        };
      })
    ),
    /***/
    4402: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var SetPrototype = Set.prototype;
        module2.exports = {
          // eslint-disable-next-line es/no-set -- safe
          Set,
          add: uncurryThis(SetPrototype.add),
          has: uncurryThis(SetPrototype.has),
          remove: uncurryThis(SetPrototype["delete"]),
          proto: SetPrototype
        };
      })
    ),
    /***/
    4449: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aSet = __webpack_require__2(7080);
        var has = __webpack_require__2(4402).has;
        var size = __webpack_require__2(5170);
        var getSetRecord = __webpack_require__2(3789);
        var iterateSet = __webpack_require__2(8469);
        var iterateSimple = __webpack_require__2(507);
        var iteratorClose = __webpack_require__2(9539);
        module2.exports = function isDisjointFrom(other) {
          var O = aSet(this);
          var otherRec = getSetRecord(other);
          if (size(O) <= otherRec.size) return iterateSet(O, function(e) {
            if (otherRec.includes(e)) return false;
          }, true) !== false;
          var iterator = otherRec.getIterator();
          return iterateSimple(iterator, function(e) {
            if (has(O, e)) return iteratorClose(iterator, "normal", false);
          }) !== false;
        };
      })
    ),
    /***/
    4483: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var getBuiltInNodeModule = __webpack_require__2(9429);
        var PROPER_STRUCTURED_CLONE_TRANSFER = __webpack_require__2(1548);
        var structuredClone2 = globalThis2.structuredClone;
        var $ArrayBuffer = globalThis2.ArrayBuffer;
        var $MessageChannel = globalThis2.MessageChannel;
        var detach = false;
        var WorkerThreads, channel, buffer, $detach;
        if (PROPER_STRUCTURED_CLONE_TRANSFER) {
          detach = function(transferable) {
            structuredClone2(transferable, { transfer: [transferable] });
          };
        } else if ($ArrayBuffer) try {
          if (!$MessageChannel) {
            WorkerThreads = getBuiltInNodeModule("worker_threads");
            if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
          }
          if ($MessageChannel) {
            channel = new $MessageChannel();
            buffer = new $ArrayBuffer(2);
            $detach = function(transferable) {
              channel.port1.postMessage(null, [transferable]);
            };
            if (buffer.byteLength === 2) {
              $detach(buffer);
              if (buffer.byteLength === 0) detach = $detach;
            }
          }
        } catch (error) {
        }
        module2.exports = detach;
      })
    ),
    /***/
    4495: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var V8_VERSION = __webpack_require__2(9519);
        var fails = __webpack_require__2(9039);
        var globalThis2 = __webpack_require__2(4576);
        var $String = globalThis2.String;
        module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
          var symbol = Symbol("symbol detection");
          return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
          !Symbol.sham && V8_VERSION && V8_VERSION < 41;
        });
      })
    ),
    /***/
    4527: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var isArray = __webpack_require__2(4376);
        var $TypeError = TypeError;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !(function() {
          if (this !== void 0) return true;
          try {
            Object.defineProperty([], "length", { writable: false }).length = 1;
          } catch (error) {
            return error instanceof TypeError;
          }
        })();
        module2.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
          if (isArray(O) && !getOwnPropertyDescriptor(O, "length").writable) {
            throw new $TypeError("Cannot set read only .length");
          }
          return O.length = length;
        } : function(O, length) {
          return O.length = length;
        };
      })
    ),
    /***/
    4549: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        module2.exports = function(METHOD_NAME, ExpectedError) {
          var Iterator2 = globalThis2.Iterator;
          var IteratorPrototype = Iterator2 && Iterator2.prototype;
          var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];
          var CLOSED = false;
          if (method) try {
            method.call({
              next: function() {
                return { done: true };
              },
              "return": function() {
                CLOSED = true;
              }
            }, -1);
          } catch (error) {
            if (!(error instanceof ExpectedError)) CLOSED = false;
          }
          if (!CLOSED) return method;
        };
      })
    ),
    /***/
    4576: (
      /***/
      (function(module2) {
        var check = function(it) {
          return it && it.Math === Math && it;
        };
        module2.exports = // eslint-disable-next-line es/no-global-this -- safe
        check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
        check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
        /* @__PURE__ */ (function() {
          return this;
        })() || Function("return this")();
      })
    ),
    /***/
    4603: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var defineBuiltIn = __webpack_require__2(6840);
        var uncurryThis = __webpack_require__2(9504);
        var toString = __webpack_require__2(655);
        var validateArgumentsLength = __webpack_require__2(2812);
        var $URLSearchParams = URLSearchParams;
        var URLSearchParamsPrototype = $URLSearchParams.prototype;
        var append = uncurryThis(URLSearchParamsPrototype.append);
        var $delete = uncurryThis(URLSearchParamsPrototype["delete"]);
        var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
        var push = uncurryThis([].push);
        var params = new $URLSearchParams("a=1&a=2&b=3");
        params["delete"]("a", 1);
        params["delete"]("b", void 0);
        if (params + "" !== "a=2") {
          defineBuiltIn(URLSearchParamsPrototype, "delete", function(name) {
            var length = arguments.length;
            var $value = length < 2 ? void 0 : arguments[1];
            if (length && $value === void 0) return $delete(this, name);
            var entries = [];
            forEach(this, function(v, k) {
              push(entries, { key: k, value: v });
            });
            validateArgumentsLength(length, 1);
            var key = toString(name);
            var value = toString($value);
            var index = 0;
            var dindex = 0;
            var found = false;
            var entriesLength = entries.length;
            var entry;
            while (index < entriesLength) {
              entry = entries[index++];
              if (found || entry.key === key) {
                found = true;
                $delete(this, entry.key);
              } else dindex++;
            }
            while (dindex < entriesLength) {
              entry = entries[dindex++];
              if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
            }
          }, { enumerable: true, unsafe: true });
        }
      })
    ),
    /***/
    4628: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var newPromiseCapabilityModule = __webpack_require__2(6043);
        $({ target: "Promise", stat: true }, {
          withResolvers: function withResolvers() {
            var promiseCapability = newPromiseCapabilityModule.f(this);
            return {
              promise: promiseCapability.promise,
              resolve: promiseCapability.resolve,
              reject: promiseCapability.reject
            };
          }
        });
      })
    ),
    /***/
    4644: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var NATIVE_ARRAY_BUFFER = __webpack_require__2(7811);
        var DESCRIPTORS = __webpack_require__2(3724);
        var globalThis2 = __webpack_require__2(4576);
        var isCallable = __webpack_require__2(4901);
        var isObject = __webpack_require__2(34);
        var hasOwn = __webpack_require__2(9297);
        var classof = __webpack_require__2(6955);
        var tryToString = __webpack_require__2(6823);
        var createNonEnumerableProperty = __webpack_require__2(6699);
        var defineBuiltIn = __webpack_require__2(6840);
        var defineBuiltInAccessor = __webpack_require__2(2106);
        var isPrototypeOf = __webpack_require__2(1625);
        var getPrototypeOf = __webpack_require__2(2787);
        var setPrototypeOf = __webpack_require__2(2967);
        var wellKnownSymbol = __webpack_require__2(8227);
        var uid = __webpack_require__2(3392);
        var InternalStateModule = __webpack_require__2(1181);
        var enforceInternalState = InternalStateModule.enforce;
        var getInternalState = InternalStateModule.get;
        var Int8Array2 = globalThis2.Int8Array;
        var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
        var Uint8ClampedArray2 = globalThis2.Uint8ClampedArray;
        var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
        var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
        var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
        var ObjectPrototype = Object.prototype;
        var TypeError2 = globalThis2.TypeError;
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
        var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
        var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis2.opera) !== "Opera";
        var TYPED_ARRAY_TAG_REQUIRED = false;
        var NAME, Constructor, Prototype;
        var TypedArrayConstructorsList = {
          Int8Array: 1,
          Uint8Array: 1,
          Uint8ClampedArray: 1,
          Int16Array: 2,
          Uint16Array: 2,
          Int32Array: 4,
          Uint32Array: 4,
          Float32Array: 4,
          Float64Array: 8
        };
        var BigIntArrayConstructorsList = {
          BigInt64Array: 8,
          BigUint64Array: 8
        };
        var isView = function isView2(it) {
          if (!isObject(it)) return false;
          var klass = classof(it);
          return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
        };
        var getTypedArrayConstructor = function(it) {
          var proto = getPrototypeOf(it);
          if (!isObject(proto)) return;
          var state = getInternalState(proto);
          return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
        };
        var isTypedArray = function(it) {
          if (!isObject(it)) return false;
          var klass = classof(it);
          return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
        };
        var aTypedArray = function(it) {
          if (isTypedArray(it)) return it;
          throw new TypeError2("Target is not a typed array");
        };
        var aTypedArrayConstructor = function(C) {
          if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
          throw new TypeError2(tryToString(C) + " is not a typed array constructor");
        };
        var exportTypedArrayMethod = function(KEY, property, forced, options) {
          if (!DESCRIPTORS) return;
          if (forced) for (var ARRAY in TypedArrayConstructorsList) {
            var TypedArrayConstructor = globalThis2[ARRAY];
            if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
              delete TypedArrayConstructor.prototype[KEY];
            } catch (error) {
              try {
                TypedArrayConstructor.prototype[KEY] = property;
              } catch (error2) {
              }
            }
          }
          if (!TypedArrayPrototype[KEY] || forced) {
            defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
          }
        };
        var exportTypedArrayStaticMethod = function(KEY, property, forced) {
          var ARRAY, TypedArrayConstructor;
          if (!DESCRIPTORS) return;
          if (setPrototypeOf) {
            if (forced) for (ARRAY in TypedArrayConstructorsList) {
              TypedArrayConstructor = globalThis2[ARRAY];
              if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
                delete TypedArrayConstructor[KEY];
              } catch (error) {
              }
            }
            if (!TypedArray[KEY] || forced) {
              try {
                return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
              } catch (error) {
              }
            } else return;
          }
          for (ARRAY in TypedArrayConstructorsList) {
            TypedArrayConstructor = globalThis2[ARRAY];
            if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
              defineBuiltIn(TypedArrayConstructor, KEY, property);
            }
          }
        };
        for (NAME in TypedArrayConstructorsList) {
          Constructor = globalThis2[NAME];
          Prototype = Constructor && Constructor.prototype;
          if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
          else NATIVE_ARRAY_BUFFER_VIEWS = false;
        }
        for (NAME in BigIntArrayConstructorsList) {
          Constructor = globalThis2[NAME];
          Prototype = Constructor && Constructor.prototype;
          if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
        }
        if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
          TypedArray = function TypedArray2() {
            throw new TypeError2("Incorrect invocation");
          };
          if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
            if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME], TypedArray);
          }
        }
        if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
          TypedArrayPrototype = TypedArray.prototype;
          if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
            if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME].prototype, TypedArrayPrototype);
          }
        }
        if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
          setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
        }
        if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
          TYPED_ARRAY_TAG_REQUIRED = true;
          defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
            configurable: true,
            get: function() {
              return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
            }
          });
          for (NAME in TypedArrayConstructorsList) if (globalThis2[NAME]) {
            createNonEnumerableProperty(globalThis2[NAME], TYPED_ARRAY_TAG, NAME);
          }
        }
        module2.exports = {
          NATIVE_ARRAY_BUFFER_VIEWS,
          TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
          aTypedArray,
          aTypedArrayConstructor,
          exportTypedArrayMethod,
          exportTypedArrayStaticMethod,
          getTypedArrayConstructor,
          isView,
          isTypedArray,
          TypedArray,
          TypedArrayPrototype
        };
      })
    ),
    /***/
    4659: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var definePropertyModule = __webpack_require__2(4913);
        var createPropertyDescriptor = __webpack_require__2(6980);
        module2.exports = function(object, key, value) {
          if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
          else object[key] = value;
        };
      })
    ),
    /***/
    4901: (
      /***/
      ((module2) => {
        var documentAll = typeof document == "object" && document.all;
        module2.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
          return typeof argument == "function" || argument === documentAll;
        } : function(argument) {
          return typeof argument == "function";
        };
      })
    ),
    /***/
    4913: (
      /***/
      ((__unused_webpack_module, exports3, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var IE8_DOM_DEFINE = __webpack_require__2(5917);
        var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(8686);
        var anObject = __webpack_require__2(8551);
        var toPropertyKey = __webpack_require__2(6969);
        var $TypeError = TypeError;
        var $defineProperty = Object.defineProperty;
        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var ENUMERABLE = "enumerable";
        var CONFIGURABLE = "configurable";
        var WRITABLE = "writable";
        exports3.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPropertyKey(P);
          anObject(Attributes);
          if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
            var current = $getOwnPropertyDescriptor(O, P);
            if (current && current[WRITABLE]) {
              O[P] = Attributes.value;
              Attributes = {
                configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                writable: false
              };
            }
          }
          return $defineProperty(O, P, Attributes);
        } : $defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPropertyKey(P);
          anObject(Attributes);
          if (IE8_DOM_DEFINE) try {
            return $defineProperty(O, P, Attributes);
          } catch (error) {
          }
          if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
          if ("value" in Attributes) O[P] = Attributes.value;
          return O;
        };
      })
    ),
    /***/
    4916: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var getBuiltIn = __webpack_require__2(7751);
        var createSetLike = function(size) {
          return {
            size,
            has: function() {
              return false;
            },
            keys: function() {
              return {
                next: function() {
                  return { done: true };
                }
              };
            }
          };
        };
        var createSetLikeWithInfinitySize = function(size) {
          return {
            size,
            has: function() {
              return true;
            },
            keys: function() {
              throw new Error("e");
            }
          };
        };
        module2.exports = function(name, callback) {
          var Set2 = getBuiltIn("Set");
          try {
            new Set2()[name](createSetLike(0));
            try {
              new Set2()[name](createSetLike(-1));
              return false;
            } catch (error2) {
              if (!callback) return true;
              try {
                new Set2()[name](createSetLikeWithInfinitySize(-Infinity));
                return false;
              } catch (error) {
                var set = new Set2();
                set.add(1);
                set.add(2);
                return callback(set[name](createSetLikeWithInfinitySize(Infinity)));
              }
            }
          } catch (error) {
            return false;
          }
        };
      })
    ),
    /***/
    4972: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var call = __webpack_require__2(9565);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var notANaN = __webpack_require__2(4149);
        var toPositiveInteger = __webpack_require__2(9590);
        var createIteratorProxy = __webpack_require__2(9462);
        var iteratorClose = __webpack_require__2(9539);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var IS_PURE = __webpack_require__2(6395);
        var takeWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError("take", RangeError);
        var IteratorProxy = createIteratorProxy(function() {
          var iterator = this.iterator;
          if (!this.remaining--) {
            this.done = true;
            return iteratorClose(iterator, "normal", void 0);
          }
          var result = anObject(call(this.next, iterator));
          var done = this.done = !!result.done;
          if (!done) return result.value;
        });
        $({ target: "Iterator", proto: true, real: true, forced: IS_PURE || takeWithoutClosingOnEarlyError }, {
          take: function take(limit) {
            anObject(this);
            var remaining;
            try {
              remaining = toPositiveInteger(notANaN(+limit));
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            if (takeWithoutClosingOnEarlyError) return call(takeWithoutClosingOnEarlyError, this, remaining);
            return new IteratorProxy(getIteratorDirect(this), {
              remaining
            });
          }
        });
      })
    ),
    /***/
    4979: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var globalThis2 = __webpack_require__2(4576);
        var getBuiltIn = __webpack_require__2(7751);
        var createPropertyDescriptor = __webpack_require__2(6980);
        var defineProperty = __webpack_require__2(4913).f;
        var hasOwn = __webpack_require__2(9297);
        var anInstance = __webpack_require__2(679);
        var inheritIfRequired = __webpack_require__2(3167);
        var normalizeStringArgument = __webpack_require__2(2603);
        var DOMExceptionConstants = __webpack_require__2(5002);
        var clearErrorStack = __webpack_require__2(8574);
        var DESCRIPTORS = __webpack_require__2(3724);
        var IS_PURE = __webpack_require__2(6395);
        var DOM_EXCEPTION = "DOMException";
        var Error2 = getBuiltIn("Error");
        var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
        var $DOMException = function DOMException() {
          anInstance(this, DOMExceptionPrototype);
          var argumentsLength = arguments.length;
          var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
          var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
          var that = new NativeDOMException(message, name);
          var error = new Error2(message);
          error.name = DOM_EXCEPTION;
          defineProperty(that, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
          inheritIfRequired(that, this, $DOMException);
          return that;
        };
        var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
        var ERROR_HAS_STACK = "stack" in new Error2(DOM_EXCEPTION);
        var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
        var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis2, DOM_EXCEPTION);
        var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);
        var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;
        $({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, {
          // TODO: fix export logic
          DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
        });
        var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
        var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
        if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
          if (!IS_PURE) {
            defineProperty(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor(1, PolyfilledDOMException));
          }
          for (var key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
            var constant = DOMExceptionConstants[key];
            var constantName = constant.s;
            if (!hasOwn(PolyfilledDOMException, constantName)) {
              defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
            }
          }
        }
      })
    ),
    /***/
    5002: (
      /***/
      ((module2) => {
        module2.exports = {
          IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
          DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
          HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
          WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
          InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
          NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
          NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
          NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
          NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
          InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
          InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
          SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
          InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
          NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
          InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
          ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
          TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
          SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
          NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
          AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
          URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
          QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
          TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
          InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
          DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
        };
      })
    ),
    /***/
    5024: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var symmetricDifference = __webpack_require__2(3650);
        var setMethodGetKeysBeforeCloning = __webpack_require__2(9835);
        var setMethodAcceptSetLike = __webpack_require__2(4916);
        var FORCED = !setMethodAcceptSetLike("symmetricDifference") || !setMethodGetKeysBeforeCloning("symmetricDifference");
        $({ target: "Set", proto: true, real: true, forced: FORCED }, {
          symmetricDifference
        });
      })
    ),
    /***/
    5031: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var getBuiltIn = __webpack_require__2(7751);
        var uncurryThis = __webpack_require__2(9504);
        var getOwnPropertyNamesModule = __webpack_require__2(8480);
        var getOwnPropertySymbolsModule = __webpack_require__2(3717);
        var anObject = __webpack_require__2(8551);
        var concat = uncurryThis([].concat);
        module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
          var keys = getOwnPropertyNamesModule.f(anObject(it));
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
        };
      })
    ),
    /***/
    5169: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isDetached = __webpack_require__2(3238);
        var $TypeError = TypeError;
        module2.exports = function(it) {
          if (isDetached(it)) throw new $TypeError("ArrayBuffer is detached");
          return it;
        };
      })
    ),
    /***/
    5170: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThisAccessor = __webpack_require__2(6706);
        var SetHelpers = __webpack_require__2(4402);
        module2.exports = uncurryThisAccessor(SetHelpers.proto, "size", "get") || function(set) {
          return set.size;
        };
      })
    ),
    /***/
    5213: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var globalThis2 = __webpack_require__2(4576);
        var arrayFromConstructorAndList = __webpack_require__2(5370);
        var $fromBase64 = __webpack_require__2(9143);
        var Uint8Array2 = globalThis2.Uint8Array;
        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.fromBase64 || !(function() {
          try {
            Uint8Array2.fromBase64("a");
            return;
          } catch (error) {
          }
          try {
            Uint8Array2.fromBase64("", null);
          } catch (error) {
            return true;
          }
        })();
        if (Uint8Array2) $({ target: "Uint8Array", stat: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
          fromBase64: function fromBase64(string) {
            var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, null, 9007199254740991);
            return arrayFromConstructorAndList(Uint8Array2, result.bytes);
          }
        });
      })
    ),
    /***/
    5370: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var lengthOfArrayLike = __webpack_require__2(6198);
        module2.exports = function(Constructor, list, $length) {
          var index = 0;
          var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
          var result = new Constructor(length);
          while (length > index) result[index] = list[index++];
          return result;
        };
      })
    ),
    /***/
    5397: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var IndexedObject = __webpack_require__2(7055);
        var requireObjectCoercible = __webpack_require__2(7750);
        module2.exports = function(it) {
          return IndexedObject(requireObjectCoercible(it));
        };
      })
    ),
    /***/
    5610: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var toIntegerOrInfinity = __webpack_require__2(1291);
        var max = Math.max;
        var min = Math.min;
        module2.exports = function(index, length) {
          var integer = toIntegerOrInfinity(index);
          return integer < 0 ? max(integer + length, 0) : min(integer, length);
        };
      })
    ),
    /***/
    5623: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        __webpack_require__2(456);
      })
    ),
    /***/
    5636: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var uncurryThis = __webpack_require__2(9504);
        var uncurryThisAccessor = __webpack_require__2(6706);
        var toIndex = __webpack_require__2(7696);
        var notDetached = __webpack_require__2(5169);
        var arrayBufferByteLength = __webpack_require__2(7394);
        var detachTransferable = __webpack_require__2(4483);
        var PROPER_STRUCTURED_CLONE_TRANSFER = __webpack_require__2(1548);
        var structuredClone2 = globalThis2.structuredClone;
        var ArrayBuffer2 = globalThis2.ArrayBuffer;
        var DataView2 = globalThis2.DataView;
        var min = Math.min;
        var ArrayBufferPrototype = ArrayBuffer2.prototype;
        var DataViewPrototype = DataView2.prototype;
        var slice = uncurryThis(ArrayBufferPrototype.slice);
        var isResizable = uncurryThisAccessor(ArrayBufferPrototype, "resizable", "get");
        var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, "maxByteLength", "get");
        var getInt8 = uncurryThis(DataViewPrototype.getInt8);
        var setInt8 = uncurryThis(DataViewPrototype.setInt8);
        module2.exports = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function(arrayBuffer, newLength, preserveResizability) {
          var byteLength = arrayBufferByteLength(arrayBuffer);
          var newByteLength = newLength === void 0 ? byteLength : toIndex(newLength);
          var fixedLength = !isResizable || !isResizable(arrayBuffer);
          var newBuffer;
          notDetached(arrayBuffer);
          if (PROPER_STRUCTURED_CLONE_TRANSFER) {
            arrayBuffer = structuredClone2(arrayBuffer, { transfer: [arrayBuffer] });
            if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;
          }
          if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {
            newBuffer = slice(arrayBuffer, 0, newByteLength);
          } else {
            var options = preserveResizability && !fixedLength && maxByteLength ? { maxByteLength: maxByteLength(arrayBuffer) } : void 0;
            newBuffer = new ArrayBuffer2(newByteLength, options);
            var a = new DataView2(arrayBuffer);
            var b = new DataView2(newBuffer);
            var copyLength = min(newByteLength, byteLength);
            for (var i = 0; i < copyLength; i++) setInt8(b, i, getInt8(a, i));
          }
          if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);
          return newBuffer;
        };
      })
    ),
    /***/
    5745: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var store = __webpack_require__2(7629);
        module2.exports = function(key, value) {
          return store[key] || (store[key] = value || {});
        };
      })
    ),
    /***/
    5781: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var getBuiltIn = __webpack_require__2(7751);
        var validateArgumentsLength = __webpack_require__2(2812);
        var toString = __webpack_require__2(655);
        var USE_NATIVE_URL = __webpack_require__2(7416);
        var URL2 = getBuiltIn("URL");
        $({ target: "URL", stat: true, forced: !USE_NATIVE_URL }, {
          parse: function parse(url) {
            var length = validateArgumentsLength(arguments.length, 1);
            var urlString = toString(url);
            var base = length < 2 || arguments[1] === void 0 ? void 0 : toString(arguments[1]);
            try {
              return new URL2(urlString, base);
            } catch (error) {
              return null;
            }
          }
        });
      })
    ),
    /***/
    5854: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var toPrimitive = __webpack_require__2(2777);
        var $TypeError = TypeError;
        module2.exports = function(argument) {
          var prim = toPrimitive(argument, "number");
          if (typeof prim == "number") throw new $TypeError("Can't convert number to bigint");
          return BigInt(prim);
        };
      })
    ),
    /***/
    5876: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var isSubsetOf = __webpack_require__2(3838);
        var setMethodAcceptSetLike = __webpack_require__2(4916);
        var INCORRECT = !setMethodAcceptSetLike("isSubsetOf", function(result) {
          return result;
        });
        $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
          isSubsetOf
        });
      })
    ),
    /***/
    5917: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var fails = __webpack_require__2(9039);
        var createElement = __webpack_require__2(4055);
        module2.exports = !DESCRIPTORS && !fails(function() {
          return Object.defineProperty(createElement("div"), "a", {
            get: function() {
              return 7;
            }
          }).a !== 7;
        });
      })
    ),
    /***/
    5966: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aCallable = __webpack_require__2(9306);
        var isNullOrUndefined = __webpack_require__2(4117);
        module2.exports = function(V, P) {
          var func = V[P];
          return isNullOrUndefined(func) ? void 0 : aCallable(func);
        };
      })
    ),
    /***/
    6043: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aCallable = __webpack_require__2(9306);
        var $TypeError = TypeError;
        var PromiseCapability = function(C) {
          var resolve, reject;
          this.promise = new C(function($$resolve, $$reject) {
            if (resolve !== void 0 || reject !== void 0) throw new $TypeError("Bad Promise constructor");
            resolve = $$resolve;
            reject = $$reject;
          });
          this.resolve = aCallable(resolve);
          this.reject = aCallable(reject);
        };
        module2.exports.f = function(C) {
          return new PromiseCapability(C);
        };
      })
    ),
    /***/
    6080: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(7476);
        var aCallable = __webpack_require__2(9306);
        var NATIVE_BIND = __webpack_require__2(616);
        var bind = uncurryThis(uncurryThis.bind);
        module2.exports = function(fn, that) {
          aCallable(fn);
          return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
            return fn.apply(that, arguments);
          };
        };
      })
    ),
    /***/
    6119: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var shared = __webpack_require__2(5745);
        var uid = __webpack_require__2(3392);
        var keys = shared("keys");
        module2.exports = function(key) {
          return keys[key] || (keys[key] = uid(key));
        };
      })
    ),
    /***/
    6193: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var ENVIRONMENT = __webpack_require__2(4215);
        module2.exports = ENVIRONMENT === "NODE";
      })
    ),
    /***/
    6198: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var toLength = __webpack_require__2(8014);
        module2.exports = function(obj) {
          return toLength(obj.length);
        };
      })
    ),
    /***/
    6269: (
      /***/
      ((module2) => {
        module2.exports = {};
      })
    ),
    /***/
    6279: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var defineBuiltIn = __webpack_require__2(6840);
        module2.exports = function(target, src, options) {
          for (var key in src) defineBuiltIn(target, key, src[key], options);
          return target;
        };
      })
    ),
    /***/
    6319: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var anObject = __webpack_require__2(8551);
        var iteratorClose = __webpack_require__2(9539);
        module2.exports = function(iterator, fn, value, ENTRIES) {
          try {
            return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
        };
      })
    ),
    /***/
    6395: (
      /***/
      ((module2) => {
        module2.exports = false;
      })
    ),
    /***/
    6518: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var getOwnPropertyDescriptor = __webpack_require__2(7347).f;
        var createNonEnumerableProperty = __webpack_require__2(6699);
        var defineBuiltIn = __webpack_require__2(6840);
        var defineGlobalProperty = __webpack_require__2(9433);
        var copyConstructorProperties = __webpack_require__2(7740);
        var isForced = __webpack_require__2(2796);
        module2.exports = function(options, source) {
          var TARGET = options.target;
          var GLOBAL = options.global;
          var STATIC = options.stat;
          var FORCED, target, key, targetProperty, sourceProperty, descriptor;
          if (GLOBAL) {
            target = globalThis2;
          } else if (STATIC) {
            target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
          } else {
            target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
          }
          if (target) for (key in source) {
            sourceProperty = source[key];
            if (options.dontCallGetSet) {
              descriptor = getOwnPropertyDescriptor(target, key);
              targetProperty = descriptor && descriptor.value;
            } else targetProperty = target[key];
            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
            if (!FORCED && targetProperty !== void 0) {
              if (typeof sourceProperty == typeof targetProperty) continue;
              copyConstructorProperties(sourceProperty, targetProperty);
            }
            if (options.sham || targetProperty && targetProperty.sham) {
              createNonEnumerableProperty(sourceProperty, "sham", true);
            }
            defineBuiltIn(target, key, sourceProperty, options);
          }
        };
      })
    ),
    /***/
    6573: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var defineBuiltInAccessor = __webpack_require__2(2106);
        var isDetached = __webpack_require__2(3238);
        var ArrayBufferPrototype = ArrayBuffer.prototype;
        if (DESCRIPTORS && !("detached" in ArrayBufferPrototype)) {
          defineBuiltInAccessor(ArrayBufferPrototype, "detached", {
            configurable: true,
            get: function detached() {
              return isDetached(this);
            }
          });
        }
      })
    ),
    /***/
    6632: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var globalThis2 = __webpack_require__2(4576);
        var $fromBase64 = __webpack_require__2(9143);
        var anUint8Array = __webpack_require__2(4154);
        var Uint8Array2 = globalThis2.Uint8Array;
        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.setFromBase64 || !(function() {
          var target = new Uint8Array2([255, 255, 255, 255, 255]);
          try {
            target.setFromBase64("", null);
            return;
          } catch (error) {
          }
          try {
            target.setFromBase64("a");
            return;
          } catch (error) {
          }
          try {
            target.setFromBase64("MjYyZg===");
          } catch (error) {
            return target[0] === 50 && target[1] === 54 && target[2] === 50 && target[3] === 255 && target[4] === 255;
          }
        })();
        if (Uint8Array2) $({ target: "Uint8Array", proto: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
          setFromBase64: function setFromBase64(string) {
            anUint8Array(this);
            var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, this, this.length);
            return { read: result.read, written: result.written };
          }
        });
      })
    ),
    /***/
    6699: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var definePropertyModule = __webpack_require__2(4913);
        var createPropertyDescriptor = __webpack_require__2(6980);
        module2.exports = DESCRIPTORS ? function(object, key, value) {
          return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
        } : function(object, key, value) {
          object[key] = value;
          return object;
        };
      })
    ),
    /***/
    6706: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var aCallable = __webpack_require__2(9306);
        module2.exports = function(object, key, method) {
          try {
            return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
          } catch (error) {
          }
        };
      })
    ),
    /***/
    6801: (
      /***/
      ((__unused_webpack_module, exports3, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(8686);
        var definePropertyModule = __webpack_require__2(4913);
        var anObject = __webpack_require__2(8551);
        var toIndexedObject = __webpack_require__2(5397);
        var objectKeys = __webpack_require__2(1072);
        exports3.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var props = toIndexedObject(Properties);
          var keys = objectKeys(Properties);
          var length = keys.length;
          var index = 0;
          var key;
          while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
          return O;
        };
      })
    ),
    /***/
    6823: (
      /***/
      ((module2) => {
        var $String = String;
        module2.exports = function(argument) {
          try {
            return $String(argument);
          } catch (error) {
            return "Object";
          }
        };
      })
    ),
    /***/
    6837: (
      /***/
      ((module2) => {
        var $TypeError = TypeError;
        var MAX_SAFE_INTEGER = 9007199254740991;
        module2.exports = function(it) {
          if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
          return it;
        };
      })
    ),
    /***/
    6840: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isCallable = __webpack_require__2(4901);
        var definePropertyModule = __webpack_require__2(4913);
        var makeBuiltIn = __webpack_require__2(283);
        var defineGlobalProperty = __webpack_require__2(9433);
        module2.exports = function(O, key, value, options) {
          if (!options) options = {};
          var simple = options.enumerable;
          var name = options.name !== void 0 ? options.name : key;
          if (isCallable(value)) makeBuiltIn(value, name, options);
          if (options.global) {
            if (simple) O[key] = value;
            else defineGlobalProperty(key, value);
          } else {
            try {
              if (!options.unsafe) delete O[key];
              else if (O[key]) simple = true;
            } catch (error) {
            }
            if (simple) O[key] = value;
            else definePropertyModule.f(O, key, {
              value,
              enumerable: false,
              configurable: !options.nonConfigurable,
              writable: !options.nonWritable
            });
          }
          return O;
        };
      })
    ),
    /***/
    6955: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var TO_STRING_TAG_SUPPORT = __webpack_require__2(2140);
        var isCallable = __webpack_require__2(4901);
        var classofRaw = __webpack_require__2(2195);
        var wellKnownSymbol = __webpack_require__2(8227);
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var $Object = Object;
        var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ (function() {
          return arguments;
        })()) === "Arguments";
        var tryGet = function(it, key) {
          try {
            return it[key];
          } catch (error) {
          }
        };
        module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
          var O, tag, result;
          return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
        };
      })
    ),
    /***/
    6969: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var toPrimitive = __webpack_require__2(2777);
        var isSymbol = __webpack_require__2(757);
        module2.exports = function(argument) {
          var key = toPrimitive(argument, "string");
          return isSymbol(key) ? key : key + "";
        };
      })
    ),
    /***/
    6980: (
      /***/
      ((module2) => {
        module2.exports = function(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value
          };
        };
      })
    ),
    /***/
    7040: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var NATIVE_SYMBOL = __webpack_require__2(4495);
        module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
      })
    ),
    /***/
    7055: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var fails = __webpack_require__2(9039);
        var classof = __webpack_require__2(2195);
        var $Object = Object;
        var split = uncurryThis("".split);
        module2.exports = fails(function() {
          return !$Object("z").propertyIsEnumerable(0);
        }) ? function(it) {
          return classof(it) === "String" ? split(it, "") : $Object(it);
        } : $Object;
      })
    ),
    /***/
    7080: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var has = __webpack_require__2(4402).has;
        module2.exports = function(it) {
          has(it);
          return it;
        };
      })
    ),
    /***/
    7347: (
      /***/
      ((__unused_webpack_module, exports3, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var call = __webpack_require__2(9565);
        var propertyIsEnumerableModule = __webpack_require__2(8773);
        var createPropertyDescriptor = __webpack_require__2(6980);
        var toIndexedObject = __webpack_require__2(5397);
        var toPropertyKey = __webpack_require__2(6969);
        var hasOwn = __webpack_require__2(9297);
        var IE8_DOM_DEFINE = __webpack_require__2(5917);
        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        exports3.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
          O = toIndexedObject(O);
          P = toPropertyKey(P);
          if (IE8_DOM_DEFINE) try {
            return $getOwnPropertyDescriptor(O, P);
          } catch (error) {
          }
          if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
        };
      })
    ),
    /***/
    7394: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var uncurryThisAccessor = __webpack_require__2(6706);
        var classof = __webpack_require__2(2195);
        var ArrayBuffer2 = globalThis2.ArrayBuffer;
        var TypeError2 = globalThis2.TypeError;
        module2.exports = ArrayBuffer2 && uncurryThisAccessor(ArrayBuffer2.prototype, "byteLength", "get") || function(O) {
          if (classof(O) !== "ArrayBuffer") throw new TypeError2("ArrayBuffer expected");
          return O.byteLength;
        };
      })
    ),
    /***/
    7416: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var fails = __webpack_require__2(9039);
        var wellKnownSymbol = __webpack_require__2(8227);
        var DESCRIPTORS = __webpack_require__2(3724);
        var IS_PURE = __webpack_require__2(6395);
        var ITERATOR = wellKnownSymbol("iterator");
        module2.exports = !fails(function() {
          var url = new URL("b?a=1&b=2&c=3", "https://a");
          var params = url.searchParams;
          var params2 = new URLSearchParams("a=1&a=2&b=3");
          var result = "";
          url.pathname = "c%20d";
          params.forEach(function(value, key) {
            params["delete"]("b");
            result += key + value;
          });
          params2["delete"]("a", 2);
          params2["delete"]("b", void 0);
          return IS_PURE && (!url.toJSON || !params2.has("a", 1) || params2.has("a", 2) || !params2.has("a", void 0) || params2.has("b")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== "https://a/c%20d?a=1&c=3" || params.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("https://").host !== "xn--e1aybc" || new URL("https://a#").hash !== "#%D0%B1" || result !== "a1c3" || new URL("https://x", void 0).host !== "x";
        });
      })
    ),
    /***/
    7476: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var classofRaw = __webpack_require__2(2195);
        var uncurryThis = __webpack_require__2(9504);
        module2.exports = function(fn) {
          if (classofRaw(fn) === "Function") return uncurryThis(fn);
        };
      })
    ),
    /***/
    7566: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var defineBuiltIn = __webpack_require__2(6840);
        var uncurryThis = __webpack_require__2(9504);
        var toString = __webpack_require__2(655);
        var validateArgumentsLength = __webpack_require__2(2812);
        var $URLSearchParams = URLSearchParams;
        var URLSearchParamsPrototype = $URLSearchParams.prototype;
        var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
        var $has = uncurryThis(URLSearchParamsPrototype.has);
        var params = new $URLSearchParams("a=1");
        if (params.has("a", 2) || !params.has("a", void 0)) {
          defineBuiltIn(URLSearchParamsPrototype, "has", function has(name) {
            var length = arguments.length;
            var $value = length < 2 ? void 0 : arguments[1];
            if (length && $value === void 0) return $has(this, name);
            var values = getAll(this, name);
            validateArgumentsLength(length, 1);
            var value = toString($value);
            var index = 0;
            while (index < values.length) {
              if (values[index++] === value) return true;
            }
            return false;
          }, { enumerable: true, unsafe: true });
        }
      })
    ),
    /***/
    7588: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var call = __webpack_require__2(9565);
        var iterate = __webpack_require__2(2652);
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var iteratorClose = __webpack_require__2(9539);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("forEach", TypeError);
        $({ target: "Iterator", proto: true, real: true, forced: forEachWithoutClosingOnEarlyError }, {
          forEach: function forEach(fn) {
            anObject(this);
            try {
              aCallable(fn);
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn);
            var record = getIteratorDirect(this);
            var counter = 0;
            iterate(record, function(value) {
              fn(value, counter++);
            }, { IS_RECORD: true });
          }
        });
      })
    ),
    /***/
    7629: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var IS_PURE = __webpack_require__2(6395);
        var globalThis2 = __webpack_require__2(4576);
        var defineGlobalProperty = __webpack_require__2(9433);
        var SHARED = "__core-js_shared__";
        var store = module2.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
        (store.versions || (store.versions = [])).push({
          version: "3.45.0",
          mode: IS_PURE ? "pure" : "global",
          copyright: " 2014-2025 Denis Pushkarev (zloirock.ru)",
          license: "https://github.com/zloirock/core-js/blob/v3.45.0/LICENSE",
          source: "https://github.com/zloirock/core-js"
        });
      })
    ),
    /***/
    7642: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var difference = __webpack_require__2(3440);
        var fails = __webpack_require__2(9039);
        var setMethodAcceptSetLike = __webpack_require__2(4916);
        var SET_LIKE_INCORRECT_BEHAVIOR = !setMethodAcceptSetLike("difference", function(result) {
          return result.size === 0;
        });
        var FORCED = SET_LIKE_INCORRECT_BEHAVIOR || fails(function() {
          var setLike = {
            size: 1,
            has: function() {
              return true;
            },
            keys: function() {
              var index = 0;
              return {
                next: function() {
                  var done = index++ > 1;
                  if (baseSet.has(1)) baseSet.clear();
                  return { done, value: 2 };
                }
              };
            }
          };
          var baseSet = /* @__PURE__ */ new Set([1, 2, 3, 4]);
          return baseSet.difference(setLike).size !== 3;
        });
        $({ target: "Set", proto: true, real: true, forced: FORCED }, {
          difference
        });
      })
    ),
    /***/
    7657: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var fails = __webpack_require__2(9039);
        var isCallable = __webpack_require__2(4901);
        var isObject = __webpack_require__2(34);
        var create = __webpack_require__2(2360);
        var getPrototypeOf = __webpack_require__2(2787);
        var defineBuiltIn = __webpack_require__2(6840);
        var wellKnownSymbol = __webpack_require__2(8227);
        var IS_PURE = __webpack_require__2(6395);
        var ITERATOR = wellKnownSymbol("iterator");
        var BUGGY_SAFARI_ITERATORS = false;
        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
        if ([].keys) {
          arrayIterator = [].keys();
          if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
          else {
            PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
          }
        }
        var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function() {
          var test = {};
          return IteratorPrototype[ITERATOR].call(test) !== test;
        });
        if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
        else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
        if (!isCallable(IteratorPrototype[ITERATOR])) {
          defineBuiltIn(IteratorPrototype, ITERATOR, function() {
            return this;
          });
        }
        module2.exports = {
          IteratorPrototype,
          BUGGY_SAFARI_ITERATORS
        };
      })
    ),
    /***/
    7680: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        module2.exports = uncurryThis([].slice);
      })
    ),
    /***/
    7696: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var toIntegerOrInfinity = __webpack_require__2(1291);
        var toLength = __webpack_require__2(8014);
        var $RangeError = RangeError;
        module2.exports = function(it) {
          if (it === void 0) return 0;
          var number = toIntegerOrInfinity(it);
          var length = toLength(number);
          if (number !== length) throw new $RangeError("Wrong length or index");
          return length;
        };
      })
    ),
    /***/
    7740: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var hasOwn = __webpack_require__2(9297);
        var ownKeys = __webpack_require__2(5031);
        var getOwnPropertyDescriptorModule = __webpack_require__2(7347);
        var definePropertyModule = __webpack_require__2(4913);
        module2.exports = function(target, source, exceptions) {
          var keys = ownKeys(source);
          var defineProperty = definePropertyModule.f;
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
              defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          }
        };
      })
    ),
    /***/
    7750: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isNullOrUndefined = __webpack_require__2(4117);
        var $TypeError = TypeError;
        module2.exports = function(it) {
          if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
          return it;
        };
      })
    ),
    /***/
    7751: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var isCallable = __webpack_require__2(4901);
        var aFunction = function(argument) {
          return isCallable(argument) ? argument : void 0;
        };
        module2.exports = function(namespace, method) {
          return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
        };
      })
    ),
    /***/
    7811: (
      /***/
      ((module2) => {
        module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
      })
    ),
    /***/
    7936: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var $transfer = __webpack_require__2(5636);
        if ($transfer) $({ target: "ArrayBuffer", proto: true }, {
          transferToFixedLength: function transferToFixedLength() {
            return $transfer(this, arguments.length ? arguments[0] : void 0, false);
          }
        });
      })
    ),
    /***/
    8004: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var fails = __webpack_require__2(9039);
        var intersection = __webpack_require__2(8750);
        var setMethodAcceptSetLike = __webpack_require__2(4916);
        var INCORRECT = !setMethodAcceptSetLike("intersection", function(result) {
          return result.size === 2 && result.has(1) && result.has(2);
        }) || fails(function() {
          return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
        });
        $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
          intersection
        });
      })
    ),
    /***/
    8014: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var toIntegerOrInfinity = __webpack_require__2(1291);
        var min = Math.min;
        module2.exports = function(argument) {
          var len = toIntegerOrInfinity(argument);
          return len > 0 ? min(len, 9007199254740991) : 0;
        };
      })
    ),
    /***/
    8100: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var $transfer = __webpack_require__2(5636);
        if ($transfer) $({ target: "ArrayBuffer", proto: true }, {
          transfer: function transfer() {
            return $transfer(this, arguments.length ? arguments[0] : void 0, true);
          }
        });
      })
    ),
    /***/
    8111: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var globalThis2 = __webpack_require__2(4576);
        var anInstance = __webpack_require__2(679);
        var anObject = __webpack_require__2(8551);
        var isCallable = __webpack_require__2(4901);
        var getPrototypeOf = __webpack_require__2(2787);
        var defineBuiltInAccessor = __webpack_require__2(2106);
        var createProperty = __webpack_require__2(4659);
        var fails = __webpack_require__2(9039);
        var hasOwn = __webpack_require__2(9297);
        var wellKnownSymbol = __webpack_require__2(8227);
        var IteratorPrototype = __webpack_require__2(7657).IteratorPrototype;
        var DESCRIPTORS = __webpack_require__2(3724);
        var IS_PURE = __webpack_require__2(6395);
        var CONSTRUCTOR = "constructor";
        var ITERATOR = "Iterator";
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var $TypeError = TypeError;
        var NativeIterator = globalThis2[ITERATOR];
        var FORCED = IS_PURE || !isCallable(NativeIterator) || NativeIterator.prototype !== IteratorPrototype || !fails(function() {
          NativeIterator({});
        });
        var IteratorConstructor = function Iterator2() {
          anInstance(this, IteratorPrototype);
          if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError("Abstract class Iterator not directly constructable");
        };
        var defineIteratorPrototypeAccessor = function(key, value) {
          if (DESCRIPTORS) {
            defineBuiltInAccessor(IteratorPrototype, key, {
              configurable: true,
              get: function() {
                return value;
              },
              set: function(replacement) {
                anObject(this);
                if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
                if (hasOwn(this, key)) this[key] = replacement;
                else createProperty(this, key, replacement);
              }
            });
          } else IteratorPrototype[key] = value;
        };
        if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);
        if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
          defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
        }
        IteratorConstructor.prototype = IteratorPrototype;
        $({ global: true, constructor: true, forced: FORCED }, {
          Iterator: IteratorConstructor
        });
      })
    ),
    /***/
    8227: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var shared = __webpack_require__2(5745);
        var hasOwn = __webpack_require__2(9297);
        var uid = __webpack_require__2(3392);
        var NATIVE_SYMBOL = __webpack_require__2(4495);
        var USE_SYMBOL_AS_UID = __webpack_require__2(7040);
        var Symbol2 = globalThis2.Symbol;
        var WellKnownSymbolsStore = shared("wks");
        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
        module2.exports = function(name) {
          if (!hasOwn(WellKnownSymbolsStore, name)) {
            WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
          }
          return WellKnownSymbolsStore[name];
        };
      })
    ),
    /***/
    8235: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var hasOwn = __webpack_require__2(9297);
        var $SyntaxError = SyntaxError;
        var $parseInt = parseInt;
        var fromCharCode = String.fromCharCode;
        var at = uncurryThis("".charAt);
        var slice = uncurryThis("".slice);
        var exec = uncurryThis(/./.exec);
        var codePoints = {
          '\\"': '"',
          "\\\\": "\\",
          "\\/": "/",
          "\\b": "\b",
          "\\f": "\f",
          "\\n": "\n",
          "\\r": "\r",
          "\\t": "	"
        };
        var IS_4_HEX_DIGITS = /^[\da-f]{4}$/i;
        var IS_C0_CONTROL_CODE = /^[\u0000-\u001F]$/;
        module2.exports = function(source, i) {
          var unterminated = true;
          var value = "";
          while (i < source.length) {
            var chr = at(source, i);
            if (chr === "\\") {
              var twoChars = slice(source, i, i + 2);
              if (hasOwn(codePoints, twoChars)) {
                value += codePoints[twoChars];
                i += 2;
              } else if (twoChars === "\\u") {
                i += 2;
                var fourHexDigits = slice(source, i, i + 4);
                if (!exec(IS_4_HEX_DIGITS, fourHexDigits)) throw new $SyntaxError("Bad Unicode escape at: " + i);
                value += fromCharCode($parseInt(fourHexDigits, 16));
                i += 4;
              } else throw new $SyntaxError('Unknown escape sequence: "' + twoChars + '"');
            } else if (chr === '"') {
              unterminated = false;
              i++;
              break;
            } else {
              if (exec(IS_C0_CONTROL_CODE, chr)) throw new $SyntaxError("Bad control character in string literal at: " + i);
              value += chr;
              i++;
            }
          }
          if (unterminated) throw new $SyntaxError("Unterminated string at: " + i);
          return { value, end: i };
        };
      })
    ),
    /***/
    8237: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var iterate = __webpack_require__2(2652);
        var aCallable = __webpack_require__2(9306);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var iteratorClose = __webpack_require__2(9539);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var apply = __webpack_require__2(8745);
        var fails = __webpack_require__2(9039);
        var $TypeError = TypeError;
        var FAILS_ON_INITIAL_UNDEFINED = fails(function() {
          [].keys().reduce(function() {
          }, void 0);
        });
        var reduceWithoutClosingOnEarlyError = !FAILS_ON_INITIAL_UNDEFINED && iteratorHelperWithoutClosingOnEarlyError("reduce", $TypeError);
        $({ target: "Iterator", proto: true, real: true, forced: FAILS_ON_INITIAL_UNDEFINED || reduceWithoutClosingOnEarlyError }, {
          reduce: function reduce(reducer) {
            anObject(this);
            try {
              aCallable(reducer);
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            var noInitial = arguments.length < 2;
            var accumulator = noInitial ? void 0 : arguments[1];
            if (reduceWithoutClosingOnEarlyError) {
              return apply(reduceWithoutClosingOnEarlyError, this, noInitial ? [reducer] : [reducer, accumulator]);
            }
            var record = getIteratorDirect(this);
            var counter = 0;
            iterate(record, function(value) {
              if (noInitial) {
                noInitial = false;
                accumulator = value;
              } else {
                accumulator = reducer(accumulator, value, counter);
              }
              counter++;
            }, { IS_RECORD: true });
            if (noInitial) throw new $TypeError("Reduce of empty iterator with no initial value");
            return accumulator;
          }
        });
      })
    ),
    /***/
    8335: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var DESCRIPTORS = __webpack_require__2(3724);
        var globalThis2 = __webpack_require__2(4576);
        var getBuiltIn = __webpack_require__2(7751);
        var uncurryThis = __webpack_require__2(9504);
        var call = __webpack_require__2(9565);
        var isCallable = __webpack_require__2(4901);
        var isObject = __webpack_require__2(34);
        var isArray = __webpack_require__2(4376);
        var hasOwn = __webpack_require__2(9297);
        var toString = __webpack_require__2(655);
        var lengthOfArrayLike = __webpack_require__2(6198);
        var createProperty = __webpack_require__2(4659);
        var fails = __webpack_require__2(9039);
        var parseJSONString = __webpack_require__2(8235);
        var NATIVE_SYMBOL = __webpack_require__2(4495);
        var JSON2 = globalThis2.JSON;
        var Number2 = globalThis2.Number;
        var SyntaxError2 = globalThis2.SyntaxError;
        var nativeParse = JSON2 && JSON2.parse;
        var enumerableOwnProperties = getBuiltIn("Object", "keys");
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var at = uncurryThis("".charAt);
        var slice = uncurryThis("".slice);
        var exec = uncurryThis(/./.exec);
        var push = uncurryThis([].push);
        var IS_DIGIT = /^\d$/;
        var IS_NON_ZERO_DIGIT = /^[1-9]$/;
        var IS_NUMBER_START = /^[\d-]$/;
        var IS_WHITESPACE = /^[\t\n\r ]$/;
        var PRIMITIVE = 0;
        var OBJECT = 1;
        var $parse = function(source, reviver) {
          source = toString(source);
          var context = new Context(source, 0);
          var root = context.parse();
          var value = root.value;
          var endIndex = context.skip(IS_WHITESPACE, root.end);
          if (endIndex < source.length) {
            throw new SyntaxError2('Unexpected extra character: "' + at(source, endIndex) + '" after the parsed data at: ' + endIndex);
          }
          return isCallable(reviver) ? internalize({ "": value }, "", reviver, root) : value;
        };
        var internalize = function(holder, name, reviver, node) {
          var val = holder[name];
          var unmodified = node && val === node.value;
          var context = unmodified && typeof node.source == "string" ? { source: node.source } : {};
          var elementRecordsLen, keys, len, i, P;
          if (isObject(val)) {
            var nodeIsArray = isArray(val);
            var nodes = unmodified ? node.nodes : nodeIsArray ? [] : {};
            if (nodeIsArray) {
              elementRecordsLen = nodes.length;
              len = lengthOfArrayLike(val);
              for (i = 0; i < len; i++) {
                internalizeProperty(val, i, internalize(val, "" + i, reviver, i < elementRecordsLen ? nodes[i] : void 0));
              }
            } else {
              keys = enumerableOwnProperties(val);
              len = lengthOfArrayLike(keys);
              for (i = 0; i < len; i++) {
                P = keys[i];
                internalizeProperty(val, P, internalize(val, P, reviver, hasOwn(nodes, P) ? nodes[P] : void 0));
              }
            }
          }
          return call(reviver, holder, name, val, context);
        };
        var internalizeProperty = function(object, key, value) {
          if (DESCRIPTORS) {
            var descriptor = getOwnPropertyDescriptor(object, key);
            if (descriptor && !descriptor.configurable) return;
          }
          if (value === void 0) delete object[key];
          else createProperty(object, key, value);
        };
        var Node2 = function(value, end, source, nodes) {
          this.value = value;
          this.end = end;
          this.source = source;
          this.nodes = nodes;
        };
        var Context = function(source, index) {
          this.source = source;
          this.index = index;
        };
        Context.prototype = {
          fork: function(nextIndex) {
            return new Context(this.source, nextIndex);
          },
          parse: function() {
            var source = this.source;
            var i = this.skip(IS_WHITESPACE, this.index);
            var fork = this.fork(i);
            var chr = at(source, i);
            if (exec(IS_NUMBER_START, chr)) return fork.number();
            switch (chr) {
              case "{":
                return fork.object();
              case "[":
                return fork.array();
              case '"':
                return fork.string();
              case "t":
                return fork.keyword(true);
              case "f":
                return fork.keyword(false);
              case "n":
                return fork.keyword(null);
            }
            throw new SyntaxError2('Unexpected character: "' + chr + '" at: ' + i);
          },
          node: function(type, value, start, end, nodes) {
            return new Node2(value, end, type ? null : slice(this.source, start, end), nodes);
          },
          object: function() {
            var source = this.source;
            var i = this.index + 1;
            var expectKeypair = false;
            var object = {};
            var nodes = {};
            while (i < source.length) {
              i = this.until(['"', "}"], i);
              if (at(source, i) === "}" && !expectKeypair) {
                i++;
                break;
              }
              var result = this.fork(i).string();
              var key = result.value;
              i = result.end;
              i = this.until([":"], i) + 1;
              i = this.skip(IS_WHITESPACE, i);
              result = this.fork(i).parse();
              createProperty(nodes, key, result);
              createProperty(object, key, result.value);
              i = this.until([",", "}"], result.end);
              var chr = at(source, i);
              if (chr === ",") {
                expectKeypair = true;
                i++;
              } else if (chr === "}") {
                i++;
                break;
              }
            }
            return this.node(OBJECT, object, this.index, i, nodes);
          },
          array: function() {
            var source = this.source;
            var i = this.index + 1;
            var expectElement = false;
            var array = [];
            var nodes = [];
            while (i < source.length) {
              i = this.skip(IS_WHITESPACE, i);
              if (at(source, i) === "]" && !expectElement) {
                i++;
                break;
              }
              var result = this.fork(i).parse();
              push(nodes, result);
              push(array, result.value);
              i = this.until([",", "]"], result.end);
              if (at(source, i) === ",") {
                expectElement = true;
                i++;
              } else if (at(source, i) === "]") {
                i++;
                break;
              }
            }
            return this.node(OBJECT, array, this.index, i, nodes);
          },
          string: function() {
            var index = this.index;
            var parsed = parseJSONString(this.source, this.index + 1);
            return this.node(PRIMITIVE, parsed.value, index, parsed.end);
          },
          number: function() {
            var source = this.source;
            var startIndex = this.index;
            var i = startIndex;
            if (at(source, i) === "-") i++;
            if (at(source, i) === "0") i++;
            else if (exec(IS_NON_ZERO_DIGIT, at(source, i))) i = this.skip(IS_DIGIT, i + 1);
            else throw new SyntaxError2("Failed to parse number at: " + i);
            if (at(source, i) === ".") i = this.skip(IS_DIGIT, i + 1);
            if (at(source, i) === "e" || at(source, i) === "E") {
              i++;
              if (at(source, i) === "+" || at(source, i) === "-") i++;
              var exponentStartIndex = i;
              i = this.skip(IS_DIGIT, i);
              if (exponentStartIndex === i) throw new SyntaxError2("Failed to parse number's exponent value at: " + i);
            }
            return this.node(PRIMITIVE, Number2(slice(source, startIndex, i)), startIndex, i);
          },
          keyword: function(value) {
            var keyword = "" + value;
            var index = this.index;
            var endIndex = index + keyword.length;
            if (slice(this.source, index, endIndex) !== keyword) throw new SyntaxError2("Failed to parse value at: " + index);
            return this.node(PRIMITIVE, value, index, endIndex);
          },
          skip: function(regex, i) {
            var source = this.source;
            for (; i < source.length; i++) if (!exec(regex, at(source, i))) break;
            return i;
          },
          until: function(array, i) {
            i = this.skip(IS_WHITESPACE, i);
            var chr = at(this.source, i);
            for (var j = 0; j < array.length; j++) if (array[j] === chr) return i;
            throw new SyntaxError2('Unexpected character: "' + chr + '" at: ' + i);
          }
        };
        var NO_SOURCE_SUPPORT = fails(function() {
          var unsafeInt = "9007199254740993";
          var source;
          nativeParse(unsafeInt, function(key, value, context) {
            source = context.source;
          });
          return source !== unsafeInt;
        });
        var PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails(function() {
          return 1 / nativeParse("-0 	") !== -Infinity;
        });
        $({ target: "JSON", stat: true, forced: NO_SOURCE_SUPPORT }, {
          parse: function parse(text, reviver) {
            return PROPER_BASE_PARSE && !isCallable(reviver) ? nativeParse(text) : $parse(text, reviver);
          }
        });
      })
    ),
    /***/
    8469: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var iterateSimple = __webpack_require__2(507);
        var SetHelpers = __webpack_require__2(4402);
        var Set2 = SetHelpers.Set;
        var SetPrototype = SetHelpers.proto;
        var forEach = uncurryThis(SetPrototype.forEach);
        var keys = uncurryThis(SetPrototype.keys);
        var next = keys(new Set2()).next;
        module2.exports = function(set, fn, interruptible) {
          return interruptible ? iterateSimple({ iterator: keys(set), next }, fn) : forEach(set, fn);
        };
      })
    ),
    /***/
    8480: (
      /***/
      ((__unused_webpack_module, exports3, __webpack_require__2) => {
        var internalObjectKeys = __webpack_require__2(1828);
        var enumBugKeys = __webpack_require__2(8727);
        var hiddenKeys = enumBugKeys.concat("length", "prototype");
        exports3.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return internalObjectKeys(O, hiddenKeys);
        };
      })
    ),
    /***/
    8527: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aSet = __webpack_require__2(7080);
        var has = __webpack_require__2(4402).has;
        var size = __webpack_require__2(5170);
        var getSetRecord = __webpack_require__2(3789);
        var iterateSimple = __webpack_require__2(507);
        var iteratorClose = __webpack_require__2(9539);
        module2.exports = function isSupersetOf(other) {
          var O = aSet(this);
          var otherRec = getSetRecord(other);
          if (size(O) < otherRec.size) return false;
          var iterator = otherRec.getIterator();
          return iterateSimple(iterator, function(e) {
            if (!has(O, e)) return iteratorClose(iterator, "normal", false);
          }) !== false;
        };
      })
    ),
    /***/
    8551: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isObject = __webpack_require__2(34);
        var $String = String;
        var $TypeError = TypeError;
        module2.exports = function(argument) {
          if (isObject(argument)) return argument;
          throw new $TypeError($String(argument) + " is not an object");
        };
      })
    ),
    /***/
    8574: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var $Error = Error;
        var replace = uncurryThis("".replace);
        var TEST = (function(arg) {
          return String(new $Error(arg).stack);
        })("zxcasd");
        var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
        var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
        module2.exports = function(stack, dropEntries) {
          if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
            while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
          }
          return stack;
        };
      })
    ),
    /***/
    8622: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var isCallable = __webpack_require__2(4901);
        var WeakMap2 = globalThis2.WeakMap;
        module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
      })
    ),
    /***/
    8646: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var call = __webpack_require__2(9565);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var getIteratorMethod = __webpack_require__2(851);
        module2.exports = function(obj, stringHandling) {
          if (!stringHandling || typeof obj !== "string") anObject(obj);
          var method = getIteratorMethod(obj);
          return getIteratorDirect(anObject(method !== void 0 ? call(method, obj) : obj));
        };
      })
    ),
    /***/
    8686: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var fails = __webpack_require__2(9039);
        module2.exports = DESCRIPTORS && fails(function() {
          return Object.defineProperty(function() {
          }, "prototype", {
            value: 42,
            writable: false
          }).prototype !== 42;
        });
      })
    ),
    /***/
    8721: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var DESCRIPTORS = __webpack_require__2(3724);
        var uncurryThis = __webpack_require__2(9504);
        var defineBuiltInAccessor = __webpack_require__2(2106);
        var URLSearchParamsPrototype = URLSearchParams.prototype;
        var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
        if (DESCRIPTORS && !("size" in URLSearchParamsPrototype)) {
          defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
            get: function size() {
              var count = 0;
              forEach(this, function() {
                count++;
              });
              return count;
            },
            configurable: true,
            enumerable: true
          });
        }
      })
    ),
    /***/
    8727: (
      /***/
      ((module2) => {
        module2.exports = [
          "constructor",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf"
        ];
      })
    ),
    /***/
    8745: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var NATIVE_BIND = __webpack_require__2(616);
        var FunctionPrototype = Function.prototype;
        var apply = FunctionPrototype.apply;
        var call = FunctionPrototype.call;
        module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
          return call.apply(apply, arguments);
        });
      })
    ),
    /***/
    8750: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var aSet = __webpack_require__2(7080);
        var SetHelpers = __webpack_require__2(4402);
        var size = __webpack_require__2(5170);
        var getSetRecord = __webpack_require__2(3789);
        var iterateSet = __webpack_require__2(8469);
        var iterateSimple = __webpack_require__2(507);
        var Set2 = SetHelpers.Set;
        var add = SetHelpers.add;
        var has = SetHelpers.has;
        module2.exports = function intersection(other) {
          var O = aSet(this);
          var otherRec = getSetRecord(other);
          var result = new Set2();
          if (size(O) > otherRec.size) {
            iterateSimple(otherRec.getIterator(), function(e) {
              if (has(O, e)) add(result, e);
            });
          } else {
            iterateSet(O, function(e) {
              if (otherRec.includes(e)) add(result, e);
            });
          }
          return result;
        };
      })
    ),
    /***/
    8773: (
      /***/
      ((__unused_webpack_module, exports3) => {
        var $propertyIsEnumerable = {}.propertyIsEnumerable;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
        exports3.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
          var descriptor = getOwnPropertyDescriptor(this, V);
          return !!descriptor && descriptor.enumerable;
        } : $propertyIsEnumerable;
      })
    ),
    /***/
    8981: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var requireObjectCoercible = __webpack_require__2(7750);
        var $Object = Object;
        module2.exports = function(argument) {
          return $Object(requireObjectCoercible(argument));
        };
      })
    ),
    /***/
    9039: (
      /***/
      ((module2) => {
        module2.exports = function(exec) {
          try {
            return !!exec();
          } catch (error) {
            return true;
          }
        };
      })
    ),
    /***/
    9143: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var uncurryThis = __webpack_require__2(9504);
        var anObjectOrUndefined = __webpack_require__2(3972);
        var aString = __webpack_require__2(3463);
        var hasOwn = __webpack_require__2(9297);
        var base64Map = __webpack_require__2(2804);
        var getAlphabetOption = __webpack_require__2(944);
        var notDetached = __webpack_require__2(5169);
        var base64Alphabet = base64Map.c2i;
        var base64UrlAlphabet = base64Map.c2iUrl;
        var SyntaxError2 = globalThis2.SyntaxError;
        var TypeError2 = globalThis2.TypeError;
        var at = uncurryThis("".charAt);
        var skipAsciiWhitespace = function(string, index) {
          var length = string.length;
          for (; index < length; index++) {
            var chr = at(string, index);
            if (chr !== " " && chr !== "	" && chr !== "\n" && chr !== "\f" && chr !== "\r") break;
          }
          return index;
        };
        var decodeBase64Chunk = function(chunk, alphabet, throwOnExtraBits) {
          var chunkLength = chunk.length;
          if (chunkLength < 4) {
            chunk += chunkLength === 2 ? "AA" : "A";
          }
          var triplet = (alphabet[at(chunk, 0)] << 18) + (alphabet[at(chunk, 1)] << 12) + (alphabet[at(chunk, 2)] << 6) + alphabet[at(chunk, 3)];
          var chunkBytes = [
            triplet >> 16 & 255,
            triplet >> 8 & 255,
            triplet & 255
          ];
          if (chunkLength === 2) {
            if (throwOnExtraBits && chunkBytes[1] !== 0) {
              throw new SyntaxError2("Extra bits");
            }
            return [chunkBytes[0]];
          }
          if (chunkLength === 3) {
            if (throwOnExtraBits && chunkBytes[2] !== 0) {
              throw new SyntaxError2("Extra bits");
            }
            return [chunkBytes[0], chunkBytes[1]];
          }
          return chunkBytes;
        };
        var writeBytes = function(bytes, elements, written) {
          var elementsLength = elements.length;
          for (var index = 0; index < elementsLength; index++) {
            bytes[written + index] = elements[index];
          }
          return written + elementsLength;
        };
        module2.exports = function(string, options, into, maxLength) {
          aString(string);
          anObjectOrUndefined(options);
          var alphabet = getAlphabetOption(options) === "base64" ? base64Alphabet : base64UrlAlphabet;
          var lastChunkHandling = options ? options.lastChunkHandling : void 0;
          if (lastChunkHandling === void 0) lastChunkHandling = "loose";
          if (lastChunkHandling !== "loose" && lastChunkHandling !== "strict" && lastChunkHandling !== "stop-before-partial") {
            throw new TypeError2("Incorrect `lastChunkHandling` option");
          }
          if (into) notDetached(into.buffer);
          var stringLength = string.length;
          var bytes = into || [];
          var written = 0;
          var read = 0;
          var chunk = "";
          var index = 0;
          if (maxLength) while (true) {
            index = skipAsciiWhitespace(string, index);
            if (index === stringLength) {
              if (chunk.length > 0) {
                if (lastChunkHandling === "stop-before-partial") {
                  break;
                }
                if (lastChunkHandling === "loose") {
                  if (chunk.length === 1) {
                    throw new SyntaxError2("Malformed padding: exactly one additional character");
                  }
                  written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
                } else {
                  throw new SyntaxError2("Missing padding");
                }
              }
              read = stringLength;
              break;
            }
            var chr = at(string, index);
            ++index;
            if (chr === "=") {
              if (chunk.length < 2) {
                throw new SyntaxError2("Padding is too early");
              }
              index = skipAsciiWhitespace(string, index);
              if (chunk.length === 2) {
                if (index === stringLength) {
                  if (lastChunkHandling === "stop-before-partial") {
                    break;
                  }
                  throw new SyntaxError2("Malformed padding: only one =");
                }
                if (at(string, index) === "=") {
                  ++index;
                  index = skipAsciiWhitespace(string, index);
                }
              }
              if (index < stringLength) {
                throw new SyntaxError2("Unexpected character after padding");
              }
              written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, lastChunkHandling === "strict"), written);
              read = stringLength;
              break;
            }
            if (!hasOwn(alphabet, chr)) {
              throw new SyntaxError2("Unexpected character");
            }
            var remainingBytes = maxLength - written;
            if (remainingBytes === 1 && chunk.length === 2 || remainingBytes === 2 && chunk.length === 3) {
              break;
            }
            chunk += chr;
            if (chunk.length === 4) {
              written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
              chunk = "";
              read = index;
              if (written === maxLength) {
                break;
              }
            }
          }
          return { bytes, read, written };
        };
      })
    ),
    /***/
    9286: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var SetHelpers = __webpack_require__2(4402);
        var iterate = __webpack_require__2(8469);
        var Set2 = SetHelpers.Set;
        var add = SetHelpers.add;
        module2.exports = function(set) {
          var result = new Set2();
          iterate(set, function(it) {
            add(result, it);
          });
          return result;
        };
      })
    ),
    /***/
    9297: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var uncurryThis = __webpack_require__2(9504);
        var toObject = __webpack_require__2(8981);
        var hasOwnProperty = uncurryThis({}.hasOwnProperty);
        module2.exports = Object.hasOwn || function hasOwn(it, key) {
          return hasOwnProperty(toObject(it), key);
        };
      })
    ),
    /***/
    9306: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var isCallable = __webpack_require__2(4901);
        var tryToString = __webpack_require__2(6823);
        var $TypeError = TypeError;
        module2.exports = function(argument) {
          if (isCallable(argument)) return argument;
          throw new $TypeError(tryToString(argument) + " is not a function");
        };
      })
    ),
    /***/
    9314: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var call = __webpack_require__2(9565);
        var anObject = __webpack_require__2(8551);
        var getIteratorDirect = __webpack_require__2(1767);
        var notANaN = __webpack_require__2(4149);
        var toPositiveInteger = __webpack_require__2(9590);
        var iteratorClose = __webpack_require__2(9539);
        var createIteratorProxy = __webpack_require__2(9462);
        var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);
        var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
        var IS_PURE = __webpack_require__2(6395);
        var DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("drop", 0);
        var dropWithoutClosingOnEarlyError = !IS_PURE && !DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("drop", RangeError);
        var FORCED = IS_PURE || DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR || dropWithoutClosingOnEarlyError;
        var IteratorProxy = createIteratorProxy(function() {
          var iterator = this.iterator;
          var next = this.next;
          var result, done;
          while (this.remaining) {
            this.remaining--;
            result = anObject(call(next, iterator));
            done = this.done = !!result.done;
            if (done) return;
          }
          result = anObject(call(next, iterator));
          done = this.done = !!result.done;
          if (!done) return result.value;
        });
        $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
          drop: function drop(limit) {
            anObject(this);
            var remaining;
            try {
              remaining = toPositiveInteger(notANaN(+limit));
            } catch (error) {
              iteratorClose(this, "throw", error);
            }
            if (dropWithoutClosingOnEarlyError) return call(dropWithoutClosingOnEarlyError, this, remaining);
            return new IteratorProxy(getIteratorDirect(this), {
              remaining
            });
          }
        });
      })
    ),
    /***/
    9429: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var IS_NODE = __webpack_require__2(6193);
        module2.exports = function(name) {
          if (IS_NODE) {
            try {
              return globalThis2.process.getBuiltinModule(name);
            } catch (error) {
            }
            try {
              return Function('return require("' + name + '")')();
            } catch (error) {
            }
          }
        };
      })
    ),
    /***/
    9432: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        __webpack_require__2(5213);
      })
    ),
    /***/
    9433: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var defineProperty = Object.defineProperty;
        module2.exports = function(key, value) {
          try {
            defineProperty(globalThis2, key, { value, configurable: true, writable: true });
          } catch (error) {
            globalThis2[key] = value;
          }
          return value;
        };
      })
    ),
    /***/
    9462: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var call = __webpack_require__2(9565);
        var create = __webpack_require__2(2360);
        var createNonEnumerableProperty = __webpack_require__2(6699);
        var defineBuiltIns = __webpack_require__2(6279);
        var wellKnownSymbol = __webpack_require__2(8227);
        var InternalStateModule = __webpack_require__2(1181);
        var getMethod = __webpack_require__2(5966);
        var IteratorPrototype = __webpack_require__2(7657).IteratorPrototype;
        var createIterResultObject = __webpack_require__2(2529);
        var iteratorClose = __webpack_require__2(9539);
        var iteratorCloseAll = __webpack_require__2(1385);
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var ITERATOR_HELPER = "IteratorHelper";
        var WRAP_FOR_VALID_ITERATOR = "WrapForValidIterator";
        var NORMAL = "normal";
        var THROW = "throw";
        var setInternalState = InternalStateModule.set;
        var createIteratorProxyPrototype = function(IS_ITERATOR) {
          var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);
          return defineBuiltIns(create(IteratorPrototype), {
            next: function next() {
              var state = getInternalState(this);
              if (IS_ITERATOR) return state.nextHandler();
              if (state.done) return createIterResultObject(void 0, true);
              try {
                var result = state.nextHandler();
                return state.returnHandlerResult ? result : createIterResultObject(result, state.done);
              } catch (error) {
                state.done = true;
                throw error;
              }
            },
            "return": function() {
              var state = getInternalState(this);
              var iterator = state.iterator;
              state.done = true;
              if (IS_ITERATOR) {
                var returnMethod = getMethod(iterator, "return");
                return returnMethod ? call(returnMethod, iterator) : createIterResultObject(void 0, true);
              }
              if (state.inner) try {
                iteratorClose(state.inner.iterator, NORMAL);
              } catch (error) {
                return iteratorClose(iterator, THROW, error);
              }
              if (state.openIters) try {
                iteratorCloseAll(state.openIters, NORMAL);
              } catch (error) {
                return iteratorClose(iterator, THROW, error);
              }
              if (iterator) iteratorClose(iterator, NORMAL);
              return createIterResultObject(void 0, true);
            }
          });
        };
        var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
        var IteratorHelperPrototype = createIteratorProxyPrototype(false);
        createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, "Iterator Helper");
        module2.exports = function(nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {
          var IteratorProxy = function Iterator2(record, state) {
            if (state) {
              state.iterator = record.iterator;
              state.next = record.next;
            } else state = record;
            state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
            state.returnHandlerResult = !!RETURN_HANDLER_RESULT;
            state.nextHandler = nextHandler;
            state.counter = 0;
            state.done = false;
            setInternalState(this, state);
          };
          IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;
          return IteratorProxy;
        };
      })
    ),
    /***/
    9486: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var $ = __webpack_require__2(6518);
        var globalThis2 = __webpack_require__2(4576);
        var uncurryThis = __webpack_require__2(9504);
        var anObjectOrUndefined = __webpack_require__2(3972);
        var anUint8Array = __webpack_require__2(4154);
        var notDetached = __webpack_require__2(5169);
        var base64Map = __webpack_require__2(2804);
        var getAlphabetOption = __webpack_require__2(944);
        var base64Alphabet = base64Map.i2c;
        var base64UrlAlphabet = base64Map.i2cUrl;
        var charAt = uncurryThis("".charAt);
        var Uint8Array2 = globalThis2.Uint8Array;
        var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.toBase64 || !(function() {
          try {
            var target = new Uint8Array2();
            target.toBase64(null);
          } catch (error) {
            return true;
          }
        })();
        if (Uint8Array2) $({ target: "Uint8Array", proto: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
          toBase64: function toBase64() {
            var array = anUint8Array(this);
            var options = arguments.length ? anObjectOrUndefined(arguments[0]) : void 0;
            var alphabet = getAlphabetOption(options) === "base64" ? base64Alphabet : base64UrlAlphabet;
            var omitPadding = !!options && !!options.omitPadding;
            notDetached(this.buffer);
            var result = "";
            var i = 0;
            var length = array.length;
            var triplet;
            var at = function(shift) {
              return charAt(alphabet, triplet >> 6 * shift & 63);
            };
            for (; i + 2 < length; i += 3) {
              triplet = (array[i] << 16) + (array[i + 1] << 8) + array[i + 2];
              result += at(3) + at(2) + at(1) + at(0);
            }
            if (i + 2 === length) {
              triplet = (array[i] << 16) + (array[i + 1] << 8);
              result += at(3) + at(2) + at(1) + (omitPadding ? "" : "=");
            } else if (i + 1 === length) {
              triplet = array[i] << 16;
              result += at(3) + at(2) + (omitPadding ? "" : "==");
            }
            return result;
          }
        });
      })
    ),
    /***/
    9504: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var NATIVE_BIND = __webpack_require__2(616);
        var FunctionPrototype = Function.prototype;
        var call = FunctionPrototype.call;
        var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
        module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
          return function() {
            return call.apply(fn, arguments);
          };
        };
      })
    ),
    /***/
    9519: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var globalThis2 = __webpack_require__2(4576);
        var userAgent = __webpack_require__2(2839);
        var process2 = globalThis2.process;
        var Deno2 = globalThis2.Deno;
        var versions = process2 && process2.versions || Deno2 && Deno2.version;
        var v8 = versions && versions.v8;
        var match, version2;
        if (v8) {
          match = v8.split(".");
          version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
        }
        if (!version2 && userAgent) {
          match = userAgent.match(/Edge\/(\d+)/);
          if (!match || match[1] >= 74) {
            match = userAgent.match(/Chrome\/(\d+)/);
            if (match) version2 = +match[1];
          }
        }
        module2.exports = version2;
      })
    ),
    /***/
    9539: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var call = __webpack_require__2(9565);
        var anObject = __webpack_require__2(8551);
        var getMethod = __webpack_require__2(5966);
        module2.exports = function(iterator, kind, value) {
          var innerResult, innerError;
          anObject(iterator);
          try {
            innerResult = getMethod(iterator, "return");
            if (!innerResult) {
              if (kind === "throw") throw value;
              return value;
            }
            innerResult = call(innerResult, iterator);
          } catch (error) {
            innerError = true;
            innerResult = error;
          }
          if (kind === "throw") throw value;
          if (innerError) throw innerResult;
          anObject(innerResult);
          return value;
        };
      })
    ),
    /***/
    9565: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var NATIVE_BIND = __webpack_require__2(616);
        var call = Function.prototype.call;
        module2.exports = NATIVE_BIND ? call.bind(call) : function() {
          return call.apply(call, arguments);
        };
      })
    ),
    /***/
    9577: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        var arrayWith = __webpack_require__2(9928);
        var ArrayBufferViewCore = __webpack_require__2(4644);
        var isBigIntArray = __webpack_require__2(1108);
        var toIntegerOrInfinity = __webpack_require__2(1291);
        var toBigInt = __webpack_require__2(5854);
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var PROPER_ORDER = (function() {
          try {
            new Int8Array(1)["with"](2, { valueOf: function() {
              throw 8;
            } });
          } catch (error) {
            return error === 8;
          }
        })();
        var THROW_ON_NEGATIVE_FRACTIONAL_INDEX = PROPER_ORDER && (function() {
          try {
            new Int8Array(1)["with"](-0.5, 1);
          } catch (error) {
            return true;
          }
        })();
        exportTypedArrayMethod("with", { "with": function(index, value) {
          var O = aTypedArray(this);
          var relativeIndex = toIntegerOrInfinity(index);
          var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;
          return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);
        } }["with"], !PROPER_ORDER || THROW_ON_NEGATIVE_FRACTIONAL_INDEX);
      })
    ),
    /***/
    9590: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var toIntegerOrInfinity = __webpack_require__2(1291);
        var $RangeError = RangeError;
        module2.exports = function(it) {
          var result = toIntegerOrInfinity(it);
          if (result < 0) throw new $RangeError("The argument can't be less than 0");
          return result;
        };
      })
    ),
    /***/
    9617: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var toIndexedObject = __webpack_require__2(5397);
        var toAbsoluteIndex = __webpack_require__2(5610);
        var lengthOfArrayLike = __webpack_require__2(6198);
        var createMethod = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O = toIndexedObject($this);
            var length = lengthOfArrayLike(O);
            if (length === 0) return !IS_INCLUDES && -1;
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            if (IS_INCLUDES && el !== el) while (length > index) {
              value = O[index++];
              if (value !== value) return true;
            }
            else for (; length > index; index++) {
              if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
            }
            return !IS_INCLUDES && -1;
          };
        };
        module2.exports = {
          // `Array.prototype.includes` method
          // https://tc39.es/ecma262/#sec-array.prototype.includes
          includes: createMethod(true),
          // `Array.prototype.indexOf` method
          // https://tc39.es/ecma262/#sec-array.prototype.indexof
          indexOf: createMethod(false)
        };
      })
    ),
    /***/
    9631: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        __webpack_require__2(9486);
      })
    ),
    /***/
    9797: (
      /***/
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        __webpack_require__2(4226);
      })
    ),
    /***/
    9835: (
      /***/
      ((module2) => {
        module2.exports = function(METHOD_NAME) {
          try {
            var baseSet = /* @__PURE__ */ new Set();
            var setLike = {
              size: 0,
              has: function() {
                return true;
              },
              keys: function() {
                return Object.defineProperty({}, "next", {
                  get: function() {
                    baseSet.clear();
                    baseSet.add(4);
                    return function() {
                      return { done: true };
                    };
                  }
                });
              }
            };
            var result = baseSet[METHOD_NAME](setLike);
            return result.size === 1 && result.values().next().value === 4;
          } catch (error) {
            return false;
          }
        };
      })
    ),
    /***/
    9928: (
      /***/
      ((module2, __unused_webpack_exports, __webpack_require__2) => {
        var lengthOfArrayLike = __webpack_require__2(6198);
        var toIntegerOrInfinity = __webpack_require__2(1291);
        var $RangeError = RangeError;
        module2.exports = function(O, C, index, value) {
          var len = lengthOfArrayLike(O);
          var relativeIndex = toIntegerOrInfinity(index);
          var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
          if (actualIndex >= len || actualIndex < 0) throw new $RangeError("Incorrect index");
          var A = new C(len);
          var k = 0;
          for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
          return A;
        };
      })
    )
    /******/
  };
  var __webpack_module_cache__ = {};
  function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== void 0) {
      return cachedModule.exports;
    }
    var module2 = __webpack_module_cache__[moduleId] = {
      /******/
      // no module.id needed
      /******/
      // no module.loaded needed
      /******/
      exports: {}
      /******/
    };
    __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
    return module2.exports;
  }
  (() => {
    __webpack_require__.d = (exports3, definition) => {
      for (var key in definition) {
        if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports3, key)) {
          Object.defineProperty(exports3, key, { enumerable: true, get: definition[key] });
        }
      }
    };
  })();
  (() => {
    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
  })();
  __webpack_require__(4114);
  __webpack_require__(6573);
  __webpack_require__(8100);
  __webpack_require__(7936);
  __webpack_require__(8111);
  __webpack_require__(8237);
  __webpack_require__(1689);
  __webpack_require__(9577);
  __webpack_require__(4235);
  __webpack_require__(9432);
  __webpack_require__(1549);
  __webpack_require__(9797);
  __webpack_require__(9631);
  __webpack_require__(5623);
  __webpack_require__(4979);
  __webpack_require__(5781);
  const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
  const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
  const LINE_FACTOR = 1.35;
  const RenderingIntentFlag = {
    ANY: 1,
    DISPLAY: 2,
    PRINT: 4,
    ANNOTATIONS_FORMS: 16,
    ANNOTATIONS_STORAGE: 32,
    ANNOTATIONS_DISABLE: 64,
    IS_EDITING: 128,
    OPLIST: 256
  };
  const AnnotationMode = {
    DISABLE: 0,
    ENABLE: 1,
    ENABLE_FORMS: 2,
    ENABLE_STORAGE: 3
  };
  const AnnotationEditorPrefix = "pdfjs_internal_editor_";
  const AnnotationEditorType = {
    DISABLE: -1,
    NONE: 0,
    FREETEXT: 3,
    HIGHLIGHT: 9,
    STAMP: 13,
    INK: 15,
    POPUP: 16,
    SIGNATURE: 101,
    COMMENT: 102
  };
  const AnnotationEditorParamsType = {
    RESIZE: 1,
    CREATE: 2,
    FREETEXT_SIZE: 11,
    FREETEXT_COLOR: 12,
    FREETEXT_OPACITY: 13,
    INK_COLOR: 21,
    INK_THICKNESS: 22,
    INK_OPACITY: 23,
    HIGHLIGHT_COLOR: 31,
    HIGHLIGHT_THICKNESS: 32,
    HIGHLIGHT_FREE: 33,
    HIGHLIGHT_SHOW_ALL: 34,
    DRAW_STEP: 41
  };
  const PermissionFlag = {
    PRINT: 4,
    MODIFY_CONTENTS: 8,
    COPY: 16,
    MODIFY_ANNOTATIONS: 32,
    FILL_INTERACTIVE_FORMS: 256,
    COPY_FOR_ACCESSIBILITY: 512,
    ASSEMBLE: 1024,
    PRINT_HIGH_QUALITY: 2048
  };
  const TextRenderingMode = {
    FILL: 0,
    STROKE: 1,
    FILL_STROKE: 2,
    INVISIBLE: 3,
    FILL_STROKE_MASK: 3,
    ADD_TO_PATH_FLAG: 4
  };
  const util_ImageKind = {
    GRAYSCALE_1BPP: 1,
    RGB_24BPP: 2,
    RGBA_32BPP: 3
  };
  const AnnotationType = {
    TEXT: 1,
    LINK: 2,
    FREETEXT: 3,
    LINE: 4,
    SQUARE: 5,
    CIRCLE: 6,
    POLYGON: 7,
    POLYLINE: 8,
    HIGHLIGHT: 9,
    UNDERLINE: 10,
    SQUIGGLY: 11,
    STRIKEOUT: 12,
    STAMP: 13,
    CARET: 14,
    INK: 15,
    POPUP: 16,
    FILEATTACHMENT: 17,
    SOUND: 18,
    MOVIE: 19,
    WIDGET: 20,
    SCREEN: 21,
    PRINTERMARK: 22,
    TRAPNET: 23,
    WATERMARK: 24,
    THREED: 25,
    REDACT: 26
  };
  const AnnotationBorderStyleType = {
    SOLID: 1,
    DASHED: 2,
    BEVELED: 3,
    INSET: 4,
    UNDERLINE: 5
  };
  const VerbosityLevel = {
    ERRORS: 0,
    WARNINGS: 1,
    INFOS: 5
  };
  const OPS = {
    dependency: 1,
    setLineWidth: 2,
    setLineCap: 3,
    setLineJoin: 4,
    setMiterLimit: 5,
    setDash: 6,
    setRenderingIntent: 7,
    setFlatness: 8,
    setGState: 9,
    save: 10,
    restore: 11,
    transform: 12,
    moveTo: 13,
    lineTo: 14,
    curveTo: 15,
    curveTo2: 16,
    curveTo3: 17,
    closePath: 18,
    rectangle: 19,
    stroke: 20,
    closeStroke: 21,
    fill: 22,
    eoFill: 23,
    fillStroke: 24,
    eoFillStroke: 25,
    closeFillStroke: 26,
    closeEOFillStroke: 27,
    endPath: 28,
    clip: 29,
    eoClip: 30,
    beginText: 31,
    endText: 32,
    setCharSpacing: 33,
    setWordSpacing: 34,
    setHScale: 35,
    setLeading: 36,
    setFont: 37,
    setTextRenderingMode: 38,
    setTextRise: 39,
    moveText: 40,
    setLeadingMoveText: 41,
    setTextMatrix: 42,
    nextLine: 43,
    showText: 44,
    showSpacedText: 45,
    nextLineShowText: 46,
    nextLineSetSpacingShowText: 47,
    setCharWidth: 48,
    setCharWidthAndBounds: 49,
    setStrokeColorSpace: 50,
    setFillColorSpace: 51,
    setStrokeColor: 52,
    setStrokeColorN: 53,
    setFillColor: 54,
    setFillColorN: 55,
    setStrokeGray: 56,
    setFillGray: 57,
    setStrokeRGBColor: 58,
    setFillRGBColor: 59,
    setStrokeCMYKColor: 60,
    setFillCMYKColor: 61,
    shadingFill: 62,
    beginInlineImage: 63,
    beginImageData: 64,
    endInlineImage: 65,
    paintXObject: 66,
    markPoint: 67,
    markPointProps: 68,
    beginMarkedContent: 69,
    beginMarkedContentProps: 70,
    endMarkedContent: 71,
    beginCompat: 72,
    endCompat: 73,
    paintFormXObjectBegin: 74,
    paintFormXObjectEnd: 75,
    beginGroup: 76,
    endGroup: 77,
    beginAnnotation: 80,
    endAnnotation: 81,
    paintImageMaskXObject: 83,
    paintImageMaskXObjectGroup: 84,
    paintImageXObject: 85,
    paintInlineImageXObject: 86,
    paintInlineImageXObjectGroup: 87,
    paintImageXObjectRepeat: 88,
    paintImageMaskXObjectRepeat: 89,
    paintSolidColorImageMask: 90,
    constructPath: 91,
    setStrokeTransparent: 92,
    setFillTransparent: 93,
    rawFillPath: 94
  };
  const DrawOPS = {
    moveTo: 0,
    lineTo: 1,
    curveTo: 2,
    closePath: 3
  };
  const PasswordResponses = {
    NEED_PASSWORD: 1,
    INCORRECT_PASSWORD: 2
  };
  let verbosity = VerbosityLevel.WARNINGS;
  function setVerbosityLevel(level) {
    if (Number.isInteger(level)) {
      verbosity = level;
    }
  }
  function getVerbosityLevel() {
    return verbosity;
  }
  function info(msg) {
    if (verbosity >= VerbosityLevel.INFOS) {
      console.log(`Info: ${msg}`);
    }
  }
  function warn(msg) {
    if (verbosity >= VerbosityLevel.WARNINGS) {
      console.log(`Warning: ${msg}`);
    }
  }
  function unreachable(msg) {
    throw new Error(msg);
  }
  function assert(cond, msg) {
    if (!cond) {
      unreachable(msg);
    }
  }
  function _isValidProtocol(url) {
    switch (url?.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "mailto:":
      case "tel:":
        return true;
      default:
        return false;
    }
  }
  function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
    if (!url) {
      return null;
    }
    if (options && typeof url === "string") {
      if (options.addDefaultProtocol && url.startsWith("www.")) {
        const dots = url.match(/\./g);
        if (dots?.length >= 2) {
          url = `http://${url}`;
        }
      }
      if (options.tryConvertEncoding) {
        try {
          url = stringToUTF8String(url);
        } catch {
        }
      }
    }
    const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
    return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;
  }
  function updateUrlHash(url, hash, allowRel = false) {
    const res = URL.parse(url);
    if (res) {
      res.hash = hash;
      return res.href;
    }
    if (allowRel && createValidAbsoluteUrl(url, "http://example.com")) {
      return url.split("#", 1)[0] + `${hash ? `#${hash}` : ""}`;
    }
    return "";
  }
  function shadow(obj, prop, value, nonSerializable = false) {
    Object.defineProperty(obj, prop, {
      value,
      enumerable: !nonSerializable,
      configurable: true,
      writable: false
    });
    return value;
  }
  const BaseException = (function BaseExceptionClosure() {
    function BaseException2(message, name) {
      this.message = message;
      this.name = name;
    }
    BaseException2.prototype = new Error();
    BaseException2.constructor = BaseException2;
    return BaseException2;
  })();
  class PasswordException extends BaseException {
    constructor(msg, code) {
      super(msg, "PasswordException");
      this.code = code;
    }
  }
  class UnknownErrorException extends BaseException {
    constructor(msg, details) {
      super(msg, "UnknownErrorException");
      this.details = details;
    }
  }
  class InvalidPDFException extends BaseException {
    constructor(msg) {
      super(msg, "InvalidPDFException");
    }
  }
  class ResponseException extends BaseException {
    constructor(msg, status, missing) {
      super(msg, "ResponseException");
      this.status = status;
      this.missing = missing;
    }
  }
  class FormatError extends BaseException {
    constructor(msg) {
      super(msg, "FormatError");
    }
  }
  class AbortException extends BaseException {
    constructor(msg) {
      super(msg, "AbortException");
    }
  }
  function bytesToString(bytes) {
    if (typeof bytes !== "object" || bytes?.length === void 0) {
      unreachable("Invalid argument for bytesToString");
    }
    const length = bytes.length;
    const MAX_ARGUMENT_COUNT = 8192;
    if (length < MAX_ARGUMENT_COUNT) {
      return String.fromCharCode.apply(null, bytes);
    }
    const strBuf = [];
    for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
      const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
      const chunk = bytes.subarray(i, chunkEnd);
      strBuf.push(String.fromCharCode.apply(null, chunk));
    }
    return strBuf.join("");
  }
  function stringToBytes(str) {
    if (typeof str !== "string") {
      unreachable("Invalid argument for stringToBytes");
    }
    const length = str.length;
    const bytes = new Uint8Array(length);
    for (let i = 0; i < length; ++i) {
      bytes[i] = str.charCodeAt(i) & 255;
    }
    return bytes;
  }
  function string32(value) {
    return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
  }
  function isLittleEndian() {
    const buffer8 = new Uint8Array(4);
    buffer8[0] = 1;
    const view32 = new Uint32Array(buffer8.buffer, 0, 1);
    return view32[0] === 1;
  }
  function isEvalSupported() {
    try {
      new Function("");
      return true;
    } catch {
      return false;
    }
  }
  class util_FeatureTest {
    static get isLittleEndian() {
      return shadow(this, "isLittleEndian", isLittleEndian());
    }
    static get isEvalSupported() {
      return shadow(this, "isEvalSupported", isEvalSupported());
    }
    static get isOffscreenCanvasSupported() {
      return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
    }
    static get isImageDecoderSupported() {
      return shadow(this, "isImageDecoderSupported", typeof ImageDecoder !== "undefined");
    }
    static get platform() {
      const {
        platform,
        userAgent
      } = navigator;
      return shadow(this, "platform", {
        isAndroid: userAgent.includes("Android"),
        isLinux: platform.includes("Linux"),
        isMac: platform.includes("Mac"),
        isWindows: platform.includes("Win"),
        isFirefox: userAgent.includes("Firefox")
      });
    }
    static get isCSSRoundSupported() {
      return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
    }
  }
  const hexNumbers = Array.from(Array(256).keys(), (n) => n.toString(16).padStart(2, "0"));
  class Util {
    static makeHexColor(r, g, b) {
      return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
    }
    static domMatrixToTransform(dm) {
      return [dm.a, dm.b, dm.c, dm.d, dm.e, dm.f];
    }
    static scaleMinMax(transform, minMax) {
      let temp;
      if (transform[0]) {
        if (transform[0] < 0) {
          temp = minMax[0];
          minMax[0] = minMax[2];
          minMax[2] = temp;
        }
        minMax[0] *= transform[0];
        minMax[2] *= transform[0];
        if (transform[3] < 0) {
          temp = minMax[1];
          minMax[1] = minMax[3];
          minMax[3] = temp;
        }
        minMax[1] *= transform[3];
        minMax[3] *= transform[3];
      } else {
        temp = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temp;
        temp = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temp;
        if (transform[1] < 0) {
          temp = minMax[1];
          minMax[1] = minMax[3];
          minMax[3] = temp;
        }
        minMax[1] *= transform[1];
        minMax[3] *= transform[1];
        if (transform[2] < 0) {
          temp = minMax[0];
          minMax[0] = minMax[2];
          minMax[2] = temp;
        }
        minMax[0] *= transform[2];
        minMax[2] *= transform[2];
      }
      minMax[0] += transform[4];
      minMax[1] += transform[5];
      minMax[2] += transform[4];
      minMax[3] += transform[5];
    }
    static transform(m1, m2) {
      return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
    }
    static multiplyByDOMMatrix(m, md) {
      return [m[0] * md.a + m[2] * md.b, m[1] * md.a + m[3] * md.b, m[0] * md.c + m[2] * md.d, m[1] * md.c + m[3] * md.d, m[0] * md.e + m[2] * md.f + m[4], m[1] * md.e + m[3] * md.f + m[5]];
    }
    static applyTransform(p, m, pos = 0) {
      const p0 = p[pos];
      const p1 = p[pos + 1];
      p[pos] = p0 * m[0] + p1 * m[2] + m[4];
      p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];
    }
    static applyTransformToBezier(p, transform, pos = 0) {
      const m0 = transform[0];
      const m1 = transform[1];
      const m2 = transform[2];
      const m3 = transform[3];
      const m4 = transform[4];
      const m5 = transform[5];
      for (let i = 0; i < 6; i += 2) {
        const pI = p[pos + i];
        const pI1 = p[pos + i + 1];
        p[pos + i] = pI * m0 + pI1 * m2 + m4;
        p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;
      }
    }
    static applyInverseTransform(p, m) {
      const p0 = p[0];
      const p1 = p[1];
      const d = m[0] * m[3] - m[1] * m[2];
      p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
      p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    }
    static axialAlignedBoundingBox(rect, transform, output) {
      const m0 = transform[0];
      const m1 = transform[1];
      const m2 = transform[2];
      const m3 = transform[3];
      const m4 = transform[4];
      const m5 = transform[5];
      const r0 = rect[0];
      const r1 = rect[1];
      const r2 = rect[2];
      const r3 = rect[3];
      let a0 = m0 * r0 + m4;
      let a2 = a0;
      let a1 = m0 * r2 + m4;
      let a3 = a1;
      let b0 = m3 * r1 + m5;
      let b2 = b0;
      let b1 = m3 * r3 + m5;
      let b3 = b1;
      if (m1 !== 0 || m2 !== 0) {
        const m1r0 = m1 * r0;
        const m1r2 = m1 * r2;
        const m2r1 = m2 * r1;
        const m2r3 = m2 * r3;
        a0 += m2r1;
        a3 += m2r1;
        a1 += m2r3;
        a2 += m2r3;
        b0 += m1r0;
        b3 += m1r0;
        b1 += m1r2;
        b2 += m1r2;
      }
      output[0] = Math.min(output[0], a0, a1, a2, a3);
      output[1] = Math.min(output[1], b0, b1, b2, b3);
      output[2] = Math.max(output[2], a0, a1, a2, a3);
      output[3] = Math.max(output[3], b0, b1, b2, b3);
    }
    static inverseTransform(m) {
      const d = m[0] * m[3] - m[1] * m[2];
      return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
    }
    static singularValueDecompose2dScale(matrix, output) {
      const m0 = matrix[0];
      const m1 = matrix[1];
      const m2 = matrix[2];
      const m3 = matrix[3];
      const a = m0 ** 2 + m1 ** 2;
      const b = m0 * m2 + m1 * m3;
      const c = m2 ** 2 + m3 ** 2;
      const first = (a + c) / 2;
      const second = Math.sqrt(first ** 2 - (a * c - b ** 2));
      output[0] = Math.sqrt(first + second || 1);
      output[1] = Math.sqrt(first - second || 1);
    }
    static normalizeRect(rect) {
      const r = rect.slice(0);
      if (rect[0] > rect[2]) {
        r[0] = rect[2];
        r[2] = rect[0];
      }
      if (rect[1] > rect[3]) {
        r[1] = rect[3];
        r[3] = rect[1];
      }
      return r;
    }
    static intersect(rect1, rect2) {
      const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
      const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
      if (xLow > xHigh) {
        return null;
      }
      const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
      const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
      if (yLow > yHigh) {
        return null;
      }
      return [xLow, yLow, xHigh, yHigh];
    }
    static pointBoundingBox(x, y, minMax) {
      minMax[0] = Math.min(minMax[0], x);
      minMax[1] = Math.min(minMax[1], y);
      minMax[2] = Math.max(minMax[2], x);
      minMax[3] = Math.max(minMax[3], y);
    }
    static rectBoundingBox(x0, y0, x1, y1, minMax) {
      minMax[0] = Math.min(minMax[0], x0, x1);
      minMax[1] = Math.min(minMax[1], y0, y1);
      minMax[2] = Math.max(minMax[2], x0, x1);
      minMax[3] = Math.max(minMax[3], y0, y1);
    }
    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {
      if (t <= 0 || t >= 1) {
        return;
      }
      const mt = 1 - t;
      const tt = t * t;
      const ttt = tt * t;
      const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;
      const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;
      minMax[0] = Math.min(minMax[0], x);
      minMax[1] = Math.min(minMax[1], y);
      minMax[2] = Math.max(minMax[2], x);
      minMax[3] = Math.max(minMax[3], y);
    }
    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) >= 1e-12) {
          this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);
        }
        return;
      }
      const delta = b ** 2 - 4 * c * a;
      if (delta < 0) {
        return;
      }
      const sqrtDelta = Math.sqrt(delta);
      const a2 = 2 * a;
      this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);
      this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);
    }
    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
      minMax[0] = Math.min(minMax[0], x0, x3);
      minMax[1] = Math.min(minMax[1], y0, y3);
      minMax[2] = Math.max(minMax[2], x0, x3);
      minMax[3] = Math.max(minMax[3], y0, y3);
      this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);
      this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);
    }
  }
  function stringToUTF8String(str) {
    return decodeURIComponent(escape(str));
  }
  let NormalizeRegex = null;
  let NormalizationMap = null;
  function normalizeUnicode(str) {
    if (!NormalizeRegex) {
      NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
      NormalizationMap = /* @__PURE__ */ new Map([["", "t"]]);
    }
    return str.replaceAll(NormalizeRegex, (_, p1, p2) => p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2));
  }
  function getUuid() {
    if (typeof crypto.randomUUID === "function") {
      return crypto.randomUUID();
    }
    const buf = new Uint8Array(32);
    crypto.getRandomValues(buf);
    return bytesToString(buf);
  }
  const AnnotationPrefix = "pdfjs_internal_id_";
  function _isValidExplicitDest(validRef, validName, dest) {
    if (!Array.isArray(dest) || dest.length < 2) {
      return false;
    }
    const [page, zoom, ...args] = dest;
    if (!validRef(page) && !Number.isInteger(page)) {
      return false;
    }
    if (!validName(zoom)) {
      return false;
    }
    const argsLen = args.length;
    let allowNull = true;
    switch (zoom.name) {
      case "XYZ":
        if (argsLen < 2 || argsLen > 3) {
          return false;
        }
        break;
      case "Fit":
      case "FitB":
        return argsLen === 0;
      case "FitH":
      case "FitBH":
      case "FitV":
      case "FitBV":
        if (argsLen > 1) {
          return false;
        }
        break;
      case "FitR":
        if (argsLen !== 4) {
          return false;
        }
        allowNull = false;
        break;
      default:
        return false;
    }
    for (const arg of args) {
      if (typeof arg === "number" || allowNull && arg === null) {
        continue;
      }
      return false;
    }
    return true;
  }
  function MathClamp(v, min, max) {
    return Math.min(Math.max(v, min), max);
  }
  function toBase64Util(arr) {
    if (Uint8Array.prototype.toBase64) {
      return arr.toBase64();
    }
    return btoa(bytesToString(arr));
  }
  function fromBase64Util(str) {
    if (Uint8Array.fromBase64) {
      return Uint8Array.fromBase64(str);
    }
    return stringToBytes(atob(str));
  }
  if (typeof Math.sumPrecise !== "function") {
    Math.sumPrecise = function(numbers) {
      return numbers.reduce((a, b) => a + b, 0);
    };
  }
  if (typeof AbortSignal.any !== "function") {
    AbortSignal.any = function(iterable) {
      const ac = new AbortController();
      const {
        signal
      } = ac;
      for (const s of iterable) {
        if (s.aborted) {
          ac.abort(s.reason);
          return signal;
        }
      }
      for (const s of iterable) {
        s.addEventListener("abort", () => {
          ac.abort(s.reason);
        }, {
          signal
        });
      }
      return signal;
    };
  }
  __webpack_require__(1701);
  __webpack_require__(4972);
  __webpack_require__(4628);
  __webpack_require__(7642);
  __webpack_require__(8004);
  __webpack_require__(3853);
  __webpack_require__(5876);
  __webpack_require__(2475);
  __webpack_require__(5024);
  __webpack_require__(1698);
  __webpack_require__(4603);
  __webpack_require__(7566);
  __webpack_require__(8721);
  __webpack_require__(9314);
  __webpack_require__(1148);
  __webpack_require__(3579);
  __webpack_require__(8335);
  const SVG_NS = "http://www.w3.org/2000/svg";
  class PixelsPerInch {
    static CSS = 96;
    static PDF = 72;
    static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
  }
  async function fetchData(url, type = "text") {
    if (isValidFetchUrl(url, document.baseURI)) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(response.statusText);
      }
      switch (type) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "json":
          return response.json();
      }
      return response.text();
    }
    return new Promise((resolve, reject) => {
      const request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = type;
      request.onreadystatechange = () => {
        if (request.readyState !== XMLHttpRequest.DONE) {
          return;
        }
        if (request.status === 200 || request.status === 0) {
          switch (type) {
            case "arraybuffer":
            case "blob":
            case "json":
              resolve(request.response);
              return;
          }
          resolve(request.responseText);
          return;
        }
        reject(new Error(request.statusText));
      };
      request.send(null);
    });
  }
  class PageViewport {
    constructor({
      viewBox,
      userUnit,
      scale,
      rotation,
      offsetX = 0,
      offsetY = 0,
      dontFlip = false
    }) {
      this.viewBox = viewBox;
      this.userUnit = userUnit;
      this.scale = scale;
      this.rotation = rotation;
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      scale *= userUnit;
      const centerX = (viewBox[2] + viewBox[0]) / 2;
      const centerY = (viewBox[3] + viewBox[1]) / 2;
      let rotateA, rotateB, rotateC, rotateD;
      rotation %= 360;
      if (rotation < 0) {
        rotation += 360;
      }
      switch (rotation) {
        case 180:
          rotateA = -1;
          rotateB = 0;
          rotateC = 0;
          rotateD = 1;
          break;
        case 90:
          rotateA = 0;
          rotateB = 1;
          rotateC = 1;
          rotateD = 0;
          break;
        case 270:
          rotateA = 0;
          rotateB = -1;
          rotateC = -1;
          rotateD = 0;
          break;
        case 0:
          rotateA = 1;
          rotateB = 0;
          rotateC = 0;
          rotateD = -1;
          break;
        default:
          throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
      }
      if (dontFlip) {
        rotateC = -rotateC;
        rotateD = -rotateD;
      }
      let offsetCanvasX, offsetCanvasY;
      let width, height;
      if (rotateA === 0) {
        offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
        offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
        width = (viewBox[3] - viewBox[1]) * scale;
        height = (viewBox[2] - viewBox[0]) * scale;
      } else {
        offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
        offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
        width = (viewBox[2] - viewBox[0]) * scale;
        height = (viewBox[3] - viewBox[1]) * scale;
      }
      this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
      this.width = width;
      this.height = height;
    }
    get rawDims() {
      const dims = this.viewBox;
      return shadow(this, "rawDims", {
        pageWidth: dims[2] - dims[0],
        pageHeight: dims[3] - dims[1],
        pageX: dims[0],
        pageY: dims[1]
      });
    }
    clone({
      scale = this.scale,
      rotation = this.rotation,
      offsetX = this.offsetX,
      offsetY = this.offsetY,
      dontFlip = false
    } = {}) {
      return new PageViewport({
        viewBox: this.viewBox.slice(),
        userUnit: this.userUnit,
        scale,
        rotation,
        offsetX,
        offsetY,
        dontFlip
      });
    }
    convertToViewportPoint(x, y) {
      const p = [x, y];
      Util.applyTransform(p, this.transform);
      return p;
    }
    convertToViewportRectangle(rect) {
      const topLeft = [rect[0], rect[1]];
      Util.applyTransform(topLeft, this.transform);
      const bottomRight = [rect[2], rect[3]];
      Util.applyTransform(bottomRight, this.transform);
      return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
    }
    convertToPdfPoint(x, y) {
      const p = [x, y];
      Util.applyInverseTransform(p, this.transform);
      return p;
    }
  }
  class RenderingCancelledException extends BaseException {
    constructor(msg, extraDelay = 0) {
      super(msg, "RenderingCancelledException");
      this.extraDelay = extraDelay;
    }
  }
  function isDataScheme(url) {
    const ii = url.length;
    let i = 0;
    while (i < ii && url[i].trim() === "") {
      i++;
    }
    return url.substring(i, i + 5).toLowerCase() === "data:";
  }
  function isPdfFile(filename) {
    return typeof filename === "string" && /\.pdf$/i.test(filename);
  }
  function getFilenameFromUrl(url) {
    [url] = url.split(/[#?]/, 1);
    return url.substring(url.lastIndexOf("/") + 1);
  }
  function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
    if (typeof url !== "string") {
      return defaultFilename;
    }
    if (isDataScheme(url)) {
      warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
      return defaultFilename;
    }
    const getURL = (urlString) => {
      try {
        return new URL(urlString);
      } catch {
        try {
          return new URL(decodeURIComponent(urlString));
        } catch {
          try {
            return new URL(urlString, "https://foo.bar");
          } catch {
            try {
              return new URL(decodeURIComponent(urlString), "https://foo.bar");
            } catch {
              return null;
            }
          }
        }
      }
    };
    const newURL = getURL(url);
    if (!newURL) {
      return defaultFilename;
    }
    const decode = (name) => {
      try {
        let decoded = decodeURIComponent(name);
        if (decoded.includes("/")) {
          decoded = decoded.split("/").at(-1);
          if (decoded.test(/^\.pdf$/i)) {
            return decoded;
          }
          return name;
        }
        return decoded;
      } catch {
        return name;
      }
    };
    const pdfRegex = /\.pdf$/i;
    const filename = newURL.pathname.split("/").at(-1);
    if (pdfRegex.test(filename)) {
      return decode(filename);
    }
    if (newURL.searchParams.size > 0) {
      const values = Array.from(newURL.searchParams.values()).reverse();
      for (const value of values) {
        if (pdfRegex.test(value)) {
          return decode(value);
        }
      }
      const keys = Array.from(newURL.searchParams.keys()).reverse();
      for (const key of keys) {
        if (pdfRegex.test(key)) {
          return decode(key);
        }
      }
    }
    if (newURL.hash) {
      const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
      const hashFilename = reFilename.exec(newURL.hash);
      if (hashFilename) {
        return decode(hashFilename[0]);
      }
    }
    return defaultFilename;
  }
  class StatTimer {
    started = /* @__PURE__ */ Object.create(null);
    times = [];
    time(name) {
      if (name in this.started) {
        warn(`Timer is already running for ${name}`);
      }
      this.started[name] = Date.now();
    }
    timeEnd(name) {
      if (!(name in this.started)) {
        warn(`Timer has not been started for ${name}`);
      }
      this.times.push({
        name,
        start: this.started[name],
        end: Date.now()
      });
      delete this.started[name];
    }
    toString() {
      const outBuf = [];
      let longest = 0;
      for (const {
        name
      } of this.times) {
        longest = Math.max(name.length, longest);
      }
      for (const {
        name,
        start,
        end
      } of this.times) {
        outBuf.push(`${name.padEnd(longest)} ${end - start}ms
`);
      }
      return outBuf.join("");
    }
  }
  function isValidFetchUrl(url, baseUrl) {
    const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
    return res?.protocol === "http:" || res?.protocol === "https:";
  }
  function noContextMenu(e) {
    e.preventDefault();
  }
  function stopEvent(e) {
    e.preventDefault();
    e.stopPropagation();
  }
  function deprecated(details) {
    console.log("Deprecated API usage: " + details);
  }
  class PDFDateString {
    static #regex;
    static toDateObject(input) {
      if (input instanceof Date) {
        return input;
      }
      if (!input || typeof input !== "string") {
        return null;
      }
      this.#regex ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
      const matches = this.#regex.exec(input);
      if (!matches) {
        return null;
      }
      const year = parseInt(matches[1], 10);
      let month = parseInt(matches[2], 10);
      month = month >= 1 && month <= 12 ? month - 1 : 0;
      let day = parseInt(matches[3], 10);
      day = day >= 1 && day <= 31 ? day : 1;
      let hour = parseInt(matches[4], 10);
      hour = hour >= 0 && hour <= 23 ? hour : 0;
      let minute = parseInt(matches[5], 10);
      minute = minute >= 0 && minute <= 59 ? minute : 0;
      let second = parseInt(matches[6], 10);
      second = second >= 0 && second <= 59 ? second : 0;
      const universalTimeRelation = matches[7] || "Z";
      let offsetHour = parseInt(matches[8], 10);
      offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
      let offsetMinute = parseInt(matches[9], 10) || 0;
      offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
      if (universalTimeRelation === "-") {
        hour += offsetHour;
        minute += offsetMinute;
      } else if (universalTimeRelation === "+") {
        hour -= offsetHour;
        minute -= offsetMinute;
      }
      return new Date(Date.UTC(year, month, day, hour, minute, second));
    }
  }
  function getXfaPageViewport(xfaPage, {
    scale = 1,
    rotation = 0
  }) {
    const {
      width,
      height
    } = xfaPage.attributes.style;
    const viewBox = [0, 0, parseInt(width), parseInt(height)];
    return new PageViewport({
      viewBox,
      userUnit: 1,
      scale,
      rotation
    });
  }
  function getRGB(color) {
    if (color.startsWith("#")) {
      const colorRGB = parseInt(color.slice(1), 16);
      return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
    }
    if (color.startsWith("rgb(")) {
      return color.slice(4, -1).split(",").map((x) => parseInt(x));
    }
    if (color.startsWith("rgba(")) {
      return color.slice(5, -1).split(",").map((x) => parseInt(x)).slice(0, 3);
    }
    warn(`Not a valid color format: "${color}"`);
    return [0, 0, 0];
  }
  function getColorValues(colors) {
    const span = document.createElement("span");
    span.style.visibility = "hidden";
    span.style.colorScheme = "only light";
    document.body.append(span);
    for (const name of colors.keys()) {
      span.style.color = name;
      const computedColor = window.getComputedStyle(span).color;
      colors.set(name, getRGB(computedColor));
    }
    span.remove();
  }
  function getCurrentTransform(ctx) {
    const {
      a,
      b,
      c,
      d,
      e,
      f
    } = ctx.getTransform();
    return [a, b, c, d, e, f];
  }
  function getCurrentTransformInverse(ctx) {
    const {
      a,
      b,
      c,
      d,
      e,
      f
    } = ctx.getTransform().invertSelf();
    return [a, b, c, d, e, f];
  }
  function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
    if (viewport instanceof PageViewport) {
      const {
        pageWidth,
        pageHeight
      } = viewport.rawDims;
      const {
        style
      } = div;
      const useRound = util_FeatureTest.isCSSRoundSupported;
      const w = `var(--total-scale-factor) * ${pageWidth}px`, h = `var(--total-scale-factor) * ${pageHeight}px`;
      const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;
      if (!mustFlip || viewport.rotation % 180 === 0) {
        style.width = widthStr;
        style.height = heightStr;
      } else {
        style.width = heightStr;
        style.height = widthStr;
      }
    }
    if (mustRotate) {
      div.setAttribute("data-main-rotation", viewport.rotation);
    }
  }
  class OutputScale {
    constructor() {
      const {
        pixelRatio
      } = OutputScale;
      this.sx = pixelRatio;
      this.sy = pixelRatio;
    }
    get scaled() {
      return this.sx !== 1 || this.sy !== 1;
    }
    get symmetric() {
      return this.sx === this.sy;
    }
    limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {
      let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;
      maxPixels = OutputScale.capPixels(maxPixels, capAreaFactor);
      if (maxPixels > 0) {
        maxAreaScale = Math.sqrt(maxPixels / (width * height));
      }
      if (maxDim !== -1) {
        maxWidthScale = maxDim / width;
        maxHeightScale = maxDim / height;
      }
      const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);
      if (this.sx > maxScale || this.sy > maxScale) {
        this.sx = maxScale;
        this.sy = maxScale;
        return true;
      }
      return false;
    }
    static get pixelRatio() {
      return globalThis.devicePixelRatio || 1;
    }
    static capPixels(maxPixels, capAreaFactor) {
      if (capAreaFactor >= 0) {
        const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));
        return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;
      }
      return maxPixels;
    }
  }
  const SupportedImageMimeTypes = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
  class EditorToolbar {
    #toolbar = null;
    #colorPicker = null;
    #editor;
    #buttons = null;
    #altText = null;
    #comment = null;
    #signatureDescriptionButton = null;
    static #l10nRemove = null;
    constructor(editor) {
      this.#editor = editor;
      EditorToolbar.#l10nRemove ||= Object.freeze({
        freetext: "pdfjs-editor-remove-freetext-button",
        highlight: "pdfjs-editor-remove-highlight-button",
        ink: "pdfjs-editor-remove-ink-button",
        stamp: "pdfjs-editor-remove-stamp-button",
        signature: "pdfjs-editor-remove-signature-button"
      });
    }
    render() {
      const editToolbar = this.#toolbar = document.createElement("div");
      editToolbar.classList.add("editToolbar", "hidden");
      editToolbar.setAttribute("role", "toolbar");
      const signal = this.#editor._uiManager._signal;
      if (signal instanceof AbortSignal && !signal.aborted) {
        editToolbar.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        editToolbar.addEventListener("pointerdown", EditorToolbar.#pointerDown, {
          signal
        });
      }
      const buttons = this.#buttons = document.createElement("div");
      buttons.className = "buttons";
      editToolbar.append(buttons);
      const position = this.#editor.toolbarPosition;
      if (position) {
        const {
          style
        } = editToolbar;
        const x = this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0];
        style.insetInlineEnd = `${100 * x}%`;
        style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;
      }
      return editToolbar;
    }
    get div() {
      return this.#toolbar;
    }
    static #pointerDown(e) {
      e.stopPropagation();
    }
    #focusIn(e) {
      this.#editor._focusEventsAllowed = false;
      stopEvent(e);
    }
    #focusOut(e) {
      this.#editor._focusEventsAllowed = true;
      stopEvent(e);
    }
    #addListenersToElement(element) {
      const signal = this.#editor._uiManager._signal;
      if (!(signal instanceof AbortSignal) || signal.aborted) {
        return false;
      }
      element.addEventListener("focusin", this.#focusIn.bind(this), {
        capture: true,
        signal
      });
      element.addEventListener("focusout", this.#focusOut.bind(this), {
        capture: true,
        signal
      });
      element.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      return true;
    }
    hide() {
      this.#toolbar.classList.add("hidden");
      this.#colorPicker?.hideDropdown();
    }
    show() {
      this.#toolbar.classList.remove("hidden");
      this.#altText?.shown();
      this.#comment?.shown();
    }
    addDeleteButton() {
      const {
        editorType,
        _uiManager
      } = this.#editor;
      const button = document.createElement("button");
      button.classList.add("basic", "deleteButton");
      button.tabIndex = 0;
      button.setAttribute("data-l10n-id", EditorToolbar.#l10nRemove[editorType]);
      if (this.#addListenersToElement(button)) {
        button.addEventListener("click", (e) => {
          _uiManager.delete();
        }, {
          signal: _uiManager._signal
        });
      }
      this.#buttons.append(button);
    }
    get #divider() {
      const divider = document.createElement("div");
      divider.className = "divider";
      return divider;
    }
    async addAltText(altText) {
      const button = await altText.render();
      this.#addListenersToElement(button);
      this.#buttons.append(button, this.#divider);
      this.#altText = altText;
    }
    addComment(comment) {
      if (this.#comment) {
        return;
      }
      const button = comment.render();
      if (!button) {
        return;
      }
      this.#addListenersToElement(button);
      this.#buttons.append(button, this.#divider);
      this.#comment = comment;
      comment.toolbar = this;
    }
    addColorPicker(colorPicker) {
      if (this.#colorPicker) {
        return;
      }
      this.#colorPicker = colorPicker;
      const button = colorPicker.renderButton();
      this.#addListenersToElement(button);
      this.#buttons.append(button, this.#divider);
    }
    async addEditSignatureButton(signatureManager) {
      const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);
      this.#addListenersToElement(button);
      this.#buttons.append(button, this.#divider);
    }
    async addButton(name, tool) {
      switch (name) {
        case "colorPicker":
          this.addColorPicker(tool);
          break;
        case "altText":
          await this.addAltText(tool);
          break;
        case "editSignature":
          await this.addEditSignatureButton(tool);
          break;
        case "delete":
          this.addDeleteButton();
          break;
        case "comment":
          this.addComment(tool);
          break;
      }
    }
    updateEditSignatureButton(description) {
      if (this.#signatureDescriptionButton) {
        this.#signatureDescriptionButton.title = description;
      }
    }
    remove() {
      this.#toolbar.remove();
      this.#colorPicker?.destroy();
      this.#colorPicker = null;
    }
  }
  class FloatingToolbar {
    #buttons = null;
    #toolbar = null;
    #uiManager;
    constructor(uiManager) {
      this.#uiManager = uiManager;
    }
    #render() {
      const editToolbar = this.#toolbar = document.createElement("div");
      editToolbar.className = "editToolbar";
      editToolbar.setAttribute("role", "toolbar");
      const signal = this.#uiManager._signal;
      if (signal instanceof AbortSignal && !signal.aborted) {
        editToolbar.addEventListener("contextmenu", noContextMenu, {
          signal
        });
      }
      const buttons = this.#buttons = document.createElement("div");
      buttons.className = "buttons";
      editToolbar.append(buttons);
      if (this.#uiManager.hasCommentManager()) {
        this.#makeButton("commentButton", `pdfjs-comment-floating-button`, "pdfjs-comment-floating-button-label", () => {
          this.#uiManager.commentSelection("floating_button");
        });
      }
      this.#makeButton("highlightButton", `pdfjs-highlight-floating-button1`, "pdfjs-highlight-floating-button-label", () => {
        this.#uiManager.highlightSelection("floating_button");
      });
      return editToolbar;
    }
    #getLastPoint(boxes, isLTR) {
      let lastY = 0;
      let lastX = 0;
      for (const box of boxes) {
        const y = box.y + box.height;
        if (y < lastY) {
          continue;
        }
        const x = box.x + (isLTR ? box.width : 0);
        if (y > lastY) {
          lastX = x;
          lastY = y;
          continue;
        }
        if (isLTR) {
          if (x > lastX) {
            lastX = x;
          }
        } else if (x < lastX) {
          lastX = x;
        }
      }
      return [isLTR ? 1 - lastX : lastX, lastY];
    }
    show(parent, boxes, isLTR) {
      const [x, y] = this.#getLastPoint(boxes, isLTR);
      const {
        style
      } = this.#toolbar ||= this.#render();
      parent.append(this.#toolbar);
      style.insetInlineEnd = `${100 * x}%`;
      style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;
    }
    hide() {
      this.#toolbar.remove();
    }
    #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {
      const button = document.createElement("button");
      button.classList.add("basic", buttonClass);
      button.tabIndex = 0;
      button.setAttribute("data-l10n-id", l10nId);
      const span = document.createElement("span");
      button.append(span);
      span.className = "visuallyHidden";
      span.setAttribute("data-l10n-id", labelL10nId);
      const signal = this.#uiManager._signal;
      if (signal instanceof AbortSignal && !signal.aborted) {
        button.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        button.addEventListener("click", clickHandler, {
          signal
        });
      }
      this.#buttons.append(button);
    }
  }
  function bindEvents(obj, element, names) {
    for (const name of names) {
      element.addEventListener(name, obj[name].bind(obj));
    }
  }
  class IdManager {
    #id = 0;
    get id() {
      return `${AnnotationEditorPrefix}${this.#id++}`;
    }
  }
  class ImageManager {
    #baseId = getUuid();
    #id = 0;
    #cache = null;
    static get _isSVGFittingCanvas() {
      const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
      const canvas = new OffscreenCanvas(1, 3);
      const ctx = canvas.getContext("2d", {
        willReadFrequently: true
      });
      const image = new Image();
      image.src = svg;
      const promise = image.decode().then(() => {
        ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
        return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
      });
      return shadow(this, "_isSVGFittingCanvas", promise);
    }
    async #get(key, rawData) {
      this.#cache ||= /* @__PURE__ */ new Map();
      let data = this.#cache.get(key);
      if (data === null) {
        return null;
      }
      if (data?.bitmap) {
        data.refCounter += 1;
        return data;
      }
      try {
        data ||= {
          bitmap: null,
          id: `image_${this.#baseId}_${this.#id++}`,
          refCounter: 0,
          isSvg: false
        };
        let image;
        if (typeof rawData === "string") {
          data.url = rawData;
          image = await fetchData(rawData, "blob");
        } else if (rawData instanceof File) {
          image = data.file = rawData;
        } else if (rawData instanceof Blob) {
          image = rawData;
        }
        if (image.type === "image/svg+xml") {
          const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;
          const fileReader = new FileReader();
          const imageElement = new Image();
          const imagePromise = new Promise((resolve, reject) => {
            imageElement.onload = () => {
              data.bitmap = imageElement;
              data.isSvg = true;
              resolve();
            };
            fileReader.onload = async () => {
              const url = data.svgUrl = fileReader.result;
              imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;
            };
            imageElement.onerror = fileReader.onerror = reject;
          });
          fileReader.readAsDataURL(image);
          await imagePromise;
        } else {
          data.bitmap = await createImageBitmap(image);
        }
        data.refCounter = 1;
      } catch (e) {
        warn(e);
        data = null;
      }
      this.#cache.set(key, data);
      if (data) {
        this.#cache.set(data.id, data);
      }
      return data;
    }
    async getFromFile(file) {
      const {
        lastModified,
        name,
        size,
        type
      } = file;
      return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
    }
    async getFromUrl(url) {
      return this.#get(url, url);
    }
    async getFromBlob(id, blobPromise) {
      const blob = await blobPromise;
      return this.#get(id, blob);
    }
    async getFromId(id) {
      this.#cache ||= /* @__PURE__ */ new Map();
      const data = this.#cache.get(id);
      if (!data) {
        return null;
      }
      if (data.bitmap) {
        data.refCounter += 1;
        return data;
      }
      if (data.file) {
        return this.getFromFile(data.file);
      }
      if (data.blobPromise) {
        const {
          blobPromise
        } = data;
        delete data.blobPromise;
        return this.getFromBlob(data.id, blobPromise);
      }
      return this.getFromUrl(data.url);
    }
    getFromCanvas(id, canvas) {
      this.#cache ||= /* @__PURE__ */ new Map();
      let data = this.#cache.get(id);
      if (data?.bitmap) {
        data.refCounter += 1;
        return data;
      }
      const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(canvas, 0, 0);
      data = {
        bitmap: offscreen.transferToImageBitmap(),
        id: `image_${this.#baseId}_${this.#id++}`,
        refCounter: 1,
        isSvg: false
      };
      this.#cache.set(id, data);
      this.#cache.set(data.id, data);
      return data;
    }
    getSvgUrl(id) {
      const data = this.#cache.get(id);
      if (!data?.isSvg) {
        return null;
      }
      return data.svgUrl;
    }
    deleteId(id) {
      this.#cache ||= /* @__PURE__ */ new Map();
      const data = this.#cache.get(id);
      if (!data) {
        return;
      }
      data.refCounter -= 1;
      if (data.refCounter !== 0) {
        return;
      }
      const {
        bitmap
      } = data;
      if (!data.url && !data.file) {
        const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
        const ctx = canvas.getContext("bitmaprenderer");
        ctx.transferFromImageBitmap(bitmap);
        data.blobPromise = canvas.convertToBlob();
      }
      bitmap.close?.();
      data.bitmap = null;
    }
    isValidId(id) {
      return id.startsWith(`image_${this.#baseId}_`);
    }
  }
  class CommandManager {
    #commands = [];
    #locked = false;
    #maxSize;
    #position = -1;
    constructor(maxSize = 128) {
      this.#maxSize = maxSize;
    }
    add({
      cmd,
      undo,
      post,
      mustExec,
      type = NaN,
      overwriteIfSameType = false,
      keepUndo = false
    }) {
      if (mustExec) {
        cmd();
      }
      if (this.#locked) {
        return;
      }
      const save = {
        cmd,
        undo,
        post,
        type
      };
      if (this.#position === -1) {
        if (this.#commands.length > 0) {
          this.#commands.length = 0;
        }
        this.#position = 0;
        this.#commands.push(save);
        return;
      }
      if (overwriteIfSameType && this.#commands[this.#position].type === type) {
        if (keepUndo) {
          save.undo = this.#commands[this.#position].undo;
        }
        this.#commands[this.#position] = save;
        return;
      }
      const next = this.#position + 1;
      if (next === this.#maxSize) {
        this.#commands.splice(0, 1);
      } else {
        this.#position = next;
        if (next < this.#commands.length) {
          this.#commands.splice(next);
        }
      }
      this.#commands.push(save);
    }
    undo() {
      if (this.#position === -1) {
        return;
      }
      this.#locked = true;
      const {
        undo,
        post
      } = this.#commands[this.#position];
      undo();
      post?.();
      this.#locked = false;
      this.#position -= 1;
    }
    redo() {
      if (this.#position < this.#commands.length - 1) {
        this.#position += 1;
        this.#locked = true;
        const {
          cmd,
          post
        } = this.#commands[this.#position];
        cmd();
        post?.();
        this.#locked = false;
      }
    }
    hasSomethingToUndo() {
      return this.#position !== -1;
    }
    hasSomethingToRedo() {
      return this.#position < this.#commands.length - 1;
    }
    cleanType(type) {
      if (this.#position === -1) {
        return;
      }
      for (let i = this.#position; i >= 0; i--) {
        if (this.#commands[i].type !== type) {
          this.#commands.splice(i + 1, this.#position - i);
          this.#position = i;
          return;
        }
      }
      this.#commands.length = 0;
      this.#position = -1;
    }
    destroy() {
      this.#commands = null;
    }
  }
  class KeyboardManager {
    constructor(callbacks) {
      this.buffer = [];
      this.callbacks = /* @__PURE__ */ new Map();
      this.allKeys = /* @__PURE__ */ new Set();
      const {
        isMac
      } = util_FeatureTest.platform;
      for (const [keys, callback, options = {}] of callbacks) {
        for (const key of keys) {
          const isMacKey = key.startsWith("mac+");
          if (isMac && isMacKey) {
            this.callbacks.set(key.slice(4), {
              callback,
              options
            });
            this.allKeys.add(key.split("+").at(-1));
          } else if (!isMac && !isMacKey) {
            this.callbacks.set(key, {
              callback,
              options
            });
            this.allKeys.add(key.split("+").at(-1));
          }
        }
      }
    }
    #serialize(event) {
      if (event.altKey) {
        this.buffer.push("alt");
      }
      if (event.ctrlKey) {
        this.buffer.push("ctrl");
      }
      if (event.metaKey) {
        this.buffer.push("meta");
      }
      if (event.shiftKey) {
        this.buffer.push("shift");
      }
      this.buffer.push(event.key);
      const str = this.buffer.join("+");
      this.buffer.length = 0;
      return str;
    }
    exec(self2, event) {
      if (!this.allKeys.has(event.key)) {
        return;
      }
      const info2 = this.callbacks.get(this.#serialize(event));
      if (!info2) {
        return;
      }
      const {
        callback,
        options: {
          bubbles = false,
          args = [],
          checker = null
        }
      } = info2;
      if (checker && !checker(self2, event)) {
        return;
      }
      callback.bind(self2, ...args, event)();
      if (!bubbles) {
        stopEvent(event);
      }
    }
  }
  class ColorManager {
    static _colorsMapping = /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
    get _colors() {
      const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
      getColorValues(colors);
      return shadow(this, "_colors", colors);
    }
    convert(color) {
      const rgb = getRGB(color);
      if (!window.matchMedia("(forced-colors: active)").matches) {
        return rgb;
      }
      for (const [name, RGB] of this._colors) {
        if (RGB.every((x, i) => x === rgb[i])) {
          return ColorManager._colorsMapping.get(name);
        }
      }
      return rgb;
    }
    getHexCode(name) {
      const rgb = this._colors.get(name);
      if (!rgb) {
        return name;
      }
      return Util.makeHexColor(...rgb);
    }
  }
  class AnnotationEditorUIManager {
    #abortController = new AbortController();
    #activeEditor = null;
    #allEditableAnnotations = null;
    #allEditors = /* @__PURE__ */ new Map();
    #allLayers = /* @__PURE__ */ new Map();
    #altTextManager = null;
    #annotationStorage = null;
    #changedExistingAnnotations = null;
    #commandManager = new CommandManager();
    #commentManager = null;
    #copyPasteAC = null;
    #currentDrawingSession = null;
    #currentPageIndex = 0;
    #deletedAnnotationsElementIds = /* @__PURE__ */ new Set();
    #draggingEditors = null;
    #editorTypes = null;
    #editorsToRescale = /* @__PURE__ */ new Set();
    _editorUndoBar = null;
    #enableHighlightFloatingButton = false;
    #enableUpdatedAddImage = false;
    #enableNewAltTextWhenAddingImage = false;
    #filterFactory = null;
    #focusMainContainerTimeoutId = null;
    #focusManagerAC = null;
    #highlightColors = null;
    #highlightWhenShiftUp = false;
    #floatingToolbar = null;
    #idManager = new IdManager();
    #isEnabled = false;
    #isPointerDown = false;
    #isWaiting = false;
    #keyboardManagerAC = null;
    #lastActiveElement = null;
    #mainHighlightColorPicker = null;
    #missingCanvases = null;
    #mlManager = null;
    #mode = AnnotationEditorType.NONE;
    #selectedEditors = /* @__PURE__ */ new Set();
    #selectedTextNode = null;
    #signatureManager = null;
    #pageColors = null;
    #showAllStates = null;
    #pdfDocument = null;
    #previousStates = {
      isEditing: false,
      isEmpty: true,
      hasSomethingToUndo: false,
      hasSomethingToRedo: false,
      hasSelectedEditor: false,
      hasSelectedText: false
    };
    #translation = [0, 0];
    #translationTimeoutId = null;
    #container = null;
    #viewer = null;
    #viewerAlert = null;
    #updateModeCapability = null;
    static TRANSLATE_SMALL = 1;
    static TRANSLATE_BIG = 10;
    static get _keyboardManager() {
      const proto = AnnotationEditorUIManager.prototype;
      const arrowChecker = (self2) => self2.#container.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && self2.hasSomethingToControl();
      const textInputChecker = (_self, {
        target: el
      }) => {
        if (el instanceof HTMLInputElement) {
          const {
            type
          } = el;
          return type !== "text" && type !== "number";
        }
        return true;
      };
      const small = this.TRANSLATE_SMALL;
      const big = this.TRANSLATE_BIG;
      return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll, {
        checker: textInputChecker
      }], [["ctrl+z", "mac+meta+z"], proto.undo, {
        checker: textInputChecker
      }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo, {
        checker: textInputChecker
      }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete, {
        checker: textInputChecker
      }], [["Enter", "mac+Enter"], proto.addNewEditorFromKeyboard, {
        checker: (self2, {
          target: el
        }) => !(el instanceof HTMLButtonElement) && self2.#container.contains(el) && !self2.isEnterHandled
      }], [[" ", "mac+ "], proto.addNewEditorFromKeyboard, {
        checker: (self2, {
          target: el
        }) => !(el instanceof HTMLButtonElement) && self2.#container.contains(document.activeElement)
      }], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
        args: [-small, 0],
        checker: arrowChecker
      }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
        args: [-big, 0],
        checker: arrowChecker
      }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
        args: [small, 0],
        checker: arrowChecker
      }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
        args: [big, 0],
        checker: arrowChecker
      }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
        args: [0, -small],
        checker: arrowChecker
      }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
        args: [0, -big],
        checker: arrowChecker
      }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
        args: [0, small],
        checker: arrowChecker
      }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
        args: [0, big],
        checker: arrowChecker
      }]]));
    }
    constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom) {
      const signal = this._signal = this.#abortController.signal;
      this.#container = container;
      this.#viewer = viewer;
      this.#viewerAlert = viewerAlert;
      this.#altTextManager = altTextManager;
      this.#commentManager = commentManager;
      this.#signatureManager = signatureManager;
      this.#pdfDocument = pdfDocument;
      this._eventBus = eventBus;
      eventBus._on("editingaction", this.onEditingAction.bind(this), {
        signal
      });
      eventBus._on("pagechanging", this.onPageChanging.bind(this), {
        signal
      });
      eventBus._on("scalechanging", this.onScaleChanging.bind(this), {
        signal
      });
      eventBus._on("rotationchanging", this.onRotationChanging.bind(this), {
        signal
      });
      eventBus._on("setpreference", this.onSetPreference.bind(this), {
        signal
      });
      eventBus._on("switchannotationeditorparams", (evt) => this.updateParams(evt.type, evt.value), {
        signal
      });
      window.addEventListener("pointerdown", () => {
        this.#isPointerDown = true;
      }, {
        capture: true,
        signal
      });
      window.addEventListener("pointerup", () => {
        this.#isPointerDown = false;
      }, {
        capture: true,
        signal
      });
      this.#addSelectionListener();
      this.#addDragAndDropListeners();
      this.#addKeyboardManager();
      this.#annotationStorage = pdfDocument.annotationStorage;
      this.#filterFactory = pdfDocument.filterFactory;
      this.#pageColors = pageColors;
      this.#highlightColors = highlightColors || null;
      this.#enableHighlightFloatingButton = enableHighlightFloatingButton;
      this.#enableUpdatedAddImage = enableUpdatedAddImage;
      this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;
      this.#mlManager = mlManager || null;
      this.viewParameters = {
        realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
        rotation: 0
      };
      this.isShiftKeyDown = false;
      this._editorUndoBar = editorUndoBar || null;
      this._supportsPinchToZoom = supportsPinchToZoom !== false;
    }
    destroy() {
      this.#updateModeCapability?.resolve();
      this.#updateModeCapability = null;
      this.#abortController?.abort();
      this.#abortController = null;
      this._signal = null;
      for (const layer of this.#allLayers.values()) {
        layer.destroy();
      }
      this.#allLayers.clear();
      this.#allEditors.clear();
      this.#editorsToRescale.clear();
      this.#missingCanvases?.clear();
      this.#activeEditor = null;
      this.#selectedEditors.clear();
      this.#commandManager.destroy();
      this.#altTextManager?.destroy();
      this.#commentManager?.destroy();
      this.#signatureManager?.destroy();
      this.#floatingToolbar?.hide();
      this.#floatingToolbar = null;
      this.#mainHighlightColorPicker?.destroy();
      this.#mainHighlightColorPicker = null;
      this.#allEditableAnnotations = null;
      if (this.#focusMainContainerTimeoutId) {
        clearTimeout(this.#focusMainContainerTimeoutId);
        this.#focusMainContainerTimeoutId = null;
      }
      if (this.#translationTimeoutId) {
        clearTimeout(this.#translationTimeoutId);
        this.#translationTimeoutId = null;
      }
      this._editorUndoBar?.destroy();
      this.#pdfDocument = null;
    }
    combinedSignal(ac) {
      return AbortSignal.any([this._signal, ac.signal]);
    }
    get mlManager() {
      return this.#mlManager;
    }
    get useNewAltTextFlow() {
      return this.#enableUpdatedAddImage;
    }
    get useNewAltTextWhenAddingImage() {
      return this.#enableNewAltTextWhenAddingImage;
    }
    get hcmFilter() {
      return shadow(this, "hcmFilter", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : "none");
    }
    get direction() {
      return shadow(this, "direction", getComputedStyle(this.#container).direction);
    }
    get _highlightColors() {
      return shadow(this, "_highlightColors", this.#highlightColors ? new Map(this.#highlightColors.split(",").map((pair) => {
        pair = pair.split("=").map((x) => x.trim());
        pair[1] = pair[1].toUpperCase();
        return pair;
      })) : null);
    }
    get highlightColors() {
      const {
        _highlightColors
      } = this;
      if (!_highlightColors) {
        return shadow(this, "highlightColors", null);
      }
      const map = /* @__PURE__ */ new Map();
      const hasHCM = !!this.#pageColors;
      for (const [name, color] of _highlightColors) {
        const isNameForHCM = name.endsWith("_HCM");
        if (hasHCM && isNameForHCM) {
          map.set(name.replace("_HCM", ""), color);
          continue;
        }
        if (!hasHCM && !isNameForHCM) {
          map.set(name, color);
        }
      }
      return shadow(this, "highlightColors", map);
    }
    get highlightColorNames() {
      return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e) => e.reverse())) : null);
    }
    getNonHCMColor(color) {
      if (!this._highlightColors) {
        return color;
      }
      const colorName = this.highlightColorNames.get(color);
      return this._highlightColors.get(colorName) || color;
    }
    getNonHCMColorName(color) {
      return this.highlightColorNames.get(color) || color;
    }
    setCurrentDrawingSession(layer) {
      if (layer) {
        this.unselectAll();
        this.disableUserSelect(true);
      } else {
        this.disableUserSelect(false);
      }
      this.#currentDrawingSession = layer;
    }
    setMainHighlightColorPicker(colorPicker) {
      this.#mainHighlightColorPicker = colorPicker;
    }
    editAltText(editor, firstTime = false) {
      this.#altTextManager?.editAltText(this, editor, firstTime);
    }
    hasCommentManager() {
      return !!this.#commentManager;
    }
    editComment(editor, position) {
      this.#commentManager?.open(this, editor, position);
    }
    getSignature(editor) {
      this.#signatureManager?.getSignature({
        uiManager: this,
        editor
      });
    }
    get signatureManager() {
      return this.#signatureManager;
    }
    switchToMode(mode, callback) {
      this._eventBus.on("annotationeditormodechanged", callback, {
        once: true,
        signal: this._signal
      });
      this._eventBus.dispatch("showannotationeditorui", {
        source: this,
        mode
      });
    }
    setPreference(name, value) {
      this._eventBus.dispatch("setpreference", {
        source: this,
        name,
        value
      });
    }
    onSetPreference({
      name,
      value
    }) {
      switch (name) {
        case "enableNewAltTextWhenAddingImage":
          this.#enableNewAltTextWhenAddingImage = value;
          break;
      }
    }
    onPageChanging({
      pageNumber
    }) {
      this.#currentPageIndex = pageNumber - 1;
    }
    focusMainContainer() {
      this.#container.focus();
    }
    findParent(x, y) {
      for (const layer of this.#allLayers.values()) {
        const {
          x: layerX,
          y: layerY,
          width,
          height
        } = layer.div.getBoundingClientRect();
        if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {
          return layer;
        }
      }
      return null;
    }
    disableUserSelect(value = false) {
      this.#viewer.classList.toggle("noUserSelect", value);
    }
    addShouldRescale(editor) {
      this.#editorsToRescale.add(editor);
    }
    removeShouldRescale(editor) {
      this.#editorsToRescale.delete(editor);
    }
    onScaleChanging({
      scale
    }) {
      this.commitOrRemove();
      this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
      for (const editor of this.#editorsToRescale) {
        editor.onScaleChanging();
      }
      this.#currentDrawingSession?.onScaleChanging();
    }
    onRotationChanging({
      pagesRotation
    }) {
      this.commitOrRemove();
      this.viewParameters.rotation = pagesRotation;
    }
    #getAnchorElementForSelection({
      anchorNode
    }) {
      return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;
    }
    #getLayerForTextLayer(textLayer) {
      const {
        currentLayer
      } = this;
      if (currentLayer.hasTextLayer(textLayer)) {
        return currentLayer;
      }
      for (const layer of this.#allLayers.values()) {
        if (layer.hasTextLayer(textLayer)) {
          return layer;
        }
      }
      return null;
    }
    highlightSelection(methodOfCreation = "", comment = false) {
      const selection = document.getSelection();
      if (!selection || selection.isCollapsed) {
        return;
      }
      const {
        anchorNode,
        anchorOffset,
        focusNode,
        focusOffset
      } = selection;
      const text = selection.toString();
      const anchorElement = this.#getAnchorElementForSelection(selection);
      const textLayer = anchorElement.closest(".textLayer");
      const boxes = this.getSelectionBoxes(textLayer);
      if (!boxes) {
        return;
      }
      selection.empty();
      const layer = this.#getLayerForTextLayer(textLayer);
      const isNoneMode = this.#mode === AnnotationEditorType.NONE;
      const callback = () => {
        const editor = layer?.createAndAddNewEditor({
          x: 0,
          y: 0
        }, false, {
          methodOfCreation,
          boxes,
          anchorNode,
          anchorOffset,
          focusNode,
          focusOffset,
          text
        });
        if (isNoneMode) {
          this.showAllEditors("highlight", true, true);
        }
        if (comment) {
          editor?.editComment();
        }
      };
      if (isNoneMode) {
        this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);
        return;
      }
      callback();
    }
    commentSelection(methodOfCreation = "") {
      this.highlightSelection(methodOfCreation, true);
    }
    #displayFloatingToolbar() {
      const selection = document.getSelection();
      if (!selection || selection.isCollapsed) {
        return;
      }
      const anchorElement = this.#getAnchorElementForSelection(selection);
      const textLayer = anchorElement.closest(".textLayer");
      const boxes = this.getSelectionBoxes(textLayer);
      if (!boxes) {
        return;
      }
      this.#floatingToolbar ||= new FloatingToolbar(this);
      this.#floatingToolbar.show(textLayer, boxes, this.direction === "ltr");
    }
    addToAnnotationStorage(editor) {
      if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {
        this.#annotationStorage.setValue(editor.id, editor);
      }
    }
    a11yAlert(messageId, args = null) {
      const viewerAlert = this.#viewerAlert;
      if (!viewerAlert) {
        return;
      }
      viewerAlert.setAttribute("data-l10n-id", messageId);
      if (args) {
        viewerAlert.setAttribute("data-l10n-args", JSON.stringify(args));
      } else {
        viewerAlert.removeAttribute("data-l10n-args");
      }
    }
    #selectionChange() {
      const selection = document.getSelection();
      if (!selection || selection.isCollapsed) {
        if (this.#selectedTextNode) {
          this.#floatingToolbar?.hide();
          this.#selectedTextNode = null;
          this.#dispatchUpdateStates({
            hasSelectedText: false
          });
        }
        return;
      }
      const {
        anchorNode
      } = selection;
      if (anchorNode === this.#selectedTextNode) {
        return;
      }
      const anchorElement = this.#getAnchorElementForSelection(selection);
      const textLayer = anchorElement.closest(".textLayer");
      if (!textLayer) {
        if (this.#selectedTextNode) {
          this.#floatingToolbar?.hide();
          this.#selectedTextNode = null;
          this.#dispatchUpdateStates({
            hasSelectedText: false
          });
        }
        return;
      }
      this.#floatingToolbar?.hide();
      this.#selectedTextNode = anchorNode;
      this.#dispatchUpdateStates({
        hasSelectedText: true
      });
      if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {
        return;
      }
      if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
        this.showAllEditors("highlight", true, true);
      }
      this.#highlightWhenShiftUp = this.isShiftKeyDown;
      if (!this.isShiftKeyDown) {
        const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;
        activeLayer?.toggleDrawing();
        if (this.#isPointerDown) {
          const ac = new AbortController();
          const signal = this.combinedSignal(ac);
          const pointerup = (e) => {
            if (e.type === "pointerup" && e.button !== 0) {
              return;
            }
            ac.abort();
            activeLayer?.toggleDrawing(true);
            if (e.type === "pointerup") {
              this.#onSelectEnd("main_toolbar");
            }
          };
          window.addEventListener("pointerup", pointerup, {
            signal
          });
          window.addEventListener("blur", pointerup, {
            signal
          });
        } else {
          activeLayer?.toggleDrawing(true);
          this.#onSelectEnd("main_toolbar");
        }
      }
    }
    #onSelectEnd(methodOfCreation = "") {
      if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
        this.highlightSelection(methodOfCreation);
      } else if (this.#enableHighlightFloatingButton) {
        this.#displayFloatingToolbar();
      }
    }
    #addSelectionListener() {
      document.addEventListener("selectionchange", this.#selectionChange.bind(this), {
        signal: this._signal
      });
    }
    #addFocusManager() {
      if (this.#focusManagerAC) {
        return;
      }
      this.#focusManagerAC = new AbortController();
      const signal = this.combinedSignal(this.#focusManagerAC);
      window.addEventListener("focus", this.focus.bind(this), {
        signal
      });
      window.addEventListener("blur", this.blur.bind(this), {
        signal
      });
    }
    #removeFocusManager() {
      this.#focusManagerAC?.abort();
      this.#focusManagerAC = null;
    }
    blur() {
      this.isShiftKeyDown = false;
      if (this.#highlightWhenShiftUp) {
        this.#highlightWhenShiftUp = false;
        this.#onSelectEnd("main_toolbar");
      }
      if (!this.hasSelection) {
        return;
      }
      const {
        activeElement
      } = document;
      for (const editor of this.#selectedEditors) {
        if (editor.div.contains(activeElement)) {
          this.#lastActiveElement = [editor, activeElement];
          editor._focusEventsAllowed = false;
          break;
        }
      }
    }
    focus() {
      if (!this.#lastActiveElement) {
        return;
      }
      const [lastEditor, lastActiveElement] = this.#lastActiveElement;
      this.#lastActiveElement = null;
      lastActiveElement.addEventListener("focusin", () => {
        lastEditor._focusEventsAllowed = true;
      }, {
        once: true,
        signal: this._signal
      });
      lastActiveElement.focus();
    }
    #addKeyboardManager() {
      if (this.#keyboardManagerAC) {
        return;
      }
      this.#keyboardManagerAC = new AbortController();
      const signal = this.combinedSignal(this.#keyboardManagerAC);
      window.addEventListener("keydown", this.keydown.bind(this), {
        signal
      });
      window.addEventListener("keyup", this.keyup.bind(this), {
        signal
      });
    }
    #removeKeyboardManager() {
      this.#keyboardManagerAC?.abort();
      this.#keyboardManagerAC = null;
    }
    #addCopyPasteListeners() {
      if (this.#copyPasteAC) {
        return;
      }
      this.#copyPasteAC = new AbortController();
      const signal = this.combinedSignal(this.#copyPasteAC);
      document.addEventListener("copy", this.copy.bind(this), {
        signal
      });
      document.addEventListener("cut", this.cut.bind(this), {
        signal
      });
      document.addEventListener("paste", this.paste.bind(this), {
        signal
      });
    }
    #removeCopyPasteListeners() {
      this.#copyPasteAC?.abort();
      this.#copyPasteAC = null;
    }
    #addDragAndDropListeners() {
      const signal = this._signal;
      document.addEventListener("dragover", this.dragOver.bind(this), {
        signal
      });
      document.addEventListener("drop", this.drop.bind(this), {
        signal
      });
    }
    addEditListeners() {
      this.#addKeyboardManager();
      this.#addCopyPasteListeners();
    }
    removeEditListeners() {
      this.#removeKeyboardManager();
      this.#removeCopyPasteListeners();
    }
    dragOver(event) {
      for (const {
        type
      } of event.dataTransfer.items) {
        for (const editorType of this.#editorTypes) {
          if (editorType.isHandlingMimeForPasting(type)) {
            event.dataTransfer.dropEffect = "copy";
            event.preventDefault();
            return;
          }
        }
      }
    }
    drop(event) {
      for (const item of event.dataTransfer.items) {
        for (const editorType of this.#editorTypes) {
          if (editorType.isHandlingMimeForPasting(item.type)) {
            editorType.paste(item, this.currentLayer);
            event.preventDefault();
            return;
          }
        }
      }
    }
    copy(event) {
      event.preventDefault();
      this.#activeEditor?.commitOrRemove();
      if (!this.hasSelection) {
        return;
      }
      const editors = [];
      for (const editor of this.#selectedEditors) {
        const serialized = editor.serialize(true);
        if (serialized) {
          editors.push(serialized);
        }
      }
      if (editors.length === 0) {
        return;
      }
      event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
    }
    cut(event) {
      this.copy(event);
      this.delete();
    }
    async paste(event) {
      event.preventDefault();
      const {
        clipboardData
      } = event;
      for (const item of clipboardData.items) {
        for (const editorType of this.#editorTypes) {
          if (editorType.isHandlingMimeForPasting(item.type)) {
            editorType.paste(item, this.currentLayer);
            return;
          }
        }
      }
      let data = clipboardData.getData("application/pdfjs");
      if (!data) {
        return;
      }
      try {
        data = JSON.parse(data);
      } catch (ex) {
        warn(`paste: "${ex.message}".`);
        return;
      }
      if (!Array.isArray(data)) {
        return;
      }
      this.unselectAll();
      const layer = this.currentLayer;
      try {
        const newEditors = [];
        for (const editor of data) {
          const deserializedEditor = await layer.deserialize(editor);
          if (!deserializedEditor) {
            return;
          }
          newEditors.push(deserializedEditor);
        }
        const cmd = () => {
          for (const editor of newEditors) {
            this.#addEditorToLayer(editor);
          }
          this.#selectEditors(newEditors);
        };
        const undo = () => {
          for (const editor of newEditors) {
            editor.remove();
          }
        };
        this.addCommands({
          cmd,
          undo,
          mustExec: true
        });
      } catch (ex) {
        warn(`paste: "${ex.message}".`);
      }
    }
    keydown(event) {
      if (!this.isShiftKeyDown && event.key === "Shift") {
        this.isShiftKeyDown = true;
      }
      if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {
        AnnotationEditorUIManager._keyboardManager.exec(this, event);
      }
    }
    keyup(event) {
      if (this.isShiftKeyDown && event.key === "Shift") {
        this.isShiftKeyDown = false;
        if (this.#highlightWhenShiftUp) {
          this.#highlightWhenShiftUp = false;
          this.#onSelectEnd("main_toolbar");
        }
      }
    }
    onEditingAction({
      name
    }) {
      switch (name) {
        case "undo":
        case "redo":
        case "delete":
        case "selectAll":
          this[name]();
          break;
        case "highlightSelection":
          this.highlightSelection("context_menu");
          break;
        case "commentSelection":
          this.commentSelection("context_menu");
          break;
      }
    }
    #dispatchUpdateStates(details) {
      const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);
      if (hasChanged) {
        this._eventBus.dispatch("annotationeditorstateschanged", {
          source: this,
          details: Object.assign(this.#previousStates, details)
        });
        if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {
          this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);
        }
      }
    }
    #dispatchUpdateUI(details) {
      this._eventBus.dispatch("annotationeditorparamschanged", {
        source: this,
        details
      });
    }
    setEditingState(isEditing) {
      if (isEditing) {
        this.#addFocusManager();
        this.#addCopyPasteListeners();
        this.#dispatchUpdateStates({
          isEditing: this.#mode !== AnnotationEditorType.NONE,
          isEmpty: this.#isEmpty(),
          hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
          hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
          hasSelectedEditor: false
        });
      } else {
        this.#removeFocusManager();
        this.#removeCopyPasteListeners();
        this.#dispatchUpdateStates({
          isEditing: false
        });
        this.disableUserSelect(false);
      }
    }
    registerEditorTypes(types) {
      if (this.#editorTypes) {
        return;
      }
      this.#editorTypes = types;
      for (const editorType of this.#editorTypes) {
        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
      }
    }
    getId() {
      return this.#idManager.id;
    }
    get currentLayer() {
      return this.#allLayers.get(this.#currentPageIndex);
    }
    getLayer(pageIndex) {
      return this.#allLayers.get(pageIndex);
    }
    get currentPageIndex() {
      return this.#currentPageIndex;
    }
    addLayer(layer) {
      this.#allLayers.set(layer.pageIndex, layer);
      if (this.#isEnabled) {
        layer.enable();
      } else {
        layer.disable();
      }
    }
    removeLayer(layer) {
      this.#allLayers.delete(layer.pageIndex);
    }
    async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {
      if (this.#mode === mode) {
        return;
      }
      if (this.#updateModeCapability) {
        await this.#updateModeCapability.promise;
        if (!this.#updateModeCapability) {
          return;
        }
      }
      this.#updateModeCapability = Promise.withResolvers();
      this.#currentDrawingSession?.commitOrRemove();
      if (this.#mode === AnnotationEditorType.POPUP) {
        this.#commentManager?.hideSidebar();
      }
      this.#mode = mode;
      if (mode === AnnotationEditorType.NONE) {
        this.setEditingState(false);
        this.#disableAll();
        this._editorUndoBar?.hide();
        this.#updateModeCapability.resolve();
        return;
      }
      if (mode === AnnotationEditorType.SIGNATURE) {
        await this.#signatureManager?.loadSignatures();
      }
      if (mode === AnnotationEditorType.POPUP) {
        this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map((editorClass) => editorClass._editorType)));
        this.#commentManager?.showSidebar(this.#allEditableAnnotations);
      }
      this.setEditingState(true);
      await this.#enableAll();
      this.unselectAll();
      for (const layer of this.#allLayers.values()) {
        layer.updateMode(mode);
      }
      if (!editId) {
        if (isFromKeyboard) {
          this.addNewEditorFromKeyboard();
        }
        this.#updateModeCapability.resolve();
        return;
      }
      for (const editor of this.#allEditors.values()) {
        if (editor.annotationElementId === editId || editor.id === editId) {
          this.setSelected(editor);
          if (editComment) {
            editor.editComment();
          } else if (mustEnterInEditMode) {
            editor.enterInEditMode();
          }
        } else {
          editor.unselect();
        }
      }
      this.#updateModeCapability.resolve();
    }
    addNewEditorFromKeyboard() {
      if (this.currentLayer.canCreateNewEmptyEditor()) {
        this.currentLayer.addNewEditor();
      }
    }
    updateToolbar(options) {
      if (options.mode === this.#mode) {
        return;
      }
      this._eventBus.dispatch("switchannotationeditormode", {
        source: this,
        ...options
      });
    }
    updateParams(type, value) {
      if (!this.#editorTypes) {
        return;
      }
      switch (type) {
        case AnnotationEditorParamsType.CREATE:
          this.currentLayer.addNewEditor(value);
          return;
        case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              data: {
                type: "highlight",
                action: "toggle_visibility"
              }
            }
          });
          (this.#showAllStates ||= /* @__PURE__ */ new Map()).set(type, value);
          this.showAllEditors("highlight", value);
          break;
      }
      if (this.hasSelection) {
        for (const editor of this.#selectedEditors) {
          editor.updateParams(type, value);
        }
      } else {
        for (const editorType of this.#editorTypes) {
          editorType.updateDefaultParams(type, value);
        }
      }
    }
    showAllEditors(type, visible, updateButton = false) {
      for (const editor of this.#allEditors.values()) {
        if (editor.editorType === type) {
          editor.show(visible);
        }
      }
      const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;
      if (state !== visible) {
        this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);
      }
    }
    enableWaiting(mustWait = false) {
      if (this.#isWaiting === mustWait) {
        return;
      }
      this.#isWaiting = mustWait;
      for (const layer of this.#allLayers.values()) {
        if (mustWait) {
          layer.disableClick();
        } else {
          layer.enableClick();
        }
        layer.div.classList.toggle("waiting", mustWait);
      }
    }
    async #enableAll() {
      if (!this.#isEnabled) {
        this.#isEnabled = true;
        const promises = [];
        for (const layer of this.#allLayers.values()) {
          promises.push(layer.enable());
        }
        await Promise.all(promises);
        for (const editor of this.#allEditors.values()) {
          editor.enable();
        }
      }
    }
    #disableAll() {
      this.unselectAll();
      if (this.#isEnabled) {
        this.#isEnabled = false;
        for (const layer of this.#allLayers.values()) {
          layer.disable();
        }
        for (const editor of this.#allEditors.values()) {
          editor.disable();
        }
      }
    }
    getEditors(pageIndex) {
      const editors = [];
      for (const editor of this.#allEditors.values()) {
        if (editor.pageIndex === pageIndex) {
          editors.push(editor);
        }
      }
      return editors;
    }
    getEditor(id) {
      return this.#allEditors.get(id);
    }
    addEditor(editor) {
      this.#allEditors.set(editor.id, editor);
    }
    removeEditor(editor) {
      if (editor.div.contains(document.activeElement)) {
        if (this.#focusMainContainerTimeoutId) {
          clearTimeout(this.#focusMainContainerTimeoutId);
        }
        this.#focusMainContainerTimeoutId = setTimeout(() => {
          this.focusMainContainer();
          this.#focusMainContainerTimeoutId = null;
        }, 0);
      }
      this.#allEditors.delete(editor.id);
      if (editor.annotationElementId) {
        this.#missingCanvases?.delete(editor.annotationElementId);
      }
      this.unselect(editor);
      if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {
        this.#annotationStorage?.remove(editor.id);
      }
    }
    addDeletedAnnotationElement(editor) {
      this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
      this.addChangedExistingAnnotation(editor);
      editor.deleted = true;
    }
    isDeletedAnnotationElement(annotationElementId) {
      return this.#deletedAnnotationsElementIds.has(annotationElementId);
    }
    removeDeletedAnnotationElement(editor) {
      this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
      this.removeChangedExistingAnnotation(editor);
      editor.deleted = false;
    }
    #addEditorToLayer(editor) {
      const layer = this.#allLayers.get(editor.pageIndex);
      if (layer) {
        layer.addOrRebuild(editor);
      } else {
        this.addEditor(editor);
        this.addToAnnotationStorage(editor);
      }
    }
    setActiveEditor(editor) {
      if (this.#activeEditor === editor) {
        return;
      }
      this.#activeEditor = editor;
      if (editor) {
        this.#dispatchUpdateUI(editor.propertiesToUpdate);
      }
    }
    get #lastSelectedEditor() {
      let ed = null;
      for (ed of this.#selectedEditors) {
      }
      return ed;
    }
    updateUI(editor) {
      if (this.#lastSelectedEditor === editor) {
        this.#dispatchUpdateUI(editor.propertiesToUpdate);
      }
    }
    updateUIForDefaultProperties(editorType) {
      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
    }
    toggleSelected(editor) {
      if (this.#selectedEditors.has(editor)) {
        this.#selectedEditors.delete(editor);
        editor.unselect();
        this.#dispatchUpdateStates({
          hasSelectedEditor: this.hasSelection
        });
        return;
      }
      this.#selectedEditors.add(editor);
      editor.select();
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
      this.#dispatchUpdateStates({
        hasSelectedEditor: true
      });
    }
    setSelected(editor) {
      this.updateToolbar({
        mode: editor.mode,
        editId: editor.id
      });
      this.#currentDrawingSession?.commitOrRemove();
      for (const ed of this.#selectedEditors) {
        if (ed !== editor) {
          ed.unselect();
        }
      }
      this.#selectedEditors.clear();
      this.#selectedEditors.add(editor);
      editor.select();
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
      this.#dispatchUpdateStates({
        hasSelectedEditor: true
      });
    }
    isSelected(editor) {
      return this.#selectedEditors.has(editor);
    }
    get firstSelectedEditor() {
      return this.#selectedEditors.values().next().value;
    }
    unselect(editor) {
      editor.unselect();
      this.#selectedEditors.delete(editor);
      this.#dispatchUpdateStates({
        hasSelectedEditor: this.hasSelection
      });
    }
    get hasSelection() {
      return this.#selectedEditors.size !== 0;
    }
    get isEnterHandled() {
      return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;
    }
    undo() {
      this.#commandManager.undo();
      this.#dispatchUpdateStates({
        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
        hasSomethingToRedo: true,
        isEmpty: this.#isEmpty()
      });
      this._editorUndoBar?.hide();
    }
    redo() {
      this.#commandManager.redo();
      this.#dispatchUpdateStates({
        hasSomethingToUndo: true,
        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
        isEmpty: this.#isEmpty()
      });
    }
    addCommands(params) {
      this.#commandManager.add(params);
      this.#dispatchUpdateStates({
        hasSomethingToUndo: true,
        hasSomethingToRedo: false,
        isEmpty: this.#isEmpty()
      });
    }
    cleanUndoStack(type) {
      this.#commandManager.cleanType(type);
    }
    #isEmpty() {
      if (this.#allEditors.size === 0) {
        return true;
      }
      if (this.#allEditors.size === 1) {
        for (const editor of this.#allEditors.values()) {
          return editor.isEmpty();
        }
      }
      return false;
    }
    delete() {
      this.commitOrRemove();
      const drawingEditor = this.currentLayer?.endDrawingSession(true);
      if (!this.hasSelection && !drawingEditor) {
        return;
      }
      const editors = drawingEditor ? [drawingEditor] : [...this.#selectedEditors];
      const cmd = () => {
        this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);
        for (const editor of editors) {
          editor.remove();
        }
      };
      const undo = () => {
        for (const editor of editors) {
          this.#addEditorToLayer(editor);
        }
      };
      this.addCommands({
        cmd,
        undo,
        mustExec: true
      });
    }
    commitOrRemove() {
      this.#activeEditor?.commitOrRemove();
    }
    hasSomethingToControl() {
      return this.#activeEditor || this.hasSelection;
    }
    #selectEditors(editors) {
      for (const editor of this.#selectedEditors) {
        editor.unselect();
      }
      this.#selectedEditors.clear();
      for (const editor of editors) {
        if (editor.isEmpty()) {
          continue;
        }
        this.#selectedEditors.add(editor);
        editor.select();
      }
      this.#dispatchUpdateStates({
        hasSelectedEditor: this.hasSelection
      });
    }
    selectAll() {
      for (const editor of this.#selectedEditors) {
        editor.commit();
      }
      this.#selectEditors(this.#allEditors.values());
    }
    unselectAll() {
      if (this.#activeEditor) {
        this.#activeEditor.commitOrRemove();
        if (this.#mode !== AnnotationEditorType.NONE) {
          return;
        }
      }
      if (this.#currentDrawingSession?.commitOrRemove()) {
        return;
      }
      if (!this.hasSelection) {
        return;
      }
      for (const editor of this.#selectedEditors) {
        editor.unselect();
      }
      this.#selectedEditors.clear();
      this.#dispatchUpdateStates({
        hasSelectedEditor: false
      });
    }
    translateSelectedEditors(x, y, noCommit = false) {
      if (!noCommit) {
        this.commitOrRemove();
      }
      if (!this.hasSelection) {
        return;
      }
      this.#translation[0] += x;
      this.#translation[1] += y;
      const [totalX, totalY] = this.#translation;
      const editors = [...this.#selectedEditors];
      const TIME_TO_WAIT = 1e3;
      if (this.#translationTimeoutId) {
        clearTimeout(this.#translationTimeoutId);
      }
      this.#translationTimeoutId = setTimeout(() => {
        this.#translationTimeoutId = null;
        this.#translation[0] = this.#translation[1] = 0;
        this.addCommands({
          cmd: () => {
            for (const editor of editors) {
              if (this.#allEditors.has(editor.id)) {
                editor.translateInPage(totalX, totalY);
                editor.translationDone();
              }
            }
          },
          undo: () => {
            for (const editor of editors) {
              if (this.#allEditors.has(editor.id)) {
                editor.translateInPage(-totalX, -totalY);
                editor.translationDone();
              }
            }
          },
          mustExec: false
        });
      }, TIME_TO_WAIT);
      for (const editor of editors) {
        editor.translateInPage(x, y);
        editor.translationDone();
      }
    }
    setUpDragSession() {
      if (!this.hasSelection) {
        return;
      }
      this.disableUserSelect(true);
      this.#draggingEditors = /* @__PURE__ */ new Map();
      for (const editor of this.#selectedEditors) {
        this.#draggingEditors.set(editor, {
          savedX: editor.x,
          savedY: editor.y,
          savedPageIndex: editor.pageIndex,
          newX: 0,
          newY: 0,
          newPageIndex: -1
        });
      }
    }
    endDragSession() {
      if (!this.#draggingEditors) {
        return false;
      }
      this.disableUserSelect(false);
      const map = this.#draggingEditors;
      this.#draggingEditors = null;
      let mustBeAddedInUndoStack = false;
      for (const [{
        x,
        y,
        pageIndex
      }, value] of map) {
        value.newX = x;
        value.newY = y;
        value.newPageIndex = pageIndex;
        mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;
      }
      if (!mustBeAddedInUndoStack) {
        return false;
      }
      const move = (editor, x, y, pageIndex) => {
        if (this.#allEditors.has(editor.id)) {
          const parent = this.#allLayers.get(pageIndex);
          if (parent) {
            editor._setParentAndPosition(parent, x, y);
          } else {
            editor.pageIndex = pageIndex;
            editor.x = x;
            editor.y = y;
          }
        }
      };
      this.addCommands({
        cmd: () => {
          for (const [editor, {
            newX,
            newY,
            newPageIndex
          }] of map) {
            move(editor, newX, newY, newPageIndex);
          }
        },
        undo: () => {
          for (const [editor, {
            savedX,
            savedY,
            savedPageIndex
          }] of map) {
            move(editor, savedX, savedY, savedPageIndex);
          }
        },
        mustExec: true
      });
      return true;
    }
    dragSelectedEditors(tx, ty) {
      if (!this.#draggingEditors) {
        return;
      }
      for (const editor of this.#draggingEditors.keys()) {
        editor.drag(tx, ty);
      }
    }
    rebuild(editor) {
      if (editor.parent === null) {
        const parent = this.getLayer(editor.pageIndex);
        if (parent) {
          parent.changeParent(editor);
          parent.addOrRebuild(editor);
        } else {
          this.addEditor(editor);
          this.addToAnnotationStorage(editor);
          editor.rebuild();
        }
      } else {
        editor.parent.addOrRebuild(editor);
      }
    }
    get isEditorHandlingKeyboard() {
      return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
    }
    isActive(editor) {
      return this.#activeEditor === editor;
    }
    getActive() {
      return this.#activeEditor;
    }
    getMode() {
      return this.#mode;
    }
    get imageManager() {
      return shadow(this, "imageManager", new ImageManager());
    }
    getSelectionBoxes(textLayer) {
      if (!textLayer) {
        return null;
      }
      const selection = document.getSelection();
      for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
        if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {
          return null;
        }
      }
      const {
        x: layerX,
        y: layerY,
        width: parentWidth,
        height: parentHeight
      } = textLayer.getBoundingClientRect();
      let rotator;
      switch (textLayer.getAttribute("data-main-rotation")) {
        case "90":
          rotator = (x, y, w, h) => ({
            x: (y - layerY) / parentHeight,
            y: 1 - (x + w - layerX) / parentWidth,
            width: h / parentHeight,
            height: w / parentWidth
          });
          break;
        case "180":
          rotator = (x, y, w, h) => ({
            x: 1 - (x + w - layerX) / parentWidth,
            y: 1 - (y + h - layerY) / parentHeight,
            width: w / parentWidth,
            height: h / parentHeight
          });
          break;
        case "270":
          rotator = (x, y, w, h) => ({
            x: 1 - (y + h - layerY) / parentHeight,
            y: (x - layerX) / parentWidth,
            width: h / parentHeight,
            height: w / parentWidth
          });
          break;
        default:
          rotator = (x, y, w, h) => ({
            x: (x - layerX) / parentWidth,
            y: (y - layerY) / parentHeight,
            width: w / parentWidth,
            height: h / parentHeight
          });
          break;
      }
      const boxes = [];
      for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
        const range = selection.getRangeAt(i);
        if (range.collapsed) {
          continue;
        }
        for (const {
          x,
          y,
          width,
          height
        } of range.getClientRects()) {
          if (width === 0 || height === 0) {
            continue;
          }
          boxes.push(rotator(x, y, width, height));
        }
      }
      return boxes.length === 0 ? null : boxes;
    }
    addChangedExistingAnnotation({
      annotationElementId,
      id
    }) {
      (this.#changedExistingAnnotations ||= /* @__PURE__ */ new Map()).set(annotationElementId, id);
    }
    removeChangedExistingAnnotation({
      annotationElementId
    }) {
      this.#changedExistingAnnotations?.delete(annotationElementId);
    }
    renderAnnotationElement(annotation) {
      const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);
      if (!editorId) {
        return;
      }
      const editor = this.#annotationStorage.getRawValue(editorId);
      if (!editor) {
        return;
      }
      if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {
        return;
      }
      editor.renderAnnotationElement(annotation);
    }
    setMissingCanvas(annotationId, annotationElementId, canvas) {
      const editor = this.#missingCanvases?.get(annotationId);
      if (!editor) {
        return;
      }
      editor.setCanvas(annotationElementId, canvas);
      this.#missingCanvases.delete(annotationId);
    }
    addMissingCanvas(annotationId, editor) {
      (this.#missingCanvases ||= /* @__PURE__ */ new Map()).set(annotationId, editor);
    }
  }
  class AltText {
    #altText = null;
    #altTextDecorative = false;
    #altTextButton = null;
    #altTextButtonLabel = null;
    #altTextTooltip = null;
    #altTextTooltipTimeout = null;
    #altTextWasFromKeyBoard = false;
    #badge = null;
    #editor = null;
    #guessedText = null;
    #textWithDisclaimer = null;
    #useNewAltTextFlow = false;
    static #l10nNewButton = null;
    static _l10n = null;
    constructor(editor) {
      this.#editor = editor;
      this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;
      AltText.#l10nNewButton ||= Object.freeze({
        added: "pdfjs-editor-new-alt-text-added-button",
        "added-label": "pdfjs-editor-new-alt-text-added-button-label",
        missing: "pdfjs-editor-new-alt-text-missing-button",
        "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
        review: "pdfjs-editor-new-alt-text-to-review-button",
        "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
      });
    }
    static initialize(l10n) {
      AltText._l10n ??= l10n;
    }
    async render() {
      const altText = this.#altTextButton = document.createElement("button");
      altText.className = "altText";
      altText.tabIndex = "0";
      const label = this.#altTextButtonLabel = document.createElement("span");
      altText.append(label);
      if (this.#useNewAltTextFlow) {
        altText.classList.add("new");
        altText.setAttribute("data-l10n-id", AltText.#l10nNewButton.missing);
        label.setAttribute("data-l10n-id", AltText.#l10nNewButton["missing-label"]);
      } else {
        altText.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button");
        label.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label");
      }
      const signal = this.#editor._uiManager._signal;
      altText.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      altText.addEventListener("pointerdown", (event) => event.stopPropagation(), {
        signal
      });
      const onClick = (event) => {
        event.preventDefault();
        this.#editor._uiManager.editAltText(this.#editor);
        if (this.#useNewAltTextFlow) {
          this.#editor._reportTelemetry({
            action: "pdfjs.image.alt_text.image_status_label_clicked",
            data: {
              label: this.#label
            }
          });
        }
      };
      altText.addEventListener("click", onClick, {
        capture: true,
        signal
      });
      altText.addEventListener("keydown", (event) => {
        if (event.target === altText && event.key === "Enter") {
          this.#altTextWasFromKeyBoard = true;
          onClick(event);
        }
      }, {
        signal
      });
      await this.#setState();
      return altText;
    }
    get #label() {
      return this.#altText && "added" || this.#altText === null && this.guessedText && "review" || "missing";
    }
    finish() {
      if (!this.#altTextButton) {
        return;
      }
      this.#altTextButton.focus({
        focusVisible: this.#altTextWasFromKeyBoard
      });
      this.#altTextWasFromKeyBoard = false;
    }
    isEmpty() {
      if (this.#useNewAltTextFlow) {
        return this.#altText === null;
      }
      return !this.#altText && !this.#altTextDecorative;
    }
    hasData() {
      if (this.#useNewAltTextFlow) {
        return this.#altText !== null || !!this.#guessedText;
      }
      return this.isEmpty();
    }
    get guessedText() {
      return this.#guessedText;
    }
    async setGuessedText(guessedText) {
      if (this.#altText !== null) {
        return;
      }
      this.#guessedText = guessedText;
      this.#textWithDisclaimer = await AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
        generatedAltText: guessedText
      });
      this.#setState();
    }
    toggleAltTextBadge(visibility = false) {
      if (!this.#useNewAltTextFlow || this.#altText) {
        this.#badge?.remove();
        this.#badge = null;
        return;
      }
      if (!this.#badge) {
        const badge = this.#badge = document.createElement("div");
        badge.className = "noAltTextBadge";
        this.#editor.div.append(badge);
      }
      this.#badge.classList.toggle("hidden", !visibility);
    }
    serialize(isForCopying) {
      let altText = this.#altText;
      if (!isForCopying && this.#guessedText === altText) {
        altText = this.#textWithDisclaimer;
      }
      return {
        altText,
        decorative: this.#altTextDecorative,
        guessedText: this.#guessedText,
        textWithDisclaimer: this.#textWithDisclaimer
      };
    }
    get data() {
      return {
        altText: this.#altText,
        decorative: this.#altTextDecorative
      };
    }
    set data({
      altText,
      decorative,
      guessedText,
      textWithDisclaimer,
      cancel = false
    }) {
      if (guessedText) {
        this.#guessedText = guessedText;
        this.#textWithDisclaimer = textWithDisclaimer;
      }
      if (this.#altText === altText && this.#altTextDecorative === decorative) {
        return;
      }
      if (!cancel) {
        this.#altText = altText;
        this.#altTextDecorative = decorative;
      }
      this.#setState();
    }
    toggle(enabled = false) {
      if (!this.#altTextButton) {
        return;
      }
      if (!enabled && this.#altTextTooltipTimeout) {
        clearTimeout(this.#altTextTooltipTimeout);
        this.#altTextTooltipTimeout = null;
      }
      this.#altTextButton.disabled = !enabled;
    }
    shown() {
      this.#editor._reportTelemetry({
        action: "pdfjs.image.alt_text.image_status_label_displayed",
        data: {
          label: this.#label
        }
      });
    }
    destroy() {
      this.#altTextButton?.remove();
      this.#altTextButton = null;
      this.#altTextButtonLabel = null;
      this.#altTextTooltip = null;
      this.#badge?.remove();
      this.#badge = null;
    }
    async #setState() {
      const button = this.#altTextButton;
      if (!button) {
        return;
      }
      if (this.#useNewAltTextFlow) {
        button.classList.toggle("done", !!this.#altText);
        button.setAttribute("data-l10n-id", AltText.#l10nNewButton[this.#label]);
        this.#altTextButtonLabel?.setAttribute("data-l10n-id", AltText.#l10nNewButton[`${this.#label}-label`]);
        if (!this.#altText) {
          this.#altTextTooltip?.remove();
          return;
        }
      } else {
        if (!this.#altText && !this.#altTextDecorative) {
          button.classList.remove("done");
          this.#altTextTooltip?.remove();
          return;
        }
        button.classList.add("done");
        button.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
      }
      let tooltip = this.#altTextTooltip;
      if (!tooltip) {
        this.#altTextTooltip = tooltip = document.createElement("span");
        tooltip.className = "tooltip";
        tooltip.setAttribute("role", "tooltip");
        tooltip.id = `alt-text-tooltip-${this.#editor.id}`;
        const DELAY_TO_SHOW_TOOLTIP = 100;
        const signal = this.#editor._uiManager._signal;
        signal.addEventListener("abort", () => {
          clearTimeout(this.#altTextTooltipTimeout);
          this.#altTextTooltipTimeout = null;
        }, {
          once: true
        });
        button.addEventListener("mouseenter", () => {
          this.#altTextTooltipTimeout = setTimeout(() => {
            this.#altTextTooltipTimeout = null;
            this.#altTextTooltip.classList.add("show");
            this.#editor._reportTelemetry({
              action: "alt_text_tooltip"
            });
          }, DELAY_TO_SHOW_TOOLTIP);
        }, {
          signal
        });
        button.addEventListener("mouseleave", () => {
          if (this.#altTextTooltipTimeout) {
            clearTimeout(this.#altTextTooltipTimeout);
            this.#altTextTooltipTimeout = null;
          }
          this.#altTextTooltip?.classList.remove("show");
        }, {
          signal
        });
      }
      if (this.#altTextDecorative) {
        tooltip.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip");
      } else {
        tooltip.removeAttribute("data-l10n-id");
        tooltip.textContent = this.#altText;
      }
      if (!tooltip.parentNode) {
        button.append(tooltip);
      }
      const element = this.#editor.getElementForAltText();
      element?.setAttribute("aria-describedby", tooltip.id);
    }
  }
  class Comment {
    #commentButton = null;
    #commentWasFromKeyBoard = false;
    #editor = null;
    #initialText = null;
    #text = null;
    #date = null;
    #deleted = false;
    constructor(editor) {
      this.#editor = editor;
      this.toolbar = null;
    }
    render() {
      if (!this.#editor._uiManager.hasCommentManager()) {
        return null;
      }
      const comment = this.#commentButton = document.createElement("button");
      comment.className = "comment";
      comment.tabIndex = "0";
      comment.setAttribute("data-l10n-id", "pdfjs-editor-edit-comment-button");
      const signal = this.#editor._uiManager._signal;
      if (!(signal instanceof AbortSignal) || signal.aborted) {
        return comment;
      }
      comment.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      comment.addEventListener("pointerdown", (event) => event.stopPropagation(), {
        signal
      });
      const onClick = (event) => {
        event.preventDefault();
        this.edit();
      };
      comment.addEventListener("click", onClick, {
        capture: true,
        signal
      });
      comment.addEventListener("keydown", (event) => {
        if (event.target === comment && event.key === "Enter") {
          this.#commentWasFromKeyBoard = true;
          onClick(event);
        }
      }, {
        signal
      });
      return comment;
    }
    edit() {
      const {
        bottom,
        left,
        right
      } = this.#editor.getClientDimensions();
      const position = {
        top: bottom
      };
      if (this.#editor._uiManager.direction === "ltr") {
        position.right = right;
      } else {
        position.left = left;
      }
      this.#editor._uiManager.editComment(this.#editor, position);
    }
    finish() {
      if (!this.#commentButton) {
        return;
      }
      this.#commentButton.focus({
        focusVisible: this.#commentWasFromKeyBoard
      });
      this.#commentWasFromKeyBoard = false;
    }
    isDeleted() {
      return this.#deleted || this.#text === "";
    }
    hasBeenEdited() {
      return this.isDeleted() || this.#text !== this.#initialText;
    }
    serialize() {
      return this.data;
    }
    get data() {
      return {
        text: this.#text,
        date: this.#date,
        deleted: this.#deleted
      };
    }
    set data(text) {
      if (text === null) {
        this.#text = "";
        this.#deleted = true;
        return;
      }
      this.#text = text;
      this.#date = /* @__PURE__ */ new Date();
      this.#deleted = false;
    }
    setInitialText(text) {
      this.#initialText = text;
      this.data = text;
    }
    toggle(enabled = false) {
      if (!this.#commentButton) {
        return;
      }
      this.#commentButton.disabled = !enabled;
    }
    shown() {
    }
    destroy() {
      this.#commentButton?.remove();
      this.#commentButton = null;
      this.#text = "";
      this.#date = null;
      this.#editor = null;
      this.#commentWasFromKeyBoard = false;
      this.#deleted = false;
    }
  }
  class TouchManager {
    #container;
    #isPinching = false;
    #isPinchingStopped = null;
    #isPinchingDisabled;
    #onPinchStart;
    #onPinching;
    #onPinchEnd;
    #pointerDownAC = null;
    #signal;
    #touchInfo = null;
    #touchManagerAC;
    #touchMoveAC = null;
    constructor({
      container,
      isPinchingDisabled = null,
      isPinchingStopped = null,
      onPinchStart = null,
      onPinching = null,
      onPinchEnd = null,
      signal
    }) {
      this.#container = container;
      this.#isPinchingStopped = isPinchingStopped;
      this.#isPinchingDisabled = isPinchingDisabled;
      this.#onPinchStart = onPinchStart;
      this.#onPinching = onPinching;
      this.#onPinchEnd = onPinchEnd;
      this.#touchManagerAC = new AbortController();
      this.#signal = AbortSignal.any([signal, this.#touchManagerAC.signal]);
      container.addEventListener("touchstart", this.#onTouchStart.bind(this), {
        passive: false,
        signal: this.#signal
      });
    }
    get MIN_TOUCH_DISTANCE_TO_PINCH() {
      return 35 / OutputScale.pixelRatio;
    }
    #onTouchStart(evt) {
      if (this.#isPinchingDisabled?.()) {
        return;
      }
      if (evt.touches.length === 1) {
        if (this.#pointerDownAC) {
          return;
        }
        const pointerDownAC = this.#pointerDownAC = new AbortController();
        const signal = AbortSignal.any([this.#signal, pointerDownAC.signal]);
        const container = this.#container;
        const opts = {
          capture: true,
          signal,
          passive: false
        };
        const cancelPointerDown = (e) => {
          if (e.pointerType === "touch") {
            this.#pointerDownAC?.abort();
            this.#pointerDownAC = null;
          }
        };
        container.addEventListener("pointerdown", (e) => {
          if (e.pointerType === "touch") {
            stopEvent(e);
            cancelPointerDown(e);
          }
        }, opts);
        container.addEventListener("pointerup", cancelPointerDown, opts);
        container.addEventListener("pointercancel", cancelPointerDown, opts);
        return;
      }
      if (!this.#touchMoveAC) {
        this.#touchMoveAC = new AbortController();
        const signal = AbortSignal.any([this.#signal, this.#touchMoveAC.signal]);
        const container = this.#container;
        const opt = {
          signal,
          capture: false,
          passive: false
        };
        container.addEventListener("touchmove", this.#onTouchMove.bind(this), opt);
        const onTouchEnd = this.#onTouchEnd.bind(this);
        container.addEventListener("touchend", onTouchEnd, opt);
        container.addEventListener("touchcancel", onTouchEnd, opt);
        opt.capture = true;
        container.addEventListener("pointerdown", stopEvent, opt);
        container.addEventListener("pointermove", stopEvent, opt);
        container.addEventListener("pointercancel", stopEvent, opt);
        container.addEventListener("pointerup", stopEvent, opt);
        this.#onPinchStart?.();
      }
      stopEvent(evt);
      if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {
        this.#touchInfo = null;
        return;
      }
      let [touch0, touch1] = evt.touches;
      if (touch0.identifier > touch1.identifier) {
        [touch0, touch1] = [touch1, touch0];
      }
      this.#touchInfo = {
        touch0X: touch0.screenX,
        touch0Y: touch0.screenY,
        touch1X: touch1.screenX,
        touch1Y: touch1.screenY
      };
    }
    #onTouchMove(evt) {
      if (!this.#touchInfo || evt.touches.length !== 2) {
        return;
      }
      stopEvent(evt);
      let [touch0, touch1] = evt.touches;
      if (touch0.identifier > touch1.identifier) {
        [touch0, touch1] = [touch1, touch0];
      }
      const {
        screenX: screen0X,
        screenY: screen0Y
      } = touch0;
      const {
        screenX: screen1X,
        screenY: screen1Y
      } = touch1;
      const touchInfo = this.#touchInfo;
      const {
        touch0X: pTouch0X,
        touch0Y: pTouch0Y,
        touch1X: pTouch1X,
        touch1Y: pTouch1Y
      } = touchInfo;
      const prevGapX = pTouch1X - pTouch0X;
      const prevGapY = pTouch1Y - pTouch0Y;
      const currGapX = screen1X - screen0X;
      const currGapY = screen1Y - screen0Y;
      const distance = Math.hypot(currGapX, currGapY) || 1;
      const pDistance = Math.hypot(prevGapX, prevGapY) || 1;
      if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {
        return;
      }
      touchInfo.touch0X = screen0X;
      touchInfo.touch0Y = screen0Y;
      touchInfo.touch1X = screen1X;
      touchInfo.touch1Y = screen1Y;
      if (!this.#isPinching) {
        this.#isPinching = true;
        return;
      }
      const origin = [(screen0X + screen1X) / 2, (screen0Y + screen1Y) / 2];
      this.#onPinching?.(origin, pDistance, distance);
    }
    #onTouchEnd(evt) {
      if (evt.touches.length >= 2) {
        return;
      }
      if (this.#touchMoveAC) {
        this.#touchMoveAC.abort();
        this.#touchMoveAC = null;
        this.#onPinchEnd?.();
      }
      if (!this.#touchInfo) {
        return;
      }
      stopEvent(evt);
      this.#touchInfo = null;
      this.#isPinching = false;
    }
    destroy() {
      this.#touchManagerAC?.abort();
      this.#touchManagerAC = null;
      this.#pointerDownAC?.abort();
      this.#pointerDownAC = null;
    }
  }
  class AnnotationEditor {
    #accessibilityData = null;
    #allResizerDivs = null;
    #altText = null;
    #comment = null;
    #disabled = false;
    #dragPointerId = null;
    #dragPointerType = "";
    #keepAspectRatio = false;
    #resizersDiv = null;
    #lastPointerCoords = null;
    #savedDimensions = null;
    #focusAC = null;
    #focusedResizerName = "";
    #hasBeenClicked = false;
    #initialRect = null;
    #isEditing = false;
    #isInEditMode = false;
    #isResizerEnabledForKeyboard = false;
    #moveInDOMTimeout = null;
    #prevDragX = 0;
    #prevDragY = 0;
    #telemetryTimeouts = null;
    #touchManager = null;
    isSelected = false;
    _isCopy = false;
    _editToolbar = null;
    _initialOptions = /* @__PURE__ */ Object.create(null);
    _initialData = null;
    _isVisible = true;
    _uiManager = null;
    _focusEventsAllowed = true;
    static _l10n = null;
    static _l10nResizer = null;
    #isDraggable = false;
    #zIndex = AnnotationEditor._zIndex++;
    static _borderLineWidth = -1;
    static _colorManager = new ColorManager();
    static _zIndex = 1;
    static _telemetryTimeout = 1e3;
    static get _resizerKeyboardManager() {
      const resize = AnnotationEditor.prototype._resizeWithKeyboard;
      const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
      const big = AnnotationEditorUIManager.TRANSLATE_BIG;
      return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], resize, {
        args: [-small, 0]
      }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], resize, {
        args: [-big, 0]
      }], [["ArrowRight", "mac+ArrowRight"], resize, {
        args: [small, 0]
      }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], resize, {
        args: [big, 0]
      }], [["ArrowUp", "mac+ArrowUp"], resize, {
        args: [0, -small]
      }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], resize, {
        args: [0, -big]
      }], [["ArrowDown", "mac+ArrowDown"], resize, {
        args: [0, small]
      }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], resize, {
        args: [0, big]
      }], [["Escape", "mac+Escape"], AnnotationEditor.prototype._stopResizingWithKeyboard]]));
    }
    constructor(parameters) {
      this.parent = parameters.parent;
      this.id = parameters.id;
      this.width = this.height = null;
      this.pageIndex = parameters.parent.pageIndex;
      this.name = parameters.name;
      this.div = null;
      this._uiManager = parameters.uiManager;
      this.annotationElementId = null;
      this._willKeepAspectRatio = false;
      this._initialOptions.isCentered = parameters.isCentered;
      this._structTreeParentId = null;
      this.annotationElementId = parameters.annotationElementId || null;
      const {
        rotation,
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      } = this.parent.viewport;
      this.rotation = rotation;
      this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
      this.pageDimensions = [pageWidth, pageHeight];
      this.pageTranslation = [pageX, pageY];
      const [width, height] = this.parentDimensions;
      this.x = parameters.x / width;
      this.y = parameters.y / height;
      this.isAttachedToDOM = false;
      this.deleted = false;
    }
    get editorType() {
      return Object.getPrototypeOf(this).constructor._type;
    }
    get mode() {
      return Object.getPrototypeOf(this).constructor._editorType;
    }
    static get isDrawer() {
      return false;
    }
    static get _defaultLineColor() {
      return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
    }
    static deleteAnnotationElement(editor) {
      const fakeEditor = new FakeEditor({
        id: editor.parent.getNextId(),
        parent: editor.parent,
        uiManager: editor._uiManager
      });
      fakeEditor.annotationElementId = editor.annotationElementId;
      fakeEditor.deleted = true;
      fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
    }
    static initialize(l10n, _uiManager) {
      AnnotationEditor._l10n ??= l10n;
      AnnotationEditor._l10nResizer ||= Object.freeze({
        topLeft: "pdfjs-editor-resizer-top-left",
        topMiddle: "pdfjs-editor-resizer-top-middle",
        topRight: "pdfjs-editor-resizer-top-right",
        middleRight: "pdfjs-editor-resizer-middle-right",
        bottomRight: "pdfjs-editor-resizer-bottom-right",
        bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
        bottomLeft: "pdfjs-editor-resizer-bottom-left",
        middleLeft: "pdfjs-editor-resizer-middle-left"
      });
      if (AnnotationEditor._borderLineWidth !== -1) {
        return;
      }
      const style = getComputedStyle(document.documentElement);
      AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
    }
    static updateDefaultParams(_type, _value) {
    }
    static get defaultPropertiesToUpdate() {
      return [];
    }
    static isHandlingMimeForPasting(mime) {
      return false;
    }
    static paste(item, parent) {
      unreachable("Not implemented");
    }
    get propertiesToUpdate() {
      return [];
    }
    get _isDraggable() {
      return this.#isDraggable;
    }
    set _isDraggable(value) {
      this.#isDraggable = value;
      this.div?.classList.toggle("draggable", value);
    }
    get isEnterHandled() {
      return true;
    }
    center() {
      const [pageWidth, pageHeight] = this.pageDimensions;
      switch (this.parentRotation) {
        case 90:
          this.x -= this.height * pageHeight / (pageWidth * 2);
          this.y += this.width * pageWidth / (pageHeight * 2);
          break;
        case 180:
          this.x += this.width / 2;
          this.y += this.height / 2;
          break;
        case 270:
          this.x += this.height * pageHeight / (pageWidth * 2);
          this.y -= this.width * pageWidth / (pageHeight * 2);
          break;
        default:
          this.x -= this.width / 2;
          this.y -= this.height / 2;
          break;
      }
      this.fixAndSetPosition();
    }
    addCommands(params) {
      this._uiManager.addCommands(params);
    }
    get currentLayer() {
      return this._uiManager.currentLayer;
    }
    setInBackground() {
      this.div.style.zIndex = 0;
    }
    setInForeground() {
      this.div.style.zIndex = this.#zIndex;
    }
    setParent(parent) {
      if (parent !== null) {
        this.pageIndex = parent.pageIndex;
        this.pageDimensions = parent.pageDimensions;
      } else {
        this.#stopResizing();
      }
      this.parent = parent;
    }
    focusin(event) {
      if (!this._focusEventsAllowed) {
        return;
      }
      if (!this.#hasBeenClicked) {
        this.parent.setSelected(this);
      } else {
        this.#hasBeenClicked = false;
      }
    }
    focusout(event) {
      if (!this._focusEventsAllowed) {
        return;
      }
      if (!this.isAttachedToDOM) {
        return;
      }
      const target = event.relatedTarget;
      if (target?.closest(`#${this.id}`)) {
        return;
      }
      event.preventDefault();
      if (!this.parent?.isMultipleSelection) {
        this.commitOrRemove();
      }
    }
    commitOrRemove() {
      if (this.isEmpty()) {
        this.remove();
      } else {
        this.commit();
      }
    }
    commit() {
      if (!this.isInEditMode()) {
        return;
      }
      this.addToAnnotationStorage();
    }
    addToAnnotationStorage() {
      this._uiManager.addToAnnotationStorage(this);
    }
    setAt(x, y, tx, ty) {
      const [width, height] = this.parentDimensions;
      [tx, ty] = this.screenToPageTranslation(tx, ty);
      this.x = (x + tx) / width;
      this.y = (y + ty) / height;
      this.fixAndSetPosition();
    }
    _moveAfterPaste(baseX, baseY) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
      this._onTranslated();
    }
    #translate([width, height], x, y) {
      [x, y] = this.screenToPageTranslation(x, y);
      this.x += x / width;
      this.y += y / height;
      this._onTranslating(this.x, this.y);
      this.fixAndSetPosition();
    }
    translate(x, y) {
      this.#translate(this.parentDimensions, x, y);
    }
    translateInPage(x, y) {
      this.#initialRect ||= [this.x, this.y, this.width, this.height];
      this.#translate(this.pageDimensions, x, y);
      this.div.scrollIntoView({
        block: "nearest"
      });
    }
    translationDone() {
      this._onTranslated(this.x, this.y);
    }
    drag(tx, ty) {
      this.#initialRect ||= [this.x, this.y, this.width, this.height];
      const {
        div,
        parentDimensions: [parentWidth, parentHeight]
      } = this;
      this.x += tx / parentWidth;
      this.y += ty / parentHeight;
      if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
        const {
          x: x2,
          y: y2
        } = this.div.getBoundingClientRect();
        if (this.parent.findNewParent(this, x2, y2)) {
          this.x -= Math.floor(this.x);
          this.y -= Math.floor(this.y);
        }
      }
      let {
        x,
        y
      } = this;
      const [bx, by] = this.getBaseTranslation();
      x += bx;
      y += by;
      const {
        style
      } = div;
      style.left = `${(100 * x).toFixed(2)}%`;
      style.top = `${(100 * y).toFixed(2)}%`;
      this._onTranslating(x, y);
      div.scrollIntoView({
        block: "nearest"
      });
    }
    _onTranslating(x, y) {
    }
    _onTranslated(x, y) {
    }
    get _hasBeenMoved() {
      return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);
    }
    get _hasBeenResized() {
      return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);
    }
    getBaseTranslation() {
      const [parentWidth, parentHeight] = this.parentDimensions;
      const {
        _borderLineWidth
      } = AnnotationEditor;
      const x = _borderLineWidth / parentWidth;
      const y = _borderLineWidth / parentHeight;
      switch (this.rotation) {
        case 90:
          return [-x, y];
        case 180:
          return [x, y];
        case 270:
          return [x, -y];
        default:
          return [-x, -y];
      }
    }
    get _mustFixPosition() {
      return true;
    }
    fixAndSetPosition(rotation = this.rotation) {
      const {
        div: {
          style
        },
        pageDimensions: [pageWidth, pageHeight]
      } = this;
      let {
        x,
        y,
        width,
        height
      } = this;
      width *= pageWidth;
      height *= pageHeight;
      x *= pageWidth;
      y *= pageHeight;
      if (this._mustFixPosition) {
        switch (rotation) {
          case 0:
            x = MathClamp(x, 0, pageWidth - width);
            y = MathClamp(y, 0, pageHeight - height);
            break;
          case 90:
            x = MathClamp(x, 0, pageWidth - height);
            y = MathClamp(y, width, pageHeight);
            break;
          case 180:
            x = MathClamp(x, width, pageWidth);
            y = MathClamp(y, height, pageHeight);
            break;
          case 270:
            x = MathClamp(x, height, pageWidth);
            y = MathClamp(y, 0, pageHeight - width);
            break;
        }
      }
      this.x = x /= pageWidth;
      this.y = y /= pageHeight;
      const [bx, by] = this.getBaseTranslation();
      x += bx;
      y += by;
      style.left = `${(100 * x).toFixed(2)}%`;
      style.top = `${(100 * y).toFixed(2)}%`;
      this.moveInDOM();
    }
    static #rotatePoint(x, y, angle) {
      switch (angle) {
        case 90:
          return [y, -x];
        case 180:
          return [-x, -y];
        case 270:
          return [-y, x];
        default:
          return [x, y];
      }
    }
    screenToPageTranslation(x, y) {
      return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);
    }
    pageTranslationToScreen(x, y) {
      return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);
    }
    #getRotationMatrix(rotation) {
      switch (rotation) {
        case 90: {
          const [pageWidth, pageHeight] = this.pageDimensions;
          return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
        }
        case 180:
          return [-1, 0, 0, -1];
        case 270: {
          const [pageWidth, pageHeight] = this.pageDimensions;
          return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
        }
        default:
          return [1, 0, 0, 1];
      }
    }
    get parentScale() {
      return this._uiManager.viewParameters.realScale;
    }
    get parentRotation() {
      return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
    }
    get parentDimensions() {
      const {
        parentScale,
        pageDimensions: [pageWidth, pageHeight]
      } = this;
      return [pageWidth * parentScale, pageHeight * parentScale];
    }
    setDims(width, height) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      const {
        style
      } = this.div;
      style.width = `${(100 * width / parentWidth).toFixed(2)}%`;
      if (!this.#keepAspectRatio) {
        style.height = `${(100 * height / parentHeight).toFixed(2)}%`;
      }
    }
    fixDims() {
      const {
        style
      } = this.div;
      const {
        height,
        width
      } = style;
      const widthPercent = width.endsWith("%");
      const heightPercent = !this.#keepAspectRatio && height.endsWith("%");
      if (widthPercent && heightPercent) {
        return;
      }
      const [parentWidth, parentHeight] = this.parentDimensions;
      if (!widthPercent) {
        style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;
      }
      if (!this.#keepAspectRatio && !heightPercent) {
        style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;
      }
    }
    getInitialTranslation() {
      return [0, 0];
    }
    #createResizers() {
      if (this.#resizersDiv) {
        return;
      }
      this.#resizersDiv = document.createElement("div");
      this.#resizersDiv.classList.add("resizers");
      const classes = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
      const signal = this._uiManager._signal;
      for (const name of classes) {
        const div = document.createElement("div");
        this.#resizersDiv.append(div);
        div.classList.add("resizer", name);
        div.setAttribute("data-resizer-name", name);
        div.addEventListener("pointerdown", this.#resizerPointerdown.bind(this, name), {
          signal
        });
        div.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        div.tabIndex = -1;
      }
      this.div.prepend(this.#resizersDiv);
    }
    #resizerPointerdown(name, event) {
      event.preventDefault();
      const {
        isMac
      } = util_FeatureTest.platform;
      if (event.button !== 0 || event.ctrlKey && isMac) {
        return;
      }
      this.#altText?.toggle(false);
      const savedDraggable = this._isDraggable;
      this._isDraggable = false;
      this.#lastPointerCoords = [event.screenX, event.screenY];
      const ac = new AbortController();
      const signal = this._uiManager.combinedSignal(ac);
      this.parent.togglePointerEvents(false);
      window.addEventListener("pointermove", this.#resizerPointermove.bind(this, name), {
        passive: true,
        capture: true,
        signal
      });
      window.addEventListener("touchmove", stopEvent, {
        passive: false,
        signal
      });
      window.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      this.#savedDimensions = {
        savedX: this.x,
        savedY: this.y,
        savedWidth: this.width,
        savedHeight: this.height
      };
      const savedParentCursor = this.parent.div.style.cursor;
      const savedCursor = this.div.style.cursor;
      this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
      const pointerUpCallback = () => {
        ac.abort();
        this.parent.togglePointerEvents(true);
        this.#altText?.toggle(true);
        this._isDraggable = savedDraggable;
        this.parent.div.style.cursor = savedParentCursor;
        this.div.style.cursor = savedCursor;
        this.#addResizeToUndoStack();
      };
      window.addEventListener("pointerup", pointerUpCallback, {
        signal
      });
      window.addEventListener("blur", pointerUpCallback, {
        signal
      });
    }
    #resize(x, y, width, height) {
      this.width = width;
      this.height = height;
      this.x = x;
      this.y = y;
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setDims(parentWidth * width, parentHeight * height);
      this.fixAndSetPosition();
      this._onResized();
    }
    _onResized() {
    }
    #addResizeToUndoStack() {
      if (!this.#savedDimensions) {
        return;
      }
      const {
        savedX,
        savedY,
        savedWidth,
        savedHeight
      } = this.#savedDimensions;
      this.#savedDimensions = null;
      const newX = this.x;
      const newY = this.y;
      const newWidth = this.width;
      const newHeight = this.height;
      if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
        return;
      }
      this.addCommands({
        cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),
        undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),
        mustExec: true
      });
    }
    static _round(x) {
      return Math.round(x * 1e4) / 1e4;
    }
    #resizerPointermove(name, event) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      const savedX = this.x;
      const savedY = this.y;
      const savedWidth = this.width;
      const savedHeight = this.height;
      const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
      const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
      const rotationMatrix = this.#getRotationMatrix(this.rotation);
      const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
      const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
      const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];
      let getPoint;
      let getOpposite;
      let isDiagonal = false;
      let isHorizontal = false;
      switch (name) {
        case "topLeft":
          isDiagonal = true;
          getPoint = (w, h) => [0, 0];
          getOpposite = (w, h) => [w, h];
          break;
        case "topMiddle":
          getPoint = (w, h) => [w / 2, 0];
          getOpposite = (w, h) => [w / 2, h];
          break;
        case "topRight":
          isDiagonal = true;
          getPoint = (w, h) => [w, 0];
          getOpposite = (w, h) => [0, h];
          break;
        case "middleRight":
          isHorizontal = true;
          getPoint = (w, h) => [w, h / 2];
          getOpposite = (w, h) => [0, h / 2];
          break;
        case "bottomRight":
          isDiagonal = true;
          getPoint = (w, h) => [w, h];
          getOpposite = (w, h) => [0, 0];
          break;
        case "bottomMiddle":
          getPoint = (w, h) => [w / 2, h];
          getOpposite = (w, h) => [w / 2, 0];
          break;
        case "bottomLeft":
          isDiagonal = true;
          getPoint = (w, h) => [0, h];
          getOpposite = (w, h) => [w, 0];
          break;
        case "middleLeft":
          isHorizontal = true;
          getPoint = (w, h) => [0, h / 2];
          getOpposite = (w, h) => [w, h / 2];
          break;
      }
      const point = getPoint(savedWidth, savedHeight);
      const oppositePoint = getOpposite(savedWidth, savedHeight);
      let transfOppositePoint = transf(...oppositePoint);
      const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);
      const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);
      let ratioX = 1;
      let ratioY = 1;
      let deltaX, deltaY;
      if (!event.fromKeyboard) {
        const {
          screenX,
          screenY
        } = event;
        const [lastScreenX, lastScreenY] = this.#lastPointerCoords;
        [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);
        this.#lastPointerCoords[0] = screenX;
        this.#lastPointerCoords[1] = screenY;
      } else {
        ({
          deltaX,
          deltaY
        } = event);
      }
      [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
      if (isDiagonal) {
        const oldDiag = Math.hypot(savedWidth, savedHeight);
        ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
      } else if (isHorizontal) {
        ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;
      } else {
        ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;
      }
      const newWidth = AnnotationEditor._round(savedWidth * ratioX);
      const newHeight = AnnotationEditor._round(savedHeight * ratioY);
      transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
      const newX = oppositeX - transfOppositePoint[0];
      const newY = oppositeY - transfOppositePoint[1];
      this.#initialRect ||= [this.x, this.y, this.width, this.height];
      this.width = newWidth;
      this.height = newHeight;
      this.x = newX;
      this.y = newY;
      this.setDims(parentWidth * newWidth, parentHeight * newHeight);
      this.fixAndSetPosition();
      this._onResizing();
    }
    _onResizing() {
    }
    altTextFinish() {
      this.#altText?.finish();
    }
    get toolbarButtons() {
      return null;
    }
    async addEditToolbar() {
      if (this._editToolbar || this.#isInEditMode) {
        return this._editToolbar;
      }
      this._editToolbar = new EditorToolbar(this);
      this.div.append(this._editToolbar.render());
      const {
        toolbarButtons
      } = this;
      if (toolbarButtons) {
        for (const [name, tool] of toolbarButtons) {
          await this._editToolbar.addButton(name, tool);
        }
      }
      this._editToolbar.addButton("comment", this.addCommentButton());
      this._editToolbar.addButton("delete");
      return this._editToolbar;
    }
    removeEditToolbar() {
      if (!this._editToolbar) {
        return;
      }
      this._editToolbar.remove();
      this._editToolbar = null;
      this.#altText?.destroy();
    }
    addContainer(container) {
      const editToolbarDiv = this._editToolbar?.div;
      if (editToolbarDiv) {
        editToolbarDiv.before(container);
      } else {
        this.div.append(container);
      }
    }
    getClientDimensions() {
      return this.div.getBoundingClientRect();
    }
    createAltText() {
      if (!this.#altText) {
        AltText.initialize(AnnotationEditor._l10n);
        this.#altText = new AltText(this);
        if (this.#accessibilityData) {
          this.#altText.data = this.#accessibilityData;
          this.#accessibilityData = null;
        }
      }
      return this.#altText;
    }
    get altTextData() {
      return this.#altText?.data;
    }
    set altTextData(data) {
      if (!this.#altText) {
        return;
      }
      this.#altText.data = data;
    }
    get guessedAltText() {
      return this.#altText?.guessedText;
    }
    async setGuessedAltText(text) {
      await this.#altText?.setGuessedText(text);
    }
    serializeAltText(isForCopying) {
      return this.#altText?.serialize(isForCopying);
    }
    hasAltText() {
      return !!this.#altText && !this.#altText.isEmpty();
    }
    hasAltTextData() {
      return this.#altText?.hasData() ?? false;
    }
    addCommentButton() {
      if (this.#comment) {
        return this.#comment;
      }
      return this.#comment = new Comment(this);
    }
    get commentColor() {
      return null;
    }
    get comment() {
      const comment = this.#comment;
      return {
        text: comment.data.text,
        date: comment.data.date,
        deleted: comment.isDeleted(),
        color: this.commentColor
      };
    }
    set comment(text) {
      if (!this.#comment) {
        this.#comment = new Comment(this);
      }
      this.#comment.data = text;
    }
    setCommentData(text) {
      if (!this.#comment) {
        this.#comment = new Comment(this);
      }
      this.#comment.setInitialText(text);
    }
    get hasEditedComment() {
      return this.#comment?.hasBeenEdited();
    }
    async editComment() {
      if (!this.#comment) {
        this.#comment = new Comment(this);
      }
      this.#comment.edit();
    }
    addComment(serialized) {
      if (this.hasEditedComment) {
        const DEFAULT_POPUP_WIDTH = 180;
        const DEFAULT_POPUP_HEIGHT = 100;
        const [, , , trY] = serialized.rect;
        const [pageWidth] = this.pageDimensions;
        const [pageX] = this.pageTranslation;
        const blX = pageX + pageWidth + 1;
        const blY = trY - DEFAULT_POPUP_HEIGHT;
        const trX = blX + DEFAULT_POPUP_WIDTH;
        serialized.popup = {
          contents: this.comment.text,
          deleted: this.comment.deleted,
          rect: [blX, blY, trX, trY]
        };
      }
    }
    render() {
      const div = this.div = document.createElement("div");
      div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
      div.className = this.name;
      div.setAttribute("id", this.id);
      div.tabIndex = this.#disabled ? -1 : 0;
      div.setAttribute("role", "application");
      if (this.defaultL10nId) {
        div.setAttribute("data-l10n-id", this.defaultL10nId);
      }
      if (!this._isVisible) {
        div.classList.add("hidden");
      }
      this.setInForeground();
      this.#addFocusListeners();
      const [parentWidth, parentHeight] = this.parentDimensions;
      if (this.parentRotation % 180 !== 0) {
        div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
        div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
      }
      const [tx, ty] = this.getInitialTranslation();
      this.translate(tx, ty);
      bindEvents(this, div, ["keydown", "pointerdown", "dblclick"]);
      if (this.isResizable && this._uiManager._supportsPinchToZoom) {
        this.#touchManager ||= new TouchManager({
          container: div,
          isPinchingDisabled: () => !this.isSelected,
          onPinchStart: this.#touchPinchStartCallback.bind(this),
          onPinching: this.#touchPinchCallback.bind(this),
          onPinchEnd: this.#touchPinchEndCallback.bind(this),
          signal: this._uiManager._signal
        });
      }
      this._uiManager._editorUndoBar?.hide();
      return div;
    }
    #touchPinchStartCallback() {
      this.#savedDimensions = {
        savedX: this.x,
        savedY: this.y,
        savedWidth: this.width,
        savedHeight: this.height
      };
      this.#altText?.toggle(false);
      this.parent.togglePointerEvents(false);
    }
    #touchPinchCallback(_origin, prevDistance, distance) {
      const slowDownFactor = 0.7;
      let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;
      if (factor === 1) {
        return;
      }
      const rotationMatrix = this.#getRotationMatrix(this.rotation);
      const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
      const [parentWidth, parentHeight] = this.parentDimensions;
      const savedX = this.x;
      const savedY = this.y;
      const savedWidth = this.width;
      const savedHeight = this.height;
      const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
      const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
      factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
      const newWidth = AnnotationEditor._round(savedWidth * factor);
      const newHeight = AnnotationEditor._round(savedHeight * factor);
      if (newWidth === savedWidth && newHeight === savedHeight) {
        return;
      }
      this.#initialRect ||= [savedX, savedY, savedWidth, savedHeight];
      const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);
      const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);
      const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);
      const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);
      this.x = centerX - newTransfCenterPoint[0];
      this.y = centerY - newTransfCenterPoint[1];
      this.width = newWidth;
      this.height = newHeight;
      this.setDims(parentWidth * newWidth, parentHeight * newHeight);
      this.fixAndSetPosition();
      this._onResizing();
    }
    #touchPinchEndCallback() {
      this.#altText?.toggle(true);
      this.parent.togglePointerEvents(true);
      this.#addResizeToUndoStack();
    }
    pointerdown(event) {
      const {
        isMac
      } = util_FeatureTest.platform;
      if (event.button !== 0 || event.ctrlKey && isMac) {
        event.preventDefault();
        return;
      }
      this.#hasBeenClicked = true;
      if (this._isDraggable) {
        this.#setUpDragSession(event);
        return;
      }
      this.#selectOnPointerEvent(event);
    }
    #selectOnPointerEvent(event) {
      const {
        isMac
      } = util_FeatureTest.platform;
      if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
        this.parent.toggleSelected(this);
      } else {
        this.parent.setSelected(this);
      }
    }
    #setUpDragSession(event) {
      const {
        isSelected
      } = this;
      this._uiManager.setUpDragSession();
      let hasDraggingStarted = false;
      const ac = new AbortController();
      const signal = this._uiManager.combinedSignal(ac);
      const opts = {
        capture: true,
        passive: false,
        signal
      };
      const cancelDrag = (e) => {
        ac.abort();
        this.#dragPointerId = null;
        this.#hasBeenClicked = false;
        if (!this._uiManager.endDragSession()) {
          this.#selectOnPointerEvent(e);
        }
        if (hasDraggingStarted) {
          this._onStopDragging();
        }
      };
      if (isSelected) {
        this.#prevDragX = event.clientX;
        this.#prevDragY = event.clientY;
        this.#dragPointerId = event.pointerId;
        this.#dragPointerType = event.pointerType;
        window.addEventListener("pointermove", (e) => {
          if (!hasDraggingStarted) {
            hasDraggingStarted = true;
            this._onStartDragging();
          }
          const {
            clientX: x,
            clientY: y,
            pointerId
          } = e;
          if (pointerId !== this.#dragPointerId) {
            stopEvent(e);
            return;
          }
          const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);
          this.#prevDragX = x;
          this.#prevDragY = y;
          this._uiManager.dragSelectedEditors(tx, ty);
        }, opts);
        window.addEventListener("touchmove", stopEvent, opts);
        window.addEventListener("pointerdown", (e) => {
          if (e.pointerType === this.#dragPointerType) {
            if (this.#touchManager || e.isPrimary) {
              cancelDrag(e);
            }
          }
          stopEvent(e);
        }, opts);
      }
      const pointerUpCallback = (e) => {
        if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {
          cancelDrag(e);
          return;
        }
        stopEvent(e);
      };
      window.addEventListener("pointerup", pointerUpCallback, {
        signal
      });
      window.addEventListener("blur", pointerUpCallback, {
        signal
      });
    }
    _onStartDragging() {
    }
    _onStopDragging() {
    }
    moveInDOM() {
      if (this.#moveInDOMTimeout) {
        clearTimeout(this.#moveInDOMTimeout);
      }
      this.#moveInDOMTimeout = setTimeout(() => {
        this.#moveInDOMTimeout = null;
        this.parent?.moveEditorInDOM(this);
      }, 0);
    }
    _setParentAndPosition(parent, x, y) {
      parent.changeParent(this);
      this.x = x;
      this.y = y;
      this.fixAndSetPosition();
      this._onTranslated();
    }
    getRect(tx, ty, rotation = this.rotation) {
      const scale = this.parentScale;
      const [pageWidth, pageHeight] = this.pageDimensions;
      const [pageX, pageY] = this.pageTranslation;
      const shiftX = tx / scale;
      const shiftY = ty / scale;
      const x = this.x * pageWidth;
      const y = this.y * pageHeight;
      const width = this.width * pageWidth;
      const height = this.height * pageHeight;
      switch (rotation) {
        case 0:
          return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];
        case 90:
          return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];
        case 180:
          return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];
        case 270:
          return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];
        default:
          throw new Error("Invalid rotation");
      }
    }
    getRectInCurrentCoords(rect, pageHeight) {
      const [x1, y1, x2, y2] = rect;
      const width = x2 - x1;
      const height = y2 - y1;
      switch (this.rotation) {
        case 0:
          return [x1, pageHeight - y2, width, height];
        case 90:
          return [x1, pageHeight - y1, height, width];
        case 180:
          return [x2, pageHeight - y1, width, height];
        case 270:
          return [x2, pageHeight - y2, height, width];
        default:
          throw new Error("Invalid rotation");
      }
    }
    getPDFRect() {
      return this.getRect(0, 0);
    }
    onceAdded(focus) {
    }
    isEmpty() {
      return false;
    }
    enableEditMode() {
      if (this.isInEditMode()) {
        return false;
      }
      this.parent.setEditingState(false);
      this.#isInEditMode = true;
      return true;
    }
    disableEditMode() {
      if (!this.isInEditMode()) {
        return false;
      }
      this.parent.setEditingState(true);
      this.#isInEditMode = false;
      return true;
    }
    isInEditMode() {
      return this.#isInEditMode;
    }
    shouldGetKeyboardEvents() {
      return this.#isResizerEnabledForKeyboard;
    }
    needsToBeRebuilt() {
      return this.div && !this.isAttachedToDOM;
    }
    get isOnScreen() {
      const {
        top,
        left,
        bottom,
        right
      } = this.getClientDimensions();
      const {
        innerHeight,
        innerWidth
      } = window;
      return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;
    }
    #addFocusListeners() {
      if (this.#focusAC || !this.div) {
        return;
      }
      this.#focusAC = new AbortController();
      const signal = this._uiManager.combinedSignal(this.#focusAC);
      this.div.addEventListener("focusin", this.focusin.bind(this), {
        signal
      });
      this.div.addEventListener("focusout", this.focusout.bind(this), {
        signal
      });
    }
    rebuild() {
      this.#addFocusListeners();
    }
    rotate(_angle) {
    }
    resize() {
    }
    serializeDeleted() {
      return {
        id: this.annotationElementId,
        deleted: true,
        pageIndex: this.pageIndex,
        popupRef: this._initialData?.popupRef || ""
      };
    }
    serialize(isForCopying = false, context = null) {
      unreachable("An editor must be serializable");
    }
    static async deserialize(data, parent, uiManager) {
      const editor = new this.prototype.constructor({
        parent,
        id: parent.getNextId(),
        uiManager,
        annotationElementId: data.annotationElementId
      });
      editor.rotation = data.rotation;
      editor.#accessibilityData = data.accessibilityData;
      editor._isCopy = data.isCopy || false;
      const [pageWidth, pageHeight] = editor.pageDimensions;
      const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
      editor.x = x / pageWidth;
      editor.y = y / pageHeight;
      editor.width = width / pageWidth;
      editor.height = height / pageHeight;
      return editor;
    }
    get hasBeenModified() {
      return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
    }
    remove() {
      this.#focusAC?.abort();
      this.#focusAC = null;
      if (!this.isEmpty()) {
        this.commit();
      }
      if (this.parent) {
        this.parent.remove(this);
      } else {
        this._uiManager.removeEditor(this);
      }
      if (this.#moveInDOMTimeout) {
        clearTimeout(this.#moveInDOMTimeout);
        this.#moveInDOMTimeout = null;
      }
      this.#stopResizing();
      this.removeEditToolbar();
      if (this.#telemetryTimeouts) {
        for (const timeout of this.#telemetryTimeouts.values()) {
          clearTimeout(timeout);
        }
        this.#telemetryTimeouts = null;
      }
      this.parent = null;
      this.#touchManager?.destroy();
      this.#touchManager = null;
    }
    get isResizable() {
      return false;
    }
    makeResizable() {
      if (this.isResizable) {
        this.#createResizers();
        this.#resizersDiv.classList.remove("hidden");
      }
    }
    get toolbarPosition() {
      return null;
    }
    keydown(event) {
      if (!this.isResizable || event.target !== this.div || event.key !== "Enter") {
        return;
      }
      this._uiManager.setSelected(this);
      this.#savedDimensions = {
        savedX: this.x,
        savedY: this.y,
        savedWidth: this.width,
        savedHeight: this.height
      };
      const children = this.#resizersDiv.children;
      if (!this.#allResizerDivs) {
        this.#allResizerDivs = Array.from(children);
        const boundResizerKeydown = this.#resizerKeydown.bind(this);
        const boundResizerBlur = this.#resizerBlur.bind(this);
        const signal = this._uiManager._signal;
        for (const div of this.#allResizerDivs) {
          const name = div.getAttribute("data-resizer-name");
          div.setAttribute("role", "spinbutton");
          div.addEventListener("keydown", boundResizerKeydown, {
            signal
          });
          div.addEventListener("blur", boundResizerBlur, {
            signal
          });
          div.addEventListener("focus", this.#resizerFocus.bind(this, name), {
            signal
          });
          div.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[name]);
        }
      }
      const first = this.#allResizerDivs[0];
      let firstPosition = 0;
      for (const div of children) {
        if (div === first) {
          break;
        }
        firstPosition++;
      }
      const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);
      if (nextFirstPosition !== firstPosition) {
        if (nextFirstPosition < firstPosition) {
          for (let i2 = 0; i2 < firstPosition - nextFirstPosition; i2++) {
            this.#resizersDiv.append(this.#resizersDiv.firstChild);
          }
        } else if (nextFirstPosition > firstPosition) {
          for (let i2 = 0; i2 < nextFirstPosition - firstPosition; i2++) {
            this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);
          }
        }
        let i = 0;
        for (const child of children) {
          const div = this.#allResizerDivs[i++];
          const name = div.getAttribute("data-resizer-name");
          child.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[name]);
        }
      }
      this.#setResizerTabIndex(0);
      this.#isResizerEnabledForKeyboard = true;
      this.#resizersDiv.firstChild.focus({
        focusVisible: true
      });
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    #resizerKeydown(event) {
      AnnotationEditor._resizerKeyboardManager.exec(this, event);
    }
    #resizerBlur(event) {
      if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {
        this.#stopResizing();
      }
    }
    #resizerFocus(name) {
      this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : "";
    }
    #setResizerTabIndex(value) {
      if (!this.#allResizerDivs) {
        return;
      }
      for (const div of this.#allResizerDivs) {
        div.tabIndex = value;
      }
    }
    _resizeWithKeyboard(x, y) {
      if (!this.#isResizerEnabledForKeyboard) {
        return;
      }
      this.#resizerPointermove(this.#focusedResizerName, {
        deltaX: x,
        deltaY: y,
        fromKeyboard: true
      });
    }
    #stopResizing() {
      this.#isResizerEnabledForKeyboard = false;
      this.#setResizerTabIndex(-1);
      this.#addResizeToUndoStack();
    }
    _stopResizingWithKeyboard() {
      this.#stopResizing();
      this.div.focus();
    }
    select() {
      if (this.isSelected && this._editToolbar) {
        return;
      }
      this.isSelected = true;
      this.makeResizable();
      this.div?.classList.add("selectedEditor");
      if (!this._editToolbar) {
        this.addEditToolbar().then(() => {
          if (this.div?.classList.contains("selectedEditor")) {
            this._editToolbar?.show();
          }
        });
        return;
      }
      this._editToolbar?.show();
      this.#altText?.toggleAltTextBadge(false);
    }
    unselect() {
      if (!this.isSelected) {
        return;
      }
      this.isSelected = false;
      this.#resizersDiv?.classList.add("hidden");
      this.div?.classList.remove("selectedEditor");
      if (this.div?.contains(document.activeElement)) {
        this._uiManager.currentLayer.div.focus({
          preventScroll: true
        });
      }
      this._editToolbar?.hide();
      this.#altText?.toggleAltTextBadge(true);
    }
    updateParams(type, value) {
    }
    disableEditing() {
    }
    enableEditing() {
    }
    get canChangeContent() {
      return false;
    }
    enterInEditMode() {
      if (!this.canChangeContent) {
        return;
      }
      this.enableEditMode();
      this.div.focus();
    }
    dblclick(event) {
      this.enterInEditMode();
      this.parent.updateToolbar({
        mode: this.constructor._editorType,
        editId: this.id
      });
    }
    getElementForAltText() {
      return this.div;
    }
    get contentDiv() {
      return this.div;
    }
    get isEditing() {
      return this.#isEditing;
    }
    set isEditing(value) {
      this.#isEditing = value;
      if (!this.parent) {
        return;
      }
      if (value) {
        this.parent.setSelected(this);
        this.parent.setActiveEditor(this);
      } else {
        this.parent.setActiveEditor(null);
      }
    }
    setAspectRatio(width, height) {
      this.#keepAspectRatio = true;
      const aspectRatio = width / height;
      const {
        style
      } = this.div;
      style.aspectRatio = aspectRatio;
      style.height = "auto";
    }
    static get MIN_SIZE() {
      return 16;
    }
    static canCreateNewEmptyEditor() {
      return true;
    }
    get telemetryInitialData() {
      return {
        action: "added"
      };
    }
    get telemetryFinalData() {
      return null;
    }
    _reportTelemetry(data, mustWait = false) {
      if (mustWait) {
        this.#telemetryTimeouts ||= /* @__PURE__ */ new Map();
        const {
          action
        } = data;
        let timeout = this.#telemetryTimeouts.get(action);
        if (timeout) {
          clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
          this._reportTelemetry(data);
          this.#telemetryTimeouts.delete(action);
          if (this.#telemetryTimeouts.size === 0) {
            this.#telemetryTimeouts = null;
          }
        }, AnnotationEditor._telemetryTimeout);
        this.#telemetryTimeouts.set(action, timeout);
        return;
      }
      data.type ||= this.editorType;
      this._uiManager._eventBus.dispatch("reporttelemetry", {
        source: this,
        details: {
          type: "editing",
          data
        }
      });
    }
    show(visible = this._isVisible) {
      this.div.classList.toggle("hidden", !visible);
      this._isVisible = visible;
    }
    enable() {
      if (this.div) {
        this.div.tabIndex = 0;
      }
      this.#disabled = false;
    }
    disable() {
      if (this.div) {
        this.div.tabIndex = -1;
      }
      this.#disabled = true;
    }
    renderAnnotationElement(annotation) {
      if (this.deleted) {
        annotation.hide();
        return null;
      }
      let content = annotation.container.querySelector(".annotationContent");
      if (!content) {
        content = document.createElement("div");
        content.classList.add("annotationContent", this.editorType);
        annotation.container.prepend(content);
      } else if (content.nodeName === "CANVAS") {
        const canvas = content;
        content = document.createElement("div");
        content.classList.add("annotationContent", this.editorType);
        canvas.before(content);
      }
      return content;
    }
    resetAnnotationElement(annotation) {
      const {
        firstChild
      } = annotation.container;
      if (firstChild?.nodeName === "DIV" && firstChild.classList.contains("annotationContent")) {
        firstChild.remove();
      }
    }
  }
  class FakeEditor extends AnnotationEditor {
    constructor(params) {
      super(params);
      this.annotationElementId = params.annotationElementId;
      this.deleted = true;
    }
    serialize() {
      return this.serializeDeleted();
    }
  }
  const SEED = 3285377520;
  const MASK_HIGH = 4294901760;
  const MASK_LOW = 65535;
  class MurmurHash3_64 {
    constructor(seed) {
      this.h1 = seed ? seed & 4294967295 : SEED;
      this.h2 = seed ? seed & 4294967295 : SEED;
    }
    update(input) {
      let data, length;
      if (typeof input === "string") {
        data = new Uint8Array(input.length * 2);
        length = 0;
        for (let i = 0, ii = input.length; i < ii; i++) {
          const code = input.charCodeAt(i);
          if (code <= 255) {
            data[length++] = code;
          } else {
            data[length++] = code >>> 8;
            data[length++] = code & 255;
          }
        }
      } else if (ArrayBuffer.isView(input)) {
        data = input.slice();
        length = data.byteLength;
      } else {
        throw new Error("Invalid data format, must be a string or TypedArray.");
      }
      const blockCounts = length >> 2;
      const tailLength = length - blockCounts * 4;
      const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
      let k1 = 0, k2 = 0;
      let h1 = this.h1, h2 = this.h2;
      const C1 = 3432918353, C2 = 461845907;
      const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
      for (let i = 0; i < blockCounts; i++) {
        if (i & 1) {
          k1 = dataUint32[i];
          k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = h1 * 5 + 3864292196;
        } else {
          k2 = dataUint32[i];
          k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
          k2 = k2 << 15 | k2 >>> 17;
          k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
          h2 ^= k2;
          h2 = h2 << 13 | h2 >>> 19;
          h2 = h2 * 5 + 3864292196;
        }
      }
      k1 = 0;
      switch (tailLength) {
        case 3:
          k1 ^= data[blockCounts * 4 + 2] << 16;
        case 2:
          k1 ^= data[blockCounts * 4 + 1] << 8;
        case 1:
          k1 ^= data[blockCounts * 4];
          k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
          if (blockCounts & 1) {
            h1 ^= k1;
          } else {
            h2 ^= k1;
          }
      }
      this.h1 = h1;
      this.h2 = h2;
    }
    hexdigest() {
      let h1 = this.h1, h2 = this.h2;
      h1 ^= h2 >>> 1;
      h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
      h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
      h1 ^= h2 >>> 1;
      h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
      h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
      h1 ^= h2 >>> 1;
      return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
    }
  }
  const SerializableEmpty = Object.freeze({
    map: null,
    hash: "",
    transfer: void 0
  });
  class AnnotationStorage {
    #modified = false;
    #modifiedIds = null;
    #storage = /* @__PURE__ */ new Map();
    constructor() {
      this.onSetModified = null;
      this.onResetModified = null;
      this.onAnnotationEditor = null;
    }
    getValue(key, defaultValue) {
      const value = this.#storage.get(key);
      if (value === void 0) {
        return defaultValue;
      }
      return Object.assign(defaultValue, value);
    }
    getRawValue(key) {
      return this.#storage.get(key);
    }
    remove(key) {
      this.#storage.delete(key);
      if (this.#storage.size === 0) {
        this.resetModified();
      }
      if (typeof this.onAnnotationEditor === "function") {
        for (const value of this.#storage.values()) {
          if (value instanceof AnnotationEditor) {
            return;
          }
        }
        this.onAnnotationEditor(null);
      }
    }
    setValue(key, value) {
      const obj = this.#storage.get(key);
      let modified = false;
      if (obj !== void 0) {
        for (const [entry, val] of Object.entries(value)) {
          if (obj[entry] !== val) {
            modified = true;
            obj[entry] = val;
          }
        }
      } else {
        modified = true;
        this.#storage.set(key, value);
      }
      if (modified) {
        this.#setModified();
      }
      if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === "function") {
        this.onAnnotationEditor(value.constructor._type);
      }
    }
    has(key) {
      return this.#storage.has(key);
    }
    get size() {
      return this.#storage.size;
    }
    #setModified() {
      if (!this.#modified) {
        this.#modified = true;
        if (typeof this.onSetModified === "function") {
          this.onSetModified();
        }
      }
    }
    resetModified() {
      if (this.#modified) {
        this.#modified = false;
        if (typeof this.onResetModified === "function") {
          this.onResetModified();
        }
      }
    }
    get print() {
      return new PrintAnnotationStorage(this);
    }
    get serializable() {
      if (this.#storage.size === 0) {
        return SerializableEmpty;
      }
      const map = /* @__PURE__ */ new Map(), hash = new MurmurHash3_64(), transfer = [];
      const context = /* @__PURE__ */ Object.create(null);
      let hasBitmap = false;
      for (const [key, val] of this.#storage) {
        const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;
        if (serialized) {
          map.set(key, serialized);
          hash.update(`${key}:${JSON.stringify(serialized)}`);
          hasBitmap ||= !!serialized.bitmap;
        }
      }
      if (hasBitmap) {
        for (const value of map.values()) {
          if (value.bitmap) {
            transfer.push(value.bitmap);
          }
        }
      }
      return map.size > 0 ? {
        map,
        hash: hash.hexdigest(),
        transfer
      } : SerializableEmpty;
    }
    get editorStats() {
      let stats = null;
      const typeToEditor = /* @__PURE__ */ new Map();
      for (const value of this.#storage.values()) {
        if (!(value instanceof AnnotationEditor)) {
          continue;
        }
        const editorStats = value.telemetryFinalData;
        if (!editorStats) {
          continue;
        }
        const {
          type
        } = editorStats;
        if (!typeToEditor.has(type)) {
          typeToEditor.set(type, Object.getPrototypeOf(value).constructor);
        }
        stats ||= /* @__PURE__ */ Object.create(null);
        const map = stats[type] ||= /* @__PURE__ */ new Map();
        for (const [key, val] of Object.entries(editorStats)) {
          if (key === "type") {
            continue;
          }
          let counters = map.get(key);
          if (!counters) {
            counters = /* @__PURE__ */ new Map();
            map.set(key, counters);
          }
          const count = counters.get(val) ?? 0;
          counters.set(val, count + 1);
        }
      }
      for (const [type, editor] of typeToEditor) {
        stats[type] = editor.computeTelemetryFinalData(stats[type]);
      }
      return stats;
    }
    resetModifiedIds() {
      this.#modifiedIds = null;
    }
    get modifiedIds() {
      if (this.#modifiedIds) {
        return this.#modifiedIds;
      }
      const ids = [];
      for (const value of this.#storage.values()) {
        if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) {
          continue;
        }
        ids.push(value.annotationElementId);
      }
      return this.#modifiedIds = {
        ids: new Set(ids),
        hash: ids.join(",")
      };
    }
    [Symbol.iterator]() {
      return this.#storage.entries();
    }
  }
  class PrintAnnotationStorage extends AnnotationStorage {
    #serializable;
    constructor(parent) {
      super();
      const {
        map,
        hash,
        transfer
      } = parent.serializable;
      const clone = structuredClone(map, transfer ? {
        transfer
      } : null);
      this.#serializable = {
        map: clone,
        hash,
        transfer
      };
    }
    get print() {
      unreachable("Should not call PrintAnnotationStorage.print");
    }
    get serializable() {
      return this.#serializable;
    }
    get modifiedIds() {
      return shadow(this, "modifiedIds", {
        ids: /* @__PURE__ */ new Set(),
        hash: ""
      });
    }
  }
  class FontLoader {
    #systemFonts = /* @__PURE__ */ new Set();
    constructor({
      ownerDocument = globalThis.document,
      styleElement = null
    }) {
      this._document = ownerDocument;
      this.nativeFontFaces = /* @__PURE__ */ new Set();
      this.styleElement = null;
      this.loadingRequests = [];
      this.loadTestFontId = 0;
    }
    addNativeFontFace(nativeFontFace) {
      this.nativeFontFaces.add(nativeFontFace);
      this._document.fonts.add(nativeFontFace);
    }
    removeNativeFontFace(nativeFontFace) {
      this.nativeFontFaces.delete(nativeFontFace);
      this._document.fonts.delete(nativeFontFace);
    }
    insertRule(rule) {
      if (!this.styleElement) {
        this.styleElement = this._document.createElement("style");
        this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
      }
      const styleSheet = this.styleElement.sheet;
      styleSheet.insertRule(rule, styleSheet.cssRules.length);
    }
    clear() {
      for (const nativeFontFace of this.nativeFontFaces) {
        this._document.fonts.delete(nativeFontFace);
      }
      this.nativeFontFaces.clear();
      this.#systemFonts.clear();
      if (this.styleElement) {
        this.styleElement.remove();
        this.styleElement = null;
      }
    }
    async loadSystemFont({
      systemFontInfo: info2,
      disableFontFace,
      _inspectFont
    }) {
      if (!info2 || this.#systemFonts.has(info2.loadedName)) {
        return;
      }
      assert(!disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
      if (this.isFontLoadingAPISupported) {
        const {
          loadedName,
          src,
          style
        } = info2;
        const fontFace = new FontFace(loadedName, src, style);
        this.addNativeFontFace(fontFace);
        try {
          await fontFace.load();
          this.#systemFonts.add(loadedName);
          _inspectFont?.(info2);
        } catch {
          warn(`Cannot load system font: ${info2.baseFontName}, installing it could help to improve PDF rendering.`);
          this.removeNativeFontFace(fontFace);
        }
        return;
      }
      unreachable("Not implemented: loadSystemFont without the Font Loading API.");
    }
    async bind(font) {
      if (font.attached || font.missingFile && !font.systemFontInfo) {
        return;
      }
      font.attached = true;
      if (font.systemFontInfo) {
        await this.loadSystemFont(font);
        return;
      }
      if (this.isFontLoadingAPISupported) {
        const nativeFontFace = font.createNativeFontFace();
        if (nativeFontFace) {
          this.addNativeFontFace(nativeFontFace);
          try {
            await nativeFontFace.loaded;
          } catch (ex) {
            warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
            font.disableFontFace = true;
            throw ex;
          }
        }
        return;
      }
      const rule = font.createFontFaceRule();
      if (rule) {
        this.insertRule(rule);
        if (this.isSyncFontLoadingSupported) {
          return;
        }
        await new Promise((resolve) => {
          const request = this._queueLoadingCallback(resolve);
          this._prepareFontLoadEvent(font, request);
        });
      }
    }
    get isFontLoadingAPISupported() {
      const hasFonts = !!this._document?.fonts;
      return shadow(this, "isFontLoadingAPISupported", hasFonts);
    }
    get isSyncFontLoadingSupported() {
      return shadow(this, "isSyncFontLoadingSupported", isNodeJS || util_FeatureTest.platform.isFirefox);
    }
    _queueLoadingCallback(callback) {
      function completeRequest() {
        assert(!request.done, "completeRequest() cannot be called twice.");
        request.done = true;
        while (loadingRequests.length > 0 && loadingRequests[0].done) {
          const otherRequest = loadingRequests.shift();
          setTimeout(otherRequest.callback, 0);
        }
      }
      const {
        loadingRequests
      } = this;
      const request = {
        done: false,
        complete: completeRequest,
        callback
      };
      loadingRequests.push(request);
      return request;
    }
    get _loadTestFont() {
      const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
      return shadow(this, "_loadTestFont", testFont);
    }
    _prepareFontLoadEvent(font, request) {
      function int32(data2, offset) {
        return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
      }
      function spliceString(s, offset, remove, insert) {
        const chunk1 = s.substring(0, offset);
        const chunk2 = s.substring(offset + remove);
        return chunk1 + insert + chunk2;
      }
      let i, ii;
      const canvas = this._document.createElement("canvas");
      canvas.width = 1;
      canvas.height = 1;
      const ctx = canvas.getContext("2d");
      let called = 0;
      function isFontReady(name, callback) {
        if (++called > 30) {
          warn("Load test font never loaded.");
          callback();
          return;
        }
        ctx.font = "30px " + name;
        ctx.fillText(".", 0, 20);
        const imageData = ctx.getImageData(0, 0, 1, 1);
        if (imageData.data[3] > 0) {
          callback();
          return;
        }
        setTimeout(isFontReady.bind(null, name, callback));
      }
      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
      let data = this._loadTestFont;
      const COMMENT_OFFSET = 976;
      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
      const CFF_CHECKSUM_OFFSET = 16;
      const XXXX_VALUE = 1482184792;
      let checksum = int32(data, CFF_CHECKSUM_OFFSET);
      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
      }
      if (i < loadTestFontId.length) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
      }
      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
      const url = `url(data:font/opentype;base64,${btoa(data)});`;
      const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
      this.insertRule(rule);
      const div = this._document.createElement("div");
      div.style.visibility = "hidden";
      div.style.width = div.style.height = "10px";
      div.style.position = "absolute";
      div.style.top = div.style.left = "0px";
      for (const name of [font.loadedName, loadTestFontId]) {
        const span = this._document.createElement("span");
        span.textContent = "Hi";
        span.style.fontFamily = name;
        div.append(span);
      }
      this._document.body.append(div);
      isFontReady(loadTestFontId, () => {
        div.remove();
        request.complete();
      });
    }
  }
  class FontFaceObject {
    constructor(translatedData, inspectFont = null) {
      this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
      for (const i in translatedData) {
        this[i] = translatedData[i];
      }
      this._inspectFont = inspectFont;
    }
    createNativeFontFace() {
      if (!this.data || this.disableFontFace) {
        return null;
      }
      let nativeFontFace;
      if (!this.cssFontInfo) {
        nativeFontFace = new FontFace(this.loadedName, this.data, {});
      } else {
        const css = {
          weight: this.cssFontInfo.fontWeight
        };
        if (this.cssFontInfo.italicAngle) {
          css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
        }
        nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
      }
      this._inspectFont?.(this);
      return nativeFontFace;
    }
    createFontFaceRule() {
      if (!this.data || this.disableFontFace) {
        return null;
      }
      const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
      let rule;
      if (!this.cssFontInfo) {
        rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
      } else {
        let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
        if (this.cssFontInfo.italicAngle) {
          css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
        }
        rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
      }
      this._inspectFont?.(this, url);
      return rule;
    }
    getPathGenerator(objs, character) {
      if (this.compiledGlyphs[character] !== void 0) {
        return this.compiledGlyphs[character];
      }
      const objId = this.loadedName + "_path_" + character;
      let cmds;
      try {
        cmds = objs.get(objId);
      } catch (ex) {
        warn(`getPathGenerator - ignoring character: "${ex}".`);
      }
      const path = new Path2D(cmds || "");
      if (!this.fontExtraProperties) {
        objs.delete(objId);
      }
      return this.compiledGlyphs[character] = path;
    }
  }
  function getUrlProp(val) {
    if (val instanceof URL) {
      return val.href;
    }
    if (typeof val === "string") {
      if (isNodeJS) {
        return val;
      }
      const url = URL.parse(val, window.location);
      if (url) {
        return url.href;
      }
    }
    throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
  }
  function getDataProp(val) {
    if (isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
      throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
    }
    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
      return val;
    }
    if (typeof val === "string") {
      return stringToBytes(val);
    }
    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === "object" && !isNaN(val?.length)) {
      return new Uint8Array(val);
    }
    throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
  }
  function getFactoryUrlProp(val) {
    if (typeof val !== "string") {
      return null;
    }
    if (val.endsWith("/")) {
      return val;
    }
    throw new Error(`Invalid factory url: "${val}" must include trailing slash.`);
  }
  const isRefProxy = (v) => typeof v === "object" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;
  const isNameProxy = (v) => typeof v === "object" && typeof v?.name === "string";
  const isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);
  class LoopbackPort {
    #listeners = /* @__PURE__ */ new Map();
    #deferred = Promise.resolve();
    postMessage(obj, transfer) {
      const event = {
        data: structuredClone(obj, transfer ? {
          transfer
        } : null)
      };
      this.#deferred.then(() => {
        for (const [listener] of this.#listeners) {
          listener.call(this, event);
        }
      });
    }
    addEventListener(name, listener, options = null) {
      let rmAbort = null;
      if (options?.signal instanceof AbortSignal) {
        const {
          signal
        } = options;
        if (signal.aborted) {
          warn("LoopbackPort - cannot use an `aborted` signal.");
          return;
        }
        const onAbort = () => this.removeEventListener(name, listener);
        rmAbort = () => signal.removeEventListener("abort", onAbort);
        signal.addEventListener("abort", onAbort);
      }
      this.#listeners.set(listener, rmAbort);
    }
    removeEventListener(name, listener) {
      const rmAbort = this.#listeners.get(listener);
      rmAbort?.();
      this.#listeners.delete(listener);
    }
    terminate() {
      for (const [, rmAbort] of this.#listeners) {
        rmAbort?.();
      }
      this.#listeners.clear();
    }
  }
  const CallbackKind = {
    DATA: 1,
    ERROR: 2
  };
  const StreamKind = {
    CANCEL: 1,
    CANCEL_COMPLETE: 2,
    CLOSE: 3,
    ENQUEUE: 4,
    ERROR: 5,
    PULL: 6,
    PULL_COMPLETE: 7,
    START_COMPLETE: 8
  };
  function onFn() {
  }
  function wrapReason(ex) {
    if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {
      return ex;
    }
    if (!(ex instanceof Error || typeof ex === "object" && ex !== null)) {
      unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
    }
    switch (ex.name) {
      case "AbortException":
        return new AbortException(ex.message);
      case "InvalidPDFException":
        return new InvalidPDFException(ex.message);
      case "PasswordException":
        return new PasswordException(ex.message, ex.code);
      case "ResponseException":
        return new ResponseException(ex.message, ex.status, ex.missing);
      case "UnknownErrorException":
        return new UnknownErrorException(ex.message, ex.details);
    }
    return new UnknownErrorException(ex.message, ex.toString());
  }
  class MessageHandler {
    #messageAC = new AbortController();
    constructor(sourceName, targetName, comObj) {
      this.sourceName = sourceName;
      this.targetName = targetName;
      this.comObj = comObj;
      this.callbackId = 1;
      this.streamId = 1;
      this.streamSinks = /* @__PURE__ */ Object.create(null);
      this.streamControllers = /* @__PURE__ */ Object.create(null);
      this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
      this.actionHandler = /* @__PURE__ */ Object.create(null);
      comObj.addEventListener("message", this.#onMessage.bind(this), {
        signal: this.#messageAC.signal
      });
    }
    #onMessage({
      data
    }) {
      if (data.targetName !== this.sourceName) {
        return;
      }
      if (data.stream) {
        this.#processStreamMessage(data);
        return;
      }
      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];
        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }
        delete this.callbackCapabilities[callbackId];
        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }
        return;
      }
      const action = this.actionHandler[data.action];
      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }
      if (data.callbackId) {
        const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
        Promise.try(action, data.data).then(function(result) {
          comObj.postMessage({
            sourceName,
            targetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }
      if (data.streamId) {
        this.#createStreamSink(data);
        return;
      }
      action(data.data);
    }
    on(actionName, handler) {
      const ah = this.actionHandler;
      if (ah[actionName]) {
        throw new Error(`There is already an actionName called "${actionName}"`);
      }
      ah[actionName] = handler;
    }
    send(actionName, data, transfers) {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        data
      }, transfers);
    }
    sendWithPromise(actionName, data, transfers) {
      const callbackId = this.callbackId++;
      const capability = Promise.withResolvers();
      this.callbackCapabilities[callbackId] = capability;
      try {
        this.comObj.postMessage({
          sourceName: this.sourceName,
          targetName: this.targetName,
          action: actionName,
          callbackId,
          data
        }, transfers);
      } catch (ex) {
        capability.reject(ex);
      }
      return capability.promise;
    }
    sendWithStream(actionName, data, queueingStrategy, transfers) {
      const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
      return new ReadableStream({
        start: (controller) => {
          const startCapability = Promise.withResolvers();
          this.streamControllers[streamId] = {
            controller,
            startCall: startCapability,
            pullCall: null,
            cancelCall: null,
            isClosed: false
          };
          comObj.postMessage({
            sourceName,
            targetName,
            action: actionName,
            streamId,
            data,
            desiredSize: controller.desiredSize
          }, transfers);
          return startCapability.promise;
        },
        pull: (controller) => {
          const pullCapability = Promise.withResolvers();
          this.streamControllers[streamId].pullCall = pullCapability;
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL,
            streamId,
            desiredSize: controller.desiredSize
          });
          return pullCapability.promise;
        },
        cancel: (reason) => {
          assert(reason instanceof Error, "cancel must have a valid reason");
          const cancelCapability = Promise.withResolvers();
          this.streamControllers[streamId].cancelCall = cancelCapability;
          this.streamControllers[streamId].isClosed = true;
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL,
            streamId,
            reason: wrapReason(reason)
          });
          return cancelCapability.promise;
        }
      }, queueingStrategy);
    }
    #createStreamSink(data) {
      const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
      const self2 = this, action = this.actionHandler[data.action];
      const streamSink = {
        enqueue(chunk, size = 1, transfers) {
          if (this.isCancelled) {
            return;
          }
          const lastDesiredSize = this.desiredSize;
          this.desiredSize -= size;
          if (lastDesiredSize > 0 && this.desiredSize <= 0) {
            this.sinkCapability = Promise.withResolvers();
            this.ready = this.sinkCapability.promise;
          }
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.ENQUEUE,
            streamId,
            chunk
          }, transfers);
        },
        close() {
          if (this.isCancelled) {
            return;
          }
          this.isCancelled = true;
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CLOSE,
            streamId
          });
          delete self2.streamSinks[streamId];
        },
        error(reason) {
          assert(reason instanceof Error, "error must have a valid reason");
          if (this.isCancelled) {
            return;
          }
          this.isCancelled = true;
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.ERROR,
            streamId,
            reason: wrapReason(reason)
          });
        },
        sinkCapability: Promise.withResolvers(),
        onPull: null,
        onCancel: null,
        isCancelled: false,
        desiredSize: data.desiredSize,
        ready: null
      };
      streamSink.sinkCapability.resolve();
      streamSink.ready = streamSink.sinkCapability.promise;
      this.streamSinks[streamId] = streamSink;
      Promise.try(action, data.data, streamSink).then(function() {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.START_COMPLETE,
          streamId,
          success: true
        });
      }, function(reason) {
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.START_COMPLETE,
          streamId,
          reason: wrapReason(reason)
        });
      });
    }
    #processStreamMessage(data) {
      const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
      const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
      switch (data.stream) {
        case StreamKind.START_COMPLETE:
          if (data.success) {
            streamController.startCall.resolve();
          } else {
            streamController.startCall.reject(wrapReason(data.reason));
          }
          break;
        case StreamKind.PULL_COMPLETE:
          if (data.success) {
            streamController.pullCall.resolve();
          } else {
            streamController.pullCall.reject(wrapReason(data.reason));
          }
          break;
        case StreamKind.PULL:
          if (!streamSink) {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.PULL_COMPLETE,
              streamId,
              success: true
            });
            break;
          }
          if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
            streamSink.sinkCapability.resolve();
          }
          streamSink.desiredSize = data.desiredSize;
          Promise.try(streamSink.onPull || onFn).then(function() {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.PULL_COMPLETE,
              streamId,
              success: true
            });
          }, function(reason) {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.PULL_COMPLETE,
              streamId,
              reason: wrapReason(reason)
            });
          });
          break;
        case StreamKind.ENQUEUE:
          assert(streamController, "enqueue should have stream controller");
          if (streamController.isClosed) {
            break;
          }
          streamController.controller.enqueue(data.chunk);
          break;
        case StreamKind.CLOSE:
          assert(streamController, "close should have stream controller");
          if (streamController.isClosed) {
            break;
          }
          streamController.isClosed = true;
          streamController.controller.close();
          this.#deleteStreamController(streamController, streamId);
          break;
        case StreamKind.ERROR:
          assert(streamController, "error should have stream controller");
          streamController.controller.error(wrapReason(data.reason));
          this.#deleteStreamController(streamController, streamId);
          break;
        case StreamKind.CANCEL_COMPLETE:
          if (data.success) {
            streamController.cancelCall.resolve();
          } else {
            streamController.cancelCall.reject(wrapReason(data.reason));
          }
          this.#deleteStreamController(streamController, streamId);
          break;
        case StreamKind.CANCEL:
          if (!streamSink) {
            break;
          }
          const dataReason = wrapReason(data.reason);
          Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.CANCEL_COMPLETE,
              streamId,
              success: true
            });
          }, function(reason) {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.CANCEL_COMPLETE,
              streamId,
              reason: wrapReason(reason)
            });
          });
          streamSink.sinkCapability.reject(dataReason);
          streamSink.isCancelled = true;
          delete this.streamSinks[streamId];
          break;
        default:
          throw new Error("Unexpected stream case");
      }
    }
    async #deleteStreamController(streamController, streamId) {
      await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);
      delete this.streamControllers[streamId];
    }
    destroy() {
      this.#messageAC?.abort();
      this.#messageAC = null;
    }
  }
  class BaseCanvasFactory {
    #enableHWA = false;
    constructor({
      enableHWA = false
    }) {
      this.#enableHWA = enableHWA;
    }
    create(width, height) {
      if (width <= 0 || height <= 0) {
        throw new Error("Invalid canvas size");
      }
      const canvas = this._createCanvas(width, height);
      return {
        canvas,
        context: canvas.getContext("2d", {
          willReadFrequently: !this.#enableHWA
        })
      };
    }
    reset(canvasAndContext, width, height) {
      if (!canvasAndContext.canvas) {
        throw new Error("Canvas is not specified");
      }
      if (width <= 0 || height <= 0) {
        throw new Error("Invalid canvas size");
      }
      canvasAndContext.canvas.width = width;
      canvasAndContext.canvas.height = height;
    }
    destroy(canvasAndContext) {
      if (!canvasAndContext.canvas) {
        throw new Error("Canvas is not specified");
      }
      canvasAndContext.canvas.width = 0;
      canvasAndContext.canvas.height = 0;
      canvasAndContext.canvas = null;
      canvasAndContext.context = null;
    }
    _createCanvas(width, height) {
      unreachable("Abstract method `_createCanvas` called.");
    }
  }
  class DOMCanvasFactory extends BaseCanvasFactory {
    constructor({
      ownerDocument = globalThis.document,
      enableHWA = false
    }) {
      super({
        enableHWA
      });
      this._document = ownerDocument;
    }
    _createCanvas(width, height) {
      const canvas = this._document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      return canvas;
    }
  }
  class BaseCMapReaderFactory {
    constructor({
      baseUrl = null,
      isCompressed = true
    }) {
      this.baseUrl = baseUrl;
      this.isCompressed = isCompressed;
    }
    async fetch({
      name
    }) {
      if (!this.baseUrl) {
        throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
      }
      if (!name) {
        throw new Error("CMap name must be specified.");
      }
      const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
      return this._fetch(url).then((cMapData) => ({
        cMapData,
        isCompressed: this.isCompressed
      })).catch((reason) => {
        throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
      });
    }
    async _fetch(url) {
      unreachable("Abstract method `_fetch` called.");
    }
  }
  class DOMCMapReaderFactory extends BaseCMapReaderFactory {
    async _fetch(url) {
      const data = await fetchData(url, this.isCompressed ? "arraybuffer" : "text");
      return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);
    }
  }
  __webpack_require__(2489);
  class BaseFilterFactory {
    addFilter(maps) {
      return "none";
    }
    addHCMFilter(fgColor, bgColor) {
      return "none";
    }
    addAlphaFilter(map) {
      return "none";
    }
    addLuminosityFilter(map) {
      return "none";
    }
    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
      return "none";
    }
    destroy(keepHCM = false) {
    }
  }
  class DOMFilterFactory extends BaseFilterFactory {
    #baseUrl;
    #_cache;
    #_defs;
    #docId;
    #document;
    #_hcmCache;
    #id = 0;
    constructor({
      docId,
      ownerDocument = globalThis.document
    }) {
      super();
      this.#docId = docId;
      this.#document = ownerDocument;
    }
    get #cache() {
      return this.#_cache ||= /* @__PURE__ */ new Map();
    }
    get #hcmCache() {
      return this.#_hcmCache ||= /* @__PURE__ */ new Map();
    }
    get #defs() {
      if (!this.#_defs) {
        const div = this.#document.createElement("div");
        const {
          style
        } = div;
        style.visibility = "hidden";
        style.contain = "strict";
        style.width = style.height = 0;
        style.position = "absolute";
        style.top = style.left = 0;
        style.zIndex = -1;
        const svg = this.#document.createElementNS(SVG_NS, "svg");
        svg.setAttribute("width", 0);
        svg.setAttribute("height", 0);
        this.#_defs = this.#document.createElementNS(SVG_NS, "defs");
        div.append(svg);
        svg.append(this.#_defs);
        this.#document.body.append(div);
      }
      return this.#_defs;
    }
    #createTables(maps) {
      if (maps.length === 1) {
        const mapR2 = maps[0];
        const buffer = new Array(256);
        for (let i = 0; i < 256; i++) {
          buffer[i] = mapR2[i] / 255;
        }
        const table = buffer.join(",");
        return [table, table, table];
      }
      const [mapR, mapG, mapB] = maps;
      const bufferR = new Array(256);
      const bufferG = new Array(256);
      const bufferB = new Array(256);
      for (let i = 0; i < 256; i++) {
        bufferR[i] = mapR[i] / 255;
        bufferG[i] = mapG[i] / 255;
        bufferB[i] = mapB[i] / 255;
      }
      return [bufferR.join(","), bufferG.join(","), bufferB.join(",")];
    }
    #createUrl(id) {
      if (this.#baseUrl === void 0) {
        this.#baseUrl = "";
        const url = this.#document.URL;
        if (url !== this.#document.baseURI) {
          if (isDataScheme(url)) {
            warn('#createUrl: ignore "data:"-URL for performance reasons.');
          } else {
            this.#baseUrl = updateUrlHash(url, "");
          }
        }
      }
      return `url(${this.#baseUrl}#${id})`;
    }
    addFilter(maps) {
      if (!maps) {
        return "none";
      }
      let value = this.#cache.get(maps);
      if (value) {
        return value;
      }
      const [tableR, tableG, tableB] = this.#createTables(maps);
      const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;
      value = this.#cache.get(key);
      if (value) {
        this.#cache.set(maps, value);
        return value;
      }
      const id = `g_${this.#docId}_transfer_map_${this.#id++}`;
      const url = this.#createUrl(id);
      this.#cache.set(maps, url);
      this.#cache.set(key, url);
      const filter = this.#createFilter(id);
      this.#addTransferMapConversion(tableR, tableG, tableB, filter);
      return url;
    }
    addHCMFilter(fgColor, bgColor) {
      const key = `${fgColor}-${bgColor}`;
      const filterName = "base";
      let info2 = this.#hcmCache.get(filterName);
      if (info2?.key === key) {
        return info2.url;
      }
      if (info2) {
        info2.filter?.remove();
        info2.key = key;
        info2.url = "none";
        info2.filter = null;
      } else {
        info2 = {
          key,
          url: "none",
          filter: null
        };
        this.#hcmCache.set(filterName, info2);
      }
      if (!fgColor || !bgColor) {
        return info2.url;
      }
      const fgRGB = this.#getRGB(fgColor);
      fgColor = Util.makeHexColor(...fgRGB);
      const bgRGB = this.#getRGB(bgColor);
      bgColor = Util.makeHexColor(...bgRGB);
      this.#defs.style.color = "";
      if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
        return info2.url;
      }
      const map = new Array(256);
      for (let i = 0; i <= 255; i++) {
        const x = i / 255;
        map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
      }
      const table = map.join(",");
      const id = `g_${this.#docId}_hcm_filter`;
      const filter = info2.filter = this.#createFilter(id);
      this.#addTransferMapConversion(table, table, table, filter);
      this.#addGrayConversion(filter);
      const getSteps = (c, n) => {
        const start = fgRGB[c] / 255;
        const end = bgRGB[c] / 255;
        const arr = new Array(n + 1);
        for (let i = 0; i <= n; i++) {
          arr[i] = start + i / n * (end - start);
        }
        return arr.join(",");
      };
      this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
      info2.url = this.#createUrl(id);
      return info2.url;
    }
    addAlphaFilter(map) {
      let value = this.#cache.get(map);
      if (value) {
        return value;
      }
      const [tableA] = this.#createTables([map]);
      const key = `alpha_${tableA}`;
      value = this.#cache.get(key);
      if (value) {
        this.#cache.set(map, value);
        return value;
      }
      const id = `g_${this.#docId}_alpha_map_${this.#id++}`;
      const url = this.#createUrl(id);
      this.#cache.set(map, url);
      this.#cache.set(key, url);
      const filter = this.#createFilter(id);
      this.#addTransferMapAlphaConversion(tableA, filter);
      return url;
    }
    addLuminosityFilter(map) {
      let value = this.#cache.get(map || "luminosity");
      if (value) {
        return value;
      }
      let tableA, key;
      if (map) {
        [tableA] = this.#createTables([map]);
        key = `luminosity_${tableA}`;
      } else {
        key = "luminosity";
      }
      value = this.#cache.get(key);
      if (value) {
        this.#cache.set(map, value);
        return value;
      }
      const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;
      const url = this.#createUrl(id);
      this.#cache.set(map, url);
      this.#cache.set(key, url);
      const filter = this.#createFilter(id);
      this.#addLuminosityConversion(filter);
      if (map) {
        this.#addTransferMapAlphaConversion(tableA, filter);
      }
      return url;
    }
    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
      const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
      let info2 = this.#hcmCache.get(filterName);
      if (info2?.key === key) {
        return info2.url;
      }
      if (info2) {
        info2.filter?.remove();
        info2.key = key;
        info2.url = "none";
        info2.filter = null;
      } else {
        info2 = {
          key,
          url: "none",
          filter: null
        };
        this.#hcmCache.set(filterName, info2);
      }
      if (!fgColor || !bgColor) {
        return info2.url;
      }
      const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));
      let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
      let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
      let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));
      if (bgGray < fgGray) {
        [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
      }
      this.#defs.style.color = "";
      const getSteps = (fg, bg, n) => {
        const arr = new Array(256);
        const step = (bgGray - fgGray) / n;
        const newStart = fg / 255;
        const newStep = (bg - fg) / (255 * n);
        let prev = 0;
        for (let i = 0; i <= n; i++) {
          const k = Math.round(fgGray + i * step);
          const value = newStart + i * newStep;
          for (let j = prev; j <= k; j++) {
            arr[j] = value;
          }
          prev = k + 1;
        }
        for (let i = prev; i < 256; i++) {
          arr[i] = arr[prev - 1];
        }
        return arr.join(",");
      };
      const id = `g_${this.#docId}_hcm_${filterName}_filter`;
      const filter = info2.filter = this.#createFilter(id);
      this.#addGrayConversion(filter);
      this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
      info2.url = this.#createUrl(id);
      return info2.url;
    }
    destroy(keepHCM = false) {
      if (keepHCM && this.#_hcmCache?.size) {
        return;
      }
      this.#_defs?.parentNode.parentNode.remove();
      this.#_defs = null;
      this.#_cache?.clear();
      this.#_cache = null;
      this.#_hcmCache?.clear();
      this.#_hcmCache = null;
      this.#id = 0;
    }
    #addLuminosityConversion(filter) {
      const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
      feColorMatrix.setAttribute("type", "matrix");
      feColorMatrix.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
      filter.append(feColorMatrix);
    }
    #addGrayConversion(filter) {
      const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
      feColorMatrix.setAttribute("type", "matrix");
      feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
      filter.append(feColorMatrix);
    }
    #createFilter(id) {
      const filter = this.#document.createElementNS(SVG_NS, "filter");
      filter.setAttribute("color-interpolation-filters", "sRGB");
      filter.setAttribute("id", id);
      this.#defs.append(filter);
      return filter;
    }
    #appendFeFunc(feComponentTransfer, func, table) {
      const feFunc = this.#document.createElementNS(SVG_NS, func);
      feFunc.setAttribute("type", "discrete");
      feFunc.setAttribute("tableValues", table);
      feComponentTransfer.append(feFunc);
    }
    #addTransferMapConversion(rTable, gTable, bTable, filter) {
      const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
      filter.append(feComponentTransfer);
      this.#appendFeFunc(feComponentTransfer, "feFuncR", rTable);
      this.#appendFeFunc(feComponentTransfer, "feFuncG", gTable);
      this.#appendFeFunc(feComponentTransfer, "feFuncB", bTable);
    }
    #addTransferMapAlphaConversion(aTable, filter) {
      const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
      filter.append(feComponentTransfer);
      this.#appendFeFunc(feComponentTransfer, "feFuncA", aTable);
    }
    #getRGB(color) {
      this.#defs.style.color = color;
      return getRGB(getComputedStyle(this.#defs).getPropertyValue("color"));
    }
  }
  class BaseStandardFontDataFactory {
    constructor({
      baseUrl = null
    }) {
      this.baseUrl = baseUrl;
    }
    async fetch({
      filename
    }) {
      if (!this.baseUrl) {
        throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
      }
      if (!filename) {
        throw new Error("Font filename must be specified.");
      }
      const url = `${this.baseUrl}${filename}`;
      return this._fetch(url).catch((reason) => {
        throw new Error(`Unable to load font data at: ${url}`);
      });
    }
    async _fetch(url) {
      unreachable("Abstract method `_fetch` called.");
    }
  }
  class DOMStandardFontDataFactory extends BaseStandardFontDataFactory {
    async _fetch(url) {
      const data = await fetchData(url, "arraybuffer");
      return new Uint8Array(data);
    }
  }
  class BaseWasmFactory {
    constructor({
      baseUrl = null
    }) {
      this.baseUrl = baseUrl;
    }
    async fetch({
      filename
    }) {
      if (!this.baseUrl) {
        throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
      }
      if (!filename) {
        throw new Error("Wasm filename must be specified.");
      }
      const url = `${this.baseUrl}${filename}`;
      return this._fetch(url).catch((reason) => {
        throw new Error(`Unable to load wasm data at: ${url}`);
      });
    }
    async _fetch(url) {
      unreachable("Abstract method `_fetch` called.");
    }
  }
  class DOMWasmFactory extends BaseWasmFactory {
    async _fetch(url) {
      const data = await fetchData(url, "arraybuffer");
      return new Uint8Array(data);
    }
  }
  if (isNodeJS) {
    let canvas;
    try {
      const require$1 = process.getBuiltinModule("module").createRequire(typeof document === "undefined" && typeof location === "undefined" ? require("url").pathToFileURL(__filename).href : typeof document === "undefined" ? location.href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("pdf-parse.umd.js", document.baseURI).href);
      try {
        canvas = require$1("@napi-rs/canvas");
      } catch (ex) {
        warn(`Cannot load "@napi-rs/canvas" package: "${ex}".`);
      }
    } catch (ex) {
      warn(`Cannot access the \`require\` function: "${ex}".`);
    }
    if (!globalThis.DOMMatrix) {
      if (canvas?.DOMMatrix) {
        globalThis.DOMMatrix = canvas.DOMMatrix;
      } else {
        warn("Cannot polyfill `DOMMatrix`, rendering may be broken.");
      }
    }
    if (!globalThis.ImageData) {
      if (canvas?.ImageData) {
        globalThis.ImageData = canvas.ImageData;
      } else {
        warn("Cannot polyfill `ImageData`, rendering may be broken.");
      }
    }
    if (!globalThis.Path2D) {
      if (canvas?.Path2D) {
        globalThis.Path2D = canvas.Path2D;
      } else {
        warn("Cannot polyfill `Path2D`, rendering may be broken.");
      }
    }
    if (!globalThis.navigator?.language) {
      globalThis.navigator = {
        language: "en-US",
        platform: "",
        userAgent: ""
      };
    }
  }
  async function node_utils_fetchData(url) {
    const fs = process.getBuiltinModule("fs");
    const data = await fs.promises.readFile(url);
    return new Uint8Array(data);
  }
  class NodeFilterFactory extends BaseFilterFactory {
  }
  class NodeCanvasFactory extends BaseCanvasFactory {
    _createCanvas(width, height) {
      const require$1 = process.getBuiltinModule("module").createRequire(typeof document === "undefined" && typeof location === "undefined" ? require("url").pathToFileURL(__filename).href : typeof document === "undefined" ? location.href : _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("pdf-parse.umd.js", document.baseURI).href);
      const canvas = require$1("@napi-rs/canvas");
      return canvas.createCanvas(width, height);
    }
  }
  class NodeCMapReaderFactory extends BaseCMapReaderFactory {
    async _fetch(url) {
      return node_utils_fetchData(url);
    }
  }
  class NodeStandardFontDataFactory extends BaseStandardFontDataFactory {
    async _fetch(url) {
      return node_utils_fetchData(url);
    }
  }
  class NodeWasmFactory extends BaseWasmFactory {
    async _fetch(url) {
      return node_utils_fetchData(url);
    }
  }
  __webpack_require__(7588);
  const FORCED_DEPENDENCY_LABEL = "__forcedDependency";
  class CanvasDependencyTracker {
    #simple = {
      __proto__: null
    };
    #incremental = {
      __proto__: null,
      transform: [],
      moveText: [],
      sameLineText: [],
      [FORCED_DEPENDENCY_LABEL]: []
    };
    #namedDependencies = /* @__PURE__ */ new Map();
    #savesStack = [];
    #markedContentStack = [];
    #baseTransformStack = [[1, 0, 0, 1, 0, 0]];
    #clipBox = [-Infinity, -Infinity, Infinity, Infinity];
    #pendingBBox = new Float64Array([Infinity, Infinity, -Infinity, -Infinity]);
    #pendingBBoxIdx = -1;
    #pendingDependencies = /* @__PURE__ */ new Set();
    #operations = /* @__PURE__ */ new Map();
    #fontBBoxTrustworthy = /* @__PURE__ */ new Map();
    #canvasWidth;
    #canvasHeight;
    constructor(canvas) {
      this.#canvasWidth = canvas.width;
      this.#canvasHeight = canvas.height;
    }
    save(opIdx) {
      this.#simple = {
        __proto__: this.#simple
      };
      this.#incremental = {
        __proto__: this.#incremental,
        transform: {
          __proto__: this.#incremental.transform
        },
        moveText: {
          __proto__: this.#incremental.moveText
        },
        sameLineText: {
          __proto__: this.#incremental.sameLineText
        },
        [FORCED_DEPENDENCY_LABEL]: {
          __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]
        }
      };
      this.#clipBox = {
        __proto__: this.#clipBox
      };
      this.#savesStack.push([opIdx, null]);
      return this;
    }
    restore(opIdx) {
      const previous = Object.getPrototypeOf(this.#simple);
      if (previous === null) {
        return this;
      }
      this.#simple = previous;
      this.#incremental = Object.getPrototypeOf(this.#incremental);
      this.#clipBox = Object.getPrototypeOf(this.#clipBox);
      const lastPair = this.#savesStack.pop();
      if (lastPair !== void 0) {
        lastPair[1] = opIdx;
      }
      return this;
    }
    recordOpenMarker(idx) {
      this.#savesStack.push([idx, null]);
      return this;
    }
    getOpenMarker() {
      if (this.#savesStack.length === 0) {
        return null;
      }
      return this.#savesStack.at(-1)[0];
    }
    recordCloseMarker(idx) {
      const lastPair = this.#savesStack.pop();
      if (lastPair !== void 0) {
        lastPair[1] = idx;
      }
      return this;
    }
    beginMarkedContent(opIdx) {
      this.#markedContentStack.push([opIdx, null]);
      return this;
    }
    endMarkedContent(opIdx) {
      const lastPair = this.#markedContentStack.pop();
      if (lastPair !== void 0) {
        lastPair[1] = opIdx;
      }
      return this;
    }
    pushBaseTransform(ctx) {
      this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));
      return this;
    }
    popBaseTransform() {
      if (this.#baseTransformStack.length > 1) {
        this.#baseTransformStack.pop();
      }
      return this;
    }
    recordSimpleData(name, idx) {
      this.#simple[name] = idx;
      return this;
    }
    recordIncrementalData(name, idx) {
      this.#incremental[name].push(idx);
      return this;
    }
    resetIncrementalData(name, idx) {
      this.#incremental[name].length = 0;
      return this;
    }
    recordNamedData(name, idx) {
      this.#namedDependencies.set(name, idx);
      return this;
    }
    recordFutureForcedDependency(name, idx) {
      this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);
      return this;
    }
    inheritSimpleDataAsFutureForcedDependencies(names) {
      for (const name of names) {
        if (name in this.#simple) {
          this.recordFutureForcedDependency(name, this.#simple[name]);
        }
      }
      return this;
    }
    inheritPendingDependenciesAsFutureForcedDependencies() {
      for (const dep of this.#pendingDependencies) {
        this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);
      }
      return this;
    }
    resetBBox(idx) {
      this.#pendingBBoxIdx = idx;
      this.#pendingBBox[0] = Infinity;
      this.#pendingBBox[1] = Infinity;
      this.#pendingBBox[2] = -Infinity;
      this.#pendingBBox[3] = -Infinity;
      return this;
    }
    get hasPendingBBox() {
      return this.#pendingBBoxIdx !== -1;
    }
    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
      const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());
      const clipBox = [Infinity, Infinity, -Infinity, -Infinity];
      Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, clipBox);
      const intersection = Util.intersect(this.#clipBox, clipBox);
      if (intersection) {
        this.#clipBox[0] = intersection[0];
        this.#clipBox[1] = intersection[1];
        this.#clipBox[2] = intersection[2];
        this.#clipBox[3] = intersection[3];
      } else {
        this.#clipBox[0] = this.#clipBox[1] = Infinity;
        this.#clipBox[2] = this.#clipBox[3] = -Infinity;
      }
      return this;
    }
    recordBBox(idx, ctx, minX, maxX, minY, maxY) {
      const clipBox = this.#clipBox;
      if (clipBox[0] === Infinity) {
        return this;
      }
      const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());
      if (clipBox[0] === -Infinity) {
        Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, this.#pendingBBox);
        return this;
      }
      const bbox = [Infinity, Infinity, -Infinity, -Infinity];
      Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, bbox);
      this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));
      this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));
      this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));
      this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));
      return this;
    }
    recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {
      const fontBBox = font.bbox;
      let isBBoxTrustworthy;
      let computedBBox;
      if (fontBBox) {
        isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);
        if (isBBoxTrustworthy !== false) {
          computedBBox = [0, 0, 0, 0];
          Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);
          if (scale !== 1 || x !== 0 || y !== 0) {
            Util.scaleMinMax([scale, 0, 0, -scale, x, y], computedBBox);
          }
          if (isBBoxTrustworthy) {
            return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
          }
        }
      }
      if (!getMeasure) {
        return this.recordFullPageBBox(idx);
      }
      const measure = getMeasure();
      if (fontBBox && computedBBox && isBBoxTrustworthy === void 0) {
        isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;
        this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);
        if (isBBoxTrustworthy) {
          return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
        }
      }
      return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);
    }
    recordFullPageBBox(idx) {
      this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);
      this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);
      this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);
      this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);
      return this;
    }
    getSimpleIndex(dependencyName) {
      return this.#simple[dependencyName];
    }
    recordDependencies(idx, dependencyNames) {
      const pendingDependencies = this.#pendingDependencies;
      const simple = this.#simple;
      const incremental = this.#incremental;
      for (const name of dependencyNames) {
        if (name in this.#simple) {
          pendingDependencies.add(simple[name]);
        } else if (name in incremental) {
          incremental[name].forEach(pendingDependencies.add, pendingDependencies);
        }
      }
      return this;
    }
    copyDependenciesFromIncrementalOperation(idx, name) {
      const operations = this.#operations;
      const pendingDependencies = this.#pendingDependencies;
      for (const depIdx of this.#incremental[name]) {
        operations.get(depIdx).dependencies.forEach(pendingDependencies.add, pendingDependencies.add(depIdx));
      }
      return this;
    }
    recordNamedDependency(idx, name) {
      if (this.#namedDependencies.has(name)) {
        this.#pendingDependencies.add(this.#namedDependencies.get(name));
      }
      return this;
    }
    recordOperation(idx, preserveBbox = false) {
      this.recordDependencies(idx, [FORCED_DEPENDENCY_LABEL]);
      const dependencies = new Set(this.#pendingDependencies);
      const pairs = this.#savesStack.concat(this.#markedContentStack);
      const bbox = this.#pendingBBoxIdx === idx ? {
        minX: this.#pendingBBox[0],
        minY: this.#pendingBBox[1],
        maxX: this.#pendingBBox[2],
        maxY: this.#pendingBBox[3]
      } : null;
      this.#operations.set(idx, {
        bbox,
        pairs,
        dependencies
      });
      if (!preserveBbox) {
        this.#pendingBBoxIdx = -1;
      }
      this.#pendingDependencies.clear();
      return this;
    }
    bboxToClipBoxDropOperation(idx) {
      if (this.#pendingBBoxIdx !== -1) {
        this.#pendingBBoxIdx = -1;
        this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);
        this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);
        this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);
        this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);
      }
      this.#pendingDependencies.clear();
      return this;
    }
    _takePendingDependencies() {
      const pendingDependencies = this.#pendingDependencies;
      this.#pendingDependencies = /* @__PURE__ */ new Set();
      return pendingDependencies;
    }
    _extractOperation(idx) {
      const operation = this.#operations.get(idx);
      this.#operations.delete(idx);
      return operation;
    }
    _pushPendingDependencies(dependencies) {
      for (const dep of dependencies) {
        this.#pendingDependencies.add(dep);
      }
    }
    take() {
      this.#fontBBoxTrustworthy.clear();
      return Array.from(this.#operations, ([idx, {
        bbox,
        pairs,
        dependencies
      }]) => {
        pairs.forEach((pair) => pair.forEach(dependencies.add, dependencies));
        dependencies.delete(idx);
        return {
          minX: (bbox?.minX ?? 0) / this.#canvasWidth,
          maxX: (bbox?.maxX ?? this.#canvasWidth) / this.#canvasWidth,
          minY: (bbox?.minY ?? 0) / this.#canvasHeight,
          maxY: (bbox?.maxY ?? this.#canvasHeight) / this.#canvasHeight,
          dependencies: Array.from(dependencies).sort((a, b) => a - b),
          idx
        };
      });
    }
  }
  class CanvasNestedDependencyTracker {
    #dependencyTracker;
    #opIdx;
    #nestingLevel = 0;
    #outerDependencies;
    #savesLevel = 0;
    constructor(dependencyTracker, opIdx) {
      if (dependencyTracker instanceof CanvasNestedDependencyTracker) {
        return dependencyTracker;
      }
      this.#dependencyTracker = dependencyTracker;
      this.#outerDependencies = dependencyTracker._takePendingDependencies();
      this.#opIdx = opIdx;
    }
    save(opIdx) {
      this.#savesLevel++;
      this.#dependencyTracker.save(this.#opIdx);
      return this;
    }
    restore(opIdx) {
      if (this.#savesLevel > 0) {
        this.#dependencyTracker.restore(this.#opIdx);
        this.#savesLevel--;
      }
      return this;
    }
    recordOpenMarker(idx) {
      this.#nestingLevel++;
      return this;
    }
    getOpenMarker() {
      return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();
    }
    recordCloseMarker(idx) {
      this.#nestingLevel--;
      return this;
    }
    beginMarkedContent(opIdx) {
      return this;
    }
    endMarkedContent(opIdx) {
      return this;
    }
    pushBaseTransform(ctx) {
      this.#dependencyTracker.pushBaseTransform(ctx);
      return this;
    }
    popBaseTransform() {
      this.#dependencyTracker.popBaseTransform();
      return this;
    }
    recordSimpleData(name, idx) {
      this.#dependencyTracker.recordSimpleData(name, this.#opIdx);
      return this;
    }
    recordIncrementalData(name, idx) {
      this.#dependencyTracker.recordIncrementalData(name, this.#opIdx);
      return this;
    }
    resetIncrementalData(name, idx) {
      this.#dependencyTracker.resetIncrementalData(name, this.#opIdx);
      return this;
    }
    recordNamedData(name, idx) {
      return this;
    }
    recordFutureForcedDependency(name, idx) {
      this.#dependencyTracker.recordFutureForcedDependency(name, this.#opIdx);
      return this;
    }
    inheritSimpleDataAsFutureForcedDependencies(names) {
      this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);
      return this;
    }
    inheritPendingDependenciesAsFutureForcedDependencies() {
      this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();
      return this;
    }
    resetBBox(idx) {
      if (!this.#dependencyTracker.hasPendingBBox) {
        this.#dependencyTracker.resetBBox(this.#opIdx);
      }
      return this;
    }
    get hasPendingBBox() {
      return this.#dependencyTracker.hasPendingBBox;
    }
    recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
      this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);
      return this;
    }
    recordBBox(idx, ctx, minX, maxX, minY, maxY) {
      this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);
      return this;
    }
    recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {
      this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x, y, getMeasure);
      return this;
    }
    recordFullPageBBox(idx) {
      this.#dependencyTracker.recordFullPageBBox(this.#opIdx);
      return this;
    }
    getSimpleIndex(dependencyName) {
      return this.#dependencyTracker.getSimpleIndex(dependencyName);
    }
    recordDependencies(idx, dependencyNames) {
      this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);
      return this;
    }
    copyDependenciesFromIncrementalOperation(idx, name) {
      this.#dependencyTracker.copyDependenciesFromIncrementalOperation(this.#opIdx, name);
      return this;
    }
    recordNamedDependency(idx, name) {
      this.#dependencyTracker.recordNamedDependency(this.#opIdx, name);
      return this;
    }
    recordOperation(idx) {
      this.#dependencyTracker.recordOperation(this.#opIdx, true);
      const operation = this.#dependencyTracker._extractOperation(this.#opIdx);
      for (const depIdx of operation.dependencies) {
        this.#outerDependencies.add(depIdx);
      }
      this.#outerDependencies.delete(this.#opIdx);
      this.#outerDependencies.delete(null);
      return this;
    }
    bboxToClipBoxDropOperation(idx) {
      this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx);
      return this;
    }
    recordNestedDependencies() {
      this.#dependencyTracker._pushPendingDependencies(this.#outerDependencies);
    }
    take() {
      throw new Error("Unreachable");
    }
  }
  const Dependencies = {
    stroke: ["path", "transform", "filter", "strokeColor", "strokeAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "dash"],
    fill: ["path", "transform", "filter", "fillColor", "fillAlpha", "globalCompositeOperation", "SMask"],
    imageXObject: ["transform", "SMask", "filter", "fillAlpha", "strokeAlpha", "globalCompositeOperation"],
    rawFillPath: ["filter", "fillColor", "fillAlpha"],
    showText: ["transform", "leading", "charSpacing", "wordSpacing", "hScale", "textRise", "moveText", "textMatrix", "font", "filter", "fillColor", "textRenderingMode", "SMask", "fillAlpha", "strokeAlpha", "globalCompositeOperation"],
    transform: ["transform"],
    transformAndFill: ["transform", "fillColor"]
  };
  const PathType = {
    FILL: "Fill",
    STROKE: "Stroke",
    SHADING: "Shading"
  };
  function applyBoundingBox(ctx, bbox) {
    if (!bbox) {
      return;
    }
    const width = bbox[2] - bbox[0];
    const height = bbox[3] - bbox[1];
    const region = new Path2D();
    region.rect(bbox[0], bbox[1], width, height);
    ctx.clip(region);
  }
  class BaseShadingPattern {
    isModifyingCurrentTransform() {
      return false;
    }
    getPattern() {
      unreachable("Abstract method `getPattern` called.");
    }
  }
  class RadialAxialShadingPattern extends BaseShadingPattern {
    constructor(IR) {
      super();
      this._type = IR[1];
      this._bbox = IR[2];
      this._colorStops = IR[3];
      this._p0 = IR[4];
      this._p1 = IR[5];
      this._r0 = IR[6];
      this._r1 = IR[7];
      this.matrix = null;
    }
    _createGradient(ctx) {
      let grad;
      if (this._type === "axial") {
        grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
      } else if (this._type === "radial") {
        grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
      }
      for (const colorStop of this._colorStops) {
        grad.addColorStop(colorStop[0], colorStop[1]);
      }
      return grad;
    }
    getPattern(ctx, owner, inverse, pathType) {
      let pattern;
      if (pathType === PathType.STROKE || pathType === PathType.FILL) {
        const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];
        const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
        const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
        const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height);
        const tmpCtx = tmpCanvas.context;
        tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
        tmpCtx.beginPath();
        tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
        tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
        inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
        tmpCtx.transform(...owner.baseTransform);
        if (this.matrix) {
          tmpCtx.transform(...this.matrix);
        }
        applyBoundingBox(tmpCtx, this._bbox);
        tmpCtx.fillStyle = this._createGradient(tmpCtx);
        tmpCtx.fill();
        pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
        const domMatrix = new DOMMatrix(inverse);
        pattern.setTransform(domMatrix);
      } else {
        applyBoundingBox(ctx, this._bbox);
        pattern = this._createGradient(ctx);
      }
      return pattern;
    }
  }
  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
    const coords = context.coords, colors = context.colors;
    const bytes = data.data, rowSize = data.width * 4;
    let tmp;
    if (coords[p1 + 1] > coords[p2 + 1]) {
      tmp = p1;
      p1 = p2;
      p2 = tmp;
      tmp = c1;
      c1 = c2;
      c2 = tmp;
    }
    if (coords[p2 + 1] > coords[p3 + 1]) {
      tmp = p2;
      p2 = p3;
      p3 = tmp;
      tmp = c2;
      c2 = c3;
      c3 = tmp;
    }
    if (coords[p1 + 1] > coords[p2 + 1]) {
      tmp = p1;
      p1 = p2;
      p2 = tmp;
      tmp = c1;
      c1 = c2;
      c2 = tmp;
    }
    const x1 = (coords[p1] + context.offsetX) * context.scaleX;
    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
    const x2 = (coords[p2] + context.offsetX) * context.scaleX;
    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
    const x3 = (coords[p3] + context.offsetX) * context.scaleX;
    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
    if (y1 >= y3) {
      return;
    }
    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
    const minY = Math.round(y1), maxY = Math.round(y3);
    let xa, car, cag, cab;
    let xb, cbr, cbg, cbb;
    for (let y = minY; y <= maxY; y++) {
      if (y < y2) {
        const k2 = y < y1 ? 0 : (y1 - y) / (y1 - y2);
        xa = x1 - (x1 - x2) * k2;
        car = c1r - (c1r - c2r) * k2;
        cag = c1g - (c1g - c2g) * k2;
        cab = c1b - (c1b - c2b) * k2;
      } else {
        let k2;
        if (y > y3) {
          k2 = 1;
        } else if (y2 === y3) {
          k2 = 0;
        } else {
          k2 = (y2 - y) / (y2 - y3);
        }
        xa = x2 - (x2 - x3) * k2;
        car = c2r - (c2r - c3r) * k2;
        cag = c2g - (c2g - c3g) * k2;
        cab = c2b - (c2b - c3b) * k2;
      }
      let k;
      if (y < y1) {
        k = 0;
      } else if (y > y3) {
        k = 1;
      } else {
        k = (y1 - y) / (y1 - y3);
      }
      xb = x1 - (x1 - x3) * k;
      cbr = c1r - (c1r - c3r) * k;
      cbg = c1g - (c1g - c3g) * k;
      cbb = c1b - (c1b - c3b) * k;
      const x1_ = Math.round(Math.min(xa, xb));
      const x2_ = Math.round(Math.max(xa, xb));
      let j = rowSize * y + x1_ * 4;
      for (let x = x1_; x <= x2_; x++) {
        k = (xa - x) / (xa - xb);
        if (k < 0) {
          k = 0;
        } else if (k > 1) {
          k = 1;
        }
        bytes[j++] = car - (car - cbr) * k | 0;
        bytes[j++] = cag - (cag - cbg) * k | 0;
        bytes[j++] = cab - (cab - cbb) * k | 0;
        bytes[j++] = 255;
      }
    }
  }
  function drawFigure(data, figure, context) {
    const ps = figure.coords;
    const cs = figure.colors;
    let i, ii;
    switch (figure.type) {
      case "lattice":
        const verticesPerRow = figure.verticesPerRow;
        const rows = Math.floor(ps.length / verticesPerRow) - 1;
        const cols = verticesPerRow - 1;
        for (i = 0; i < rows; i++) {
          let q = i * verticesPerRow;
          for (let j = 0; j < cols; j++, q++) {
            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
          }
        }
        break;
      case "triangles":
        for (i = 0, ii = ps.length; i < ii; i += 3) {
          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
        }
        break;
      default:
        throw new Error("illegal figure");
    }
  }
  class MeshShadingPattern extends BaseShadingPattern {
    constructor(IR) {
      super();
      this._coords = IR[2];
      this._colors = IR[3];
      this._figures = IR[4];
      this._bounds = IR[5];
      this._bbox = IR[6];
      this._background = IR[7];
      this.matrix = null;
    }
    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
      const EXPECTED_SCALE = 1.1;
      const MAX_PATTERN_SIZE = 3e3;
      const BORDER_SIZE = 2;
      const offsetX = Math.floor(this._bounds[0]);
      const offsetY = Math.floor(this._bounds[1]);
      const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
      const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
      const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
      const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
      const scaleX = boundsWidth / width;
      const scaleY = boundsHeight / height;
      const context = {
        coords: this._coords,
        colors: this._colors,
        offsetX: -offsetX,
        offsetY: -offsetY,
        scaleX: 1 / scaleX,
        scaleY: 1 / scaleY
      };
      const paddedWidth = width + BORDER_SIZE * 2;
      const paddedHeight = height + BORDER_SIZE * 2;
      const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight);
      const tmpCtx = tmpCanvas.context;
      const data = tmpCtx.createImageData(width, height);
      if (backgroundColor) {
        const bytes = data.data;
        for (let i = 0, ii = bytes.length; i < ii; i += 4) {
          bytes[i] = backgroundColor[0];
          bytes[i + 1] = backgroundColor[1];
          bytes[i + 2] = backgroundColor[2];
          bytes[i + 3] = 255;
        }
      }
      for (const figure of this._figures) {
        drawFigure(data, figure, context);
      }
      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
      const canvas = tmpCanvas.canvas;
      return {
        canvas,
        offsetX: offsetX - BORDER_SIZE * scaleX,
        offsetY: offsetY - BORDER_SIZE * scaleY,
        scaleX,
        scaleY
      };
    }
    isModifyingCurrentTransform() {
      return true;
    }
    getPattern(ctx, owner, inverse, pathType) {
      applyBoundingBox(ctx, this._bbox);
      const scale = new Float32Array(2);
      if (pathType === PathType.SHADING) {
        Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);
      } else if (this.matrix) {
        Util.singularValueDecompose2dScale(this.matrix, scale);
        const [matrixScaleX, matrixScaleY] = scale;
        Util.singularValueDecompose2dScale(owner.baseTransform, scale);
        scale[0] *= matrixScaleX;
        scale[1] *= matrixScaleY;
      } else {
        Util.singularValueDecompose2dScale(owner.baseTransform, scale);
      }
      const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
      if (pathType !== PathType.SHADING) {
        ctx.setTransform(...owner.baseTransform);
        if (this.matrix) {
          ctx.transform(...this.matrix);
        }
      }
      ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
      ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
      return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
    }
  }
  class DummyShadingPattern extends BaseShadingPattern {
    getPattern() {
      return "hotpink";
    }
  }
  function getShadingPattern(IR) {
    switch (IR[0]) {
      case "RadialAxial":
        return new RadialAxialShadingPattern(IR);
      case "Mesh":
        return new MeshShadingPattern(IR);
      case "Dummy":
        return new DummyShadingPattern();
    }
    throw new Error(`Unknown IR type: ${IR[0]}`);
  }
  const PaintType = {
    COLORED: 1,
    UNCOLORED: 2
  };
  class TilingPattern {
    static MAX_PATTERN_SIZE = 3e3;
    constructor(IR, ctx, canvasGraphicsFactory, baseTransform) {
      this.color = IR[1];
      this.operatorList = IR[2];
      this.matrix = IR[3];
      this.bbox = IR[4];
      this.xstep = IR[5];
      this.ystep = IR[6];
      this.paintType = IR[7];
      this.tilingType = IR[8];
      this.ctx = ctx;
      this.canvasGraphicsFactory = canvasGraphicsFactory;
      this.baseTransform = baseTransform;
    }
    createPatternCanvas(owner) {
      const {
        bbox,
        operatorList,
        paintType,
        tilingType,
        color,
        canvasGraphicsFactory
      } = this;
      let {
        xstep,
        ystep
      } = this;
      xstep = Math.abs(xstep);
      ystep = Math.abs(ystep);
      info("TilingType: " + tilingType);
      const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
      const width = x1 - x0;
      const height = y1 - y0;
      const scale = new Float32Array(2);
      Util.singularValueDecompose2dScale(this.matrix, scale);
      const [matrixScaleX, matrixScaleY] = scale;
      Util.singularValueDecompose2dScale(this.baseTransform, scale);
      const combinedScaleX = matrixScaleX * scale[0];
      const combinedScaleY = matrixScaleY * scale[1];
      let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;
      const xScaledStep = Math.ceil(xstep * combinedScaleX);
      const yScaledStep = Math.ceil(ystep * combinedScaleY);
      const xScaledWidth = Math.ceil(width * combinedScaleX);
      const yScaledHeight = Math.ceil(height * combinedScaleY);
      if (xScaledStep >= xScaledWidth) {
        canvasWidth = xstep;
      } else {
        redrawHorizontally = true;
      }
      if (yScaledStep >= yScaledHeight) {
        canvasHeight = ystep;
      } else {
        redrawVertically = true;
      }
      const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
      const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size);
      const tmpCtx = tmpCanvas.context;
      const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
      graphics.groupLevel = owner.groupLevel;
      this.setFillAndStrokeStyleToContext(graphics, paintType, color);
      tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);
      graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);
      tmpCtx.save();
      graphics.dependencyTracker?.save();
      this.clipBbox(graphics, x0, y0, x1, y1);
      graphics.baseTransform = getCurrentTransform(graphics.ctx);
      graphics.executeOperatorList(operatorList);
      graphics.endDrawing();
      graphics.dependencyTracker?.restore().recordNestedDependencies?.();
      tmpCtx.restore();
      if (redrawHorizontally || redrawVertically) {
        const image = tmpCanvas.canvas;
        if (redrawHorizontally) {
          canvasWidth = xstep;
        }
        if (redrawVertically) {
          canvasHeight = ystep;
        }
        const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
        const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
        const xSize = dimx2.size;
        const ySize = dimy2.size;
        const tmpCanvas2 = owner.cachedCanvases.getCanvas("pattern-workaround", xSize, ySize);
        const tmpCtx2 = tmpCanvas2.context;
        const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;
        const jj = redrawVertically ? Math.floor(height / ystep) : 0;
        for (let i = 0; i <= ii; i++) {
          for (let j = 0; j <= jj; j++) {
            tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);
          }
        }
        return {
          canvas: tmpCanvas2.canvas,
          scaleX: dimx2.scale,
          scaleY: dimy2.scale,
          offsetX: x0,
          offsetY: y0
        };
      }
      return {
        canvas: tmpCanvas.canvas,
        scaleX: dimx.scale,
        scaleY: dimy.scale,
        offsetX: x0,
        offsetY: y0
      };
    }
    getSizeAndScale(step, realOutputSize, scale) {
      const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
      let size = Math.ceil(step * scale);
      if (size >= maxSize) {
        size = maxSize;
      } else {
        scale = size / step;
      }
      return {
        scale,
        size
      };
    }
    clipBbox(graphics, x0, y0, x1, y1) {
      const bboxWidth = x1 - x0;
      const bboxHeight = y1 - y0;
      graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
      Util.axialAlignedBoundingBox([x0, y0, x1, y1], getCurrentTransform(graphics.ctx), graphics.current.minMax);
      graphics.clip();
      graphics.endPath();
    }
    setFillAndStrokeStyleToContext(graphics, paintType, color) {
      const context = graphics.ctx, current = graphics.current;
      switch (paintType) {
        case PaintType.COLORED:
          const {
            fillStyle,
            strokeStyle
          } = this.ctx;
          context.fillStyle = current.fillColor = fillStyle;
          context.strokeStyle = current.strokeColor = strokeStyle;
          break;
        case PaintType.UNCOLORED:
          context.fillStyle = context.strokeStyle = color;
          current.fillColor = current.strokeColor = color;
          break;
        default:
          throw new FormatError(`Unsupported paint type: ${paintType}`);
      }
    }
    isModifyingCurrentTransform() {
      return false;
    }
    getPattern(ctx, owner, inverse, pathType) {
      let matrix = inverse;
      if (pathType !== PathType.SHADING) {
        matrix = Util.transform(matrix, owner.baseTransform);
        if (this.matrix) {
          matrix = Util.transform(matrix, this.matrix);
        }
      }
      const temporaryPatternCanvas = this.createPatternCanvas(owner);
      let domMatrix = new DOMMatrix(matrix);
      domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
      domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
      const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
      pattern.setTransform(domMatrix);
      return pattern;
    }
  }
  function convertBlackAndWhiteToRGBA({
    src,
    srcPos = 0,
    dest,
    width,
    height,
    nonBlackColor = 4294967295,
    inverseDecode = false
  }) {
    const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
    const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
    const widthInSource = width >> 3;
    const widthRemainder = width & 7;
    const srcLength = src.length;
    dest = new Uint32Array(dest.buffer);
    let destPos = 0;
    for (let i = 0; i < height; i++) {
      for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
        const elem2 = srcPos < srcLength ? src[srcPos] : 255;
        dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
        dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
        dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
        dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
        dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
        dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
        dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
        dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
      }
      if (widthRemainder === 0) {
        continue;
      }
      const elem = srcPos < srcLength ? src[srcPos++] : 255;
      for (let j = 0; j < widthRemainder; j++) {
        dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
      }
    }
    return {
      srcPos,
      destPos
    };
  }
  const MIN_FONT_SIZE = 16;
  const MAX_FONT_SIZE = 100;
  const EXECUTION_TIME = 15;
  const EXECUTION_STEPS = 10;
  const FULL_CHUNK_HEIGHT = 16;
  const SCALE_MATRIX = new DOMMatrix();
  const XY = new Float32Array(2);
  const MIN_MAX_INIT = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
  function mirrorContextOperations(ctx, destCtx) {
    if (ctx._removeMirroring) {
      throw new Error("Context is already forwarding operations.");
    }
    ctx.__originalSave = ctx.save;
    ctx.__originalRestore = ctx.restore;
    ctx.__originalRotate = ctx.rotate;
    ctx.__originalScale = ctx.scale;
    ctx.__originalTranslate = ctx.translate;
    ctx.__originalTransform = ctx.transform;
    ctx.__originalSetTransform = ctx.setTransform;
    ctx.__originalResetTransform = ctx.resetTransform;
    ctx.__originalClip = ctx.clip;
    ctx.__originalMoveTo = ctx.moveTo;
    ctx.__originalLineTo = ctx.lineTo;
    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
    ctx.__originalRect = ctx.rect;
    ctx.__originalClosePath = ctx.closePath;
    ctx.__originalBeginPath = ctx.beginPath;
    ctx._removeMirroring = () => {
      ctx.save = ctx.__originalSave;
      ctx.restore = ctx.__originalRestore;
      ctx.rotate = ctx.__originalRotate;
      ctx.scale = ctx.__originalScale;
      ctx.translate = ctx.__originalTranslate;
      ctx.transform = ctx.__originalTransform;
      ctx.setTransform = ctx.__originalSetTransform;
      ctx.resetTransform = ctx.__originalResetTransform;
      ctx.clip = ctx.__originalClip;
      ctx.moveTo = ctx.__originalMoveTo;
      ctx.lineTo = ctx.__originalLineTo;
      ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
      ctx.rect = ctx.__originalRect;
      ctx.closePath = ctx.__originalClosePath;
      ctx.beginPath = ctx.__originalBeginPath;
      delete ctx._removeMirroring;
    };
    ctx.save = function() {
      destCtx.save();
      this.__originalSave();
    };
    ctx.restore = function() {
      destCtx.restore();
      this.__originalRestore();
    };
    ctx.translate = function(x, y) {
      destCtx.translate(x, y);
      this.__originalTranslate(x, y);
    };
    ctx.scale = function(x, y) {
      destCtx.scale(x, y);
      this.__originalScale(x, y);
    };
    ctx.transform = function(a, b, c, d, e, f) {
      destCtx.transform(a, b, c, d, e, f);
      this.__originalTransform(a, b, c, d, e, f);
    };
    ctx.setTransform = function(a, b, c, d, e, f) {
      destCtx.setTransform(a, b, c, d, e, f);
      this.__originalSetTransform(a, b, c, d, e, f);
    };
    ctx.resetTransform = function() {
      destCtx.resetTransform();
      this.__originalResetTransform();
    };
    ctx.rotate = function(angle) {
      destCtx.rotate(angle);
      this.__originalRotate(angle);
    };
    ctx.clip = function(rule) {
      destCtx.clip(rule);
      this.__originalClip(rule);
    };
    ctx.moveTo = function(x, y) {
      destCtx.moveTo(x, y);
      this.__originalMoveTo(x, y);
    };
    ctx.lineTo = function(x, y) {
      destCtx.lineTo(x, y);
      this.__originalLineTo(x, y);
    };
    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
      destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    };
    ctx.rect = function(x, y, width, height) {
      destCtx.rect(x, y, width, height);
      this.__originalRect(x, y, width, height);
    };
    ctx.closePath = function() {
      destCtx.closePath();
      this.__originalClosePath();
    };
    ctx.beginPath = function() {
      destCtx.beginPath();
      this.__originalBeginPath();
    };
  }
  class CachedCanvases {
    constructor(canvasFactory) {
      this.canvasFactory = canvasFactory;
      this.cache = /* @__PURE__ */ Object.create(null);
    }
    getCanvas(id, width, height) {
      let canvasEntry;
      if (this.cache[id] !== void 0) {
        canvasEntry = this.cache[id];
        this.canvasFactory.reset(canvasEntry, width, height);
      } else {
        canvasEntry = this.canvasFactory.create(width, height);
        this.cache[id] = canvasEntry;
      }
      return canvasEntry;
    }
    delete(id) {
      delete this.cache[id];
    }
    clear() {
      for (const id in this.cache) {
        const canvasEntry = this.cache[id];
        this.canvasFactory.destroy(canvasEntry);
        delete this.cache[id];
      }
    }
  }
  function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
    if (b === 0 && c === 0) {
      const tlX = destX * a + tx;
      const rTlX = Math.round(tlX);
      const tlY = destY * d + ty;
      const rTlY = Math.round(tlY);
      const brX = (destX + destW) * a + tx;
      const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
      const brY = (destY + destH) * d + ty;
      const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
      ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
      ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
      ctx.setTransform(a, b, c, d, tx, ty);
      return [rWidth, rHeight];
    }
    if (a === 0 && d === 0) {
      const tlX = destY * c + tx;
      const rTlX = Math.round(tlX);
      const tlY = destX * b + ty;
      const rTlY = Math.round(tlY);
      const brX = (destY + destH) * c + tx;
      const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
      const brY = (destX + destW) * b + ty;
      const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
      ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
      ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
      ctx.setTransform(a, b, c, d, tx, ty);
      return [rHeight, rWidth];
    }
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
    const scaleX = Math.hypot(a, b);
    const scaleY = Math.hypot(c, d);
    return [scaleX * destW, scaleY * destH];
  }
  class CanvasExtraState {
    alphaIsShape = false;
    fontSize = 0;
    fontSizeScale = 1;
    textMatrix = null;
    textMatrixScale = 1;
    fontMatrix = FONT_IDENTITY_MATRIX;
    leading = 0;
    x = 0;
    y = 0;
    lineX = 0;
    lineY = 0;
    charSpacing = 0;
    wordSpacing = 0;
    textHScale = 1;
    textRenderingMode = TextRenderingMode.FILL;
    textRise = 0;
    fillColor = "#000000";
    strokeColor = "#000000";
    patternFill = false;
    patternStroke = false;
    fillAlpha = 1;
    strokeAlpha = 1;
    lineWidth = 1;
    activeSMask = null;
    transferMaps = "none";
    constructor(width, height, preInit) {
      preInit?.(this);
      this.clipBox = new Float32Array([0, 0, width, height]);
      this.minMax = MIN_MAX_INIT.slice();
    }
    clone() {
      const clone = Object.create(this);
      clone.clipBox = this.clipBox.slice();
      clone.minMax = this.minMax.slice();
      return clone;
    }
    getPathBoundingBox(pathType = PathType.FILL, transform = null) {
      const box = this.minMax.slice();
      if (pathType === PathType.STROKE) {
        if (!transform) {
          unreachable("Stroke bounding box must include transform.");
        }
        Util.singularValueDecompose2dScale(transform, XY);
        const xStrokePad = XY[0] * this.lineWidth / 2;
        const yStrokePad = XY[1] * this.lineWidth / 2;
        box[0] -= xStrokePad;
        box[1] -= yStrokePad;
        box[2] += xStrokePad;
        box[3] += yStrokePad;
      }
      return box;
    }
    updateClipFromPath() {
      const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
      this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
    }
    isEmptyClip() {
      return this.minMax[0] === Infinity;
    }
    startNewPathAndClipBox(box) {
      this.clipBox.set(box, 0);
      this.minMax.set(MIN_MAX_INIT, 0);
    }
    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
      return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
    }
  }
  function putBinaryImageData(ctx, imgData) {
    if (imgData instanceof ImageData) {
      ctx.putImageData(imgData, 0, 0);
      return;
    }
    const height = imgData.height, width = imgData.width;
    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    let srcPos = 0, destPos;
    const src = imgData.data;
    const dest = chunkImgData.data;
    let i, j, thisChunkHeight, elemsInThisChunk;
    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {
      const srcLength = src.byteLength;
      const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
      const dest32DataLength = dest32.length;
      const fullSrcDiff = width + 7 >> 3;
      const white = 4294967295;
      const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
      for (i = 0; i < totalChunks; i++) {
        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
        destPos = 0;
        for (j = 0; j < thisChunkHeight; j++) {
          const srcDiff = srcLength - srcPos;
          let k = 0;
          const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
          const kEndUnrolled = kEnd & -8;
          let mask = 0;
          let srcByte = 0;
          for (; k < kEndUnrolled; k += 8) {
            srcByte = src[srcPos++];
            dest32[destPos++] = srcByte & 128 ? white : black;
            dest32[destPos++] = srcByte & 64 ? white : black;
            dest32[destPos++] = srcByte & 32 ? white : black;
            dest32[destPos++] = srcByte & 16 ? white : black;
            dest32[destPos++] = srcByte & 8 ? white : black;
            dest32[destPos++] = srcByte & 4 ? white : black;
            dest32[destPos++] = srcByte & 2 ? white : black;
            dest32[destPos++] = srcByte & 1 ? white : black;
          }
          for (; k < kEnd; k++) {
            if (mask === 0) {
              srcByte = src[srcPos++];
              mask = 128;
            }
            dest32[destPos++] = srcByte & mask ? white : black;
            mask >>= 1;
          }
        }
        while (destPos < dest32DataLength) {
          dest32[destPos++] = 0;
        }
        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
      }
    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {
      j = 0;
      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
      for (i = 0; i < fullChunks; i++) {
        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
        srcPos += elemsInThisChunk;
        ctx.putImageData(chunkImgData, 0, j);
        j += FULL_CHUNK_HEIGHT;
      }
      if (i < totalChunks) {
        elemsInThisChunk = width * partialChunkHeight * 4;
        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
        ctx.putImageData(chunkImgData, 0, j);
      }
    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {
      thisChunkHeight = FULL_CHUNK_HEIGHT;
      elemsInThisChunk = width * thisChunkHeight;
      for (i = 0; i < totalChunks; i++) {
        if (i >= fullChunks) {
          thisChunkHeight = partialChunkHeight;
          elemsInThisChunk = width * thisChunkHeight;
        }
        destPos = 0;
        for (j = elemsInThisChunk; j--; ) {
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = src[srcPos++];
          dest[destPos++] = 255;
        }
        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
      }
    } else {
      throw new Error(`bad image kind: ${imgData.kind}`);
    }
  }
  function putBinaryImageMask(ctx, imgData) {
    if (imgData.bitmap) {
      ctx.drawImage(imgData.bitmap, 0, 0);
      return;
    }
    const height = imgData.height, width = imgData.width;
    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
    let srcPos = 0;
    const src = imgData.data;
    const dest = chunkImgData.data;
    for (let i = 0; i < totalChunks; i++) {
      const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      ({
        srcPos
      } = convertBlackAndWhiteToRGBA({
        src,
        srcPos,
        dest,
        width,
        height: thisChunkHeight,
        nonBlackColor: 0
      }));
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  }
  function copyCtxState(sourceCtx, destCtx) {
    const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
    for (const property of properties) {
      if (sourceCtx[property] !== void 0) {
        destCtx[property] = sourceCtx[property];
      }
    }
    if (sourceCtx.setLineDash !== void 0) {
      destCtx.setLineDash(sourceCtx.getLineDash());
      destCtx.lineDashOffset = sourceCtx.lineDashOffset;
    }
  }
  function resetCtxToDefault(ctx) {
    ctx.strokeStyle = ctx.fillStyle = "#000000";
    ctx.fillRule = "nonzero";
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 10;
    ctx.globalCompositeOperation = "source-over";
    ctx.font = "10px sans-serif";
    if (ctx.setLineDash !== void 0) {
      ctx.setLineDash([]);
      ctx.lineDashOffset = 0;
    }
    const {
      filter
    } = ctx;
    if (filter !== "none" && filter !== "") {
      ctx.filter = "none";
    }
  }
  function getImageSmoothingEnabled(transform, interpolate) {
    if (interpolate) {
      return true;
    }
    Util.singularValueDecompose2dScale(transform, XY);
    const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
    return XY[0] <= actualScale && XY[1] <= actualScale;
  }
  const LINE_CAP_STYLES = ["butt", "round", "square"];
  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
  const NORMAL_CLIP = {};
  const EO_CLIP = {};
  class CanvasGraphics {
    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
      optionalContentConfig,
      markedContentStack = null
    }, annotationCanvasMap, pageColors, dependencyTracker) {
      this.ctx = canvasCtx;
      this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
      this.stateStack = [];
      this.pendingClip = null;
      this.pendingEOFill = false;
      this.res = null;
      this.xobjs = null;
      this.commonObjs = commonObjs;
      this.objs = objs;
      this.canvasFactory = canvasFactory;
      this.filterFactory = filterFactory;
      this.groupStack = [];
      this.baseTransform = null;
      this.baseTransformStack = [];
      this.groupLevel = 0;
      this.smaskStack = [];
      this.smaskCounter = 0;
      this.tempSMask = null;
      this.suspendedCtx = null;
      this.contentVisible = true;
      this.markedContentStack = markedContentStack || [];
      this.optionalContentConfig = optionalContentConfig;
      this.cachedCanvases = new CachedCanvases(this.canvasFactory);
      this.cachedPatterns = /* @__PURE__ */ new Map();
      this.annotationCanvasMap = annotationCanvasMap;
      this.viewportScale = 1;
      this.outputScaleX = 1;
      this.outputScaleY = 1;
      this.pageColors = pageColors;
      this._cachedScaleForStroking = [-1, 0];
      this._cachedGetSinglePixelWidth = null;
      this._cachedBitmapsMap = /* @__PURE__ */ new Map();
      this.dependencyTracker = dependencyTracker ?? null;
    }
    getObject(opIdx, data, fallback = null) {
      if (typeof data === "string") {
        this.dependencyTracker?.recordNamedDependency(opIdx, data);
        return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
      }
      return fallback;
    }
    beginDrawing({
      transform,
      viewport,
      transparency = false,
      background = null
    }) {
      const width = this.ctx.canvas.width;
      const height = this.ctx.canvas.height;
      const savedFillStyle = this.ctx.fillStyle;
      this.ctx.fillStyle = background || "#ffffff";
      this.ctx.fillRect(0, 0, width, height);
      this.ctx.fillStyle = savedFillStyle;
      if (transparency) {
        const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
        this.compositeCtx = this.ctx;
        this.transparentCanvas = transparentCanvas.canvas;
        this.ctx = transparentCanvas.context;
        this.ctx.save();
        this.ctx.transform(...getCurrentTransform(this.compositeCtx));
      }
      this.ctx.save();
      resetCtxToDefault(this.ctx);
      if (transform) {
        this.ctx.transform(...transform);
        this.outputScaleX = transform[0];
        this.outputScaleY = transform[0];
      }
      this.ctx.transform(...viewport.transform);
      this.viewportScale = viewport.scale;
      this.baseTransform = getCurrentTransform(this.ctx);
    }
    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, filteredOperationIndexes) {
      const argsArray = operatorList.argsArray;
      const fnArray = operatorList.fnArray;
      let i = executionStartIdx || 0;
      const argsArrayLen = argsArray.length;
      if (argsArrayLen === i) {
        return i;
      }
      const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
      const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
      let steps = 0;
      const commonObjs = this.commonObjs;
      const objs = this.objs;
      let fnId, fnArgs;
      while (true) {
        if (stepper !== void 0 && i === stepper.nextBreakPoint) {
          stepper.breakIt(i, continueCallback);
          return i;
        }
        if (!filteredOperationIndexes || filteredOperationIndexes.has(i)) {
          fnId = fnArray[i];
          fnArgs = argsArray[i] ?? null;
          if (fnId !== OPS.dependency) {
            if (fnArgs === null) {
              this[fnId](i);
            } else {
              this[fnId](i, ...fnArgs);
            }
          } else {
            for (const depObjId of fnArgs) {
              this.dependencyTracker?.recordNamedData(depObjId, i);
              const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
              if (!objsPool.has(depObjId)) {
                objsPool.get(depObjId, continueCallback);
                return i;
              }
            }
          }
        }
        i++;
        if (i === argsArrayLen) {
          return i;
        }
        if (chunkOperations && ++steps > EXECUTION_STEPS) {
          if (Date.now() > endTime) {
            continueCallback();
            return i;
          }
          steps = 0;
        }
      }
    }
    #restoreInitialState() {
      while (this.stateStack.length || this.inSMaskMode) {
        this.restore();
      }
      this.current.activeSMask = null;
      this.ctx.restore();
      if (this.transparentCanvas) {
        this.ctx = this.compositeCtx;
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.drawImage(this.transparentCanvas, 0, 0);
        this.ctx.restore();
        this.transparentCanvas = null;
      }
    }
    endDrawing() {
      this.#restoreInitialState();
      this.cachedCanvases.clear();
      this.cachedPatterns.clear();
      for (const cache of this._cachedBitmapsMap.values()) {
        for (const canvas of cache.values()) {
          if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
            canvas.width = canvas.height = 0;
          }
        }
        cache.clear();
      }
      this._cachedBitmapsMap.clear();
      this.#drawFilter();
    }
    #drawFilter() {
      if (this.pageColors) {
        const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
        if (hcmFilterId !== "none") {
          const savedFilter = this.ctx.filter;
          this.ctx.filter = hcmFilterId;
          this.ctx.drawImage(this.ctx.canvas, 0, 0);
          this.ctx.filter = savedFilter;
        }
      }
    }
    _scaleImage(img, inverseTransform) {
      const width = img.width ?? img.displayWidth;
      const height = img.height ?? img.displayHeight;
      let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
      let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
      let paintWidth = width, paintHeight = height;
      let tmpCanvasId = "prescale1";
      let tmpCanvas, tmpCtx;
      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
        let newWidth = paintWidth, newHeight = paintHeight;
        if (widthScale > 2 && paintWidth > 1) {
          newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
          widthScale /= paintWidth / newWidth;
        }
        if (heightScale > 2 && paintHeight > 1) {
          newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
          heightScale /= paintHeight / newHeight;
        }
        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
        tmpCtx = tmpCanvas.context;
        tmpCtx.clearRect(0, 0, newWidth, newHeight);
        tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
        img = tmpCanvas.canvas;
        paintWidth = newWidth;
        paintHeight = newHeight;
        tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
      }
      return {
        img,
        paintWidth,
        paintHeight
      };
    }
    _createMaskCanvas(opIdx, img) {
      const ctx = this.ctx;
      const {
        width,
        height
      } = img;
      const fillColor = this.current.fillColor;
      const isPatternFill = this.current.patternFill;
      const currentTransform = getCurrentTransform(ctx);
      let cache, cacheKey, scaled, maskCanvas;
      if ((img.bitmap || img.data) && img.count > 1) {
        const mainKey = img.bitmap || img.data.buffer;
        cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
        cache = this._cachedBitmapsMap.get(mainKey);
        if (!cache) {
          cache = /* @__PURE__ */ new Map();
          this._cachedBitmapsMap.set(mainKey, cache);
        }
        const cachedImage = cache.get(cacheKey);
        if (cachedImage && !isPatternFill) {
          const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
          const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
          this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);
          return {
            canvas: cachedImage,
            offsetX: offsetX2,
            offsetY: offsetY2
          };
        }
        scaled = cachedImage;
      }
      if (!scaled) {
        maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
        putBinaryImageMask(maskCanvas.context, img);
      }
      let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
      maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
      const minMax = MIN_MAX_INIT.slice();
      Util.axialAlignedBoundingBox([0, 0, width, height], maskToCanvas, minMax);
      const [minX, minY, maxX, maxY] = minMax;
      const drawnWidth = Math.round(maxX - minX) || 1;
      const drawnHeight = Math.round(maxY - minY) || 1;
      const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
      const fillCtx = fillCanvas.context;
      const offsetX = minX;
      const offsetY = minY;
      fillCtx.translate(-offsetX, -offsetY);
      fillCtx.transform(...maskToCanvas);
      if (!scaled) {
        scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));
        scaled = scaled.img;
        if (cache && isPatternFill) {
          cache.set(cacheKey, scaled);
        }
      }
      fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);
      drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
      fillCtx.globalCompositeOperation = "source-in";
      const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
      fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;
      fillCtx.fillRect(0, 0, width, height);
      if (cache && !isPatternFill) {
        this.cachedCanvases.delete("fillCanvas");
        cache.set(cacheKey, fillCanvas.canvas);
      }
      this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);
      return {
        canvas: fillCanvas.canvas,
        offsetX: Math.round(offsetX),
        offsetY: Math.round(offsetY)
      };
    }
    setLineWidth(opIdx, width) {
      this.dependencyTracker?.recordSimpleData("lineWidth", opIdx);
      if (width !== this.current.lineWidth) {
        this._cachedScaleForStroking[0] = -1;
      }
      this.current.lineWidth = width;
      this.ctx.lineWidth = width;
    }
    setLineCap(opIdx, style) {
      this.dependencyTracker?.recordSimpleData("lineCap", opIdx);
      this.ctx.lineCap = LINE_CAP_STYLES[style];
    }
    setLineJoin(opIdx, style) {
      this.dependencyTracker?.recordSimpleData("lineJoin", opIdx);
      this.ctx.lineJoin = LINE_JOIN_STYLES[style];
    }
    setMiterLimit(opIdx, limit) {
      this.dependencyTracker?.recordSimpleData("miterLimit", opIdx);
      this.ctx.miterLimit = limit;
    }
    setDash(opIdx, dashArray, dashPhase) {
      this.dependencyTracker?.recordSimpleData("dash", opIdx);
      const ctx = this.ctx;
      if (ctx.setLineDash !== void 0) {
        ctx.setLineDash(dashArray);
        ctx.lineDashOffset = dashPhase;
      }
    }
    setRenderingIntent(opIdx, intent) {
    }
    setFlatness(opIdx, flatness) {
    }
    setGState(opIdx, states) {
      for (const [key, value] of states) {
        switch (key) {
          case "LW":
            this.setLineWidth(opIdx, value);
            break;
          case "LC":
            this.setLineCap(opIdx, value);
            break;
          case "LJ":
            this.setLineJoin(opIdx, value);
            break;
          case "ML":
            this.setMiterLimit(opIdx, value);
            break;
          case "D":
            this.setDash(opIdx, value[0], value[1]);
            break;
          case "RI":
            this.setRenderingIntent(opIdx, value);
            break;
          case "FL":
            this.setFlatness(opIdx, value);
            break;
          case "Font":
            this.setFont(opIdx, value[0], value[1]);
            break;
          case "CA":
            this.dependencyTracker?.recordSimpleData("strokeAlpha", opIdx);
            this.current.strokeAlpha = value;
            break;
          case "ca":
            this.dependencyTracker?.recordSimpleData("fillAlpha", opIdx);
            this.ctx.globalAlpha = this.current.fillAlpha = value;
            break;
          case "BM":
            this.dependencyTracker?.recordSimpleData("globalCompositeOperation", opIdx);
            this.ctx.globalCompositeOperation = value;
            break;
          case "SMask":
            this.dependencyTracker?.recordSimpleData("SMask", opIdx);
            this.current.activeSMask = value ? this.tempSMask : null;
            this.tempSMask = null;
            this.checkSMaskState();
            break;
          case "TR":
            this.dependencyTracker?.recordSimpleData("filter", opIdx);
            this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
            break;
        }
      }
    }
    get inSMaskMode() {
      return !!this.suspendedCtx;
    }
    checkSMaskState() {
      const inSMaskMode = this.inSMaskMode;
      if (this.current.activeSMask && !inSMaskMode) {
        this.beginSMaskMode();
      } else if (!this.current.activeSMask && inSMaskMode) {
        this.endSMaskMode();
      }
    }
    beginSMaskMode(opIdx) {
      if (this.inSMaskMode) {
        throw new Error("beginSMaskMode called while already in smask mode");
      }
      const drawnWidth = this.ctx.canvas.width;
      const drawnHeight = this.ctx.canvas.height;
      const cacheId = "smaskGroupAt" + this.groupLevel;
      const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
      this.suspendedCtx = this.ctx;
      const ctx = this.ctx = scratchCanvas.context;
      ctx.setTransform(this.suspendedCtx.getTransform());
      copyCtxState(this.suspendedCtx, ctx);
      mirrorContextOperations(ctx, this.suspendedCtx);
      this.setGState(opIdx, [["BM", "source-over"]]);
    }
    endSMaskMode() {
      if (!this.inSMaskMode) {
        throw new Error("endSMaskMode called while not in smask mode");
      }
      this.ctx._removeMirroring();
      copyCtxState(this.ctx, this.suspendedCtx);
      this.ctx = this.suspendedCtx;
      this.suspendedCtx = null;
    }
    compose(dirtyBox) {
      if (!this.current.activeSMask) {
        return;
      }
      if (!dirtyBox) {
        dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
      } else {
        dirtyBox[0] = Math.floor(dirtyBox[0]);
        dirtyBox[1] = Math.floor(dirtyBox[1]);
        dirtyBox[2] = Math.ceil(dirtyBox[2]);
        dirtyBox[3] = Math.ceil(dirtyBox[3]);
      }
      const smask = this.current.activeSMask;
      const suspendedCtx = this.suspendedCtx;
      this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
      this.ctx.restore();
    }
    composeSMask(ctx, smask, layerCtx, layerBox) {
      const layerOffsetX = layerBox[0];
      const layerOffsetY = layerBox[1];
      const layerWidth = layerBox[2] - layerOffsetX;
      const layerHeight = layerBox[3] - layerOffsetY;
      if (layerWidth === 0 || layerHeight === 0) {
        return;
      }
      this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(layerCtx.canvas, 0, 0);
      ctx.restore();
    }
    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
      let maskCanvas = maskCtx.canvas;
      let maskX = layerOffsetX - maskOffsetX;
      let maskY = layerOffsetY - maskOffsetY;
      if (backdrop) {
        if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {
          const canvas = this.cachedCanvases.getCanvas("maskExtension", width, height);
          const ctx = canvas.context;
          ctx.drawImage(maskCanvas, -maskX, -maskY);
          ctx.globalCompositeOperation = "destination-atop";
          ctx.fillStyle = backdrop;
          ctx.fillRect(0, 0, width, height);
          ctx.globalCompositeOperation = "source-over";
          maskCanvas = canvas.canvas;
          maskX = maskY = 0;
        } else {
          maskCtx.save();
          maskCtx.globalAlpha = 1;
          maskCtx.setTransform(1, 0, 0, 1, 0, 0);
          const clip2 = new Path2D();
          clip2.rect(maskX, maskY, width, height);
          maskCtx.clip(clip2);
          maskCtx.globalCompositeOperation = "destination-atop";
          maskCtx.fillStyle = backdrop;
          maskCtx.fillRect(maskX, maskY, width, height);
          maskCtx.restore();
        }
      }
      layerCtx.save();
      layerCtx.globalAlpha = 1;
      layerCtx.setTransform(1, 0, 0, 1, 0, 0);
      if (subtype === "Alpha" && transferMap) {
        layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
      } else if (subtype === "Luminosity") {
        layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
      }
      const clip = new Path2D();
      clip.rect(layerOffsetX, layerOffsetY, width, height);
      layerCtx.clip(clip);
      layerCtx.globalCompositeOperation = "destination-in";
      layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);
      layerCtx.restore();
    }
    save(opIdx) {
      if (this.inSMaskMode) {
        copyCtxState(this.ctx, this.suspendedCtx);
      }
      this.ctx.save();
      const old = this.current;
      this.stateStack.push(old);
      this.current = old.clone();
      this.dependencyTracker?.save(opIdx);
    }
    restore(opIdx) {
      this.dependencyTracker?.restore(opIdx);
      if (this.stateStack.length === 0) {
        if (this.inSMaskMode) {
          this.endSMaskMode();
        }
        return;
      }
      this.current = this.stateStack.pop();
      this.ctx.restore();
      if (this.inSMaskMode) {
        copyCtxState(this.suspendedCtx, this.ctx);
      }
      this.checkSMaskState();
      this.pendingClip = null;
      this._cachedScaleForStroking[0] = -1;
      this._cachedGetSinglePixelWidth = null;
    }
    transform(opIdx, a, b, c, d, e, f) {
      this.dependencyTracker?.recordIncrementalData("transform", opIdx);
      this.ctx.transform(a, b, c, d, e, f);
      this._cachedScaleForStroking[0] = -1;
      this._cachedGetSinglePixelWidth = null;
    }
    constructPath(opIdx, op, data, minMax) {
      let [path] = data;
      if (!minMax) {
        path ||= data[0] = new Path2D();
        this[op](opIdx, path);
        return;
      }
      if (this.dependencyTracker !== null) {
        const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;
        this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, ["transform"]);
      }
      if (!(path instanceof Path2D)) {
        const path2d = data[0] = new Path2D();
        for (let i = 0, ii = path.length; i < ii; ) {
          switch (path[i++]) {
            case DrawOPS.moveTo:
              path2d.moveTo(path[i++], path[i++]);
              break;
            case DrawOPS.lineTo:
              path2d.lineTo(path[i++], path[i++]);
              break;
            case DrawOPS.curveTo:
              path2d.bezierCurveTo(path[i++], path[i++], path[i++], path[i++], path[i++], path[i++]);
              break;
            case DrawOPS.closePath:
              path2d.closePath();
              break;
            default:
              warn(`Unrecognized drawing path operator: ${path[i - 1]}`);
              break;
          }
        }
        path = path2d;
      }
      Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);
      this[op](opIdx, path);
      this._pathStartIdx = opIdx;
    }
    closePath(opIdx) {
      this.ctx.closePath();
    }
    stroke(opIdx, path, consumePath = true) {
      const ctx = this.ctx;
      const strokeColor = this.current.strokeColor;
      ctx.globalAlpha = this.current.strokeAlpha;
      if (this.contentVisible) {
        if (typeof strokeColor === "object" && strokeColor?.getPattern) {
          const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
          ctx.save();
          ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);
          if (baseTransform) {
            const newPath = new Path2D();
            newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
            path = newPath;
          }
          this.rescaleAndStroke(path, false);
          ctx.restore();
        } else {
          this.rescaleAndStroke(path, true);
        }
      }
      this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);
      if (consumePath) {
        this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));
      }
      ctx.globalAlpha = this.current.fillAlpha;
    }
    closeStroke(opIdx, path) {
      this.stroke(opIdx, path);
    }
    fill(opIdx, path, consumePath = true) {
      const ctx = this.ctx;
      const fillColor = this.current.fillColor;
      const isPatternFill = this.current.patternFill;
      let needRestore = false;
      if (isPatternFill) {
        const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
        this.dependencyTracker?.save(opIdx);
        ctx.save();
        ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
        if (baseTransform) {
          const newPath = new Path2D();
          newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
          path = newPath;
        }
        needRestore = true;
      }
      const intersect = this.current.getClippedPathBoundingBox();
      if (this.contentVisible && intersect !== null) {
        if (this.pendingEOFill) {
          ctx.fill(path, "evenodd");
          this.pendingEOFill = false;
        } else {
          ctx.fill(path);
        }
      }
      this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);
      if (needRestore) {
        ctx.restore();
        this.dependencyTracker?.restore(opIdx);
      }
      if (consumePath) {
        this.consumePath(opIdx, path, intersect);
      }
    }
    eoFill(opIdx, path) {
      this.pendingEOFill = true;
      this.fill(opIdx, path);
    }
    fillStroke(opIdx, path) {
      this.fill(opIdx, path, false);
      this.stroke(opIdx, path, false);
      this.consumePath(opIdx, path);
    }
    eoFillStroke(opIdx, path) {
      this.pendingEOFill = true;
      this.fillStroke(opIdx, path);
    }
    closeFillStroke(opIdx, path) {
      this.fillStroke(opIdx, path);
    }
    closeEOFillStroke(opIdx, path) {
      this.pendingEOFill = true;
      this.fillStroke(opIdx, path);
    }
    endPath(opIdx, path) {
      this.consumePath(opIdx, path);
    }
    rawFillPath(opIdx, path) {
      this.ctx.fill(path);
      this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);
    }
    clip(opIdx) {
      this.dependencyTracker?.recordFutureForcedDependency("clipMode", opIdx);
      this.pendingClip = NORMAL_CLIP;
    }
    eoClip(opIdx) {
      this.dependencyTracker?.recordFutureForcedDependency("clipMode", opIdx);
      this.pendingClip = EO_CLIP;
    }
    beginText(opIdx) {
      this.current.textMatrix = null;
      this.current.textMatrixScale = 1;
      this.current.x = this.current.lineX = 0;
      this.current.y = this.current.lineY = 0;
      this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData("sameLineText").resetIncrementalData("moveText", opIdx);
    }
    endText(opIdx) {
      const paths = this.pendingTextPaths;
      const ctx = this.ctx;
      if (this.dependencyTracker) {
        const {
          dependencyTracker
        } = this;
        if (paths !== void 0) {
          dependencyTracker.recordFutureForcedDependency("textClip", dependencyTracker.getOpenMarker()).recordFutureForcedDependency("textClip", opIdx);
        }
        dependencyTracker.recordCloseMarker(opIdx);
      }
      if (paths !== void 0) {
        const newPath = new Path2D();
        const invTransf = ctx.getTransform().invertSelf();
        for (const {
          transform,
          x,
          y,
          fontSize,
          path
        } of paths) {
          if (!path) {
            continue;
          }
          newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));
        }
        ctx.clip(newPath);
      }
      delete this.pendingTextPaths;
    }
    setCharSpacing(opIdx, spacing) {
      this.dependencyTracker?.recordSimpleData("charSpacing", opIdx);
      this.current.charSpacing = spacing;
    }
    setWordSpacing(opIdx, spacing) {
      this.dependencyTracker?.recordSimpleData("wordSpacing", opIdx);
      this.current.wordSpacing = spacing;
    }
    setHScale(opIdx, scale) {
      this.dependencyTracker?.recordSimpleData("hScale", opIdx);
      this.current.textHScale = scale / 100;
    }
    setLeading(opIdx, leading) {
      this.dependencyTracker?.recordSimpleData("leading", opIdx);
      this.current.leading = -leading;
    }
    setFont(opIdx, fontRefName, size) {
      this.dependencyTracker?.recordSimpleData("font", opIdx).recordNamedDependency(opIdx, fontRefName);
      const fontObj = this.commonObjs.get(fontRefName);
      const current = this.current;
      if (!fontObj) {
        throw new Error(`Can't find font for ${fontRefName}`);
      }
      current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
        warn("Invalid font matrix for font " + fontRefName);
      }
      if (size < 0) {
        size = -size;
        current.fontDirection = -1;
      } else {
        current.fontDirection = 1;
      }
      this.current.font = fontObj;
      this.current.fontSize = size;
      if (fontObj.isType3Font) {
        return;
      }
      const name = fontObj.loadedName || "sans-serif";
      const typeface = fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
      let bold = "normal";
      if (fontObj.black) {
        bold = "900";
      } else if (fontObj.bold) {
        bold = "bold";
      }
      const italic = fontObj.italic ? "italic" : "normal";
      let browserFontSize = size;
      if (size < MIN_FONT_SIZE) {
        browserFontSize = MIN_FONT_SIZE;
      } else if (size > MAX_FONT_SIZE) {
        browserFontSize = MAX_FONT_SIZE;
      }
      this.current.fontSizeScale = size / browserFontSize;
      this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
    }
    setTextRenderingMode(opIdx, mode) {
      this.dependencyTracker?.recordSimpleData("textRenderingMode", opIdx);
      this.current.textRenderingMode = mode;
    }
    setTextRise(opIdx, rise) {
      this.dependencyTracker?.recordSimpleData("textRise", opIdx);
      this.current.textRise = rise;
    }
    moveText(opIdx, x, y) {
      this.dependencyTracker?.resetIncrementalData("sameLineText").recordIncrementalData("moveText", opIdx);
      this.current.x = this.current.lineX += x;
      this.current.y = this.current.lineY += y;
    }
    setLeadingMoveText(opIdx, x, y) {
      this.setLeading(opIdx, -y);
      this.moveText(opIdx, x, y);
    }
    setTextMatrix(opIdx, matrix) {
      this.dependencyTracker?.recordSimpleData("textMatrix", opIdx);
      const {
        current
      } = this;
      current.textMatrix = matrix;
      current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);
      current.x = current.lineX = 0;
      current.y = current.lineY = 0;
    }
    nextLine(opIdx) {
      this.moveText(opIdx, 0, this.current.leading);
      this.dependencyTracker?.recordIncrementalData("moveText", this.dependencyTracker.getSimpleIndex("leading") ?? opIdx);
    }
    #getScaledPath(path, currentTransform, transform) {
      const newPath = new Path2D();
      newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));
      return newPath;
    }
    paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {
      const ctx = this.ctx;
      const current = this.current;
      const font = current.font;
      const textRenderingMode = current.textRenderingMode;
      const fontSize = current.fontSize / current.fontSizeScale;
      const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
      const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
      const patternFill = current.patternFill && !font.missingFile;
      const patternStroke = current.patternStroke && !font.missingFile;
      let path;
      if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {
        path = font.getPathGenerator(this.commonObjs, character);
      }
      if (path && (font.disableFontFace || patternFill || patternStroke)) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(fontSize, -fontSize);
        this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);
        let currentTransform;
        if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
          if (patternFillTransform) {
            currentTransform = ctx.getTransform();
            ctx.setTransform(...patternFillTransform);
            const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);
            ctx.fill(scaledPath);
          } else {
            ctx.fill(path);
          }
        }
        if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
          if (patternStrokeTransform) {
            currentTransform ||= ctx.getTransform();
            ctx.setTransform(...patternStrokeTransform);
            const {
              a,
              b,
              c,
              d
            } = currentTransform;
            const invPatternTransform = Util.inverseTransform(patternStrokeTransform);
            const transf = Util.transform([a, b, c, d, 0, 0], invPatternTransform);
            Util.singularValueDecompose2dScale(transf, XY);
            ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;
            ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));
          } else {
            ctx.lineWidth /= fontSize;
            ctx.stroke(path);
          }
        }
        ctx.restore();
      } else {
        if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
          ctx.fillText(character, x, y);
          this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character));
        }
        if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
          if (this.dependencyTracker) {
            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);
          }
          ctx.strokeText(character, x, y);
        }
      }
      if (isAddToPathSet) {
        const paths = this.pendingTextPaths ||= [];
        paths.push({
          transform: getCurrentTransform(ctx),
          x,
          y,
          fontSize,
          path
        });
        this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);
      }
    }
    get isFontSubpixelAAEnabled() {
      const {
        context: ctx
      } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
      ctx.scale(1.5, 1);
      ctx.fillText("I", 0, 10);
      const data = ctx.getImageData(0, 0, 10, 10).data;
      let enabled = false;
      for (let i = 3; i < data.length; i += 4) {
        if (data[i] > 0 && data[i] < 255) {
          enabled = true;
          break;
        }
      }
      return shadow(this, "isFontSubpixelAAEnabled", enabled);
    }
    showText(opIdx, glyphs) {
      if (this.dependencyTracker) {
        this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).copyDependenciesFromIncrementalOperation(opIdx, "sameLineText").resetBBox(opIdx);
        if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {
          this.dependencyTracker.recordFutureForcedDependency("textClip", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();
        }
      }
      const current = this.current;
      const font = current.font;
      if (font.isType3Font) {
        this.showType3Text(opIdx, glyphs);
        this.dependencyTracker?.recordOperation(opIdx).recordIncrementalData("sameLineText", opIdx);
        return void 0;
      }
      const fontSize = current.fontSize;
      if (fontSize === 0) {
        this.dependencyTracker?.recordOperation(opIdx);
        return void 0;
      }
      const ctx = this.ctx;
      const fontSizeScale = current.fontSizeScale;
      const charSpacing = current.charSpacing;
      const wordSpacing = current.wordSpacing;
      const fontDirection = current.fontDirection;
      const textHScale = current.textHScale * fontDirection;
      const glyphsLength = glyphs.length;
      const vertical = font.vertical;
      const spacingDir = vertical ? 1 : -1;
      const defaultVMetrics = font.defaultVMetrics;
      const widthAdvanceScale = fontSize * current.fontMatrix[0];
      const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
      ctx.save();
      if (current.textMatrix) {
        ctx.transform(...current.textMatrix);
      }
      ctx.translate(current.x, current.y + current.textRise);
      if (fontDirection > 0) {
        ctx.scale(textHScale, -1);
      } else {
        ctx.scale(textHScale, 1);
      }
      let patternFillTransform, patternStrokeTransform;
      if (current.patternFill) {
        ctx.save();
        const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
        patternFillTransform = getCurrentTransform(ctx);
        ctx.restore();
        ctx.fillStyle = pattern;
      }
      if (current.patternStroke) {
        ctx.save();
        const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);
        patternStrokeTransform = getCurrentTransform(ctx);
        ctx.restore();
        ctx.strokeStyle = pattern;
      }
      let lineWidth = current.lineWidth;
      const scale = current.textMatrixScale;
      if (scale === 0 || lineWidth === 0) {
        const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
        if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
          lineWidth = this.getSinglePixelWidth();
        }
      } else {
        lineWidth /= scale;
      }
      if (fontSizeScale !== 1) {
        ctx.scale(fontSizeScale, fontSizeScale);
        lineWidth /= fontSizeScale;
      }
      ctx.lineWidth = lineWidth;
      if (font.isInvalidPDFjsFont) {
        const chars = [];
        let width = 0;
        for (const glyph of glyphs) {
          chars.push(glyph.unicode);
          width += glyph.width;
        }
        const joinedChars = chars.join("");
        ctx.fillText(joinedChars, 0, 0);
        if (this.dependencyTracker !== null) {
          const measure = ctx.measureText(joinedChars);
          this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordOperation(opIdx).recordIncrementalData("sameLineText", opIdx);
        }
        current.x += width * widthAdvanceScale * textHScale;
        ctx.restore();
        this.compose();
        return void 0;
      }
      let x = 0, i;
      for (i = 0; i < glyphsLength; ++i) {
        const glyph = glyphs[i];
        if (typeof glyph === "number") {
          x += spacingDir * glyph * fontSize / 1e3;
          continue;
        }
        let restoreNeeded = false;
        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        const character = glyph.fontChar;
        const accent = glyph.accent;
        let scaledX, scaledY;
        let width = glyph.width;
        if (vertical) {
          const vmetric = glyph.vmetric || defaultVMetrics;
          const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
          const vy = vmetric[2] * widthAdvanceScale;
          width = vmetric ? -vmetric[0] : width;
          scaledX = vx / fontSizeScale;
          scaledY = (x + vy) / fontSizeScale;
        } else {
          scaledX = x / fontSizeScale;
          scaledY = 0;
        }
        let measure;
        if (font.remeasure && width > 0) {
          measure = ctx.measureText(character);
          const measuredWidth = measure.width * 1e3 / fontSize * fontSizeScale;
          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
            const characterScaleX = width / measuredWidth;
            restoreNeeded = true;
            ctx.save();
            ctx.scale(characterScaleX, 1);
            scaledX /= characterScaleX;
          } else if (width !== measuredWidth) {
            scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
          }
        }
        if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
          if (simpleFillText && !accent) {
            ctx.fillText(character, scaledX, scaledY);
            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {
              bbox: null
            } : font, fontSize / fontSizeScale, scaledX, scaledY, () => measure ?? ctx.measureText(character));
          } else {
            this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);
            if (accent) {
              const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
              const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
              this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);
            }
          }
        }
        const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
        x += charWidth;
        if (restoreNeeded) {
          ctx.restore();
        }
      }
      if (vertical) {
        current.y -= x;
      } else {
        current.x += x * textHScale;
      }
      ctx.restore();
      this.compose();
      this.dependencyTracker?.recordOperation(opIdx).recordIncrementalData("sameLineText", opIdx);
      return void 0;
    }
    showType3Text(opIdx, glyphs) {
      const ctx = this.ctx;
      const current = this.current;
      const font = current.font;
      const fontSize = current.fontSize;
      const fontDirection = current.fontDirection;
      const spacingDir = font.vertical ? 1 : -1;
      const charSpacing = current.charSpacing;
      const wordSpacing = current.wordSpacing;
      const textHScale = current.textHScale * fontDirection;
      const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
      const glyphsLength = glyphs.length;
      const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
      let i, glyph, width, spacingLength;
      if (isTextInvisible || fontSize === 0) {
        return;
      }
      this._cachedScaleForStroking[0] = -1;
      this._cachedGetSinglePixelWidth = null;
      ctx.save();
      if (current.textMatrix) {
        ctx.transform(...current.textMatrix);
      }
      ctx.translate(current.x, current.y + current.textRise);
      ctx.scale(textHScale, fontDirection);
      const dependencyTracker = this.dependencyTracker;
      this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;
      for (i = 0; i < glyphsLength; ++i) {
        glyph = glyphs[i];
        if (typeof glyph === "number") {
          spacingLength = spacingDir * glyph * fontSize / 1e3;
          this.ctx.translate(spacingLength, 0);
          current.x += spacingLength * textHScale;
          continue;
        }
        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        const operatorList = font.charProcOperatorList[glyph.operatorListId];
        if (!operatorList) {
          warn(`Type3 character "${glyph.operatorListId}" is not available.`);
        } else if (this.contentVisible) {
          this.save();
          ctx.scale(fontSize, fontSize);
          ctx.transform(...fontMatrix);
          this.executeOperatorList(operatorList);
          this.restore();
        }
        const p = [glyph.width, 0];
        Util.applyTransform(p, fontMatrix);
        width = p[0] * fontSize + spacing;
        ctx.translate(width, 0);
        current.x += width * textHScale;
      }
      ctx.restore();
      if (dependencyTracker) {
        this.dependencyTracker.recordNestedDependencies();
        this.dependencyTracker = dependencyTracker;
      }
    }
    setCharWidth(opIdx, xWidth, yWidth) {
    }
    setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {
      const clip = new Path2D();
      clip.rect(llx, lly, urx - llx, ury - lly);
      this.ctx.clip(clip);
      this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);
      this.endPath(opIdx);
    }
    getColorN_Pattern(opIdx, IR) {
      let pattern;
      if (IR[0] === "TilingPattern") {
        const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
        const canvasGraphicsFactory = {
          createCanvasGraphics: (ctx) => new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
            optionalContentConfig: this.optionalContentConfig,
            markedContentStack: this.markedContentStack
          }, void 0, void 0, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, opIdx) : null)
        };
        pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);
      } else {
        pattern = this._getPattern(opIdx, IR[1], IR[2]);
      }
      return pattern;
    }
    setStrokeColorN(opIdx, ...args) {
      this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
      this.current.strokeColor = this.getColorN_Pattern(opIdx, args);
      this.current.patternStroke = true;
    }
    setFillColorN(opIdx, ...args) {
      this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
      this.current.fillColor = this.getColorN_Pattern(opIdx, args);
      this.current.patternFill = true;
    }
    setStrokeRGBColor(opIdx, color) {
      this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
      this.ctx.strokeStyle = this.current.strokeColor = color;
      this.current.patternStroke = false;
    }
    setStrokeTransparent(opIdx) {
      this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
      this.ctx.strokeStyle = this.current.strokeColor = "transparent";
      this.current.patternStroke = false;
    }
    setFillRGBColor(opIdx, color) {
      this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
      this.ctx.fillStyle = this.current.fillColor = color;
      this.current.patternFill = false;
    }
    setFillTransparent(opIdx) {
      this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
      this.ctx.fillStyle = this.current.fillColor = "transparent";
      this.current.patternFill = false;
    }
    _getPattern(opIdx, objId, matrix = null) {
      let pattern;
      if (this.cachedPatterns.has(objId)) {
        pattern = this.cachedPatterns.get(objId);
      } else {
        pattern = getShadingPattern(this.getObject(opIdx, objId));
        this.cachedPatterns.set(objId, pattern);
      }
      if (matrix) {
        pattern.matrix = matrix;
      }
      return pattern;
    }
    shadingFill(opIdx, objId) {
      if (!this.contentVisible) {
        return;
      }
      const ctx = this.ctx;
      this.save(opIdx);
      const pattern = this._getPattern(opIdx, objId);
      ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);
      const inv = getCurrentTransformInverse(ctx);
      if (inv) {
        const {
          width,
          height
        } = ctx.canvas;
        const minMax = MIN_MAX_INIT.slice();
        Util.axialAlignedBoundingBox([0, 0, width, height], inv, minMax);
        const [x0, y0, x1, y1] = minMax;
        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
      } else {
        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
      }
      this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
      this.compose(this.current.getClippedPathBoundingBox());
      this.restore(opIdx);
    }
    beginInlineImage() {
      unreachable("Should not call beginInlineImage");
    }
    beginImageData() {
      unreachable("Should not call beginImageData");
    }
    paintFormXObjectBegin(opIdx, matrix, bbox) {
      if (!this.contentVisible) {
        return;
      }
      this.save(opIdx);
      this.baseTransformStack.push(this.baseTransform);
      if (matrix) {
        this.transform(opIdx, ...matrix);
      }
      this.baseTransform = getCurrentTransform(this.ctx);
      if (bbox) {
        Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);
        const [x0, y0, x1, y1] = bbox;
        const clip = new Path2D();
        clip.rect(x0, y0, x1 - x0, y1 - y0);
        this.ctx.clip(clip);
        this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);
        this.endPath(opIdx);
      }
    }
    paintFormXObjectEnd(opIdx) {
      if (!this.contentVisible) {
        return;
      }
      this.restore(opIdx);
      this.baseTransform = this.baseTransformStack.pop();
    }
    beginGroup(opIdx, group) {
      if (!this.contentVisible) {
        return;
      }
      this.save(opIdx);
      if (this.inSMaskMode) {
        this.endSMaskMode();
        this.current.activeSMask = null;
      }
      const currentCtx = this.ctx;
      if (!group.isolated) {
        info("TODO: Support non-isolated groups.");
      }
      if (group.knockout) {
        warn("Knockout groups not supported.");
      }
      const currentTransform = getCurrentTransform(currentCtx);
      if (group.matrix) {
        currentCtx.transform(...group.matrix);
      }
      if (!group.bbox) {
        throw new Error("Bounding box is required.");
      }
      let bounds = MIN_MAX_INIT.slice();
      Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);
      const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
      bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
      const offsetX = Math.floor(bounds[0]);
      const offsetY = Math.floor(bounds[1]);
      const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
      const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
      this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
      let cacheId = "groupAt" + this.groupLevel;
      if (group.smask) {
        cacheId += "_smask_" + this.smaskCounter++ % 2;
      }
      const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
      const groupCtx = scratchCanvas.context;
      groupCtx.translate(-offsetX, -offsetY);
      groupCtx.transform(...currentTransform);
      let clip = new Path2D();
      const [x0, y0, x1, y1] = group.bbox;
      clip.rect(x0, y0, x1 - x0, y1 - y0);
      if (group.matrix) {
        const path = new Path2D();
        path.addPath(clip, new DOMMatrix(group.matrix));
        clip = path;
      }
      groupCtx.clip(clip);
      if (group.smask) {
        this.smaskStack.push({
          canvas: scratchCanvas.canvas,
          context: groupCtx,
          offsetX,
          offsetY,
          subtype: group.smask.subtype,
          backdrop: group.smask.backdrop,
          transferMap: group.smask.transferMap || null,
          startTransformInverse: null
        });
      }
      if (!group.smask || this.dependencyTracker) {
        currentCtx.setTransform(1, 0, 0, 1, 0, 0);
        currentCtx.translate(offsetX, offsetY);
        currentCtx.save();
      }
      copyCtxState(currentCtx, groupCtx);
      this.ctx = groupCtx;
      this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies(["fillAlpha", "strokeAlpha", "globalCompositeOperation"]).pushBaseTransform(currentCtx);
      this.setGState(opIdx, [["BM", "source-over"], ["ca", 1], ["CA", 1]]);
      this.groupStack.push(currentCtx);
      this.groupLevel++;
    }
    endGroup(opIdx, group) {
      if (!this.contentVisible) {
        return;
      }
      this.groupLevel--;
      const groupCtx = this.ctx;
      const ctx = this.groupStack.pop();
      this.ctx = ctx;
      this.ctx.imageSmoothingEnabled = false;
      this.dependencyTracker?.popBaseTransform();
      if (group.smask) {
        this.tempSMask = this.smaskStack.pop();
        this.restore(opIdx);
        if (this.dependencyTracker) {
          this.ctx.restore();
        }
      } else {
        this.ctx.restore();
        const currentMtx = getCurrentTransform(this.ctx);
        this.restore(opIdx);
        this.ctx.save();
        this.ctx.setTransform(...currentMtx);
        const dirtyBox = MIN_MAX_INIT.slice();
        Util.axialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx, dirtyBox);
        this.ctx.drawImage(groupCtx.canvas, 0, 0);
        this.ctx.restore();
        this.compose(dirtyBox);
      }
    }
    beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {
      this.#restoreInitialState();
      resetCtxToDefault(this.ctx);
      this.ctx.save();
      this.save(opIdx);
      if (this.baseTransform) {
        this.ctx.setTransform(...this.baseTransform);
      }
      if (rect) {
        const width = rect[2] - rect[0];
        const height = rect[3] - rect[1];
        if (hasOwnCanvas && this.annotationCanvasMap) {
          transform = transform.slice();
          transform[4] -= rect[0];
          transform[5] -= rect[1];
          rect = rect.slice();
          rect[0] = rect[1] = 0;
          rect[2] = width;
          rect[3] = height;
          Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);
          const {
            viewportScale
          } = this;
          const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
          const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
          this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
          const {
            canvas,
            context
          } = this.annotationCanvas;
          this.annotationCanvasMap.set(id, canvas);
          this.annotationCanvas.savedCtx = this.ctx;
          this.ctx = context;
          this.ctx.save();
          this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);
          resetCtxToDefault(this.ctx);
        } else {
          resetCtxToDefault(this.ctx);
          this.endPath(opIdx);
          const clip = new Path2D();
          clip.rect(rect[0], rect[1], width, height);
          this.ctx.clip(clip);
        }
      }
      this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
      this.transform(opIdx, ...transform);
      this.transform(opIdx, ...matrix);
    }
    endAnnotation(opIdx) {
      if (this.annotationCanvas) {
        this.ctx.restore();
        this.#drawFilter();
        this.ctx = this.annotationCanvas.savedCtx;
        delete this.annotationCanvas.savedCtx;
        delete this.annotationCanvas;
      }
    }
    paintImageMaskXObject(opIdx, img) {
      if (!this.contentVisible) {
        return;
      }
      const count = img.count;
      img = this.getObject(opIdx, img.data, img);
      img.count = count;
      const ctx = this.ctx;
      const mask = this._createMaskCanvas(opIdx, img);
      const maskCanvas = mask.canvas;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
      this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);
      ctx.restore();
      this.compose();
    }
    paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
      if (!this.contentVisible) {
        return;
      }
      img = this.getObject(opIdx, img.data, img);
      const ctx = this.ctx;
      ctx.save();
      const currentTransform = getCurrentTransform(ctx);
      ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
      const mask = this._createMaskCanvas(opIdx, img);
      ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
      this.dependencyTracker?.resetBBox(opIdx);
      for (let i = 0, ii = positions.length; i < ii; i += 2) {
        const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
        ctx.drawImage(mask.canvas, trans[4], trans[5]);
        this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);
      }
      ctx.restore();
      this.compose();
      this.dependencyTracker?.recordOperation(opIdx);
    }
    paintImageMaskXObjectGroup(opIdx, images) {
      if (!this.contentVisible) {
        return;
      }
      const ctx = this.ctx;
      const fillColor = this.current.fillColor;
      const isPatternFill = this.current.patternFill;
      this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);
      for (const image of images) {
        const {
          data,
          width,
          height,
          transform
        } = image;
        const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
        const maskCtx = maskCanvas.context;
        maskCtx.save();
        const img = this.getObject(opIdx, data, image);
        putBinaryImageMask(maskCtx, img);
        maskCtx.globalCompositeOperation = "source-in";
        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;
        maskCtx.fillRect(0, 0, width, height);
        maskCtx.restore();
        ctx.save();
        ctx.transform(...transform);
        ctx.scale(1, -1);
        drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
        this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);
        ctx.restore();
      }
      this.compose();
      this.dependencyTracker?.recordOperation(opIdx);
    }
    paintImageXObject(opIdx, objId) {
      if (!this.contentVisible) {
        return;
      }
      const imgData = this.getObject(opIdx, objId);
      if (!imgData) {
        warn("Dependent image isn't ready yet");
        return;
      }
      this.paintInlineImageXObject(opIdx, imgData);
    }
    paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {
      if (!this.contentVisible) {
        return;
      }
      const imgData = this.getObject(opIdx, objId);
      if (!imgData) {
        warn("Dependent image isn't ready yet");
        return;
      }
      const width = imgData.width;
      const height = imgData.height;
      const map = [];
      for (let i = 0, ii = positions.length; i < ii; i += 2) {
        map.push({
          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
          x: 0,
          y: 0,
          w: width,
          h: height
        });
      }
      this.paintInlineImageXObjectGroup(opIdx, imgData, map);
    }
    applyTransferMapsToCanvas(ctx) {
      if (this.current.transferMaps !== "none") {
        ctx.filter = this.current.transferMaps;
        ctx.drawImage(ctx.canvas, 0, 0);
        ctx.filter = "none";
      }
      return ctx.canvas;
    }
    applyTransferMapsToBitmap(imgData) {
      if (this.current.transferMaps === "none") {
        return imgData.bitmap;
      }
      const {
        bitmap,
        width,
        height
      } = imgData;
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.filter = this.current.transferMaps;
      tmpCtx.drawImage(bitmap, 0, 0);
      tmpCtx.filter = "none";
      return tmpCanvas.canvas;
    }
    paintInlineImageXObject(opIdx, imgData) {
      if (!this.contentVisible) {
        return;
      }
      const width = imgData.width;
      const height = imgData.height;
      const ctx = this.ctx;
      this.save(opIdx);
      const {
        filter
      } = ctx;
      if (filter !== "none" && filter !== "") {
        ctx.filter = "none";
      }
      ctx.scale(1 / width, -1 / height);
      let imgToPaint;
      if (imgData.bitmap) {
        imgToPaint = this.applyTransferMapsToBitmap(imgData);
      } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
        imgToPaint = imgData;
      } else {
        const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
        const tmpCtx = tmpCanvas.context;
        putBinaryImageData(tmpCtx, imgData);
        imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
      }
      const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));
      ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);
      this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);
      drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
      this.compose();
      this.restore(opIdx);
    }
    paintInlineImageXObjectGroup(opIdx, imgData, map) {
      if (!this.contentVisible) {
        return;
      }
      const ctx = this.ctx;
      let imgToPaint;
      if (imgData.bitmap) {
        imgToPaint = imgData.bitmap;
      } else {
        const w = imgData.width;
        const h = imgData.height;
        const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
        const tmpCtx = tmpCanvas.context;
        putBinaryImageData(tmpCtx, imgData);
        imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
      }
      this.dependencyTracker?.resetBBox(opIdx);
      for (const entry of map) {
        ctx.save();
        ctx.transform(...entry.transform);
        ctx.scale(1, -1);
        drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
        this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);
        ctx.restore();
      }
      this.dependencyTracker?.recordOperation(opIdx);
      this.compose();
    }
    paintSolidColorImageMask(opIdx) {
      if (!this.contentVisible) {
        return;
      }
      this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
      this.ctx.fillRect(0, 0, 1, 1);
      this.compose();
    }
    markPoint(opIdx, tag) {
    }
    markPointProps(opIdx, tag, properties) {
    }
    beginMarkedContent(opIdx, tag) {
      this.dependencyTracker?.beginMarkedContent(opIdx);
      this.markedContentStack.push({
        visible: true
      });
    }
    beginMarkedContentProps(opIdx, tag, properties) {
      this.dependencyTracker?.beginMarkedContent(opIdx);
      if (tag === "OC") {
        this.markedContentStack.push({
          visible: this.optionalContentConfig.isVisible(properties)
        });
      } else {
        this.markedContentStack.push({
          visible: true
        });
      }
      this.contentVisible = this.isContentVisible();
    }
    endMarkedContent(opIdx) {
      this.dependencyTracker?.endMarkedContent(opIdx);
      this.markedContentStack.pop();
      this.contentVisible = this.isContentVisible();
    }
    beginCompat(opIdx) {
    }
    endCompat(opIdx) {
    }
    consumePath(opIdx, path, clipBox) {
      const isEmpty = this.current.isEmptyClip();
      if (this.pendingClip) {
        this.current.updateClipFromPath();
      }
      if (!this.pendingClip) {
        this.compose(clipBox);
      }
      const ctx = this.ctx;
      if (this.pendingClip) {
        if (!isEmpty) {
          if (this.pendingClip === EO_CLIP) {
            ctx.clip(path, "evenodd");
          } else {
            ctx.clip(path);
          }
        }
        this.pendingClip = null;
        this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency("clipPath", opIdx);
      } else {
        this.dependencyTracker?.recordOperation(opIdx);
      }
      this.current.startNewPathAndClipBox(this.current.clipBox);
    }
    getSinglePixelWidth() {
      if (!this._cachedGetSinglePixelWidth) {
        const m = getCurrentTransform(this.ctx);
        if (m[1] === 0 && m[2] === 0) {
          this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
        } else {
          const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
          const normX = Math.hypot(m[0], m[2]);
          const normY = Math.hypot(m[1], m[3]);
          this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
        }
      }
      return this._cachedGetSinglePixelWidth;
    }
    getScaleForStroking() {
      if (this._cachedScaleForStroking[0] === -1) {
        const {
          lineWidth
        } = this.current;
        const {
          a,
          b,
          c,
          d
        } = this.ctx.getTransform();
        let scaleX, scaleY;
        if (b === 0 && c === 0) {
          const normX = Math.abs(a);
          const normY = Math.abs(d);
          if (normX === normY) {
            if (lineWidth === 0) {
              scaleX = scaleY = 1 / normX;
            } else {
              const scaledLineWidth = normX * lineWidth;
              scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
            }
          } else if (lineWidth === 0) {
            scaleX = 1 / normX;
            scaleY = 1 / normY;
          } else {
            const scaledXLineWidth = normX * lineWidth;
            const scaledYLineWidth = normY * lineWidth;
            scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
            scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
          }
        } else {
          const absDet = Math.abs(a * d - b * c);
          const normX = Math.hypot(a, b);
          const normY = Math.hypot(c, d);
          if (lineWidth === 0) {
            scaleX = normY / absDet;
            scaleY = normX / absDet;
          } else {
            const baseArea = lineWidth * absDet;
            scaleX = normY > baseArea ? normY / baseArea : 1;
            scaleY = normX > baseArea ? normX / baseArea : 1;
          }
        }
        this._cachedScaleForStroking[0] = scaleX;
        this._cachedScaleForStroking[1] = scaleY;
      }
      return this._cachedScaleForStroking;
    }
    rescaleAndStroke(path, saveRestore) {
      const {
        ctx,
        current: {
          lineWidth
        }
      } = this;
      const [scaleX, scaleY] = this.getScaleForStroking();
      if (scaleX === scaleY) {
        ctx.lineWidth = (lineWidth || 1) * scaleX;
        ctx.stroke(path);
        return;
      }
      const dashes = ctx.getLineDash();
      if (saveRestore) {
        ctx.save();
      }
      ctx.scale(scaleX, scaleY);
      SCALE_MATRIX.a = 1 / scaleX;
      SCALE_MATRIX.d = 1 / scaleY;
      const newPath = new Path2D();
      newPath.addPath(path, SCALE_MATRIX);
      if (dashes.length > 0) {
        const scale = Math.max(scaleX, scaleY);
        ctx.setLineDash(dashes.map((x) => x / scale));
        ctx.lineDashOffset /= scale;
      }
      ctx.lineWidth = lineWidth || 1;
      ctx.stroke(newPath);
      if (saveRestore) {
        ctx.restore();
      }
    }
    isContentVisible() {
      for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
        if (!this.markedContentStack[i].visible) {
          return false;
        }
      }
      return true;
    }
  }
  for (const op in OPS) {
    if (CanvasGraphics.prototype[op] !== void 0) {
      CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
    }
  }
  class GlobalWorkerOptions {
    static #port = null;
    static #src = "";
    static get workerPort() {
      return this.#port;
    }
    static set workerPort(val) {
      if (!(typeof Worker !== "undefined" && val instanceof Worker) && val !== null) {
        throw new Error("Invalid `workerPort` type.");
      }
      this.#port = val;
    }
    static get workerSrc() {
      return this.#src;
    }
    static set workerSrc(val) {
      if (typeof val !== "string") {
        throw new Error("Invalid `workerSrc` type.");
      }
      this.#src = val;
    }
  }
  class Metadata {
    #map;
    #data;
    constructor({
      parsedData,
      rawData
    }) {
      this.#map = parsedData;
      this.#data = rawData;
    }
    getRaw() {
      return this.#data;
    }
    get(name) {
      return this.#map.get(name) ?? null;
    }
    [Symbol.iterator]() {
      return this.#map.entries();
    }
  }
  const INTERNAL = Symbol("INTERNAL");
  class OptionalContentGroup {
    #isDisplay = false;
    #isPrint = false;
    #userSet = false;
    #visible = true;
    constructor(renderingIntent, {
      name,
      intent,
      usage,
      rbGroups
    }) {
      this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);
      this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
      this.name = name;
      this.intent = intent;
      this.usage = usage;
      this.rbGroups = rbGroups;
    }
    get visible() {
      if (this.#userSet) {
        return this.#visible;
      }
      if (!this.#visible) {
        return false;
      }
      const {
        print,
        view
      } = this.usage;
      if (this.#isDisplay) {
        return view?.viewState !== "OFF";
      } else if (this.#isPrint) {
        return print?.printState !== "OFF";
      }
      return true;
    }
    _setVisible(internal, visible, userSet = false) {
      if (internal !== INTERNAL) {
        unreachable("Internal method `_setVisible` called.");
      }
      this.#userSet = userSet;
      this.#visible = visible;
    }
  }
  class OptionalContentConfig {
    #cachedGetHash = null;
    #groups = /* @__PURE__ */ new Map();
    #initialHash = null;
    #order = null;
    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {
      this.renderingIntent = renderingIntent;
      this.name = null;
      this.creator = null;
      if (data === null) {
        return;
      }
      this.name = data.name;
      this.creator = data.creator;
      this.#order = data.order;
      for (const group of data.groups) {
        this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));
      }
      if (data.baseState === "OFF") {
        for (const group of this.#groups.values()) {
          group._setVisible(INTERNAL, false);
        }
      }
      for (const on of data.on) {
        this.#groups.get(on)._setVisible(INTERNAL, true);
      }
      for (const off of data.off) {
        this.#groups.get(off)._setVisible(INTERNAL, false);
      }
      this.#initialHash = this.getHash();
    }
    #evaluateVisibilityExpression(array) {
      const length = array.length;
      if (length < 2) {
        return true;
      }
      const operator = array[0];
      for (let i = 1; i < length; i++) {
        const element = array[i];
        let state;
        if (Array.isArray(element)) {
          state = this.#evaluateVisibilityExpression(element);
        } else if (this.#groups.has(element)) {
          state = this.#groups.get(element).visible;
        } else {
          warn(`Optional content group not found: ${element}`);
          return true;
        }
        switch (operator) {
          case "And":
            if (!state) {
              return false;
            }
            break;
          case "Or":
            if (state) {
              return true;
            }
            break;
          case "Not":
            return !state;
          default:
            return true;
        }
      }
      return operator === "And";
    }
    isVisible(group) {
      if (this.#groups.size === 0) {
        return true;
      }
      if (!group) {
        info("Optional content group not defined.");
        return true;
      }
      if (group.type === "OCG") {
        if (!this.#groups.has(group.id)) {
          warn(`Optional content group not found: ${group.id}`);
          return true;
        }
        return this.#groups.get(group.id).visible;
      } else if (group.type === "OCMD") {
        if (group.expression) {
          return this.#evaluateVisibilityExpression(group.expression);
        }
        if (!group.policy || group.policy === "AnyOn") {
          for (const id of group.ids) {
            if (!this.#groups.has(id)) {
              warn(`Optional content group not found: ${id}`);
              return true;
            }
            if (this.#groups.get(id).visible) {
              return true;
            }
          }
          return false;
        } else if (group.policy === "AllOn") {
          for (const id of group.ids) {
            if (!this.#groups.has(id)) {
              warn(`Optional content group not found: ${id}`);
              return true;
            }
            if (!this.#groups.get(id).visible) {
              return false;
            }
          }
          return true;
        } else if (group.policy === "AnyOff") {
          for (const id of group.ids) {
            if (!this.#groups.has(id)) {
              warn(`Optional content group not found: ${id}`);
              return true;
            }
            if (!this.#groups.get(id).visible) {
              return true;
            }
          }
          return false;
        } else if (group.policy === "AllOff") {
          for (const id of group.ids) {
            if (!this.#groups.has(id)) {
              warn(`Optional content group not found: ${id}`);
              return true;
            }
            if (this.#groups.get(id).visible) {
              return false;
            }
          }
          return true;
        }
        warn(`Unknown optional content policy ${group.policy}.`);
        return true;
      }
      warn(`Unknown group type ${group.type}.`);
      return true;
    }
    setVisibility(id, visible = true, preserveRB = true) {
      const group = this.#groups.get(id);
      if (!group) {
        warn(`Optional content group not found: ${id}`);
        return;
      }
      if (preserveRB && visible && group.rbGroups.length) {
        for (const rbGroup of group.rbGroups) {
          for (const otherId of rbGroup) {
            if (otherId !== id) {
              this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);
            }
          }
        }
      }
      group._setVisible(INTERNAL, !!visible, true);
      this.#cachedGetHash = null;
    }
    setOCGState({
      state,
      preserveRB
    }) {
      let operator;
      for (const elem of state) {
        switch (elem) {
          case "ON":
          case "OFF":
          case "Toggle":
            operator = elem;
            continue;
        }
        const group = this.#groups.get(elem);
        if (!group) {
          continue;
        }
        switch (operator) {
          case "ON":
            this.setVisibility(elem, true, preserveRB);
            break;
          case "OFF":
            this.setVisibility(elem, false, preserveRB);
            break;
          case "Toggle":
            this.setVisibility(elem, !group.visible, preserveRB);
            break;
        }
      }
      this.#cachedGetHash = null;
    }
    get hasInitialVisibility() {
      return this.#initialHash === null || this.getHash() === this.#initialHash;
    }
    getOrder() {
      if (!this.#groups.size) {
        return null;
      }
      if (this.#order) {
        return this.#order.slice();
      }
      return [...this.#groups.keys()];
    }
    getGroup(id) {
      return this.#groups.get(id) || null;
    }
    getHash() {
      if (this.#cachedGetHash !== null) {
        return this.#cachedGetHash;
      }
      const hash = new MurmurHash3_64();
      for (const [id, group] of this.#groups) {
        hash.update(`${id}:${group.visible}`);
      }
      return this.#cachedGetHash = hash.hexdigest();
    }
    [Symbol.iterator]() {
      return this.#groups.entries();
    }
  }
  class PDFDataTransportStream {
    constructor(pdfDataRangeTransport, {
      disableRange = false,
      disableStream = false
    }) {
      assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
      const {
        length,
        initialData,
        progressiveDone,
        contentDispositionFilename
      } = pdfDataRangeTransport;
      this._queuedChunks = [];
      this._progressiveDone = progressiveDone;
      this._contentDispositionFilename = contentDispositionFilename;
      if (initialData?.length > 0) {
        const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
        this._queuedChunks.push(buffer);
      }
      this._pdfDataRangeTransport = pdfDataRangeTransport;
      this._isStreamingSupported = !disableStream;
      this._isRangeSupported = !disableRange;
      this._contentLength = length;
      this._fullRequestReader = null;
      this._rangeReaders = [];
      pdfDataRangeTransport.addRangeListener((begin, chunk) => {
        this._onReceiveData({
          begin,
          chunk
        });
      });
      pdfDataRangeTransport.addProgressListener((loaded, total) => {
        this._onProgress({
          loaded,
          total
        });
      });
      pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
        this._onReceiveData({
          chunk
        });
      });
      pdfDataRangeTransport.addProgressiveDoneListener(() => {
        this._onProgressiveDone();
      });
      pdfDataRangeTransport.transportReady();
    }
    _onReceiveData({
      begin,
      chunk
    }) {
      const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
      if (begin === void 0) {
        if (this._fullRequestReader) {
          this._fullRequestReader._enqueue(buffer);
        } else {
          this._queuedChunks.push(buffer);
        }
      } else {
        const found = this._rangeReaders.some(function(rangeReader) {
          if (rangeReader._begin !== begin) {
            return false;
          }
          rangeReader._enqueue(buffer);
          return true;
        });
        assert(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
      }
    }
    get _progressiveDataLength() {
      return this._fullRequestReader?._loaded ?? 0;
    }
    _onProgress(evt) {
      if (evt.total === void 0) {
        this._rangeReaders[0]?.onProgress?.({
          loaded: evt.loaded
        });
      } else {
        this._fullRequestReader?.onProgress?.({
          loaded: evt.loaded,
          total: evt.total
        });
      }
    }
    _onProgressiveDone() {
      this._fullRequestReader?.progressiveDone();
      this._progressiveDone = true;
    }
    _removeRangeReader(reader) {
      const i = this._rangeReaders.indexOf(reader);
      if (i >= 0) {
        this._rangeReaders.splice(i, 1);
      }
    }
    getFullReader() {
      assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
      const queuedChunks = this._queuedChunks;
      this._queuedChunks = null;
      return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
    }
    getRangeReader(begin, end) {
      if (end <= this._progressiveDataLength) {
        return null;
      }
      const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
      this._pdfDataRangeTransport.requestDataRange(begin, end);
      this._rangeReaders.push(reader);
      return reader;
    }
    cancelAllRequests(reason) {
      this._fullRequestReader?.cancel(reason);
      for (const reader of this._rangeReaders.slice(0)) {
        reader.cancel(reason);
      }
      this._pdfDataRangeTransport.abort();
    }
  }
  class PDFDataTransportStreamReader {
    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
      this._stream = stream;
      this._done = progressiveDone || false;
      this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;
      this._queuedChunks = queuedChunks || [];
      this._loaded = 0;
      for (const chunk of this._queuedChunks) {
        this._loaded += chunk.byteLength;
      }
      this._requests = [];
      this._headersReady = Promise.resolve();
      stream._fullRequestReader = this;
      this.onProgress = null;
    }
    _enqueue(chunk) {
      if (this._done) {
        return;
      }
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();
        requestCapability.resolve({
          value: chunk,
          done: false
        });
      } else {
        this._queuedChunks.push(chunk);
      }
      this._loaded += chunk.byteLength;
    }
    get headersReady() {
      return this._headersReady;
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._stream._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._stream._isStreamingSupported;
    }
    get contentLength() {
      return this._stream._contentLength;
    }
    async read() {
      if (this._queuedChunks.length > 0) {
        const chunk = this._queuedChunks.shift();
        return {
          value: chunk,
          done: false
        };
      }
      if (this._done) {
        return {
          value: void 0,
          done: true
        };
      }
      const requestCapability = Promise.withResolvers();
      this._requests.push(requestCapability);
      return requestCapability.promise;
    }
    cancel(reason) {
      this._done = true;
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
    }
    progressiveDone() {
      if (this._done) {
        return;
      }
      this._done = true;
    }
  }
  class PDFDataTransportStreamRangeReader {
    constructor(stream, begin, end) {
      this._stream = stream;
      this._begin = begin;
      this._end = end;
      this._queuedChunk = null;
      this._requests = [];
      this._done = false;
      this.onProgress = null;
    }
    _enqueue(chunk) {
      if (this._done) {
        return;
      }
      if (this._requests.length === 0) {
        this._queuedChunk = chunk;
      } else {
        const requestsCapability = this._requests.shift();
        requestsCapability.resolve({
          value: chunk,
          done: false
        });
        for (const requestCapability of this._requests) {
          requestCapability.resolve({
            value: void 0,
            done: true
          });
        }
        this._requests.length = 0;
      }
      this._done = true;
      this._stream._removeRangeReader(this);
    }
    get isStreamingSupported() {
      return false;
    }
    async read() {
      if (this._queuedChunk) {
        const chunk = this._queuedChunk;
        this._queuedChunk = null;
        return {
          value: chunk,
          done: false
        };
      }
      if (this._done) {
        return {
          value: void 0,
          done: true
        };
      }
      const requestCapability = Promise.withResolvers();
      this._requests.push(requestCapability);
      return requestCapability.promise;
    }
    cancel(reason) {
      this._done = true;
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
      this._stream._removeRangeReader(this);
    }
  }
  function getFilenameFromContentDispositionHeader(contentDisposition) {
    let needsEncodingFixup = true;
    let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
    if (tmp) {
      tmp = tmp[1];
      let filename = rfc2616unquote(tmp);
      filename = unescape(filename);
      filename = rfc5987decode(filename);
      filename = rfc2047decode(filename);
      return fixupEncoding(filename);
    }
    tmp = rfc2231getparam(contentDisposition);
    if (tmp) {
      const filename = rfc2047decode(tmp);
      return fixupEncoding(filename);
    }
    tmp = toParamRegExp("filename", "i").exec(contentDisposition);
    if (tmp) {
      tmp = tmp[1];
      let filename = rfc2616unquote(tmp);
      filename = rfc2047decode(filename);
      return fixupEncoding(filename);
    }
    function toParamRegExp(attributePattern, flags) {
      return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
    }
    function textdecode(encoding, value) {
      if (encoding) {
        if (!/^[\x00-\xFF]+$/.test(value)) {
          return value;
        }
        try {
          const decoder = new TextDecoder(encoding, {
            fatal: true
          });
          const buffer = stringToBytes(value);
          value = decoder.decode(buffer);
          needsEncodingFixup = false;
        } catch {
        }
      }
      return value;
    }
    function fixupEncoding(value) {
      if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
        value = textdecode("utf-8", value);
        if (needsEncodingFixup) {
          value = textdecode("iso-8859-1", value);
        }
      }
      return value;
    }
    function rfc2231getparam(contentDispositionStr) {
      const matches = [];
      let match;
      const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
      while ((match = iter.exec(contentDispositionStr)) !== null) {
        let [, n, quot, part] = match;
        n = parseInt(n, 10);
        if (n in matches) {
          if (n === 0) {
            break;
          }
          continue;
        }
        matches[n] = [quot, part];
      }
      const parts = [];
      for (let n = 0; n < matches.length; ++n) {
        if (!(n in matches)) {
          break;
        }
        let [quot, part] = matches[n];
        part = rfc2616unquote(part);
        if (quot) {
          part = unescape(part);
          if (n === 0) {
            part = rfc5987decode(part);
          }
        }
        parts.push(part);
      }
      return parts.join("");
    }
    function rfc2616unquote(value) {
      if (value.startsWith('"')) {
        const parts = value.slice(1).split('\\"');
        for (let i = 0; i < parts.length; ++i) {
          const quotindex = parts[i].indexOf('"');
          if (quotindex !== -1) {
            parts[i] = parts[i].slice(0, quotindex);
            parts.length = i + 1;
          }
          parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
        }
        value = parts.join('"');
      }
      return value;
    }
    function rfc5987decode(extvalue) {
      const encodingend = extvalue.indexOf("'");
      if (encodingend === -1) {
        return extvalue;
      }
      const encoding = extvalue.slice(0, encodingend);
      const langvalue = extvalue.slice(encodingend + 1);
      const value = langvalue.replace(/^[^']*'/, "");
      return textdecode(encoding, value);
    }
    function rfc2047decode(value) {
      if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
        return value;
      }
      return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
        if (encoding === "q" || encoding === "Q") {
          text = text.replaceAll("_", " ");
          text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {
            return String.fromCharCode(parseInt(hex, 16));
          });
          return textdecode(charset, text);
        }
        try {
          text = atob(text);
        } catch {
        }
        return textdecode(charset, text);
      });
    }
    return "";
  }
  function createHeaders(isHttp, httpHeaders) {
    const headers = new Headers();
    if (!isHttp || !httpHeaders || typeof httpHeaders !== "object") {
      return headers;
    }
    for (const key in httpHeaders) {
      const val = httpHeaders[key];
      if (val !== void 0) {
        headers.append(key, val);
      }
    }
    return headers;
  }
  function getResponseOrigin(url) {
    return URL.parse(url)?.origin ?? null;
  }
  function validateRangeRequestCapabilities({
    responseHeaders,
    isHttp,
    rangeChunkSize,
    disableRange
  }) {
    const returnValues = {
      allowRangeRequests: false,
      suggestedLength: void 0
    };
    const length = parseInt(responseHeaders.get("Content-Length"), 10);
    if (!Number.isInteger(length)) {
      return returnValues;
    }
    returnValues.suggestedLength = length;
    if (length <= 2 * rangeChunkSize) {
      return returnValues;
    }
    if (disableRange || !isHttp) {
      return returnValues;
    }
    if (responseHeaders.get("Accept-Ranges") !== "bytes") {
      return returnValues;
    }
    const contentEncoding = responseHeaders.get("Content-Encoding") || "identity";
    if (contentEncoding !== "identity") {
      return returnValues;
    }
    returnValues.allowRangeRequests = true;
    return returnValues;
  }
  function extractFilenameFromHeader(responseHeaders) {
    const contentDisposition = responseHeaders.get("Content-Disposition");
    if (contentDisposition) {
      let filename = getFilenameFromContentDispositionHeader(contentDisposition);
      if (filename.includes("%")) {
        try {
          filename = decodeURIComponent(filename);
        } catch {
        }
      }
      if (isPdfFile(filename)) {
        return filename;
      }
    }
    return null;
  }
  function createResponseError(status, url) {
    return new ResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status, status === 404 || status === 0 && url.startsWith("file:"));
  }
  function validateResponseStatus(status) {
    return status === 200 || status === 206;
  }
  function createFetchOptions(headers, withCredentials, abortController) {
    return {
      method: "GET",
      headers,
      signal: abortController.signal,
      mode: "cors",
      credentials: withCredentials ? "include" : "same-origin",
      redirect: "follow"
    };
  }
  function getArrayBuffer(val) {
    if (val instanceof Uint8Array) {
      return val.buffer;
    }
    if (val instanceof ArrayBuffer) {
      return val;
    }
    warn(`getArrayBuffer - unexpected data format: ${val}`);
    return new Uint8Array(val).buffer;
  }
  class PDFFetchStream {
    _responseOrigin = null;
    constructor(source) {
      this.source = source;
      this.isHttp = /^https?:/i.test(source.url);
      this.headers = createHeaders(this.isHttp, source.httpHeaders);
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
      assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
      this._fullRequestReader = new PDFFetchStreamReader(this);
      return this._fullRequestReader;
    }
    getRangeReader(begin, end) {
      if (end <= this._progressiveDataLength) {
        return null;
      }
      const reader = new PDFFetchStreamRangeReader(this, begin, end);
      this._rangeRequestReaders.push(reader);
      return reader;
    }
    cancelAllRequests(reason) {
      this._fullRequestReader?.cancel(reason);
      for (const reader of this._rangeRequestReaders.slice(0)) {
        reader.cancel(reason);
      }
    }
  }
  class PDFFetchStreamReader {
    constructor(stream) {
      this._stream = stream;
      this._reader = null;
      this._loaded = 0;
      this._filename = null;
      const source = stream.source;
      this._withCredentials = source.withCredentials || false;
      this._contentLength = source.length;
      this._headersCapability = Promise.withResolvers();
      this._disableRange = source.disableRange || false;
      this._rangeChunkSize = source.rangeChunkSize;
      if (!this._rangeChunkSize && !this._disableRange) {
        this._disableRange = true;
      }
      this._abortController = new AbortController();
      this._isStreamingSupported = !source.disableStream;
      this._isRangeSupported = !source.disableRange;
      const headers = new Headers(stream.headers);
      const url = source.url;
      fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
        stream._responseOrigin = getResponseOrigin(response.url);
        if (!validateResponseStatus(response.status)) {
          throw createResponseError(response.status, url);
        }
        this._reader = response.body.getReader();
        this._headersCapability.resolve();
        const responseHeaders = response.headers;
        const {
          allowRangeRequests,
          suggestedLength
        } = validateRangeRequestCapabilities({
          responseHeaders,
          isHttp: stream.isHttp,
          rangeChunkSize: this._rangeChunkSize,
          disableRange: this._disableRange
        });
        this._isRangeSupported = allowRangeRequests;
        this._contentLength = suggestedLength || this._contentLength;
        this._filename = extractFilenameFromHeader(responseHeaders);
        if (!this._isStreamingSupported && this._isRangeSupported) {
          this.cancel(new AbortException("Streaming is disabled."));
        }
      }).catch(this._headersCapability.reject);
      this.onProgress = null;
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      await this._headersCapability.promise;
      const {
        value,
        done
      } = await this._reader.read();
      if (done) {
        return {
          value,
          done
        };
      }
      this._loaded += value.byteLength;
      this.onProgress?.({
        loaded: this._loaded,
        total: this._contentLength
      });
      return {
        value: getArrayBuffer(value),
        done: false
      };
    }
    cancel(reason) {
      this._reader?.cancel(reason);
      this._abortController.abort();
    }
  }
  class PDFFetchStreamRangeReader {
    constructor(stream, begin, end) {
      this._stream = stream;
      this._reader = null;
      this._loaded = 0;
      const source = stream.source;
      this._withCredentials = source.withCredentials || false;
      this._readCapability = Promise.withResolvers();
      this._isStreamingSupported = !source.disableStream;
      this._abortController = new AbortController();
      const headers = new Headers(stream.headers);
      headers.append("Range", `bytes=${begin}-${end - 1}`);
      const url = source.url;
      fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
        const responseOrigin = getResponseOrigin(response.url);
        if (responseOrigin !== stream._responseOrigin) {
          throw new Error(`Expected range response-origin "${responseOrigin}" to match "${stream._responseOrigin}".`);
        }
        if (!validateResponseStatus(response.status)) {
          throw createResponseError(response.status, url);
        }
        this._readCapability.resolve();
        this._reader = response.body.getReader();
      }).catch(this._readCapability.reject);
      this.onProgress = null;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      await this._readCapability.promise;
      const {
        value,
        done
      } = await this._reader.read();
      if (done) {
        return {
          value,
          done
        };
      }
      this._loaded += value.byteLength;
      this.onProgress?.({
        loaded: this._loaded
      });
      return {
        value: getArrayBuffer(value),
        done: false
      };
    }
    cancel(reason) {
      this._reader?.cancel(reason);
      this._abortController.abort();
    }
  }
  const OK_RESPONSE = 200;
  const PARTIAL_CONTENT_RESPONSE = 206;
  function network_getArrayBuffer(xhr) {
    const data = xhr.response;
    if (typeof data !== "string") {
      return data;
    }
    return stringToBytes(data).buffer;
  }
  class NetworkManager {
    _responseOrigin = null;
    constructor({
      url,
      httpHeaders,
      withCredentials
    }) {
      this.url = url;
      this.isHttp = /^https?:/i.test(url);
      this.headers = createHeaders(this.isHttp, httpHeaders);
      this.withCredentials = withCredentials || false;
      this.currXhrId = 0;
      this.pendingRequests = /* @__PURE__ */ Object.create(null);
    }
    request(args) {
      const xhr = new XMLHttpRequest();
      const xhrId = this.currXhrId++;
      const pendingRequest = this.pendingRequests[xhrId] = {
        xhr
      };
      xhr.open("GET", this.url);
      xhr.withCredentials = this.withCredentials;
      for (const [key, val] of this.headers) {
        xhr.setRequestHeader(key, val);
      }
      if (this.isHttp && "begin" in args && "end" in args) {
        xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
        pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
      } else {
        pendingRequest.expectedStatus = OK_RESPONSE;
      }
      xhr.responseType = "arraybuffer";
      assert(args.onError, "Expected `onError` callback to be provided.");
      xhr.onerror = () => {
        args.onError(xhr.status);
      };
      xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
      xhr.onprogress = this.onProgress.bind(this, xhrId);
      pendingRequest.onHeadersReceived = args.onHeadersReceived;
      pendingRequest.onDone = args.onDone;
      pendingRequest.onError = args.onError;
      pendingRequest.onProgress = args.onProgress;
      xhr.send(null);
      return xhrId;
    }
    onProgress(xhrId, evt) {
      const pendingRequest = this.pendingRequests[xhrId];
      if (!pendingRequest) {
        return;
      }
      pendingRequest.onProgress?.(evt);
    }
    onStateChange(xhrId, evt) {
      const pendingRequest = this.pendingRequests[xhrId];
      if (!pendingRequest) {
        return;
      }
      const xhr = pendingRequest.xhr;
      if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
        pendingRequest.onHeadersReceived();
        delete pendingRequest.onHeadersReceived;
      }
      if (xhr.readyState !== 4) {
        return;
      }
      if (!(xhrId in this.pendingRequests)) {
        return;
      }
      delete this.pendingRequests[xhrId];
      if (xhr.status === 0 && this.isHttp) {
        pendingRequest.onError(xhr.status);
        return;
      }
      const xhrStatus = xhr.status || OK_RESPONSE;
      const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
      if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
        pendingRequest.onError(xhr.status);
        return;
      }
      const chunk = network_getArrayBuffer(xhr);
      if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
        const rangeHeader = xhr.getResponseHeader("Content-Range");
        const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
        if (matches) {
          pendingRequest.onDone({
            begin: parseInt(matches[1], 10),
            chunk
          });
        } else {
          warn(`Missing or invalid "Content-Range" header.`);
          pendingRequest.onError(0);
        }
      } else if (chunk) {
        pendingRequest.onDone({
          begin: 0,
          chunk
        });
      } else {
        pendingRequest.onError(xhr.status);
      }
    }
    getRequestXhr(xhrId) {
      return this.pendingRequests[xhrId].xhr;
    }
    isPendingRequest(xhrId) {
      return xhrId in this.pendingRequests;
    }
    abortRequest(xhrId) {
      const xhr = this.pendingRequests[xhrId].xhr;
      delete this.pendingRequests[xhrId];
      xhr.abort();
    }
  }
  class PDFNetworkStream {
    constructor(source) {
      this._source = source;
      this._manager = new NetworkManager(source);
      this._rangeChunkSize = source.rangeChunkSize;
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }
    _onRangeRequestReaderClosed(reader) {
      const i = this._rangeRequestReaders.indexOf(reader);
      if (i >= 0) {
        this._rangeRequestReaders.splice(i, 1);
      }
    }
    getFullReader() {
      assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
      this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
      return this._fullRequestReader;
    }
    getRangeReader(begin, end) {
      const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
      reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
      this._rangeRequestReaders.push(reader);
      return reader;
    }
    cancelAllRequests(reason) {
      this._fullRequestReader?.cancel(reason);
      for (const reader of this._rangeRequestReaders.slice(0)) {
        reader.cancel(reason);
      }
    }
  }
  class PDFNetworkStreamFullRequestReader {
    constructor(manager, source) {
      this._manager = manager;
      this._url = source.url;
      this._fullRequestId = manager.request({
        onHeadersReceived: this._onHeadersReceived.bind(this),
        onDone: this._onDone.bind(this),
        onError: this._onError.bind(this),
        onProgress: this._onProgress.bind(this)
      });
      this._headersCapability = Promise.withResolvers();
      this._disableRange = source.disableRange || false;
      this._contentLength = source.length;
      this._rangeChunkSize = source.rangeChunkSize;
      if (!this._rangeChunkSize && !this._disableRange) {
        this._disableRange = true;
      }
      this._isStreamingSupported = false;
      this._isRangeSupported = false;
      this._cachedChunks = [];
      this._requests = [];
      this._done = false;
      this._storedError = void 0;
      this._filename = null;
      this.onProgress = null;
    }
    _onHeadersReceived() {
      const fullRequestXhrId = this._fullRequestId;
      const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
      this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);
      const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();
      const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((x) => {
        const [key, ...val] = x.split(": ");
        return [key, val.join(": ")];
      }) : []);
      const {
        allowRangeRequests,
        suggestedLength
      } = validateRangeRequestCapabilities({
        responseHeaders,
        isHttp: this._manager.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      if (allowRangeRequests) {
        this._isRangeSupported = true;
      }
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = extractFilenameFromHeader(responseHeaders);
      if (this._isRangeSupported) {
        this._manager.abortRequest(fullRequestXhrId);
      }
      this._headersCapability.resolve();
    }
    _onDone(data) {
      if (data) {
        if (this._requests.length > 0) {
          const requestCapability = this._requests.shift();
          requestCapability.resolve({
            value: data.chunk,
            done: false
          });
        } else {
          this._cachedChunks.push(data.chunk);
        }
      }
      this._done = true;
      if (this._cachedChunks.length > 0) {
        return;
      }
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
    }
    _onError(status) {
      this._storedError = createResponseError(status, this._url);
      this._headersCapability.reject(this._storedError);
      for (const requestCapability of this._requests) {
        requestCapability.reject(this._storedError);
      }
      this._requests.length = 0;
      this._cachedChunks.length = 0;
    }
    _onProgress(evt) {
      this.onProgress?.({
        loaded: evt.loaded,
        total: evt.lengthComputable ? evt.total : this._contentLength
      });
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    get contentLength() {
      return this._contentLength;
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    async read() {
      await this._headersCapability.promise;
      if (this._storedError) {
        throw this._storedError;
      }
      if (this._cachedChunks.length > 0) {
        const chunk = this._cachedChunks.shift();
        return {
          value: chunk,
          done: false
        };
      }
      if (this._done) {
        return {
          value: void 0,
          done: true
        };
      }
      const requestCapability = Promise.withResolvers();
      this._requests.push(requestCapability);
      return requestCapability.promise;
    }
    cancel(reason) {
      this._done = true;
      this._headersCapability.reject(reason);
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
      if (this._manager.isPendingRequest(this._fullRequestId)) {
        this._manager.abortRequest(this._fullRequestId);
      }
      this._fullRequestReader = null;
    }
  }
  class PDFNetworkStreamRangeRequestReader {
    constructor(manager, begin, end) {
      this._manager = manager;
      this._url = manager.url;
      this._requestId = manager.request({
        begin,
        end,
        onHeadersReceived: this._onHeadersReceived.bind(this),
        onDone: this._onDone.bind(this),
        onError: this._onError.bind(this),
        onProgress: this._onProgress.bind(this)
      });
      this._requests = [];
      this._queuedChunk = null;
      this._done = false;
      this._storedError = void 0;
      this.onProgress = null;
      this.onClosed = null;
    }
    _onHeadersReceived() {
      const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);
      if (responseOrigin !== this._manager._responseOrigin) {
        this._storedError = new Error(`Expected range response-origin "${responseOrigin}" to match "${this._manager._responseOrigin}".`);
        this._onError(0);
      }
    }
    _close() {
      this.onClosed?.(this);
    }
    _onDone(data) {
      const chunk = data.chunk;
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();
        requestCapability.resolve({
          value: chunk,
          done: false
        });
      } else {
        this._queuedChunk = chunk;
      }
      this._done = true;
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
      this._close();
    }
    _onError(status) {
      this._storedError ??= createResponseError(status, this._url);
      for (const requestCapability of this._requests) {
        requestCapability.reject(this._storedError);
      }
      this._requests.length = 0;
      this._queuedChunk = null;
    }
    _onProgress(evt) {
      if (!this.isStreamingSupported) {
        this.onProgress?.({
          loaded: evt.loaded
        });
      }
    }
    get isStreamingSupported() {
      return false;
    }
    async read() {
      if (this._storedError) {
        throw this._storedError;
      }
      if (this._queuedChunk !== null) {
        const chunk = this._queuedChunk;
        this._queuedChunk = null;
        return {
          value: chunk,
          done: false
        };
      }
      if (this._done) {
        return {
          value: void 0,
          done: true
        };
      }
      const requestCapability = Promise.withResolvers();
      this._requests.push(requestCapability);
      return requestCapability.promise;
    }
    cancel(reason) {
      this._done = true;
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
      if (this._manager.isPendingRequest(this._requestId)) {
        this._manager.abortRequest(this._requestId);
      }
      this._close();
    }
  }
  const urlRegex = /^[a-z][a-z0-9\-+.]+:/i;
  function parseUrlOrPath(sourceUrl) {
    if (urlRegex.test(sourceUrl)) {
      return new URL(sourceUrl);
    }
    const url = process.getBuiltinModule("url");
    return new URL(url.pathToFileURL(sourceUrl));
  }
  class PDFNodeStream {
    constructor(source) {
      this.source = source;
      this.url = parseUrlOrPath(source.url);
      assert(this.url.protocol === "file:", "PDFNodeStream only supports file:// URLs.");
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
      assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
      this._fullRequestReader = new PDFNodeStreamFsFullReader(this);
      return this._fullRequestReader;
    }
    getRangeReader(start, end) {
      if (end <= this._progressiveDataLength) {
        return null;
      }
      const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);
      this._rangeRequestReaders.push(rangeReader);
      return rangeReader;
    }
    cancelAllRequests(reason) {
      this._fullRequestReader?.cancel(reason);
      for (const reader of this._rangeRequestReaders.slice(0)) {
        reader.cancel(reason);
      }
    }
  }
  class PDFNodeStreamFsFullReader {
    constructor(stream) {
      this._url = stream.url;
      this._done = false;
      this._storedError = null;
      this.onProgress = null;
      const source = stream.source;
      this._contentLength = source.length;
      this._loaded = 0;
      this._filename = null;
      this._disableRange = source.disableRange || false;
      this._rangeChunkSize = source.rangeChunkSize;
      if (!this._rangeChunkSize && !this._disableRange) {
        this._disableRange = true;
      }
      this._isStreamingSupported = !source.disableStream;
      this._isRangeSupported = !source.disableRange;
      this._readableStream = null;
      this._readCapability = Promise.withResolvers();
      this._headersCapability = Promise.withResolvers();
      const fs = process.getBuiltinModule("fs");
      fs.promises.lstat(this._url).then((stat) => {
        this._contentLength = stat.size;
        this._setReadableStream(fs.createReadStream(this._url));
        this._headersCapability.resolve();
      }, (error) => {
        if (error.code === "ENOENT") {
          error = createResponseError(0, this._url.href);
        }
        this._storedError = error;
        this._headersCapability.reject(error);
      });
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      await this._readCapability.promise;
      if (this._done) {
        return {
          value: void 0,
          done: true
        };
      }
      if (this._storedError) {
        throw this._storedError;
      }
      const chunk = this._readableStream.read();
      if (chunk === null) {
        this._readCapability = Promise.withResolvers();
        return this.read();
      }
      this._loaded += chunk.length;
      this.onProgress?.({
        loaded: this._loaded,
        total: this._contentLength
      });
      const buffer = new Uint8Array(chunk).buffer;
      return {
        value: buffer,
        done: false
      };
    }
    cancel(reason) {
      if (!this._readableStream) {
        this._error(reason);
        return;
      }
      this._readableStream.destroy(reason);
    }
    _error(reason) {
      this._storedError = reason;
      this._readCapability.resolve();
    }
    _setReadableStream(readableStream) {
      this._readableStream = readableStream;
      readableStream.on("readable", () => {
        this._readCapability.resolve();
      });
      readableStream.on("end", () => {
        readableStream.destroy();
        this._done = true;
        this._readCapability.resolve();
      });
      readableStream.on("error", (reason) => {
        this._error(reason);
      });
      if (!this._isStreamingSupported && this._isRangeSupported) {
        this._error(new AbortException("streaming is disabled"));
      }
      if (this._storedError) {
        this._readableStream.destroy(this._storedError);
      }
    }
  }
  class PDFNodeStreamFsRangeReader {
    constructor(stream, start, end) {
      this._url = stream.url;
      this._done = false;
      this._storedError = null;
      this.onProgress = null;
      this._loaded = 0;
      this._readableStream = null;
      this._readCapability = Promise.withResolvers();
      const source = stream.source;
      this._isStreamingSupported = !source.disableStream;
      const fs = process.getBuiltinModule("fs");
      this._setReadableStream(fs.createReadStream(this._url, {
        start,
        end: end - 1
      }));
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      await this._readCapability.promise;
      if (this._done) {
        return {
          value: void 0,
          done: true
        };
      }
      if (this._storedError) {
        throw this._storedError;
      }
      const chunk = this._readableStream.read();
      if (chunk === null) {
        this._readCapability = Promise.withResolvers();
        return this.read();
      }
      this._loaded += chunk.length;
      this.onProgress?.({
        loaded: this._loaded
      });
      const buffer = new Uint8Array(chunk).buffer;
      return {
        value: buffer,
        done: false
      };
    }
    cancel(reason) {
      if (!this._readableStream) {
        this._error(reason);
        return;
      }
      this._readableStream.destroy(reason);
    }
    _error(reason) {
      this._storedError = reason;
      this._readCapability.resolve();
    }
    _setReadableStream(readableStream) {
      this._readableStream = readableStream;
      readableStream.on("readable", () => {
        this._readCapability.resolve();
      });
      readableStream.on("end", () => {
        readableStream.destroy();
        this._done = true;
        this._readCapability.resolve();
      });
      readableStream.on("error", (reason) => {
        this._error(reason);
      });
      if (this._storedError) {
        this._readableStream.destroy(this._storedError);
      }
    }
  }
  const INITIAL_DATA = Symbol("INITIAL_DATA");
  class PDFObjects {
    #objs = /* @__PURE__ */ Object.create(null);
    #ensureObj(objId) {
      return this.#objs[objId] ||= {
        ...Promise.withResolvers(),
        data: INITIAL_DATA
      };
    }
    get(objId, callback = null) {
      if (callback) {
        const obj2 = this.#ensureObj(objId);
        obj2.promise.then(() => callback(obj2.data));
        return null;
      }
      const obj = this.#objs[objId];
      if (!obj || obj.data === INITIAL_DATA) {
        throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
      }
      return obj.data;
    }
    has(objId) {
      const obj = this.#objs[objId];
      return !!obj && obj.data !== INITIAL_DATA;
    }
    delete(objId) {
      const obj = this.#objs[objId];
      if (!obj || obj.data === INITIAL_DATA) {
        return false;
      }
      delete this.#objs[objId];
      return true;
    }
    resolve(objId, data = null) {
      const obj = this.#ensureObj(objId);
      obj.data = data;
      obj.resolve();
    }
    clear() {
      for (const objId in this.#objs) {
        const {
          data
        } = this.#objs[objId];
        data?.bitmap?.close();
      }
      this.#objs = /* @__PURE__ */ Object.create(null);
    }
    *[Symbol.iterator]() {
      for (const objId in this.#objs) {
        const {
          data
        } = this.#objs[objId];
        if (data === INITIAL_DATA) {
          continue;
        }
        yield [objId, data];
      }
    }
  }
  const MAX_TEXT_DIVS_TO_RENDER = 1e5;
  const DEFAULT_FONT_SIZE = 30;
  class TextLayer {
    #capability = Promise.withResolvers();
    #container = null;
    #disableProcessItems = false;
    #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
    #lang = null;
    #layoutTextParams = null;
    #pageHeight = 0;
    #pageWidth = 0;
    #reader = null;
    #rootContainer = null;
    #rotation = 0;
    #scale = 0;
    #styleCache = /* @__PURE__ */ Object.create(null);
    #textContentItemsStr = [];
    #textContentSource = null;
    #textDivs = [];
    #textDivProperties = /* @__PURE__ */ new WeakMap();
    #transform = null;
    static #ascentCache = /* @__PURE__ */ new Map();
    static #canvasContexts = /* @__PURE__ */ new Map();
    static #canvasCtxFonts = /* @__PURE__ */ new WeakMap();
    static #minFontSize = null;
    static #pendingTextLayers = /* @__PURE__ */ new Set();
    constructor({
      textContentSource,
      container,
      viewport
    }) {
      if (textContentSource instanceof ReadableStream) {
        this.#textContentSource = textContentSource;
      } else if (typeof textContentSource === "object") {
        this.#textContentSource = new ReadableStream({
          start(controller) {
            controller.enqueue(textContentSource);
            controller.close();
          }
        });
      } else {
        throw new Error('No "textContentSource" parameter specified.');
      }
      this.#container = this.#rootContainer = container;
      this.#scale = viewport.scale * OutputScale.pixelRatio;
      this.#rotation = viewport.rotation;
      this.#layoutTextParams = {
        div: null,
        properties: null,
        ctx: null
      };
      const {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      } = viewport.rawDims;
      this.#transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
      this.#pageWidth = pageWidth;
      this.#pageHeight = pageHeight;
      TextLayer.#ensureMinFontSizeComputed();
      setLayerDimensions(container, viewport);
      this.#capability.promise.finally(() => {
        TextLayer.#pendingTextLayers.delete(this);
        this.#layoutTextParams = null;
        this.#styleCache = null;
      }).catch(() => {
      });
    }
    static get fontFamilyMap() {
      const {
        isWindows,
        isFirefox
      } = util_FeatureTest.platform;
      return shadow(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", `${isWindows && isFirefox ? "Calibri, " : ""}sans-serif`], ["monospace", `${isWindows && isFirefox ? "Lucida Console, " : ""}monospace`]]));
    }
    render() {
      const pump = () => {
        this.#reader.read().then(({
          value,
          done
        }) => {
          if (done) {
            this.#capability.resolve();
            return;
          }
          this.#lang ??= value.lang;
          Object.assign(this.#styleCache, value.styles);
          this.#processItems(value.items);
          pump();
        }, this.#capability.reject);
      };
      this.#reader = this.#textContentSource.getReader();
      TextLayer.#pendingTextLayers.add(this);
      pump();
      return this.#capability.promise;
    }
    update({
      viewport,
      onBefore = null
    }) {
      const scale = viewport.scale * OutputScale.pixelRatio;
      const rotation = viewport.rotation;
      if (rotation !== this.#rotation) {
        onBefore?.();
        this.#rotation = rotation;
        setLayerDimensions(this.#rootContainer, {
          rotation
        });
      }
      if (scale !== this.#scale) {
        onBefore?.();
        this.#scale = scale;
        const params = {
          div: null,
          properties: null,
          ctx: TextLayer.#getCtx(this.#lang)
        };
        for (const div of this.#textDivs) {
          params.properties = this.#textDivProperties.get(div);
          params.div = div;
          this.#layout(params);
        }
      }
    }
    cancel() {
      const abortEx = new AbortException("TextLayer task cancelled.");
      this.#reader?.cancel(abortEx).catch(() => {
      });
      this.#reader = null;
      this.#capability.reject(abortEx);
    }
    get textDivs() {
      return this.#textDivs;
    }
    get textContentItemsStr() {
      return this.#textContentItemsStr;
    }
    #processItems(items) {
      if (this.#disableProcessItems) {
        return;
      }
      this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);
      const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;
      for (const item of items) {
        if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {
          warn("Ignoring additional textDivs for performance reasons.");
          this.#disableProcessItems = true;
          return;
        }
        if (item.str === void 0) {
          if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
            const parent = this.#container;
            this.#container = document.createElement("span");
            this.#container.classList.add("markedContent");
            if (item.id) {
              this.#container.setAttribute("id", `${item.id}`);
            }
            parent.append(this.#container);
          } else if (item.type === "endMarkedContent") {
            this.#container = this.#container.parentNode;
          }
          continue;
        }
        textContentItemsStr.push(item.str);
        this.#appendText(item);
      }
    }
    #appendText(geom) {
      const textDiv = document.createElement("span");
      const textDivProperties = {
        angle: 0,
        canvasWidth: 0,
        hasText: geom.str !== "",
        hasEOL: geom.hasEOL,
        fontSize: 0
      };
      this.#textDivs.push(textDiv);
      const tx = Util.transform(this.#transform, geom.transform);
      let angle = Math.atan2(tx[1], tx[0]);
      const style = this.#styleCache[geom.fontName];
      if (style.vertical) {
        angle += Math.PI / 2;
      }
      let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;
      fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;
      const fontHeight = Math.hypot(tx[2], tx[3]);
      const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, style, this.#lang);
      let left, top;
      if (angle === 0) {
        left = tx[4];
        top = tx[5] - fontAscent;
      } else {
        left = tx[4] + fontAscent * Math.sin(angle);
        top = tx[5] - fontAscent * Math.cos(angle);
      }
      const scaleFactorStr = "calc(var(--total-scale-factor) *";
      const divStyle = textDiv.style;
      if (this.#container === this.#rootContainer) {
        divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;
        divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;
      } else {
        divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
        divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
      }
      divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;
      divStyle.fontFamily = fontFamily;
      textDivProperties.fontSize = fontHeight;
      textDiv.setAttribute("role", "presentation");
      textDiv.textContent = geom.str;
      textDiv.dir = geom.dir;
      if (this.#fontInspectorEnabled) {
        textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;
      }
      if (angle !== 0) {
        textDivProperties.angle = angle * (180 / Math.PI);
      }
      let shouldScaleText = false;
      if (geom.str.length > 1) {
        shouldScaleText = true;
      } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
        const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
        if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
          shouldScaleText = true;
        }
      }
      if (shouldScaleText) {
        textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
      }
      this.#textDivProperties.set(textDiv, textDivProperties);
      this.#layoutTextParams.div = textDiv;
      this.#layoutTextParams.properties = textDivProperties;
      this.#layout(this.#layoutTextParams);
      if (textDivProperties.hasText) {
        this.#container.append(textDiv);
      }
      if (textDivProperties.hasEOL) {
        const br = document.createElement("br");
        br.setAttribute("role", "presentation");
        this.#container.append(br);
      }
    }
    #layout(params) {
      const {
        div,
        properties,
        ctx
      } = params;
      const {
        style
      } = div;
      let transform = "";
      if (TextLayer.#minFontSize > 1) {
        transform = `scale(${1 / TextLayer.#minFontSize})`;
      }
      if (properties.canvasWidth !== 0 && properties.hasText) {
        const {
          fontFamily
        } = style;
        const {
          canvasWidth,
          fontSize
        } = properties;
        TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);
        const {
          width
        } = ctx.measureText(div.textContent);
        if (width > 0) {
          transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;
        }
      }
      if (properties.angle !== 0) {
        transform = `rotate(${properties.angle}deg) ${transform}`;
      }
      if (transform.length > 0) {
        style.transform = transform;
      }
    }
    static cleanup() {
      if (this.#pendingTextLayers.size > 0) {
        return;
      }
      this.#ascentCache.clear();
      for (const {
        canvas
      } of this.#canvasContexts.values()) {
        canvas.remove();
      }
      this.#canvasContexts.clear();
    }
    static #getCtx(lang = null) {
      let ctx = this.#canvasContexts.get(lang ||= "");
      if (!ctx) {
        const canvas = document.createElement("canvas");
        canvas.className = "hiddenCanvasElement";
        canvas.lang = lang;
        document.body.append(canvas);
        ctx = canvas.getContext("2d", {
          alpha: false,
          willReadFrequently: true
        });
        this.#canvasContexts.set(lang, ctx);
        this.#canvasCtxFonts.set(ctx, {
          size: 0,
          family: ""
        });
      }
      return ctx;
    }
    static #ensureCtxFont(ctx, size, family) {
      const cached = this.#canvasCtxFonts.get(ctx);
      if (size === cached.size && family === cached.family) {
        return;
      }
      ctx.font = `${size}px ${family}`;
      cached.size = size;
      cached.family = family;
    }
    static #ensureMinFontSizeComputed() {
      if (this.#minFontSize !== null) {
        return;
      }
      const div = document.createElement("div");
      div.style.opacity = 0;
      div.style.lineHeight = 1;
      div.style.fontSize = "1px";
      div.style.position = "absolute";
      div.textContent = "X";
      document.body.append(div);
      this.#minFontSize = div.getBoundingClientRect().height;
      div.remove();
    }
    static #getAscent(fontFamily, style, lang) {
      const cachedAscent = this.#ascentCache.get(fontFamily);
      if (cachedAscent) {
        return cachedAscent;
      }
      const ctx = this.#getCtx(lang);
      ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;
      this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);
      const metrics = ctx.measureText("");
      const ascent = metrics.fontBoundingBoxAscent;
      const descent = Math.abs(metrics.fontBoundingBoxDescent);
      ctx.canvas.width = ctx.canvas.height = 0;
      let ratio = 0.8;
      if (ascent) {
        ratio = ascent / (ascent + descent);
      } else {
        if (util_FeatureTest.platform.isFirefox) {
          warn("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering.");
        }
        if (style.ascent) {
          ratio = style.ascent;
        } else if (style.descent) {
          ratio = 1 + style.descent;
        }
      }
      this.#ascentCache.set(fontFamily, ratio);
      return ratio;
    }
  }
  class XfaText {
    static textContent(xfa) {
      const items = [];
      const output = {
        items,
        styles: /* @__PURE__ */ Object.create(null)
      };
      function walk(node) {
        if (!node) {
          return;
        }
        let str = null;
        const name = node.name;
        if (name === "#text") {
          str = node.value;
        } else if (!XfaText.shouldBuildText(name)) {
          return;
        } else if (node?.attributes?.textContent) {
          str = node.attributes.textContent;
        } else if (node.value) {
          str = node.value;
        }
        if (str !== null) {
          items.push({
            str
          });
        }
        if (!node.children) {
          return;
        }
        for (const child of node.children) {
          walk(child);
        }
      }
      walk(xfa);
      return output;
    }
    static shouldBuildText(name) {
      return !(name === "textarea" || name === "input" || name === "option" || name === "select");
    }
  }
  const RENDERING_CANCELLED_TIMEOUT = 100;
  function getDocument(src = {}) {
    if (typeof src === "string" || src instanceof URL) {
      src = {
        url: src
      };
    } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {
      src = {
        data: src
      };
    }
    const task = new PDFDocumentLoadingTask();
    const {
      docId
    } = task;
    const url = src.url ? getUrlProp(src.url) : null;
    const data = src.data ? getDataProp(src.data) : null;
    const httpHeaders = src.httpHeaders || null;
    const withCredentials = src.withCredentials === true;
    const password = src.password ?? null;
    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;
    let worker = src.worker instanceof PDFWorker ? src.worker : null;
    const verbosity2 = src.verbosity;
    const docBaseUrl = typeof src.docBaseUrl === "string" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;
    const cMapUrl = getFactoryUrlProp(src.cMapUrl);
    const cMapPacked = src.cMapPacked !== false;
    const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);
    const iccUrl = getFactoryUrlProp(src.iccUrl);
    const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);
    const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);
    const wasmUrl = getFactoryUrlProp(src.wasmUrl);
    const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);
    const ignoreErrors = src.stopAtErrors !== true;
    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
    const isEvalSupported2 = src.isEvalSupported !== false;
    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !isNodeJS;
    const isImageDecoderSupported = typeof src.isImageDecoderSupported === "boolean" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);
    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
    const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
    const fontExtraProperties = src.fontExtraProperties === true;
    const enableXfa = src.enableXfa === true;
    const ownerDocument = src.ownerDocument || globalThis.document;
    const disableRange = src.disableRange === true;
    const disableStream = src.disableStream === true;
    const disableAutoFetch = src.disableAutoFetch === true;
    const pdfBug = src.pdfBug === true;
    const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);
    const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);
    const enableHWA = src.enableHWA === true;
    const useWasm = src.useWasm !== false;
    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
    const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !isNodeJS && !disableFontFace;
    const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));
    const styleElement = null;
    setVerbosityLevel(verbosity2);
    const transportFactory = {
      canvasFactory: new CanvasFactory({
        ownerDocument,
        enableHWA
      }),
      filterFactory: new FilterFactory({
        docId,
        ownerDocument
      }),
      cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({
        baseUrl: cMapUrl,
        isCompressed: cMapPacked
      }),
      standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({
        baseUrl: standardFontDataUrl
      }),
      wasmFactory: useWorkerFetch ? null : new WasmFactory({
        baseUrl: wasmUrl
      })
    };
    if (!worker) {
      worker = PDFWorker.create({
        verbosity: verbosity2,
        port: GlobalWorkerOptions.workerPort
      });
      task._worker = worker;
    }
    const docParams = {
      docId,
      apiVersion: "5.4.149",
      data,
      password,
      disableAutoFetch,
      rangeChunkSize,
      length,
      docBaseUrl,
      enableXfa,
      evaluatorOptions: {
        maxImageSize,
        disableFontFace,
        ignoreErrors,
        isEvalSupported: isEvalSupported2,
        isOffscreenCanvasSupported,
        isImageDecoderSupported,
        canvasMaxAreaInBytes,
        fontExtraProperties,
        useSystemFonts,
        useWasm,
        useWorkerFetch,
        cMapUrl,
        iccUrl,
        standardFontDataUrl,
        wasmUrl
      }
    };
    const transportParams = {
      ownerDocument,
      pdfBug,
      styleElement,
      loadingParams: {
        disableAutoFetch,
        enableXfa
      }
    };
    worker.promise.then(function() {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }
      if (worker.destroyed) {
        throw new Error("Worker was destroyed");
      }
      const workerIdPromise = worker.messageHandler.sendWithPromise("GetDocRequest", docParams, data ? [data.buffer] : null);
      let networkStream;
      if (rangeTransport) {
        networkStream = new PDFDataTransportStream(rangeTransport, {
          disableRange,
          disableStream
        });
      } else if (!data) {
        if (!url) {
          throw new Error("getDocument - no `url` parameter provided.");
        }
        const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;
        networkStream = new NetworkStream({
          url,
          length,
          httpHeaders,
          withCredentials,
          rangeChunkSize,
          disableRange,
          disableStream
        });
      }
      return workerIdPromise.then((workerId) => {
        if (task.destroyed) {
          throw new Error("Loading aborted");
        }
        if (worker.destroyed) {
          throw new Error("Worker was destroyed");
        }
        const messageHandler = new MessageHandler(docId, workerId, worker.port);
        const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);
        task._transport = transport;
        messageHandler.send("Ready", null);
      });
    }).catch(task._capability.reject);
    return task;
  }
  class PDFDocumentLoadingTask {
    static #docId = 0;
    _capability = Promise.withResolvers();
    _transport = null;
    _worker = null;
    docId = `d${PDFDocumentLoadingTask.#docId++}`;
    destroyed = false;
    onPassword = null;
    onProgress = null;
    get promise() {
      return this._capability.promise;
    }
    async destroy() {
      this.destroyed = true;
      try {
        if (this._worker?.port) {
          this._worker._pendingDestroy = true;
        }
        await this._transport?.destroy();
      } catch (ex) {
        if (this._worker?.port) {
          delete this._worker._pendingDestroy;
        }
        throw ex;
      }
      this._transport = null;
      this._worker?.destroy();
      this._worker = null;
    }
    async getData() {
      return this._transport.getData();
    }
  }
  class PDFDataRangeTransport {
    #capability = Promise.withResolvers();
    #progressiveDoneListeners = [];
    #progressiveReadListeners = [];
    #progressListeners = [];
    #rangeListeners = [];
    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
      this.length = length;
      this.initialData = initialData;
      this.progressiveDone = progressiveDone;
      this.contentDispositionFilename = contentDispositionFilename;
    }
    addRangeListener(listener) {
      this.#rangeListeners.push(listener);
    }
    addProgressListener(listener) {
      this.#progressListeners.push(listener);
    }
    addProgressiveReadListener(listener) {
      this.#progressiveReadListeners.push(listener);
    }
    addProgressiveDoneListener(listener) {
      this.#progressiveDoneListeners.push(listener);
    }
    onDataRange(begin, chunk) {
      for (const listener of this.#rangeListeners) {
        listener(begin, chunk);
      }
    }
    onDataProgress(loaded, total) {
      this.#capability.promise.then(() => {
        for (const listener of this.#progressListeners) {
          listener(loaded, total);
        }
      });
    }
    onDataProgressiveRead(chunk) {
      this.#capability.promise.then(() => {
        for (const listener of this.#progressiveReadListeners) {
          listener(chunk);
        }
      });
    }
    onDataProgressiveDone() {
      this.#capability.promise.then(() => {
        for (const listener of this.#progressiveDoneListeners) {
          listener();
        }
      });
    }
    transportReady() {
      this.#capability.resolve();
    }
    requestDataRange(begin, end) {
      unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
    }
    abort() {
    }
  }
  class PDFDocumentProxy {
    constructor(pdfInfo, transport) {
      this._pdfInfo = pdfInfo;
      this._transport = transport;
    }
    get annotationStorage() {
      return this._transport.annotationStorage;
    }
    get canvasFactory() {
      return this._transport.canvasFactory;
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get numPages() {
      return this._pdfInfo.numPages;
    }
    get fingerprints() {
      return this._pdfInfo.fingerprints;
    }
    get isPureXfa() {
      return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    get allXfaHtml() {
      return this._transport._htmlForXfa;
    }
    getPage(pageNumber) {
      return this._transport.getPage(pageNumber);
    }
    getPageIndex(ref) {
      return this._transport.getPageIndex(ref);
    }
    getDestinations() {
      return this._transport.getDestinations();
    }
    getDestination(id) {
      return this._transport.getDestination(id);
    }
    getPageLabels() {
      return this._transport.getPageLabels();
    }
    getPageLayout() {
      return this._transport.getPageLayout();
    }
    getPageMode() {
      return this._transport.getPageMode();
    }
    getViewerPreferences() {
      return this._transport.getViewerPreferences();
    }
    getOpenAction() {
      return this._transport.getOpenAction();
    }
    getAttachments() {
      return this._transport.getAttachments();
    }
    getAnnotationsByType(types, pageIndexesToSkip) {
      return this._transport.getAnnotationsByType(types, pageIndexesToSkip);
    }
    getJSActions() {
      return this._transport.getDocJSActions();
    }
    getOutline() {
      return this._transport.getOutline();
    }
    getOptionalContentConfig({
      intent = "display"
    } = {}) {
      const {
        renderingIntent
      } = this._transport.getRenderingIntent(intent);
      return this._transport.getOptionalContentConfig(renderingIntent);
    }
    getPermissions() {
      return this._transport.getPermissions();
    }
    getMetadata() {
      return this._transport.getMetadata();
    }
    getMarkInfo() {
      return this._transport.getMarkInfo();
    }
    getData() {
      return this._transport.getData();
    }
    saveDocument() {
      return this._transport.saveDocument();
    }
    getDownloadInfo() {
      return this._transport.downloadInfoCapability.promise;
    }
    cleanup(keepLoadedFonts = false) {
      return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
    }
    destroy() {
      return this.loadingTask.destroy();
    }
    cachedPageNumber(ref) {
      return this._transport.cachedPageNumber(ref);
    }
    get loadingParams() {
      return this._transport.loadingParams;
    }
    get loadingTask() {
      return this._transport.loadingTask;
    }
    getFieldObjects() {
      return this._transport.getFieldObjects();
    }
    hasJSActions() {
      return this._transport.hasJSActions();
    }
    getCalculationOrderIds() {
      return this._transport.getCalculationOrderIds();
    }
  }
  class PDFPageProxy {
    #pendingCleanup = false;
    constructor(pageIndex, pageInfo, transport, pdfBug = false) {
      this._pageIndex = pageIndex;
      this._pageInfo = pageInfo;
      this._transport = transport;
      this._stats = pdfBug ? new StatTimer() : null;
      this._pdfBug = pdfBug;
      this.commonObjs = transport.commonObjs;
      this.objs = new PDFObjects();
      this._intentStates = /* @__PURE__ */ new Map();
      this.destroyed = false;
      this.recordedGroups = null;
    }
    get pageNumber() {
      return this._pageIndex + 1;
    }
    get rotate() {
      return this._pageInfo.rotate;
    }
    get ref() {
      return this._pageInfo.ref;
    }
    get userUnit() {
      return this._pageInfo.userUnit;
    }
    get view() {
      return this._pageInfo.view;
    }
    getViewport({
      scale,
      rotation = this.rotate,
      offsetX = 0,
      offsetY = 0,
      dontFlip = false
    } = {}) {
      return new PageViewport({
        viewBox: this.view,
        userUnit: this.userUnit,
        scale,
        rotation,
        offsetX,
        offsetY,
        dontFlip
      });
    }
    getAnnotations({
      intent = "display"
    } = {}) {
      const {
        renderingIntent
      } = this._transport.getRenderingIntent(intent);
      return this._transport.getAnnotations(this._pageIndex, renderingIntent);
    }
    getJSActions() {
      return this._transport.getPageJSActions(this._pageIndex);
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get isPureXfa() {
      return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    async getXfa() {
      return this._transport._htmlForXfa?.children[this._pageIndex] || null;
    }
    render({
      canvasContext,
      canvas = canvasContext.canvas,
      viewport,
      intent = "display",
      annotationMode = AnnotationMode.ENABLE,
      transform = null,
      background = null,
      optionalContentConfigPromise = null,
      annotationCanvasMap = null,
      pageColors = null,
      printAnnotationStorage = null,
      isEditing = false,
      recordOperations = false,
      filteredOperationIndexes = null
    }) {
      this._stats?.time("Overall");
      const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);
      const {
        renderingIntent,
        cacheKey
      } = intentArgs;
      this.#pendingCleanup = false;
      optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);
      let intentState = this._intentStates.get(cacheKey);
      if (!intentState) {
        intentState = /* @__PURE__ */ Object.create(null);
        this._intentStates.set(cacheKey, intentState);
      }
      if (intentState.streamReaderCancelTimeout) {
        clearTimeout(intentState.streamReaderCancelTimeout);
        intentState.streamReaderCancelTimeout = null;
      }
      const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
      if (!intentState.displayReadyCapability) {
        intentState.displayReadyCapability = Promise.withResolvers();
        intentState.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false,
          separateAnnots: null
        };
        this._stats?.time("Page Request");
        this._pumpOperatorList(intentArgs);
      }
      const shouldRecordOperations = !this.recordedGroups && (recordOperations || this._pdfBug && globalThis.StepperManager?.enabled);
      const complete = (error) => {
        intentState.renderTasks.delete(internalRenderTask);
        if (shouldRecordOperations) {
          const recordedGroups = internalRenderTask.gfx?.dependencyTracker.take();
          if (recordedGroups) {
            internalRenderTask.stepper?.setOperatorGroups(recordedGroups);
            if (recordOperations) {
              this.recordedGroups = recordedGroups;
            }
          } else if (recordOperations) {
            this.recordedGroups = [];
          }
        }
        if (intentPrint) {
          this.#pendingCleanup = true;
        }
        this.#tryCleanup();
        if (error) {
          internalRenderTask.capability.reject(error);
          this._abortOperatorList({
            intentState,
            reason: error instanceof Error ? error : new Error(error)
          });
        } else {
          internalRenderTask.capability.resolve();
        }
        if (this._stats) {
          this._stats.timeEnd("Rendering");
          this._stats.timeEnd("Overall");
          if (globalThis.Stats?.enabled) {
            globalThis.Stats.add(this.pageNumber, this._stats);
          }
        }
      };
      const internalRenderTask = new InternalRenderTask({
        callback: complete,
        params: {
          canvas,
          canvasContext,
          dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas) : null,
          viewport,
          transform,
          background
        },
        objs: this.objs,
        commonObjs: this.commonObjs,
        annotationCanvasMap,
        operatorList: intentState.operatorList,
        pageIndex: this._pageIndex,
        canvasFactory: this._transport.canvasFactory,
        filterFactory: this._transport.filterFactory,
        useRequestAnimationFrame: !intentPrint,
        pdfBug: this._pdfBug,
        pageColors,
        enableHWA: this._transport.enableHWA,
        filteredOperationIndexes
      });
      (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(internalRenderTask);
      const renderTask = internalRenderTask.task;
      Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
        if (this.destroyed) {
          complete();
          return;
        }
        this._stats?.time("Rendering");
        if (!(optionalContentConfig.renderingIntent & renderingIntent)) {
          throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
        }
        internalRenderTask.initializeGraphics({
          transparency,
          optionalContentConfig
        });
        internalRenderTask.operatorListChanged();
      }).catch(complete);
      return renderTask;
    }
    getOperatorList({
      intent = "display",
      annotationMode = AnnotationMode.ENABLE,
      printAnnotationStorage = null,
      isEditing = false
    } = {}) {
      function operatorListChanged() {
        if (intentState.operatorList.lastChunk) {
          intentState.opListReadCapability.resolve(intentState.operatorList);
          intentState.renderTasks.delete(opListTask);
        }
      }
      const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);
      let intentState = this._intentStates.get(intentArgs.cacheKey);
      if (!intentState) {
        intentState = /* @__PURE__ */ Object.create(null);
        this._intentStates.set(intentArgs.cacheKey, intentState);
      }
      let opListTask;
      if (!intentState.opListReadCapability) {
        opListTask = /* @__PURE__ */ Object.create(null);
        opListTask.operatorListChanged = operatorListChanged;
        intentState.opListReadCapability = Promise.withResolvers();
        (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(opListTask);
        intentState.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false,
          separateAnnots: null
        };
        this._stats?.time("Page Request");
        this._pumpOperatorList(intentArgs);
      }
      return intentState.opListReadCapability.promise;
    }
    streamTextContent({
      includeMarkedContent = false,
      disableNormalization = false
    } = {}) {
      const TEXT_CONTENT_CHUNK_SIZE = 100;
      return this._transport.messageHandler.sendWithStream("GetTextContent", {
        pageIndex: this._pageIndex,
        includeMarkedContent: includeMarkedContent === true,
        disableNormalization: disableNormalization === true
      }, {
        highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
        size(textContent) {
          return textContent.items.length;
        }
      });
    }
    getTextContent(params = {}) {
      if (this._transport._htmlForXfa) {
        return this.getXfa().then((xfa) => XfaText.textContent(xfa));
      }
      const readableStream = this.streamTextContent(params);
      return new Promise(function(resolve, reject) {
        function pump() {
          reader.read().then(function({
            value,
            done
          }) {
            if (done) {
              resolve(textContent);
              return;
            }
            textContent.lang ??= value.lang;
            Object.assign(textContent.styles, value.styles);
            textContent.items.push(...value.items);
            pump();
          }, reject);
        }
        const reader = readableStream.getReader();
        const textContent = {
          items: [],
          styles: /* @__PURE__ */ Object.create(null),
          lang: null
        };
        pump();
      });
    }
    getStructTree() {
      return this._transport.getStructTree(this._pageIndex);
    }
    _destroy() {
      this.destroyed = true;
      const waitOn = [];
      for (const intentState of this._intentStates.values()) {
        this._abortOperatorList({
          intentState,
          reason: new Error("Page was destroyed."),
          force: true
        });
        if (intentState.opListReadCapability) {
          continue;
        }
        for (const internalRenderTask of intentState.renderTasks) {
          waitOn.push(internalRenderTask.completed);
          internalRenderTask.cancel();
        }
      }
      this.objs.clear();
      this.#pendingCleanup = false;
      return Promise.all(waitOn);
    }
    cleanup(resetStats = false) {
      this.#pendingCleanup = true;
      const success = this.#tryCleanup();
      if (resetStats && success) {
        this._stats &&= new StatTimer();
      }
      return success;
    }
    #tryCleanup() {
      if (!this.#pendingCleanup || this.destroyed) {
        return false;
      }
      for (const {
        renderTasks,
        operatorList
      } of this._intentStates.values()) {
        if (renderTasks.size > 0 || !operatorList.lastChunk) {
          return false;
        }
      }
      this._intentStates.clear();
      this.objs.clear();
      this.#pendingCleanup = false;
      return true;
    }
    _startRenderPage(transparency, cacheKey) {
      const intentState = this._intentStates.get(cacheKey);
      if (!intentState) {
        return;
      }
      this._stats?.timeEnd("Page Request");
      intentState.displayReadyCapability?.resolve(transparency);
    }
    _renderPageChunk(operatorListChunk, intentState) {
      for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
        intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
      }
      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
      intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
      for (const internalRenderTask of intentState.renderTasks) {
        internalRenderTask.operatorListChanged();
      }
      if (operatorListChunk.lastChunk) {
        this.#tryCleanup();
      }
    }
    _pumpOperatorList({
      renderingIntent,
      cacheKey,
      annotationStorageSerializable,
      modifiedIds
    }) {
      const {
        map,
        transfer
      } = annotationStorageSerializable;
      const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
        pageIndex: this._pageIndex,
        intent: renderingIntent,
        cacheKey,
        annotationStorage: map,
        modifiedIds
      }, transfer);
      const reader = readableStream.getReader();
      const intentState = this._intentStates.get(cacheKey);
      intentState.streamReader = reader;
      const pump = () => {
        reader.read().then(({
          value,
          done
        }) => {
          if (done) {
            intentState.streamReader = null;
            return;
          }
          if (this._transport.destroyed) {
            return;
          }
          this._renderPageChunk(value, intentState);
          pump();
        }, (reason) => {
          intentState.streamReader = null;
          if (this._transport.destroyed) {
            return;
          }
          if (intentState.operatorList) {
            intentState.operatorList.lastChunk = true;
            for (const internalRenderTask of intentState.renderTasks) {
              internalRenderTask.operatorListChanged();
            }
            this.#tryCleanup();
          }
          if (intentState.displayReadyCapability) {
            intentState.displayReadyCapability.reject(reason);
          } else if (intentState.opListReadCapability) {
            intentState.opListReadCapability.reject(reason);
          } else {
            throw reason;
          }
        });
      };
      pump();
    }
    _abortOperatorList({
      intentState,
      reason,
      force = false
    }) {
      if (!intentState.streamReader) {
        return;
      }
      if (intentState.streamReaderCancelTimeout) {
        clearTimeout(intentState.streamReaderCancelTimeout);
        intentState.streamReaderCancelTimeout = null;
      }
      if (!force) {
        if (intentState.renderTasks.size > 0) {
          return;
        }
        if (reason instanceof RenderingCancelledException) {
          let delay = RENDERING_CANCELLED_TIMEOUT;
          if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {
            delay += reason.extraDelay;
          }
          intentState.streamReaderCancelTimeout = setTimeout(() => {
            intentState.streamReaderCancelTimeout = null;
            this._abortOperatorList({
              intentState,
              reason,
              force: true
            });
          }, delay);
          return;
        }
      }
      intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => {
      });
      intentState.streamReader = null;
      if (this._transport.destroyed) {
        return;
      }
      for (const [curCacheKey, curIntentState] of this._intentStates) {
        if (curIntentState === intentState) {
          this._intentStates.delete(curCacheKey);
          break;
        }
      }
      this.cleanup();
    }
    get stats() {
      return this._stats;
    }
  }
  const _PDFWorker = class _PDFWorker {
    constructor({
      name = null,
      port = null,
      verbosity: verbosity2 = getVerbosityLevel()
    } = {}) {
      __privateAdd(this, _PDFWorker_instances);
      __privateAdd(this, _capability, Promise.withResolvers());
      __privateAdd(this, _messageHandler, null);
      __privateAdd(this, _port, null);
      __privateAdd(this, _webWorker, null);
      this.name = name;
      this.destroyed = false;
      this.verbosity = verbosity2;
      if (port) {
        if (__privateGet(_PDFWorker, _workerPorts).has(port)) {
          throw new Error("Cannot use more than one PDFWorker per port.");
        }
        __privateGet(_PDFWorker, _workerPorts).set(port, this);
        __privateMethod(this, _PDFWorker_instances, initializeFromPort_fn).call(this, port);
      } else {
        __privateMethod(this, _PDFWorker_instances, initialize_fn).call(this);
      }
    }
    get promise() {
      return __privateGet(this, _capability).promise;
    }
    get port() {
      return __privateGet(this, _port);
    }
    get messageHandler() {
      return __privateGet(this, _messageHandler);
    }
    destroy() {
      this.destroyed = true;
      __privateGet(this, _webWorker)?.terminate();
      __privateSet(this, _webWorker, null);
      __privateGet(_PDFWorker, _workerPorts).delete(__privateGet(this, _port));
      __privateSet(this, _port, null);
      __privateGet(this, _messageHandler)?.destroy();
      __privateSet(this, _messageHandler, null);
    }
    static create(params) {
      const cachedPort = __privateGet(this, _workerPorts).get(params?.port);
      if (cachedPort) {
        if (cachedPort._pendingDestroy) {
          throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
        }
        return cachedPort;
      }
      return new _PDFWorker(params);
    }
    static get workerSrc() {
      if (GlobalWorkerOptions.workerSrc) {
        return GlobalWorkerOptions.workerSrc;
      }
      throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
    }
    static get _setupFakeWorkerGlobal() {
      const loader = async () => {
        if (__privateGet(this, _PDFWorker_static, mainThreadWorkerMessageHandler_get)) {
          return __privateGet(this, _PDFWorker_static, mainThreadWorkerMessageHandler_get);
        }
        const worker = await import(
          /*webpackIgnore: true*/
          /*@vite-ignore*/
          this.workerSrc
        );
        return worker.WorkerMessageHandler;
      };
      return shadow(this, "_setupFakeWorkerGlobal", loader());
    }
  };
  _capability = new WeakMap();
  _messageHandler = new WeakMap();
  _port = new WeakMap();
  _webWorker = new WeakMap();
  _fakeWorkerId = new WeakMap();
  _isWorkerDisabled = new WeakMap();
  _workerPorts = new WeakMap();
  _PDFWorker_instances = new WeakSet();
  resolve_fn = function() {
    __privateGet(this, _capability).resolve();
    __privateGet(this, _messageHandler).send("configure", {
      verbosity: this.verbosity
    });
  };
  initializeFromPort_fn = function(port) {
    __privateSet(this, _port, port);
    __privateSet(this, _messageHandler, new MessageHandler("main", "worker", port));
    __privateGet(this, _messageHandler).on("ready", () => {
    });
    __privateMethod(this, _PDFWorker_instances, resolve_fn).call(this);
  };
  initialize_fn = function() {
    if (__privateGet(_PDFWorker, _isWorkerDisabled) || __privateGet(_PDFWorker, _PDFWorker_static, mainThreadWorkerMessageHandler_get)) {
      __privateMethod(this, _PDFWorker_instances, setupFakeWorker_fn).call(this);
      return;
    }
    let {
      workerSrc
    } = _PDFWorker;
    try {
      if (!_PDFWorker._isSameOrigin(window.location, workerSrc)) {
        workerSrc = _PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);
      }
      const worker = new Worker(workerSrc, {
        type: "module"
      });
      const messageHandler = new MessageHandler("main", "worker", worker);
      const terminateEarly = () => {
        ac.abort();
        messageHandler.destroy();
        worker.terminate();
        if (this.destroyed) {
          __privateGet(this, _capability).reject(new Error("Worker was destroyed"));
        } else {
          __privateMethod(this, _PDFWorker_instances, setupFakeWorker_fn).call(this);
        }
      };
      const ac = new AbortController();
      worker.addEventListener("error", () => {
        if (!__privateGet(this, _webWorker)) {
          terminateEarly();
        }
      }, {
        signal: ac.signal
      });
      messageHandler.on("test", (data) => {
        ac.abort();
        if (this.destroyed || !data) {
          terminateEarly();
          return;
        }
        __privateSet(this, _messageHandler, messageHandler);
        __privateSet(this, _port, worker);
        __privateSet(this, _webWorker, worker);
        __privateMethod(this, _PDFWorker_instances, resolve_fn).call(this);
      });
      messageHandler.on("ready", (data) => {
        ac.abort();
        if (this.destroyed) {
          terminateEarly();
          return;
        }
        try {
          sendTest();
        } catch {
          __privateMethod(this, _PDFWorker_instances, setupFakeWorker_fn).call(this);
        }
      });
      const sendTest = () => {
        const testObj = new Uint8Array();
        messageHandler.send("test", testObj, [testObj.buffer]);
      };
      sendTest();
      return;
    } catch {
      info("The worker has been disabled.");
    }
    __privateMethod(this, _PDFWorker_instances, setupFakeWorker_fn).call(this);
  };
  setupFakeWorker_fn = function() {
    if (!__privateGet(_PDFWorker, _isWorkerDisabled)) {
      warn("Setting up fake worker.");
      __privateSet(_PDFWorker, _isWorkerDisabled, true);
    }
    _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
      if (this.destroyed) {
        __privateGet(this, _capability).reject(new Error("Worker was destroyed"));
        return;
      }
      const port = new LoopbackPort();
      __privateSet(this, _port, port);
      const id = `fake${__privateWrapper(_PDFWorker, _fakeWorkerId)._++}`;
      const workerHandler = new MessageHandler(id + "_worker", id, port);
      WorkerMessageHandler.setup(workerHandler, port);
      __privateSet(this, _messageHandler, new MessageHandler(id, id + "_worker", port));
      __privateMethod(this, _PDFWorker_instances, resolve_fn).call(this);
    }).catch((reason) => {
      __privateGet(this, _capability).reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
    });
  };
  _PDFWorker_static = new WeakSet();
  mainThreadWorkerMessageHandler_get = function() {
    try {
      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
    } catch {
      return null;
    }
  };
  __privateAdd(_PDFWorker, _PDFWorker_static);
  __privateAdd(_PDFWorker, _fakeWorkerId, 0);
  __privateAdd(_PDFWorker, _isWorkerDisabled, false);
  __privateAdd(_PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap());
  (() => {
    if (isNodeJS) {
      __privateSet(_PDFWorker, _isWorkerDisabled, true);
      GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs";
    }
    _PDFWorker._isSameOrigin = (baseUrl, otherUrl) => {
      const base = URL.parse(baseUrl);
      if (!base?.origin || base.origin === "null") {
        return false;
      }
      const other = new URL(otherUrl, base);
      return base.origin === other.origin;
    };
    _PDFWorker._createCDNWrapper = (url) => {
      const wrapper = `await import("${url}");`;
      return URL.createObjectURL(new Blob([wrapper], {
        type: "text/javascript"
      }));
    };
    _PDFWorker.fromPort = (params) => {
      deprecated("`PDFWorker.fromPort` - please use `PDFWorker.create` instead.");
      if (!params?.port) {
        throw new Error("PDFWorker.fromPort - invalid method signature.");
      }
      return _PDFWorker.create(params);
    };
  })();
  let PDFWorker = _PDFWorker;
  class WorkerTransport {
    #methodPromises = /* @__PURE__ */ new Map();
    #pageCache = /* @__PURE__ */ new Map();
    #pagePromises = /* @__PURE__ */ new Map();
    #pageRefCache = /* @__PURE__ */ new Map();
    #passwordCapability = null;
    constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA) {
      this.messageHandler = messageHandler;
      this.loadingTask = loadingTask;
      this.commonObjs = new PDFObjects();
      this.fontLoader = new FontLoader({
        ownerDocument: params.ownerDocument,
        styleElement: params.styleElement
      });
      this.loadingParams = params.loadingParams;
      this._params = params;
      this.canvasFactory = factory.canvasFactory;
      this.filterFactory = factory.filterFactory;
      this.cMapReaderFactory = factory.cMapReaderFactory;
      this.standardFontDataFactory = factory.standardFontDataFactory;
      this.wasmFactory = factory.wasmFactory;
      this.destroyed = false;
      this.destroyCapability = null;
      this._networkStream = networkStream;
      this._fullReader = null;
      this._lastProgress = null;
      this.downloadInfoCapability = Promise.withResolvers();
      this.enableHWA = enableHWA;
      this.setupMessageHandler();
    }
    #cacheSimpleMethod(name, data = null) {
      const cachedPromise = this.#methodPromises.get(name);
      if (cachedPromise) {
        return cachedPromise;
      }
      const promise = this.messageHandler.sendWithPromise(name, data);
      this.#methodPromises.set(name, promise);
      return promise;
    }
    get annotationStorage() {
      return shadow(this, "annotationStorage", new AnnotationStorage());
    }
    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {
      let renderingIntent = RenderingIntentFlag.DISPLAY;
      let annotationStorageSerializable = SerializableEmpty;
      switch (intent) {
        case "any":
          renderingIntent = RenderingIntentFlag.ANY;
          break;
        case "display":
          break;
        case "print":
          renderingIntent = RenderingIntentFlag.PRINT;
          break;
        default:
          warn(`getRenderingIntent - invalid intent: ${intent}`);
      }
      const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
      switch (annotationMode) {
        case AnnotationMode.DISABLE:
          renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
          break;
        case AnnotationMode.ENABLE:
          break;
        case AnnotationMode.ENABLE_FORMS:
          renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
          break;
        case AnnotationMode.ENABLE_STORAGE:
          renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
          annotationStorageSerializable = annotationStorage.serializable;
          break;
        default:
          warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
      }
      if (isEditing) {
        renderingIntent += RenderingIntentFlag.IS_EDITING;
      }
      if (isOpList) {
        renderingIntent += RenderingIntentFlag.OPLIST;
      }
      const {
        ids: modifiedIds,
        hash: modifiedIdsHash
      } = annotationStorage.modifiedIds;
      const cacheKeyBuf = [renderingIntent, annotationStorageSerializable.hash, modifiedIdsHash];
      return {
        renderingIntent,
        cacheKey: cacheKeyBuf.join("_"),
        annotationStorageSerializable,
        modifiedIds
      };
    }
    destroy() {
      if (this.destroyCapability) {
        return this.destroyCapability.promise;
      }
      this.destroyed = true;
      this.destroyCapability = Promise.withResolvers();
      this.#passwordCapability?.reject(new Error("Worker was destroyed during onPassword callback"));
      const waitOn = [];
      for (const page of this.#pageCache.values()) {
        waitOn.push(page._destroy());
      }
      this.#pageCache.clear();
      this.#pagePromises.clear();
      this.#pageRefCache.clear();
      if (this.hasOwnProperty("annotationStorage")) {
        this.annotationStorage.resetModified();
      }
      const terminated = this.messageHandler.sendWithPromise("Terminate", null);
      waitOn.push(terminated);
      Promise.all(waitOn).then(() => {
        this.commonObjs.clear();
        this.fontLoader.clear();
        this.#methodPromises.clear();
        this.filterFactory.destroy();
        TextLayer.cleanup();
        this._networkStream?.cancelAllRequests(new AbortException("Worker was terminated."));
        this.messageHandler?.destroy();
        this.messageHandler = null;
        this.destroyCapability.resolve();
      }, this.destroyCapability.reject);
      return this.destroyCapability.promise;
    }
    setupMessageHandler() {
      const {
        messageHandler,
        loadingTask
      } = this;
      messageHandler.on("GetReader", (data, sink) => {
        assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
        this._fullReader = this._networkStream.getFullReader();
        this._fullReader.onProgress = (evt) => {
          this._lastProgress = {
            loaded: evt.loaded,
            total: evt.total
          };
        };
        sink.onPull = () => {
          this._fullReader.read().then(function({
            value,
            done
          }) {
            if (done) {
              sink.close();
              return;
            }
            assert(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
            sink.enqueue(new Uint8Array(value), 1, [value]);
          }).catch((reason) => {
            sink.error(reason);
          });
        };
        sink.onCancel = (reason) => {
          this._fullReader.cancel(reason);
          sink.ready.catch((readyReason) => {
            if (this.destroyed) {
              return;
            }
            throw readyReason;
          });
        };
      });
      messageHandler.on("ReaderHeadersReady", async (data) => {
        await this._fullReader.headersReady;
        const {
          isStreamingSupported,
          isRangeSupported,
          contentLength
        } = this._fullReader;
        if (!isStreamingSupported || !isRangeSupported) {
          if (this._lastProgress) {
            loadingTask.onProgress?.(this._lastProgress);
          }
          this._fullReader.onProgress = (evt) => {
            loadingTask.onProgress?.({
              loaded: evt.loaded,
              total: evt.total
            });
          };
        }
        return {
          isStreamingSupported,
          isRangeSupported,
          contentLength
        };
      });
      messageHandler.on("GetRangeReader", (data, sink) => {
        assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
        const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
        if (!rangeReader) {
          sink.close();
          return;
        }
        sink.onPull = () => {
          rangeReader.read().then(function({
            value,
            done
          }) {
            if (done) {
              sink.close();
              return;
            }
            assert(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
            sink.enqueue(new Uint8Array(value), 1, [value]);
          }).catch((reason) => {
            sink.error(reason);
          });
        };
        sink.onCancel = (reason) => {
          rangeReader.cancel(reason);
          sink.ready.catch((readyReason) => {
            if (this.destroyed) {
              return;
            }
            throw readyReason;
          });
        };
      });
      messageHandler.on("GetDoc", ({
        pdfInfo
      }) => {
        this._numPages = pdfInfo.numPages;
        this._htmlForXfa = pdfInfo.htmlForXfa;
        delete pdfInfo.htmlForXfa;
        loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
      });
      messageHandler.on("DocException", (ex) => {
        loadingTask._capability.reject(wrapReason(ex));
      });
      messageHandler.on("PasswordRequest", (ex) => {
        this.#passwordCapability = Promise.withResolvers();
        try {
          if (!loadingTask.onPassword) {
            throw wrapReason(ex);
          }
          const updatePassword = (password) => {
            if (password instanceof Error) {
              this.#passwordCapability.reject(password);
            } else {
              this.#passwordCapability.resolve({
                password
              });
            }
          };
          loadingTask.onPassword(updatePassword, ex.code);
        } catch (err) {
          this.#passwordCapability.reject(err);
        }
        return this.#passwordCapability.promise;
      });
      messageHandler.on("DataLoaded", (data) => {
        loadingTask.onProgress?.({
          loaded: data.length,
          total: data.length
        });
        this.downloadInfoCapability.resolve(data);
      });
      messageHandler.on("StartRenderPage", (data) => {
        if (this.destroyed) {
          return;
        }
        const page = this.#pageCache.get(data.pageIndex);
        page._startRenderPage(data.transparency, data.cacheKey);
      });
      messageHandler.on("commonobj", ([id, type, exportedData]) => {
        if (this.destroyed) {
          return null;
        }
        if (this.commonObjs.has(id)) {
          return null;
        }
        switch (type) {
          case "Font":
            if ("error" in exportedData) {
              const exportedError = exportedData.error;
              warn(`Error during font loading: ${exportedError}`);
              this.commonObjs.resolve(id, exportedError);
              break;
            }
            const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font2, url) => globalThis.FontInspector.fontAdded(font2, url) : null;
            const font = new FontFaceObject(exportedData, inspectFont);
            this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise("FontFallback", {
              id
            })).finally(() => {
              if (!font.fontExtraProperties && font.data) {
                font.data = null;
              }
              this.commonObjs.resolve(id, font);
            });
            break;
          case "CopyLocalImage":
            const {
              imageRef
            } = exportedData;
            assert(imageRef, "The imageRef must be defined.");
            for (const pageProxy of this.#pageCache.values()) {
              for (const [, data] of pageProxy.objs) {
                if (data?.ref !== imageRef) {
                  continue;
                }
                if (!data.dataLen) {
                  return null;
                }
                this.commonObjs.resolve(id, structuredClone(data));
                return data.dataLen;
              }
            }
            break;
          case "FontPath":
          case "Image":
          case "Pattern":
            this.commonObjs.resolve(id, exportedData);
            break;
          default:
            throw new Error(`Got unknown common object type ${type}`);
        }
        return null;
      });
      messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
        if (this.destroyed) {
          return;
        }
        const pageProxy = this.#pageCache.get(pageIndex);
        if (pageProxy.objs.has(id)) {
          return;
        }
        if (pageProxy._intentStates.size === 0) {
          imageData?.bitmap?.close();
          return;
        }
        switch (type) {
          case "Image":
          case "Pattern":
            pageProxy.objs.resolve(id, imageData);
            break;
          default:
            throw new Error(`Got unknown object type ${type}`);
        }
      });
      messageHandler.on("DocProgress", (data) => {
        if (this.destroyed) {
          return;
        }
        loadingTask.onProgress?.({
          loaded: data.loaded,
          total: data.total
        });
      });
      messageHandler.on("FetchBinaryData", async (data) => {
        if (this.destroyed) {
          throw new Error("Worker was destroyed.");
        }
        const factory = this[data.type];
        if (!factory) {
          throw new Error(`${data.type} not initialized, see the \`useWorkerFetch\` parameter.`);
        }
        return factory.fetch(data);
      });
    }
    getData() {
      return this.messageHandler.sendWithPromise("GetData", null);
    }
    saveDocument() {
      if (this.annotationStorage.size <= 0) {
        warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
      }
      const {
        map,
        transfer
      } = this.annotationStorage.serializable;
      return this.messageHandler.sendWithPromise("SaveDocument", {
        isPureXfa: !!this._htmlForXfa,
        numPages: this._numPages,
        annotationStorage: map,
        filename: this._fullReader?.filename ?? null
      }, transfer).finally(() => {
        this.annotationStorage.resetModified();
      });
    }
    getPage(pageNumber) {
      if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
        return Promise.reject(new Error("Invalid page request."));
      }
      const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);
      if (cachedPromise) {
        return cachedPromise;
      }
      const promise = this.messageHandler.sendWithPromise("GetPage", {
        pageIndex
      }).then((pageInfo) => {
        if (this.destroyed) {
          throw new Error("Transport destroyed");
        }
        if (pageInfo.refStr) {
          this.#pageRefCache.set(pageInfo.refStr, pageNumber);
        }
        const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
        this.#pageCache.set(pageIndex, page);
        return page;
      });
      this.#pagePromises.set(pageIndex, promise);
      return promise;
    }
    getPageIndex(ref) {
      if (!isRefProxy(ref)) {
        return Promise.reject(new Error("Invalid pageIndex request."));
      }
      return this.messageHandler.sendWithPromise("GetPageIndex", {
        num: ref.num,
        gen: ref.gen
      });
    }
    getAnnotations(pageIndex, intent) {
      return this.messageHandler.sendWithPromise("GetAnnotations", {
        pageIndex,
        intent
      });
    }
    getFieldObjects() {
      return this.#cacheSimpleMethod("GetFieldObjects");
    }
    hasJSActions() {
      return this.#cacheSimpleMethod("HasJSActions");
    }
    getCalculationOrderIds() {
      return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
    }
    getDestinations() {
      return this.messageHandler.sendWithPromise("GetDestinations", null);
    }
    getDestination(id) {
      if (typeof id !== "string") {
        return Promise.reject(new Error("Invalid destination request."));
      }
      return this.messageHandler.sendWithPromise("GetDestination", {
        id
      });
    }
    getPageLabels() {
      return this.messageHandler.sendWithPromise("GetPageLabels", null);
    }
    getPageLayout() {
      return this.messageHandler.sendWithPromise("GetPageLayout", null);
    }
    getPageMode() {
      return this.messageHandler.sendWithPromise("GetPageMode", null);
    }
    getViewerPreferences() {
      return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
    }
    getOpenAction() {
      return this.messageHandler.sendWithPromise("GetOpenAction", null);
    }
    getAttachments() {
      return this.messageHandler.sendWithPromise("GetAttachments", null);
    }
    getAnnotationsByType(types, pageIndexesToSkip) {
      return this.messageHandler.sendWithPromise("GetAnnotationsByType", {
        types,
        pageIndexesToSkip
      });
    }
    getDocJSActions() {
      return this.#cacheSimpleMethod("GetDocJSActions");
    }
    getPageJSActions(pageIndex) {
      return this.messageHandler.sendWithPromise("GetPageJSActions", {
        pageIndex
      });
    }
    getStructTree(pageIndex) {
      return this.messageHandler.sendWithPromise("GetStructTree", {
        pageIndex
      });
    }
    getOutline() {
      return this.messageHandler.sendWithPromise("GetOutline", null);
    }
    getOptionalContentConfig(renderingIntent) {
      return this.#cacheSimpleMethod("GetOptionalContentConfig").then((data) => new OptionalContentConfig(data, renderingIntent));
    }
    getPermissions() {
      return this.messageHandler.sendWithPromise("GetPermissions", null);
    }
    getMetadata() {
      const name = "GetMetadata", cachedPromise = this.#methodPromises.get(name);
      if (cachedPromise) {
        return cachedPromise;
      }
      const promise = this.messageHandler.sendWithPromise(name, null).then((results) => ({
        info: results[0],
        metadata: results[1] ? new Metadata(results[1]) : null,
        contentDispositionFilename: this._fullReader?.filename ?? null,
        contentLength: this._fullReader?.contentLength ?? null
      }));
      this.#methodPromises.set(name, promise);
      return promise;
    }
    getMarkInfo() {
      return this.messageHandler.sendWithPromise("GetMarkInfo", null);
    }
    async startCleanup(keepLoadedFonts = false) {
      if (this.destroyed) {
        return;
      }
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const page of this.#pageCache.values()) {
        const cleanupSuccessful = page.cleanup();
        if (!cleanupSuccessful) {
          throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
        }
      }
      this.commonObjs.clear();
      if (!keepLoadedFonts) {
        this.fontLoader.clear();
      }
      this.#methodPromises.clear();
      this.filterFactory.destroy(true);
      TextLayer.cleanup();
    }
    cachedPageNumber(ref) {
      if (!isRefProxy(ref)) {
        return null;
      }
      const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;
      return this.#pageRefCache.get(refStr) ?? null;
    }
  }
  class RenderTask {
    #internalRenderTask = null;
    onContinue = null;
    onError = null;
    constructor(internalRenderTask) {
      this.#internalRenderTask = internalRenderTask;
    }
    get promise() {
      return this.#internalRenderTask.capability.promise;
    }
    cancel(extraDelay = 0) {
      this.#internalRenderTask.cancel(null, extraDelay);
    }
    get separateAnnots() {
      const {
        separateAnnots
      } = this.#internalRenderTask.operatorList;
      if (!separateAnnots) {
        return false;
      }
      const {
        annotationCanvasMap
      } = this.#internalRenderTask;
      return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
    }
  }
  class InternalRenderTask {
    #rAF = null;
    static #canvasInUse = /* @__PURE__ */ new WeakSet();
    constructor({
      callback,
      params,
      objs,
      commonObjs,
      annotationCanvasMap,
      operatorList,
      pageIndex,
      canvasFactory,
      filterFactory,
      useRequestAnimationFrame = false,
      pdfBug = false,
      pageColors = null,
      enableHWA = false,
      filteredOperationIndexes = null
    }) {
      this.callback = callback;
      this.params = params;
      this.objs = objs;
      this.commonObjs = commonObjs;
      this.annotationCanvasMap = annotationCanvasMap;
      this.operatorListIdx = null;
      this.operatorList = operatorList;
      this._pageIndex = pageIndex;
      this.canvasFactory = canvasFactory;
      this.filterFactory = filterFactory;
      this._pdfBug = pdfBug;
      this.pageColors = pageColors;
      this.running = false;
      this.graphicsReadyCallback = null;
      this.graphicsReady = false;
      this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
      this.cancelled = false;
      this.capability = Promise.withResolvers();
      this.task = new RenderTask(this);
      this._cancelBound = this.cancel.bind(this);
      this._continueBound = this._continue.bind(this);
      this._scheduleNextBound = this._scheduleNext.bind(this);
      this._nextBound = this._next.bind(this);
      this._canvas = params.canvas;
      this._canvasContext = params.canvas ? null : params.canvasContext;
      this._enableHWA = enableHWA;
      this._dependencyTracker = params.dependencyTracker;
      this._filteredOperationIndexes = filteredOperationIndexes;
    }
    get completed() {
      return this.capability.promise.catch(function() {
      });
    }
    initializeGraphics({
      transparency = false,
      optionalContentConfig
    }) {
      if (this.cancelled) {
        return;
      }
      if (this._canvas) {
        if (InternalRenderTask.#canvasInUse.has(this._canvas)) {
          throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
        }
        InternalRenderTask.#canvasInUse.add(this._canvas);
      }
      if (this._pdfBug && globalThis.StepperManager?.enabled) {
        this.stepper = globalThis.StepperManager.create(this._pageIndex);
        this.stepper.init(this.operatorList);
        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
      }
      const {
        viewport,
        transform,
        background,
        dependencyTracker
      } = this.params;
      const canvasContext = this._canvasContext || this._canvas.getContext("2d", {
        alpha: false,
        willReadFrequently: !this._enableHWA
      });
      this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
        optionalContentConfig
      }, this.annotationCanvasMap, this.pageColors, dependencyTracker);
      this.gfx.beginDrawing({
        transform,
        viewport,
        transparency,
        background
      });
      this.operatorListIdx = 0;
      this.graphicsReady = true;
      this.graphicsReadyCallback?.();
    }
    cancel(error = null, extraDelay = 0) {
      this.running = false;
      this.cancelled = true;
      this.gfx?.endDrawing();
      if (this.#rAF) {
        window.cancelAnimationFrame(this.#rAF);
        this.#rAF = null;
      }
      InternalRenderTask.#canvasInUse.delete(this._canvas);
      error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);
      this.callback(error);
      this.task.onError?.(error);
    }
    operatorListChanged() {
      if (!this.graphicsReady) {
        this.graphicsReadyCallback ||= this._continueBound;
        return;
      }
      this.stepper?.updateOperatorList(this.operatorList);
      if (this.running) {
        return;
      }
      this._continue();
    }
    _continue() {
      this.running = true;
      if (this.cancelled) {
        return;
      }
      if (this.task.onContinue) {
        this.task.onContinue(this._scheduleNextBound);
      } else {
        this._scheduleNext();
      }
    }
    _scheduleNext() {
      if (this._useRequestAnimationFrame) {
        this.#rAF = window.requestAnimationFrame(() => {
          this.#rAF = null;
          this._nextBound().catch(this._cancelBound);
        });
      } else {
        Promise.resolve().then(this._nextBound).catch(this._cancelBound);
      }
    }
    async _next() {
      if (this.cancelled) {
        return;
      }
      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._filteredOperationIndexes);
      if (this.operatorListIdx === this.operatorList.argsArray.length) {
        this.running = false;
        if (this.operatorList.lastChunk) {
          this.gfx.endDrawing();
          InternalRenderTask.#canvasInUse.delete(this._canvas);
          this.callback();
        }
      }
    }
  }
  const version = "5.4.149";
  const build = "9e2e9e209";
  class ColorPicker {
    #button = null;
    #buttonSwatch = null;
    #defaultColor;
    #dropdown = null;
    #dropdownWasFromKeyboard = false;
    #isMainColorPicker = false;
    #editor = null;
    #eventBus;
    #openDropdownAC = null;
    #uiManager = null;
    static #l10nColor = null;
    static get _keyboardManager() {
      return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], ColorPicker.prototype._moveToEnd]]));
    }
    constructor({
      editor = null,
      uiManager = null
    }) {
      if (editor) {
        this.#isMainColorPicker = false;
        this.#editor = editor;
      } else {
        this.#isMainColorPicker = true;
      }
      this.#uiManager = editor?._uiManager || uiManager;
      this.#eventBus = this.#uiManager._eventBus;
      this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || "#FFFF98";
      ColorPicker.#l10nColor ||= Object.freeze({
        blue: "pdfjs-editor-colorpicker-blue",
        green: "pdfjs-editor-colorpicker-green",
        pink: "pdfjs-editor-colorpicker-pink",
        red: "pdfjs-editor-colorpicker-red",
        yellow: "pdfjs-editor-colorpicker-yellow"
      });
    }
    renderButton() {
      const button = this.#button = document.createElement("button");
      button.className = "colorPicker";
      button.tabIndex = "0";
      button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
      button.ariaHasPopup = "true";
      if (this.#editor) {
        button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;
      }
      const signal = this.#uiManager._signal;
      button.addEventListener("click", this.#openDropdown.bind(this), {
        signal
      });
      button.addEventListener("keydown", this.#keyDown.bind(this), {
        signal
      });
      const swatch = this.#buttonSwatch = document.createElement("span");
      swatch.className = "swatch";
      swatch.ariaHidden = "true";
      swatch.style.backgroundColor = this.#defaultColor;
      button.append(swatch);
      return button;
    }
    renderMainDropdown() {
      const dropdown = this.#dropdown = this.#getDropdownRoot();
      dropdown.ariaOrientation = "horizontal";
      dropdown.ariaLabelledBy = "highlightColorPickerLabel";
      return dropdown;
    }
    #getDropdownRoot() {
      const div = document.createElement("div");
      const signal = this.#uiManager._signal;
      div.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      div.className = "dropdown";
      div.role = "listbox";
      div.ariaMultiSelectable = "false";
      div.ariaOrientation = "vertical";
      div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
      if (this.#editor) {
        div.id = `${this.#editor.id}_colorpicker_dropdown`;
      }
      for (const [name, color] of this.#uiManager.highlightColors) {
        const button = document.createElement("button");
        button.tabIndex = "0";
        button.role = "option";
        button.setAttribute("data-color", color);
        button.title = name;
        button.setAttribute("data-l10n-id", ColorPicker.#l10nColor[name]);
        const swatch = document.createElement("span");
        button.append(swatch);
        swatch.className = "swatch";
        swatch.style.backgroundColor = color;
        button.ariaSelected = color === this.#defaultColor;
        button.addEventListener("click", this.#colorSelect.bind(this, color), {
          signal
        });
        div.append(button);
      }
      div.addEventListener("keydown", this.#keyDown.bind(this), {
        signal
      });
      return div;
    }
    #colorSelect(color, event) {
      event.stopPropagation();
      this.#eventBus.dispatch("switchannotationeditorparams", {
        source: this,
        type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
        value: color
      });
      this.updateColor(color);
    }
    _colorSelectFromKeyboard(event) {
      if (event.target === this.#button) {
        this.#openDropdown(event);
        return;
      }
      const color = event.target.getAttribute("data-color");
      if (!color) {
        return;
      }
      this.#colorSelect(color, event);
    }
    _moveToNext(event) {
      if (!this.#isDropdownVisible) {
        this.#openDropdown(event);
        return;
      }
      if (event.target === this.#button) {
        this.#dropdown.firstChild?.focus();
        return;
      }
      event.target.nextSibling?.focus();
    }
    _moveToPrevious(event) {
      if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {
        if (this.#isDropdownVisible) {
          this._hideDropdownFromKeyboard();
        }
        return;
      }
      if (!this.#isDropdownVisible) {
        this.#openDropdown(event);
      }
      event.target.previousSibling?.focus();
    }
    _moveToBeginning(event) {
      if (!this.#isDropdownVisible) {
        this.#openDropdown(event);
        return;
      }
      this.#dropdown.firstChild?.focus();
    }
    _moveToEnd(event) {
      if (!this.#isDropdownVisible) {
        this.#openDropdown(event);
        return;
      }
      this.#dropdown.lastChild?.focus();
    }
    #keyDown(event) {
      ColorPicker._keyboardManager.exec(this, event);
    }
    #openDropdown(event) {
      if (this.#isDropdownVisible) {
        this.hideDropdown();
        return;
      }
      this.#dropdownWasFromKeyboard = event.detail === 0;
      if (!this.#openDropdownAC) {
        this.#openDropdownAC = new AbortController();
        window.addEventListener("pointerdown", this.#pointerDown.bind(this), {
          signal: this.#uiManager.combinedSignal(this.#openDropdownAC)
        });
      }
      this.#button.ariaExpanded = "true";
      if (this.#dropdown) {
        this.#dropdown.classList.remove("hidden");
        return;
      }
      const root = this.#dropdown = this.#getDropdownRoot();
      this.#button.append(root);
    }
    #pointerDown(event) {
      if (this.#dropdown?.contains(event.target)) {
        return;
      }
      this.hideDropdown();
    }
    hideDropdown() {
      this.#dropdown?.classList.add("hidden");
      this.#button.ariaExpanded = "false";
      this.#openDropdownAC?.abort();
      this.#openDropdownAC = null;
    }
    get #isDropdownVisible() {
      return this.#dropdown && !this.#dropdown.classList.contains("hidden");
    }
    _hideDropdownFromKeyboard() {
      if (this.#isMainColorPicker) {
        return;
      }
      if (!this.#isDropdownVisible) {
        this.#editor?.unselect();
        return;
      }
      this.hideDropdown();
      this.#button.focus({
        preventScroll: true,
        focusVisible: this.#dropdownWasFromKeyboard
      });
    }
    updateColor(color) {
      if (this.#buttonSwatch) {
        this.#buttonSwatch.style.backgroundColor = color;
      }
      if (!this.#dropdown) {
        return;
      }
      const i = this.#uiManager.highlightColors.values();
      for (const child of this.#dropdown.children) {
        child.ariaSelected = i.next().value === color.toUpperCase();
      }
    }
    destroy() {
      this.#button?.remove();
      this.#button = null;
      this.#buttonSwatch = null;
      this.#dropdown?.remove();
      this.#dropdown = null;
    }
  }
  class BasicColorPicker {
    #input = null;
    #editor = null;
    #uiManager = null;
    static #l10nColor = null;
    constructor(editor) {
      this.#editor = editor;
      this.#uiManager = editor._uiManager;
      BasicColorPicker.#l10nColor ||= Object.freeze({
        freetext: "pdfjs-editor-color-picker-free-text-input",
        ink: "pdfjs-editor-color-picker-ink-input"
      });
    }
    renderButton() {
      if (this.#input) {
        return this.#input;
      }
      const {
        editorType,
        colorType,
        colorValue
      } = this.#editor;
      const input = this.#input = document.createElement("input");
      input.type = "color";
      input.value = colorValue || "#000000";
      input.className = "basicColorPicker";
      input.tabIndex = 0;
      input.setAttribute("data-l10n-id", BasicColorPicker.#l10nColor[editorType]);
      input.addEventListener("input", () => {
        this.#uiManager.updateParams(colorType, input.value);
      }, {
        signal: this.#uiManager._signal
      });
      return input;
    }
    update(value) {
      if (!this.#input) {
        return;
      }
      this.#input.value = value;
    }
    destroy() {
      this.#input?.remove();
      this.#input = null;
    }
    hideDropdown() {
    }
  }
  __webpack_require__(116);
  __webpack_require__(531);
  function makeColorComp(n) {
    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
  }
  function scaleAndClamp(x) {
    return Math.max(0, Math.min(255, 255 * x));
  }
  class ColorConverters {
    static CMYK_G([c, y, m, k]) {
      return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
    }
    static G_CMYK([g]) {
      return ["CMYK", 0, 0, 0, 1 - g];
    }
    static G_RGB([g]) {
      return ["RGB", g, g, g];
    }
    static G_rgb([g]) {
      g = scaleAndClamp(g);
      return [g, g, g];
    }
    static G_HTML([g]) {
      const G = makeColorComp(g);
      return `#${G}${G}${G}`;
    }
    static RGB_G([r, g, b]) {
      return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
    }
    static RGB_rgb(color) {
      return color.map(scaleAndClamp);
    }
    static RGB_HTML(color) {
      return `#${color.map(makeColorComp).join("")}`;
    }
    static T_HTML() {
      return "#00000000";
    }
    static T_rgb() {
      return [null];
    }
    static CMYK_RGB([c, y, m, k]) {
      return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
    }
    static CMYK_rgb([c, y, m, k]) {
      return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];
    }
    static CMYK_HTML(components) {
      const rgb = this.CMYK_RGB(components).slice(1);
      return this.RGB_HTML(rgb);
    }
    static RGB_CMYK([r, g, b]) {
      const c = 1 - r;
      const m = 1 - g;
      const y = 1 - b;
      const k = Math.min(c, m, y);
      return ["CMYK", c, m, y, k];
    }
  }
  class BaseSVGFactory {
    create(width, height, skipDimensions = false) {
      if (width <= 0 || height <= 0) {
        throw new Error("Invalid SVG dimensions");
      }
      const svg = this._createSVG("svg:svg");
      svg.setAttribute("version", "1.1");
      if (!skipDimensions) {
        svg.setAttribute("width", `${width}px`);
        svg.setAttribute("height", `${height}px`);
      }
      svg.setAttribute("preserveAspectRatio", "none");
      svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
      return svg;
    }
    createElement(type) {
      if (typeof type !== "string") {
        throw new Error("Invalid SVG element type");
      }
      return this._createSVG(type);
    }
    _createSVG(type) {
      unreachable("Abstract method `_createSVG` called.");
    }
  }
  class DOMSVGFactory extends BaseSVGFactory {
    _createSVG(type) {
      return document.createElementNS(SVG_NS, type);
    }
  }
  class XfaLayer {
    static setupStorage(html, id, element, storage, intent) {
      const storedData = storage.getValue(id, {
        value: null
      });
      switch (element.name) {
        case "textarea":
          if (storedData.value !== null) {
            html.textContent = storedData.value;
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("input", (event) => {
            storage.setValue(id, {
              value: event.target.value
            });
          });
          break;
        case "input":
          if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
            if (storedData.value === element.attributes.xfaOn) {
              html.setAttribute("checked", true);
            } else if (storedData.value === element.attributes.xfaOff) {
              html.removeAttribute("checked");
            }
            if (intent === "print") {
              break;
            }
            html.addEventListener("change", (event) => {
              storage.setValue(id, {
                value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
              });
            });
          } else {
            if (storedData.value !== null) {
              html.setAttribute("value", storedData.value);
            }
            if (intent === "print") {
              break;
            }
            html.addEventListener("input", (event) => {
              storage.setValue(id, {
                value: event.target.value
              });
            });
          }
          break;
        case "select":
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
            for (const option of element.children) {
              if (option.attributes.value === storedData.value) {
                option.attributes.selected = true;
              } else if (option.attributes.hasOwnProperty("selected")) {
                delete option.attributes.selected;
              }
            }
          }
          html.addEventListener("input", (event) => {
            const options = event.target.options;
            const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
            storage.setValue(id, {
              value
            });
          });
          break;
      }
    }
    static setAttributes({
      html,
      element,
      storage = null,
      intent,
      linkService
    }) {
      const {
        attributes
      } = element;
      const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
      if (attributes.type === "radio") {
        attributes.name = `${attributes.name}-${intent}`;
      }
      for (const [key, value] of Object.entries(attributes)) {
        if (value === null || value === void 0) {
          continue;
        }
        switch (key) {
          case "class":
            if (value.length) {
              html.setAttribute(key, value.join(" "));
            }
            break;
          case "dataId":
            break;
          case "id":
            html.setAttribute("data-element-id", value);
            break;
          case "style":
            Object.assign(html.style, value);
            break;
          case "textContent":
            html.textContent = value;
            break;
          default:
            if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
              html.setAttribute(key, value);
            }
        }
      }
      if (isHTMLAnchorElement) {
        linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
      }
      if (storage && attributes.dataId) {
        this.setupStorage(html, attributes.dataId, element, storage);
      }
    }
    static render(parameters) {
      const storage = parameters.annotationStorage;
      const linkService = parameters.linkService;
      const root = parameters.xfaHtml;
      const intent = parameters.intent || "display";
      const rootHtml = document.createElement(root.name);
      if (root.attributes) {
        this.setAttributes({
          html: rootHtml,
          element: root,
          intent,
          linkService
        });
      }
      const isNotForRichText = intent !== "richText";
      const rootDiv = parameters.div;
      rootDiv.append(rootHtml);
      if (parameters.viewport) {
        const transform = `matrix(${parameters.viewport.transform.join(",")})`;
        rootDiv.style.transform = transform;
      }
      if (isNotForRichText) {
        rootDiv.setAttribute("class", "xfaLayer xfaFont");
      }
      const textDivs = [];
      if (root.children.length === 0) {
        if (root.value) {
          const node = document.createTextNode(root.value);
          rootHtml.append(node);
          if (isNotForRichText && XfaText.shouldBuildText(root.name)) {
            textDivs.push(node);
          }
        }
        return {
          textDivs
        };
      }
      const stack = [[root, -1, rootHtml]];
      while (stack.length > 0) {
        const [parent, i, html] = stack.at(-1);
        if (i + 1 === parent.children.length) {
          stack.pop();
          continue;
        }
        const child = parent.children[++stack.at(-1)[1]];
        if (child === null) {
          continue;
        }
        const {
          name
        } = child;
        if (name === "#text") {
          const node = document.createTextNode(child.value);
          textDivs.push(node);
          html.append(node);
          continue;
        }
        const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
        html.append(childHtml);
        if (child.attributes) {
          this.setAttributes({
            html: childHtml,
            element: child,
            storage,
            intent,
            linkService
          });
        }
        if (child.children?.length > 0) {
          stack.push([child, -1, childHtml]);
        } else if (child.value) {
          const node = document.createTextNode(child.value);
          if (isNotForRichText && XfaText.shouldBuildText(name)) {
            textDivs.push(node);
          }
          childHtml.append(node);
        }
      }
      for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
        el.setAttribute("readOnly", true);
      }
      return {
        textDivs
      };
    }
    static update(parameters) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
      parameters.div.style.transform = transform;
      parameters.div.hidden = false;
    }
  }
  const annotation_layer_DEFAULT_FONT_SIZE = 9;
  const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
  const TIMEZONE_OFFSET = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 60 * 1e3;
  class AnnotationElementFactory {
    static create(parameters) {
      const subtype = parameters.data.annotationType;
      switch (subtype) {
        case AnnotationType.LINK:
          return new LinkAnnotationElement(parameters);
        case AnnotationType.TEXT:
          return new TextAnnotationElement(parameters);
        case AnnotationType.WIDGET:
          const fieldType = parameters.data.fieldType;
          switch (fieldType) {
            case "Tx":
              return new TextWidgetAnnotationElement(parameters);
            case "Btn":
              if (parameters.data.radioButton) {
                return new RadioButtonWidgetAnnotationElement(parameters);
              } else if (parameters.data.checkBox) {
                return new CheckboxWidgetAnnotationElement(parameters);
              }
              return new PushButtonWidgetAnnotationElement(parameters);
            case "Ch":
              return new ChoiceWidgetAnnotationElement(parameters);
            case "Sig":
              return new SignatureWidgetAnnotationElement(parameters);
          }
          return new WidgetAnnotationElement(parameters);
        case AnnotationType.POPUP:
          return new PopupAnnotationElement(parameters);
        case AnnotationType.FREETEXT:
          return new FreeTextAnnotationElement(parameters);
        case AnnotationType.LINE:
          return new LineAnnotationElement(parameters);
        case AnnotationType.SQUARE:
          return new SquareAnnotationElement(parameters);
        case AnnotationType.CIRCLE:
          return new CircleAnnotationElement(parameters);
        case AnnotationType.POLYLINE:
          return new PolylineAnnotationElement(parameters);
        case AnnotationType.CARET:
          return new CaretAnnotationElement(parameters);
        case AnnotationType.INK:
          return new InkAnnotationElement(parameters);
        case AnnotationType.POLYGON:
          return new PolygonAnnotationElement(parameters);
        case AnnotationType.HIGHLIGHT:
          return new HighlightAnnotationElement(parameters);
        case AnnotationType.UNDERLINE:
          return new UnderlineAnnotationElement(parameters);
        case AnnotationType.SQUIGGLY:
          return new SquigglyAnnotationElement(parameters);
        case AnnotationType.STRIKEOUT:
          return new StrikeOutAnnotationElement(parameters);
        case AnnotationType.STAMP:
          return new StampAnnotationElement(parameters);
        case AnnotationType.FILEATTACHMENT:
          return new FileAttachmentAnnotationElement(parameters);
        default:
          return new AnnotationElement(parameters);
      }
    }
  }
  class AnnotationElement {
    #updates = null;
    #hasBorder = false;
    #popupElement = null;
    constructor(parameters, {
      isRenderable = false,
      ignoreBorder = false,
      createQuadrilaterals = false
    } = {}) {
      this.isRenderable = isRenderable;
      this.data = parameters.data;
      this.layer = parameters.layer;
      this.linkService = parameters.linkService;
      this.downloadManager = parameters.downloadManager;
      this.imageResourcesPath = parameters.imageResourcesPath;
      this.renderForms = parameters.renderForms;
      this.svgFactory = parameters.svgFactory;
      this.annotationStorage = parameters.annotationStorage;
      this.enableComment = parameters.enableComment;
      this.enableScripting = parameters.enableScripting;
      this.hasJSActions = parameters.hasJSActions;
      this._fieldObjects = parameters.fieldObjects;
      this.parent = parameters.parent;
      if (isRenderable) {
        this.container = this._createContainer(ignoreBorder);
      }
      if (createQuadrilaterals) {
        this._createQuadrilaterals();
      }
    }
    static _hasPopupData({
      contentsObj,
      richText
    }) {
      return !!(contentsObj?.str || richText?.str);
    }
    get _isEditable() {
      return this.data.isEditable;
    }
    get hasPopupData() {
      return AnnotationElement._hasPopupData(this.data);
    }
    get hasCommentButton() {
      return this.enableComment && this._isEditable && this.hasPopupElement;
    }
    get commentButtonPosition() {
      const {
        quadPoints,
        rect
      } = this.data;
      let maxX = -Infinity;
      let maxY = -Infinity;
      if (quadPoints?.length >= 8) {
        for (let i = 0; i < quadPoints.length; i += 8) {
          if (quadPoints[i + 1] > maxY) {
            maxY = quadPoints[i + 1];
            maxX = quadPoints[i + 2];
          } else if (quadPoints[i + 1] === maxY) {
            maxX = Math.max(maxX, quadPoints[i + 2]);
          }
        }
        return [maxX, maxY];
      }
      if (rect) {
        return [rect[2], rect[3]];
      }
      return null;
    }
    get commentButtonColor() {
      if (!this.data.color) {
        return null;
      }
      const [r, g, b] = this.data.color;
      const opacity = this.data.opacity ?? 1;
      const oppositeOpacity = 255 * (1 - opacity);
      return this.#changeLightness(Math.min(r + oppositeOpacity, 255), Math.min(g + oppositeOpacity, 255), Math.min(b + oppositeOpacity, 255));
    }
    #changeLightness(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const l = (max + min) / 2;
      const newL = ((1 + Math.sqrt(l)) / 2 * 100).toFixed(2);
      if (max === min) {
        return `hsl(0, 0%, ${newL}%)`;
      }
      const d = max - min;
      let h;
      if (max === r) {
        h = (g - b) / d + (g < b ? 6 : 0);
      } else if (max === g) {
        h = (b - r) / d + 2;
      } else {
        h = (r - g) / d + 4;
      }
      h = (h * 60).toFixed(2);
      const s = (d / (1 - Math.abs(2 * l - 1)) * 100).toFixed(2);
      return `hsl(${h}, ${s}%, ${newL}%)`;
    }
    _normalizePoint(point) {
      const {
        page: {
          view
        },
        viewport: {
          rawDims: {
            pageWidth,
            pageHeight,
            pageX,
            pageY
          }
        }
      } = this.parent;
      point[1] = view[3] - point[1] + view[1];
      point[0] = 100 * (point[0] - pageX) / pageWidth;
      point[1] = 100 * (point[1] - pageY) / pageHeight;
      return point;
    }
    updateEdited(params) {
      if (!this.container) {
        return;
      }
      if (params.rect) {
        this.#updates ||= {
          rect: this.data.rect.slice(0)
        };
      }
      const {
        rect,
        popup: newPopup
      } = params;
      if (rect) {
        this.#setRectEdited(rect);
      }
      let popup = this.#popupElement?.popup || this.popup;
      if (!popup && newPopup?.text) {
        this._createPopup(newPopup);
        popup = this.#popupElement.popup;
      }
      if (!popup) {
        return;
      }
      popup.updateEdited(params);
      if (newPopup?.deleted) {
        popup.remove();
        this.#popupElement = null;
        this.popup = null;
      }
    }
    resetEdited() {
      if (!this.#updates) {
        return;
      }
      this.#setRectEdited(this.#updates.rect);
      this.#popupElement?.popup.resetEdited();
      this.#updates = null;
    }
    #setRectEdited(rect) {
      const {
        container: {
          style
        },
        data: {
          rect: currentRect,
          rotation
        },
        parent: {
          viewport: {
            rawDims: {
              pageWidth,
              pageHeight,
              pageX,
              pageY
            }
          }
        }
      } = this;
      currentRect?.splice(0, 4, ...rect);
      style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
      style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;
      if (rotation === 0) {
        style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;
        style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;
      } else {
        this.setRotation(rotation);
      }
    }
    _createContainer(ignoreBorder) {
      const {
        data,
        parent: {
          page,
          viewport
        }
      } = this;
      const container = document.createElement("section");
      container.setAttribute("data-annotation-id", data.id);
      if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {
        container.tabIndex = 0;
      }
      const {
        style
      } = container;
      style.zIndex = this.parent.zIndex;
      this.parent.zIndex += 2;
      if (data.alternativeText) {
        container.title = data.alternativeText;
      }
      if (data.noRotate) {
        container.classList.add("norotate");
      }
      if (!data.rect || this instanceof PopupAnnotationElement) {
        const {
          rotation: rotation2
        } = data;
        if (!data.hasOwnCanvas && rotation2 !== 0) {
          this.setRotation(rotation2, container);
        }
        return container;
      }
      const {
        width,
        height
      } = this;
      if (!ignoreBorder && data.borderStyle.width > 0) {
        style.borderWidth = `${data.borderStyle.width}px`;
        const horizontalRadius = data.borderStyle.horizontalCornerRadius;
        const verticalRadius = data.borderStyle.verticalCornerRadius;
        if (horizontalRadius > 0 || verticalRadius > 0) {
          const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;
          style.borderRadius = radius;
        } else if (this instanceof RadioButtonWidgetAnnotationElement) {
          const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;
          style.borderRadius = radius;
        }
        switch (data.borderStyle.style) {
          case AnnotationBorderStyleType.SOLID:
            style.borderStyle = "solid";
            break;
          case AnnotationBorderStyleType.DASHED:
            style.borderStyle = "dashed";
            break;
          case AnnotationBorderStyleType.BEVELED:
            warn("Unimplemented border style: beveled");
            break;
          case AnnotationBorderStyleType.INSET:
            warn("Unimplemented border style: inset");
            break;
          case AnnotationBorderStyleType.UNDERLINE:
            style.borderBottomStyle = "solid";
            break;
        }
        const borderColor = data.borderColor || null;
        if (borderColor) {
          this.#hasBorder = true;
          style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
        } else {
          style.borderWidth = 0;
        }
      }
      const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
      const {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      } = viewport.rawDims;
      style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
      style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
      const {
        rotation
      } = data;
      if (data.hasOwnCanvas || rotation === 0) {
        style.width = `${100 * width / pageWidth}%`;
        style.height = `${100 * height / pageHeight}%`;
      } else {
        this.setRotation(rotation, container);
      }
      return container;
    }
    setRotation(angle, container = this.container) {
      if (!this.data.rect) {
        return;
      }
      const {
        pageWidth,
        pageHeight
      } = this.parent.viewport.rawDims;
      let {
        width,
        height
      } = this;
      if (angle % 180 !== 0) {
        [width, height] = [height, width];
      }
      container.style.width = `${100 * width / pageWidth}%`;
      container.style.height = `${100 * height / pageHeight}%`;
      container.setAttribute("data-main-rotation", (360 - angle) % 360);
    }
    get _commonActions() {
      const setColor = (jsName, styleName, event) => {
        const color = event.detail[jsName];
        const colorType = color[0];
        const colorArray = color.slice(1);
        event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);
        this.annotationStorage.setValue(this.data.id, {
          [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)
        });
      };
      return shadow(this, "_commonActions", {
        display: (event) => {
          const {
            display
          } = event.detail;
          const hidden = display % 2 === 1;
          this.container.style.visibility = hidden ? "hidden" : "visible";
          this.annotationStorage.setValue(this.data.id, {
            noView: hidden,
            noPrint: display === 1 || display === 2
          });
        },
        print: (event) => {
          this.annotationStorage.setValue(this.data.id, {
            noPrint: !event.detail.print
          });
        },
        hidden: (event) => {
          const {
            hidden
          } = event.detail;
          this.container.style.visibility = hidden ? "hidden" : "visible";
          this.annotationStorage.setValue(this.data.id, {
            noPrint: hidden,
            noView: hidden
          });
        },
        focus: (event) => {
          setTimeout(() => event.target.focus({
            preventScroll: false
          }), 0);
        },
        userName: (event) => {
          event.target.title = event.detail.userName;
        },
        readonly: (event) => {
          event.target.disabled = event.detail.readonly;
        },
        required: (event) => {
          this._setRequired(event.target, event.detail.required);
        },
        bgColor: (event) => {
          setColor("bgColor", "backgroundColor", event);
        },
        fillColor: (event) => {
          setColor("fillColor", "backgroundColor", event);
        },
        fgColor: (event) => {
          setColor("fgColor", "color", event);
        },
        textColor: (event) => {
          setColor("textColor", "color", event);
        },
        borderColor: (event) => {
          setColor("borderColor", "borderColor", event);
        },
        strokeColor: (event) => {
          setColor("strokeColor", "borderColor", event);
        },
        rotation: (event) => {
          const angle = event.detail.rotation;
          this.setRotation(angle);
          this.annotationStorage.setValue(this.data.id, {
            rotation: angle
          });
        }
      });
    }
    _dispatchEventFromSandbox(actions, jsEvent) {
      const commonActions = this._commonActions;
      for (const name of Object.keys(jsEvent.detail)) {
        const action = actions[name] || commonActions[name];
        action?.(jsEvent);
      }
    }
    _setDefaultPropertiesFromJS(element) {
      if (!this.enableScripting) {
        return;
      }
      const storedData = this.annotationStorage.getRawValue(this.data.id);
      if (!storedData) {
        return;
      }
      const commonActions = this._commonActions;
      for (const [actionName, detail] of Object.entries(storedData)) {
        const action = commonActions[actionName];
        if (action) {
          const eventProxy = {
            detail: {
              [actionName]: detail
            },
            target: element
          };
          action(eventProxy);
          delete storedData[actionName];
        }
      }
    }
    _createQuadrilaterals() {
      if (!this.container) {
        return;
      }
      const {
        quadPoints
      } = this.data;
      if (!quadPoints) {
        return;
      }
      const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x) => Math.fround(x));
      if (quadPoints.length === 8) {
        const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);
        if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
          return;
        }
      }
      const {
        style
      } = this.container;
      let svgBuffer;
      if (this.#hasBorder) {
        const {
          borderColor,
          borderWidth
        } = style;
        style.borderWidth = 0;
        svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
        this.container.classList.add("hasBorder");
      }
      const width = rectTrX - rectBlX;
      const height = rectTrY - rectBlY;
      const {
        svgFactory
      } = this;
      const svg = svgFactory.createElement("svg");
      svg.classList.add("quadrilateralsContainer");
      svg.setAttribute("width", 0);
      svg.setAttribute("height", 0);
      svg.role = "none";
      const defs = svgFactory.createElement("defs");
      svg.append(defs);
      const clipPath = svgFactory.createElement("clipPath");
      const id = `clippath_${this.data.id}`;
      clipPath.setAttribute("id", id);
      clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
      defs.append(clipPath);
      for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {
        const trX = quadPoints[i];
        const trY = quadPoints[i + 1];
        const blX = quadPoints[i + 2];
        const blY = quadPoints[i + 3];
        const rect = svgFactory.createElement("rect");
        const x = (blX - rectBlX) / width;
        const y = (rectTrY - trY) / height;
        const rectWidth = (trX - blX) / width;
        const rectHeight = (trY - blY) / height;
        rect.setAttribute("x", x);
        rect.setAttribute("y", y);
        rect.setAttribute("width", rectWidth);
        rect.setAttribute("height", rectHeight);
        clipPath.append(rect);
        svgBuffer?.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`);
      }
      if (this.#hasBorder) {
        svgBuffer.push(`</g></svg>')`);
        style.backgroundImage = svgBuffer.join("");
      }
      this.container.append(svg);
      this.container.style.clipPath = `url(#${id})`;
    }
    _createPopup(popupData = null) {
      const {
        data
      } = this;
      let contentsObj, modificationDate;
      if (popupData) {
        contentsObj = {
          str: popupData.text
        };
        modificationDate = popupData.date;
      } else {
        contentsObj = data.contentsObj;
        modificationDate = data.modificationDate;
      }
      const popup = this.#popupElement = new PopupAnnotationElement({
        data: {
          color: data.color,
          titleObj: data.titleObj,
          modificationDate,
          contentsObj,
          richText: data.richText,
          parentRect: data.rect,
          borderStyle: 0,
          id: `popup_${data.id}`,
          rotation: data.rotation,
          noRotate: true
        },
        linkService: this.linkService,
        parent: this.parent,
        elements: [this]
      });
      this.parent.div.append(popup.render());
    }
    get hasPopupElement() {
      return !!(this.#popupElement || this.popup || this.data.popupRef);
    }
    render() {
      unreachable("Abstract method `AnnotationElement.render` called");
    }
    _getElementsByName(name, skipId = null) {
      const fields = [];
      if (this._fieldObjects) {
        const fieldObj = this._fieldObjects[name];
        if (fieldObj) {
          for (const {
            page,
            id,
            exportValues
          } of fieldObj) {
            if (page === -1) {
              continue;
            }
            if (id === skipId) {
              continue;
            }
            const exportValue = typeof exportValues === "string" ? exportValues : null;
            const domElement = document.querySelector(`[data-element-id="${id}"]`);
            if (domElement && !GetElementsByNameSet.has(domElement)) {
              warn(`_getElementsByName - element not allowed: ${id}`);
              continue;
            }
            fields.push({
              id,
              exportValue,
              domElement
            });
          }
        }
        return fields;
      }
      for (const domElement of document.getElementsByName(name)) {
        const {
          exportValue
        } = domElement;
        const id = domElement.getAttribute("data-element-id");
        if (id === skipId) {
          continue;
        }
        if (!GetElementsByNameSet.has(domElement)) {
          continue;
        }
        fields.push({
          id,
          exportValue,
          domElement
        });
      }
      return fields;
    }
    show() {
      if (this.container) {
        this.container.hidden = false;
      }
      this.popup?.maybeShow();
    }
    hide() {
      if (this.container) {
        this.container.hidden = true;
      }
      this.popup?.forceHide();
    }
    getElementsToTriggerPopup() {
      return this.container;
    }
    addHighlightArea() {
      const triggers = this.getElementsToTriggerPopup();
      if (Array.isArray(triggers)) {
        for (const element of triggers) {
          element.classList.add("highlightArea");
        }
      } else {
        triggers.classList.add("highlightArea");
      }
    }
    _editOnDoubleClick() {
      if (!this._isEditable) {
        return;
      }
      const {
        annotationEditorType: mode,
        data: {
          id: editId
        }
      } = this;
      this.container.addEventListener("dblclick", () => {
        this.linkService.eventBus?.dispatch("switchannotationeditormode", {
          source: this,
          mode,
          editId,
          mustEnterInEditMode: true
        });
      });
    }
    get width() {
      return this.data.rect[2] - this.data.rect[0];
    }
    get height() {
      return this.data.rect[3] - this.data.rect[1];
    }
  }
  class LinkAnnotationElement extends AnnotationElement {
    constructor(parameters, options = null) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: !!options?.ignoreBorder,
        createQuadrilaterals: true
      });
      this.isTooltipOnly = parameters.data.isTooltipOnly;
    }
    render() {
      const {
        data,
        linkService
      } = this;
      const link = document.createElement("a");
      link.setAttribute("data-element-id", data.id);
      let isBound = false;
      if (data.url) {
        linkService.addLinkAttributes(link, data.url, data.newWindow);
        isBound = true;
      } else if (data.action) {
        this._bindNamedAction(link, data.action, data.overlaidText);
        isBound = true;
      } else if (data.attachment) {
        this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);
        isBound = true;
      } else if (data.setOCGState) {
        this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);
        isBound = true;
      } else if (data.dest) {
        this._bindLink(link, data.dest, data.overlaidText);
        isBound = true;
      } else {
        if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
          this._bindJSAction(link, data);
          isBound = true;
        }
        if (data.resetForm) {
          this._bindResetFormAction(link, data.resetForm);
          isBound = true;
        } else if (this.isTooltipOnly && !isBound) {
          this._bindLink(link, "");
          isBound = true;
        }
      }
      this.container.classList.add("linkAnnotation");
      if (isBound) {
        this.container.append(link);
      }
      return this.container;
    }
    #setInternalLink() {
      this.container.setAttribute("data-internal-link", "");
    }
    _bindLink(link, destination, overlaidText = "") {
      link.href = this.linkService.getDestinationHash(destination);
      link.onclick = () => {
        if (destination) {
          this.linkService.goToDestination(destination);
        }
        return false;
      };
      if (destination || destination === "") {
        this.#setInternalLink();
      }
      if (overlaidText) {
        link.title = overlaidText;
      }
    }
    _bindNamedAction(link, action, overlaidText = "") {
      link.href = this.linkService.getAnchorUrl("");
      link.onclick = () => {
        this.linkService.executeNamedAction(action);
        return false;
      };
      if (overlaidText) {
        link.title = overlaidText;
      }
      this.#setInternalLink();
    }
    #bindAttachment(link, attachment, overlaidText = "", dest = null) {
      link.href = this.linkService.getAnchorUrl("");
      if (attachment.description) {
        link.title = attachment.description;
      } else if (overlaidText) {
        link.title = overlaidText;
      }
      link.onclick = () => {
        this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);
        return false;
      };
      this.#setInternalLink();
    }
    #bindSetOCGState(link, action, overlaidText = "") {
      link.href = this.linkService.getAnchorUrl("");
      link.onclick = () => {
        this.linkService.executeSetOCGState(action);
        return false;
      };
      if (overlaidText) {
        link.title = overlaidText;
      }
      this.#setInternalLink();
    }
    _bindJSAction(link, data) {
      link.href = this.linkService.getAnchorUrl("");
      const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
      for (const name of Object.keys(data.actions)) {
        const jsName = map.get(name);
        if (!jsName) {
          continue;
        }
        link[jsName] = () => {
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: data.id,
              name
            }
          });
          return false;
        };
      }
      if (data.overlaidText) {
        link.title = data.overlaidText;
      }
      if (!link.onclick) {
        link.onclick = () => false;
      }
      this.#setInternalLink();
    }
    _bindResetFormAction(link, resetForm) {
      const otherClickAction = link.onclick;
      if (!otherClickAction) {
        link.href = this.linkService.getAnchorUrl("");
      }
      this.#setInternalLink();
      if (!this._fieldObjects) {
        warn(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
        if (!otherClickAction) {
          link.onclick = () => false;
        }
        return;
      }
      link.onclick = () => {
        otherClickAction?.();
        const {
          fields: resetFormFields,
          refs: resetFormRefs,
          include
        } = resetForm;
        const allFields = [];
        if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
          const fieldIds = new Set(resetFormRefs);
          for (const fieldName of resetFormFields) {
            const fields = this._fieldObjects[fieldName] || [];
            for (const {
              id
            } of fields) {
              fieldIds.add(id);
            }
          }
          for (const fields of Object.values(this._fieldObjects)) {
            for (const field of fields) {
              if (fieldIds.has(field.id) === include) {
                allFields.push(field);
              }
            }
          }
        } else {
          for (const fields of Object.values(this._fieldObjects)) {
            allFields.push(...fields);
          }
        }
        const storage = this.annotationStorage;
        const allIds = [];
        for (const field of allFields) {
          const {
            id
          } = field;
          allIds.push(id);
          switch (field.type) {
            case "text": {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }
            case "checkbox":
            case "radiobutton": {
              const value = field.defaultValue === field.exportValues;
              storage.setValue(id, {
                value
              });
              break;
            }
            case "combobox":
            case "listbox": {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }
            default:
              continue;
          }
          const domElement = document.querySelector(`[data-element-id="${id}"]`);
          if (!domElement) {
            continue;
          } else if (!GetElementsByNameSet.has(domElement)) {
            warn(`_bindResetFormAction - element not allowed: ${id}`);
            continue;
          }
          domElement.dispatchEvent(new Event("resetform"));
        }
        if (this.enableScripting) {
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: "app",
              ids: allIds,
              name: "ResetForm"
            }
          });
        }
        return false;
      };
    }
  }
  class TextAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: true
      });
    }
    render() {
      this.container.classList.add("textAnnotation");
      const image = document.createElement("img");
      image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
      image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
      image.setAttribute("data-l10n-args", JSON.stringify({
        type: this.data.name
      }));
      if (!this.data.popupRef && this.hasPopupData) {
        this._createPopup();
      }
      this.container.append(image);
      return this.container;
    }
  }
  class WidgetAnnotationElement extends AnnotationElement {
    render() {
      return this.container;
    }
    showElementAndHideCanvas(element) {
      if (this.data.hasOwnCanvas) {
        if (element.previousSibling?.nodeName === "CANVAS") {
          element.previousSibling.hidden = true;
        }
        element.hidden = false;
      }
    }
    _getKeyModifier(event) {
      return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
    }
    _setEventListener(element, elementData, baseName, eventName, valueGetter) {
      if (baseName.includes("mouse")) {
        element.addEventListener(baseName, (event) => {
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: this.data.id,
              name: eventName,
              value: valueGetter(event),
              shift: event.shiftKey,
              modifier: this._getKeyModifier(event)
            }
          });
        });
      } else {
        element.addEventListener(baseName, (event) => {
          if (baseName === "blur") {
            if (!elementData.focused || !event.relatedTarget) {
              return;
            }
            elementData.focused = false;
          } else if (baseName === "focus") {
            if (elementData.focused) {
              return;
            }
            elementData.focused = true;
          }
          if (!valueGetter) {
            return;
          }
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: this.data.id,
              name: eventName,
              value: valueGetter(event)
            }
          });
        });
      }
    }
    _setEventListeners(element, elementData, names, getter) {
      for (const [baseName, eventName] of names) {
        if (eventName === "Action" || this.data.actions?.[eventName]) {
          if (eventName === "Focus" || eventName === "Blur") {
            elementData ||= {
              focused: false
            };
          }
          this._setEventListener(element, elementData, baseName, eventName, getter);
          if (eventName === "Focus" && !this.data.actions?.Blur) {
            this._setEventListener(element, elementData, "blur", "Blur", null);
          } else if (eventName === "Blur" && !this.data.actions?.Focus) {
            this._setEventListener(element, elementData, "focus", "Focus", null);
          }
        }
      }
    }
    _setBackgroundColor(element) {
      const color = this.data.backgroundColor || null;
      element.style.backgroundColor = color === null ? "transparent" : Util.makeHexColor(color[0], color[1], color[2]);
    }
    _setTextStyle(element) {
      const TEXT_ALIGNMENT = ["left", "center", "right"];
      const {
        fontColor
      } = this.data.defaultAppearanceData;
      const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;
      const style = element.style;
      let computedFontSize;
      const BORDER_SIZE = 2;
      const roundToOneDecimal = (x) => Math.round(10 * x) / 10;
      if (this.data.multiLine) {
        const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
        const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
        const lineHeight = height / numberOfLines;
        computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));
      } else {
        const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
        computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));
      }
      style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;
      style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
      if (this.data.textAlignment !== null) {
        style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
      }
    }
    _setRequired(element, isRequired) {
      if (isRequired) {
        element.setAttribute("required", true);
      } else {
        element.removeAttribute("required");
      }
      element.setAttribute("aria-required", isRequired);
    }
  }
  class TextWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters) {
      const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
      super(parameters, {
        isRenderable
      });
    }
    setPropertyOnSiblings(base, key, value, keyInStorage) {
      const storage = this.annotationStorage;
      for (const element of this._getElementsByName(base.name, base.id)) {
        if (element.domElement) {
          element.domElement[key] = value;
        }
        storage.setValue(element.id, {
          [keyInStorage]: value
        });
      }
    }
    render() {
      const storage = this.annotationStorage;
      const id = this.data.id;
      this.container.classList.add("textWidgetAnnotation");
      let element = null;
      if (this.renderForms) {
        const storedData = storage.getValue(id, {
          value: this.data.fieldValue
        });
        let textContent = storedData.value || "";
        const maxLen = storage.getValue(id, {
          charLimit: this.data.maxLen
        }).charLimit;
        if (maxLen && textContent.length > maxLen) {
          textContent = textContent.slice(0, maxLen);
        }
        let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join("\n") || null;
        if (fieldFormattedValues && this.data.comb) {
          fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
        }
        const elementData = {
          userValue: textContent,
          formattedValue: fieldFormattedValues,
          lastCommittedValue: null,
          commitKey: 1,
          focused: false
        };
        if (this.data.multiLine) {
          element = document.createElement("textarea");
          element.textContent = fieldFormattedValues ?? textContent;
          if (this.data.doNotScroll) {
            element.style.overflowY = "hidden";
          }
        } else {
          element = document.createElement("input");
          element.type = this.data.password ? "password" : "text";
          element.setAttribute("value", fieldFormattedValues ?? textContent);
          if (this.data.doNotScroll) {
            element.style.overflowX = "hidden";
          }
        }
        if (this.data.hasOwnCanvas) {
          element.hidden = true;
        }
        GetElementsByNameSet.add(element);
        element.setAttribute("data-element-id", id);
        element.disabled = this.data.readOnly;
        element.name = this.data.fieldName;
        element.tabIndex = 0;
        const {
          datetimeFormat,
          datetimeType,
          timeStep
        } = this.data;
        const hasDateOrTime = !!datetimeType && this.enableScripting;
        if (datetimeFormat) {
          element.title = datetimeFormat;
        }
        this._setRequired(element, this.data.required);
        if (maxLen) {
          element.maxLength = maxLen;
        }
        element.addEventListener("input", (event) => {
          storage.setValue(id, {
            value: event.target.value
          });
          this.setPropertyOnSiblings(element, "value", event.target.value, "value");
          elementData.formattedValue = null;
        });
        element.addEventListener("resetform", (event) => {
          const defaultValue = this.data.defaultFieldValue ?? "";
          element.value = elementData.userValue = defaultValue;
          elementData.formattedValue = null;
        });
        let blurListener = (event) => {
          const {
            formattedValue
          } = elementData;
          if (formattedValue !== null && formattedValue !== void 0) {
            event.target.value = formattedValue;
          }
          event.target.scrollLeft = 0;
        };
        if (this.enableScripting && this.hasJSActions) {
          element.addEventListener("focus", (event) => {
            if (elementData.focused) {
              return;
            }
            const {
              target
            } = event;
            if (hasDateOrTime) {
              target.type = datetimeType;
              if (timeStep) {
                target.step = timeStep;
              }
            }
            if (elementData.userValue) {
              const value = elementData.userValue;
              if (hasDateOrTime) {
                if (datetimeType === "time") {
                  const date = new Date(value);
                  const parts = [date.getHours(), date.getMinutes(), date.getSeconds()];
                  target.value = parts.map((v) => v.toString().padStart(2, "0")).join(":");
                } else {
                  target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === "date" ? "T" : ".", 1)[0];
                }
              } else {
                target.value = value;
              }
            }
            elementData.lastCommittedValue = target.value;
            elementData.commitKey = 1;
            if (!this.data.actions?.Focus) {
              elementData.focused = true;
            }
          });
          element.addEventListener("updatefromsandbox", (jsEvent) => {
            this.showElementAndHideCanvas(jsEvent.target);
            const actions = {
              value(event) {
                elementData.userValue = event.detail.value ?? "";
                if (!hasDateOrTime) {
                  storage.setValue(id, {
                    value: elementData.userValue.toString()
                  });
                }
                event.target.value = elementData.userValue;
              },
              formattedValue(event) {
                const {
                  formattedValue
                } = event.detail;
                elementData.formattedValue = formattedValue;
                if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                  event.target.value = formattedValue;
                }
                const data = {
                  formattedValue
                };
                if (hasDateOrTime) {
                  data.value = formattedValue;
                }
                storage.setValue(id, data);
              },
              selRange(event) {
                event.target.setSelectionRange(...event.detail.selRange);
              },
              charLimit: (event) => {
                const {
                  charLimit
                } = event.detail;
                const {
                  target
                } = event;
                if (charLimit === 0) {
                  target.removeAttribute("maxLength");
                  return;
                }
                target.setAttribute("maxLength", charLimit);
                let value = elementData.userValue;
                if (!value || value.length <= charLimit) {
                  return;
                }
                value = value.slice(0, charLimit);
                target.value = elementData.userValue = value;
                storage.setValue(id, {
                  value
                });
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id,
                    name: "Keystroke",
                    value,
                    willCommit: true,
                    commitKey: 1,
                    selStart: target.selectionStart,
                    selEnd: target.selectionEnd
                  }
                });
              }
            };
            this._dispatchEventFromSandbox(actions, jsEvent);
          });
          element.addEventListener("keydown", (event) => {
            elementData.commitKey = 1;
            let commitKey = -1;
            if (event.key === "Escape") {
              commitKey = 0;
            } else if (event.key === "Enter" && !this.data.multiLine) {
              commitKey = 2;
            } else if (event.key === "Tab") {
              elementData.commitKey = 3;
            }
            if (commitKey === -1) {
              return;
            }
            const {
              value
            } = event.target;
            if (elementData.lastCommittedValue === value) {
              return;
            }
            elementData.lastCommittedValue = value;
            elementData.userValue = value;
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                willCommit: true,
                commitKey,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          });
          const _blurListener = blurListener;
          blurListener = null;
          element.addEventListener("blur", (event) => {
            if (!elementData.focused || !event.relatedTarget) {
              return;
            }
            if (!this.data.actions?.Blur) {
              elementData.focused = false;
            }
            const {
              target
            } = event;
            let {
              value
            } = target;
            if (hasDateOrTime) {
              if (value && datetimeType === "time") {
                const parts = value.split(":").map((v) => parseInt(v, 10));
                value = new Date(2e3, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();
                target.step = "";
              } else {
                value = new Date(value).valueOf();
              }
              target.type = "text";
            }
            elementData.userValue = value;
            if (elementData.lastCommittedValue !== value) {
              this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey: elementData.commitKey,
                  selStart: event.target.selectionStart,
                  selEnd: event.target.selectionEnd
                }
              });
            }
            _blurListener(event);
          });
          if (this.data.actions?.Keystroke) {
            element.addEventListener("beforeinput", (event) => {
              elementData.lastCommittedValue = null;
              const {
                data,
                target
              } = event;
              const {
                value,
                selectionStart,
                selectionEnd
              } = target;
              let selStart = selectionStart, selEnd = selectionEnd;
              switch (event.inputType) {
                case "deleteWordBackward": {
                  const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                  if (match) {
                    selStart -= match[0].length;
                  }
                  break;
                }
                case "deleteWordForward": {
                  const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                  if (match) {
                    selEnd += match[0].length;
                  }
                  break;
                }
                case "deleteContentBackward":
                  if (selectionStart === selectionEnd) {
                    selStart -= 1;
                  }
                  break;
                case "deleteContentForward":
                  if (selectionStart === selectionEnd) {
                    selEnd += 1;
                  }
                  break;
              }
              event.preventDefault();
              this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  change: data || "",
                  willCommit: false,
                  selStart,
                  selEnd
                }
              });
            });
          }
          this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
        }
        if (blurListener) {
          element.addEventListener("blur", blurListener);
        }
        if (this.data.comb) {
          const fieldWidth = this.data.rect[2] - this.data.rect[0];
          const combWidth = fieldWidth / maxLen;
          element.classList.add("comb");
          element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;
        }
      } else {
        element = document.createElement("div");
        element.textContent = this.data.fieldValue;
        element.style.verticalAlign = "middle";
        element.style.display = "table-cell";
        if (this.data.hasOwnCanvas) {
          element.hidden = true;
        }
      }
      this._setTextStyle(element);
      this._setBackgroundColor(element);
      this._setDefaultPropertiesFromJS(element);
      this.container.append(element);
      return this.container;
    }
  }
  class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: !!parameters.data.hasOwnCanvas
      });
    }
  }
  class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: parameters.renderForms
      });
    }
    render() {
      const storage = this.annotationStorage;
      const data = this.data;
      const id = data.id;
      let value = storage.getValue(id, {
        value: data.exportValue === data.fieldValue
      }).value;
      if (typeof value === "string") {
        value = value !== "Off";
        storage.setValue(id, {
          value
        });
      }
      this.container.classList.add("buttonWidgetAnnotation", "checkBox");
      const element = document.createElement("input");
      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id);
      element.disabled = data.readOnly;
      this._setRequired(element, this.data.required);
      element.type = "checkbox";
      element.name = data.fieldName;
      if (value) {
        element.setAttribute("checked", true);
      }
      element.setAttribute("exportValue", data.exportValue);
      element.tabIndex = 0;
      element.addEventListener("change", (event) => {
        const {
          name,
          checked
        } = event.target;
        for (const checkbox of this._getElementsByName(name, id)) {
          const curChecked = checked && checkbox.exportValue === data.exportValue;
          if (checkbox.domElement) {
            checkbox.domElement.checked = curChecked;
          }
          storage.setValue(checkbox.id, {
            value: curChecked
          });
        }
        storage.setValue(id, {
          value: checked
        });
      });
      element.addEventListener("resetform", (event) => {
        const defaultValue = data.defaultFieldValue || "Off";
        event.target.checked = defaultValue === data.exportValue;
      });
      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("updatefromsandbox", (jsEvent) => {
          const actions = {
            value(event) {
              event.target.checked = event.detail.value !== "Off";
              storage.setValue(id, {
                value: event.target.checked
              });
            }
          };
          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
      }
      this._setBackgroundColor(element);
      this._setDefaultPropertiesFromJS(element);
      this.container.append(element);
      return this.container;
    }
  }
  class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: parameters.renderForms
      });
    }
    render() {
      this.container.classList.add("buttonWidgetAnnotation", "radioButton");
      const storage = this.annotationStorage;
      const data = this.data;
      const id = data.id;
      let value = storage.getValue(id, {
        value: data.fieldValue === data.buttonValue
      }).value;
      if (typeof value === "string") {
        value = value !== data.buttonValue;
        storage.setValue(id, {
          value
        });
      }
      if (value) {
        for (const radio of this._getElementsByName(data.fieldName, id)) {
          storage.setValue(radio.id, {
            value: false
          });
        }
      }
      const element = document.createElement("input");
      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id);
      element.disabled = data.readOnly;
      this._setRequired(element, this.data.required);
      element.type = "radio";
      element.name = data.fieldName;
      if (value) {
        element.setAttribute("checked", true);
      }
      element.tabIndex = 0;
      element.addEventListener("change", (event) => {
        const {
          name,
          checked
        } = event.target;
        for (const radio of this._getElementsByName(name, id)) {
          storage.setValue(radio.id, {
            value: false
          });
        }
        storage.setValue(id, {
          value: checked
        });
      });
      element.addEventListener("resetform", (event) => {
        const defaultValue = data.defaultFieldValue;
        event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
      });
      if (this.enableScripting && this.hasJSActions) {
        const pdfButtonValue = data.buttonValue;
        element.addEventListener("updatefromsandbox", (jsEvent) => {
          const actions = {
            value: (event) => {
              const checked = pdfButtonValue === event.detail.value;
              for (const radio of this._getElementsByName(event.target.name)) {
                const curChecked = checked && radio.id === id;
                if (radio.domElement) {
                  radio.domElement.checked = curChecked;
                }
                storage.setValue(radio.id, {
                  value: curChecked
                });
              }
            }
          };
          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
      }
      this._setBackgroundColor(element);
      this._setDefaultPropertiesFromJS(element);
      this.container.append(element);
      return this.container;
    }
  }
  class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
    constructor(parameters) {
      super(parameters, {
        ignoreBorder: parameters.data.hasAppearance
      });
    }
    render() {
      const container = super.render();
      container.classList.add("buttonWidgetAnnotation", "pushButton");
      const linkElement = container.lastChild;
      if (this.enableScripting && this.hasJSActions && linkElement) {
        this._setDefaultPropertiesFromJS(linkElement);
        linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
          this._dispatchEventFromSandbox({}, jsEvent);
        });
      }
      return container;
    }
  }
  class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: parameters.renderForms
      });
    }
    render() {
      this.container.classList.add("choiceWidgetAnnotation");
      const storage = this.annotationStorage;
      const id = this.data.id;
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue
      });
      const selectElement = document.createElement("select");
      GetElementsByNameSet.add(selectElement);
      selectElement.setAttribute("data-element-id", id);
      selectElement.disabled = this.data.readOnly;
      this._setRequired(selectElement, this.data.required);
      selectElement.name = this.data.fieldName;
      selectElement.tabIndex = 0;
      let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
      if (!this.data.combo) {
        selectElement.size = this.data.options.length;
        if (this.data.multiSelect) {
          selectElement.multiple = true;
        }
      }
      selectElement.addEventListener("resetform", (event) => {
        const defaultValue = this.data.defaultFieldValue;
        for (const option of selectElement.options) {
          option.selected = option.value === defaultValue;
        }
      });
      for (const option of this.data.options) {
        const optionElement = document.createElement("option");
        optionElement.textContent = option.displayValue;
        optionElement.value = option.exportValue;
        if (storedData.value.includes(option.exportValue)) {
          optionElement.setAttribute("selected", true);
          addAnEmptyEntry = false;
        }
        selectElement.append(optionElement);
      }
      let removeEmptyEntry = null;
      if (addAnEmptyEntry) {
        const noneOptionElement = document.createElement("option");
        noneOptionElement.value = " ";
        noneOptionElement.setAttribute("hidden", true);
        noneOptionElement.setAttribute("selected", true);
        selectElement.prepend(noneOptionElement);
        removeEmptyEntry = () => {
          noneOptionElement.remove();
          selectElement.removeEventListener("input", removeEmptyEntry);
          removeEmptyEntry = null;
        };
        selectElement.addEventListener("input", removeEmptyEntry);
      }
      const getValue = (isExport) => {
        const name = isExport ? "value" : "textContent";
        const {
          options,
          multiple
        } = selectElement;
        if (!multiple) {
          return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
        }
        return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
      };
      let selectedValues = getValue(false);
      const getItems = (event) => {
        const options = event.target.options;
        return Array.prototype.map.call(options, (option) => ({
          displayValue: option.textContent,
          exportValue: option.value
        }));
      };
      if (this.enableScripting && this.hasJSActions) {
        selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
          const actions = {
            value(event) {
              removeEmptyEntry?.();
              const value = event.detail.value;
              const values = new Set(Array.isArray(value) ? value : [value]);
              for (const option of selectElement.options) {
                option.selected = values.has(option.value);
              }
              storage.setValue(id, {
                value: getValue(true)
              });
              selectedValues = getValue(false);
            },
            multipleSelection(event) {
              selectElement.multiple = true;
            },
            remove(event) {
              const options = selectElement.options;
              const index = event.detail.remove;
              options[index].selected = false;
              selectElement.remove(index);
              if (options.length > 0) {
                const i = Array.prototype.findIndex.call(options, (option) => option.selected);
                if (i === -1) {
                  options[0].selected = true;
                }
              }
              storage.setValue(id, {
                value: getValue(true),
                items: getItems(event)
              });
              selectedValues = getValue(false);
            },
            clear(event) {
              while (selectElement.length !== 0) {
                selectElement.remove(0);
              }
              storage.setValue(id, {
                value: null,
                items: []
              });
              selectedValues = getValue(false);
            },
            insert(event) {
              const {
                index,
                displayValue,
                exportValue
              } = event.detail.insert;
              const selectChild = selectElement.children[index];
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              if (selectChild) {
                selectChild.before(optionElement);
              } else {
                selectElement.append(optionElement);
              }
              storage.setValue(id, {
                value: getValue(true),
                items: getItems(event)
              });
              selectedValues = getValue(false);
            },
            items(event) {
              const {
                items
              } = event.detail;
              while (selectElement.length !== 0) {
                selectElement.remove(0);
              }
              for (const item of items) {
                const {
                  displayValue,
                  exportValue
                } = item;
                const optionElement = document.createElement("option");
                optionElement.textContent = displayValue;
                optionElement.value = exportValue;
                selectElement.append(optionElement);
              }
              if (selectElement.options.length > 0) {
                selectElement.options[0].selected = true;
              }
              storage.setValue(id, {
                value: getValue(true),
                items: getItems(event)
              });
              selectedValues = getValue(false);
            },
            indices(event) {
              const indices = new Set(event.detail.indices);
              for (const option of event.target.options) {
                option.selected = indices.has(option.index);
              }
              storage.setValue(id, {
                value: getValue(true)
              });
              selectedValues = getValue(false);
            },
            editable(event) {
              event.target.disabled = !event.detail.editable;
            }
          };
          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        selectElement.addEventListener("input", (event) => {
          const exportValue = getValue(true);
          const change = getValue(false);
          storage.setValue(id, {
            value: exportValue
          });
          event.preventDefault();
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value: selectedValues,
              change,
              changeEx: exportValue,
              willCommit: false,
              commitKey: 1,
              keyDown: false
            }
          });
        });
        this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (event) => event.target.value);
      } else {
        selectElement.addEventListener("input", function(event) {
          storage.setValue(id, {
            value: getValue(true)
          });
        });
      }
      if (this.data.combo) {
        this._setTextStyle(selectElement);
      }
      this._setBackgroundColor(selectElement);
      this._setDefaultPropertiesFromJS(selectElement);
      this.container.append(selectElement);
      return this.container;
    }
  }
  class PopupAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      const {
        data,
        elements
      } = parameters;
      super(parameters, {
        isRenderable: AnnotationElement._hasPopupData(data)
      });
      this.elements = elements;
      this.popup = null;
    }
    render() {
      const {
        container
      } = this;
      container.classList.add("popupAnnotation");
      container.role = "comment";
      const popup = this.popup = new PopupElement({
        container: this.container,
        color: this.data.color,
        titleObj: this.data.titleObj,
        modificationDate: this.data.modificationDate || this.data.creationDate,
        contentsObj: this.data.contentsObj,
        richText: this.data.richText,
        rect: this.data.rect,
        parentRect: this.data.parentRect || null,
        parent: this.parent,
        elements: this.elements,
        open: this.data.open,
        eventBus: this.linkService.eventBus
      });
      const elementIds = [];
      for (const element of this.elements) {
        element.popup = popup;
        element.container.ariaHasPopup = "dialog";
        elementIds.push(element.data.id);
        element.addHighlightArea();
      }
      this.container.setAttribute("aria-controls", elementIds.map((id) => `${AnnotationPrefix}${id}`).join(","));
      return this.container;
    }
  }
  class PopupElement {
    #boundKeyDown = this.#keyDown.bind(this);
    #boundHide = this.#hide.bind(this);
    #boundShow = this.#show.bind(this);
    #boundToggle = this.#toggle.bind(this);
    #color = null;
    #container = null;
    #contentsObj = null;
    #dateObj = null;
    #elements = null;
    #eventBus = null;
    #parent = null;
    #parentRect = null;
    #pinned = false;
    #popup = null;
    #popupAbortController = null;
    #position = null;
    #commentButton = null;
    #commentButtonPosition = null;
    #commentButtonColor = null;
    #rect = null;
    #richText = null;
    #titleObj = null;
    #updates = null;
    #wasVisible = false;
    constructor({
      container,
      color,
      elements,
      titleObj,
      modificationDate,
      contentsObj,
      richText,
      parent,
      rect,
      parentRect,
      open,
      eventBus = null
    }) {
      this.#container = container;
      this.#titleObj = titleObj;
      this.#contentsObj = contentsObj;
      this.#richText = richText;
      this.#parent = parent;
      this.#color = color;
      this.#rect = rect;
      this.#parentRect = parentRect;
      this.#elements = elements;
      this.#eventBus = eventBus;
      this.#dateObj = PDFDateString.toDateObject(modificationDate);
      this.trigger = elements.flatMap((e) => e.getElementsToTriggerPopup());
      this.#addEventListeners();
      this.#container.hidden = true;
      if (open) {
        this.#toggle();
      }
    }
    #addEventListeners() {
      if (this.#popupAbortController) {
        return;
      }
      this.#popupAbortController = new AbortController();
      const {
        signal
      } = this.#popupAbortController;
      for (const element of this.trigger) {
        element.addEventListener("click", this.#boundToggle, {
          signal
        });
        element.addEventListener("mouseenter", this.#boundShow, {
          signal
        });
        element.addEventListener("mouseleave", this.#boundHide, {
          signal
        });
        element.classList.add("popupTriggerArea");
      }
      for (const element of this.#elements) {
        element.container?.addEventListener("keydown", this.#boundKeyDown, {
          signal
        });
      }
      this.#renderCommentButton();
    }
    #setCommentButtonPosition() {
      const element = this.#elements.find((e) => e.hasCommentButton);
      if (!element) {
        return;
      }
      this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);
      this.#commentButtonColor = element.commentButtonColor;
    }
    #renderCommentButton() {
      if (this.#commentButton) {
        return;
      }
      if (!this.#commentButtonPosition) {
        this.#setCommentButtonPosition();
      }
      if (!this.#commentButtonPosition) {
        return;
      }
      const button = this.#commentButton = document.createElement("button");
      button.className = "annotationCommentButton";
      const parentContainer = this.#elements[0].container;
      button.style.zIndex = parentContainer.style.zIndex + 1;
      button.tabIndex = 0;
      const {
        signal
      } = this.#popupAbortController;
      button.addEventListener("hover", this.#boundToggle, {
        signal
      });
      button.addEventListener("keydown", this.#boundKeyDown, {
        signal
      });
      button.addEventListener("click", () => {
        const [{
          data: {
            id: editId
          },
          annotationEditorType: mode
        }] = this.#elements;
        this.#eventBus?.dispatch("switchannotationeditormode", {
          source: this,
          editId,
          mode,
          editComment: true
        });
      }, {
        signal
      });
      const {
        style
      } = button;
      style.left = `calc(${this.#commentButtonPosition[0]}%)`;
      style.top = `calc(${this.#commentButtonPosition[1]}% - var(--comment-button-dim))`;
      if (this.#commentButtonColor) {
        style.backgroundColor = this.#commentButtonColor;
      }
      parentContainer.after(button);
    }
    render() {
      if (this.#popup) {
        return;
      }
      const popup = this.#popup = document.createElement("div");
      popup.className = "popup";
      if (this.#color) {
        const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);
        popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
      }
      const header = document.createElement("span");
      header.className = "header";
      if (this.#titleObj?.str) {
        const title = document.createElement("span");
        title.className = "title";
        header.append(title);
        ({
          dir: title.dir,
          str: title.textContent
        } = this.#titleObj);
      }
      popup.append(header);
      if (this.#dateObj) {
        const modificationDate = document.createElement("time");
        modificationDate.className = "popupDate";
        modificationDate.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string");
        modificationDate.setAttribute("data-l10n-args", JSON.stringify({
          dateObj: this.#dateObj.valueOf()
        }));
        modificationDate.dateTime = this.#dateObj.toISOString();
        header.append(modificationDate);
      }
      const html = this.#html;
      if (html) {
        XfaLayer.render({
          xfaHtml: html,
          intent: "richText",
          div: popup
        });
        popup.lastChild.classList.add("richText", "popupContent");
      } else {
        const contents = this._formatContents(this.#contentsObj);
        popup.append(contents);
      }
      this.#container.append(popup);
    }
    get #html() {
      const richText = this.#richText;
      const contentsObj = this.#contentsObj;
      if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {
        return this.#richText.html || null;
      }
      return null;
    }
    get #fontSize() {
      return this.#html?.attributes?.style?.fontSize || 0;
    }
    get #fontColor() {
      return this.#html?.attributes?.style?.color || null;
    }
    #makePopupContent(text) {
      const popupLines = [];
      const popupContent = {
        str: text,
        html: {
          name: "div",
          attributes: {
            dir: "auto"
          },
          children: [{
            name: "p",
            children: popupLines
          }]
        }
      };
      const lineAttributes = {
        style: {
          color: this.#fontColor,
          fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : ""
        }
      };
      for (const line of text.split("\n")) {
        popupLines.push({
          name: "span",
          value: line,
          attributes: lineAttributes
        });
      }
      return popupContent;
    }
    _formatContents({
      str,
      dir
    }) {
      const p = document.createElement("p");
      p.classList.add("popupContent");
      p.dir = dir;
      const lines = str.split(/(?:\r\n?|\n)/);
      for (let i = 0, ii = lines.length; i < ii; ++i) {
        const line = lines[i];
        p.append(document.createTextNode(line));
        if (i < ii - 1) {
          p.append(document.createElement("br"));
        }
      }
      return p;
    }
    #keyDown(event) {
      if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
        return;
      }
      if (event.key === "Enter" || event.key === "Escape" && this.#pinned) {
        this.#toggle();
      }
    }
    updateEdited({
      rect,
      popup,
      deleted
    }) {
      if (deleted || popup?.deleted) {
        this.remove();
        return;
      }
      this.#addEventListeners();
      this.#updates ||= {
        contentsObj: this.#contentsObj,
        richText: this.#richText
      };
      if (rect) {
        this.#position = null;
      }
      if (popup) {
        this.#richText = this.#makePopupContent(popup.text);
        this.#dateObj = PDFDateString.toDateObject(popup.date);
        this.#contentsObj = null;
      }
      this.#popup?.remove();
      this.#popup = null;
    }
    resetEdited() {
      if (!this.#updates) {
        return;
      }
      ({
        contentsObj: this.#contentsObj,
        richText: this.#richText
      } = this.#updates);
      this.#updates = null;
      this.#popup?.remove();
      this.#popup = null;
      this.#position = null;
    }
    remove() {
      this.#popupAbortController?.abort();
      this.#popupAbortController = null;
      this.#popup?.remove();
      this.#popup = null;
      this.#wasVisible = false;
      this.#pinned = false;
      for (const element of this.trigger) {
        element.classList.remove("popupTriggerArea");
      }
    }
    #setPosition() {
      if (this.#position !== null) {
        return;
      }
      const {
        page: {
          view
        },
        viewport: {
          rawDims: {
            pageWidth,
            pageHeight,
            pageX,
            pageY
          }
        }
      } = this.#parent;
      let useParentRect = !!this.#parentRect;
      let rect = useParentRect ? this.#parentRect : this.#rect;
      for (const element of this.#elements) {
        if (!rect || Util.intersect(element.data.rect, rect) !== null) {
          rect = element.data.rect;
          useParentRect = true;
          break;
        }
      }
      const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
      const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
      const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
      const popupLeft = normalizedRect[0] + parentWidth;
      const popupTop = normalizedRect[1];
      this.#position = [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight];
      const {
        style
      } = this.#container;
      style.left = `${this.#position[0]}%`;
      style.top = `${this.#position[1]}%`;
    }
    #toggle() {
      this.#pinned = !this.#pinned;
      if (this.#pinned) {
        this.#show();
        this.#container.addEventListener("click", this.#boundToggle);
        this.#container.addEventListener("keydown", this.#boundKeyDown);
      } else {
        this.#hide();
        this.#container.removeEventListener("click", this.#boundToggle);
        this.#container.removeEventListener("keydown", this.#boundKeyDown);
      }
    }
    #show() {
      if (!this.#popup) {
        this.render();
      }
      if (!this.isVisible) {
        this.#setPosition();
        this.#container.hidden = false;
        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1e3;
      } else if (this.#pinned) {
        this.#container.classList.add("focused");
      }
    }
    #hide() {
      this.#container.classList.remove("focused");
      if (this.#pinned || !this.isVisible) {
        return;
      }
      this.#container.hidden = true;
      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1e3;
    }
    forceHide() {
      this.#wasVisible = this.isVisible;
      if (!this.#wasVisible) {
        return;
      }
      this.#container.hidden = true;
    }
    maybeShow() {
      this.#addEventListeners();
      if (!this.#wasVisible) {
        return;
      }
      if (!this.#popup) {
        this.#show();
      }
      this.#wasVisible = false;
      this.#container.hidden = false;
    }
    get isVisible() {
      return this.#container.hidden === false;
    }
  }
  class FreeTextAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true
      });
      this.textContent = parameters.data.textContent;
      this.textPosition = parameters.data.textPosition;
      this.annotationEditorType = AnnotationEditorType.FREETEXT;
    }
    render() {
      this.container.classList.add("freeTextAnnotation");
      if (this.textContent) {
        const content = document.createElement("div");
        content.classList.add("annotationTextContent");
        content.setAttribute("role", "comment");
        for (const line of this.textContent) {
          const lineSpan = document.createElement("span");
          lineSpan.textContent = line;
          content.append(lineSpan);
        }
        this.container.append(content);
      }
      if (!this.data.popupRef && this.hasPopupData) {
        this._createPopup();
      }
      this._editOnDoubleClick();
      return this.container;
    }
  }
  class LineAnnotationElement extends AnnotationElement {
    #line = null;
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true
      });
    }
    render() {
      this.container.classList.add("lineAnnotation");
      const {
        data,
        width,
        height
      } = this;
      const svg = this.svgFactory.create(width, height, true);
      const line = this.#line = this.svgFactory.createElement("svg:line");
      line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
      line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
      line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
      line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
      line.setAttribute("stroke-width", data.borderStyle.width || 1);
      line.setAttribute("stroke", "transparent");
      line.setAttribute("fill", "transparent");
      svg.append(line);
      this.container.append(svg);
      if (!data.popupRef && this.hasPopupData) {
        this._createPopup();
      }
      return this.container;
    }
    getElementsToTriggerPopup() {
      return this.#line;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  class SquareAnnotationElement extends AnnotationElement {
    #square = null;
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true
      });
    }
    render() {
      this.container.classList.add("squareAnnotation");
      const {
        data,
        width,
        height
      } = this;
      const svg = this.svgFactory.create(width, height, true);
      const borderWidth = data.borderStyle.width;
      const square = this.#square = this.svgFactory.createElement("svg:rect");
      square.setAttribute("x", borderWidth / 2);
      square.setAttribute("y", borderWidth / 2);
      square.setAttribute("width", width - borderWidth);
      square.setAttribute("height", height - borderWidth);
      square.setAttribute("stroke-width", borderWidth || 1);
      square.setAttribute("stroke", "transparent");
      square.setAttribute("fill", "transparent");
      svg.append(square);
      this.container.append(svg);
      if (!data.popupRef && this.hasPopupData) {
        this._createPopup();
      }
      return this.container;
    }
    getElementsToTriggerPopup() {
      return this.#square;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  class CircleAnnotationElement extends AnnotationElement {
    #circle = null;
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true
      });
    }
    render() {
      this.container.classList.add("circleAnnotation");
      const {
        data,
        width,
        height
      } = this;
      const svg = this.svgFactory.create(width, height, true);
      const borderWidth = data.borderStyle.width;
      const circle = this.#circle = this.svgFactory.createElement("svg:ellipse");
      circle.setAttribute("cx", width / 2);
      circle.setAttribute("cy", height / 2);
      circle.setAttribute("rx", width / 2 - borderWidth / 2);
      circle.setAttribute("ry", height / 2 - borderWidth / 2);
      circle.setAttribute("stroke-width", borderWidth || 1);
      circle.setAttribute("stroke", "transparent");
      circle.setAttribute("fill", "transparent");
      svg.append(circle);
      this.container.append(svg);
      if (!data.popupRef && this.hasPopupData) {
        this._createPopup();
      }
      return this.container;
    }
    getElementsToTriggerPopup() {
      return this.#circle;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  class PolylineAnnotationElement extends AnnotationElement {
    #polyline = null;
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true
      });
      this.containerClassName = "polylineAnnotation";
      this.svgElementName = "svg:polyline";
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const {
        data: {
          rect,
          vertices,
          borderStyle,
          popupRef
        },
        width,
        height
      } = this;
      if (!vertices) {
        return this.container;
      }
      const svg = this.svgFactory.create(width, height, true);
      let points = [];
      for (let i = 0, ii = vertices.length; i < ii; i += 2) {
        const x = vertices[i] - rect[0];
        const y = rect[3] - vertices[i + 1];
        points.push(`${x},${y}`);
      }
      points = points.join(" ");
      const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);
      polyline.setAttribute("points", points);
      polyline.setAttribute("stroke-width", borderStyle.width || 1);
      polyline.setAttribute("stroke", "transparent");
      polyline.setAttribute("fill", "transparent");
      svg.append(polyline);
      this.container.append(svg);
      if (!popupRef && this.hasPopupData) {
        this._createPopup();
      }
      return this.container;
    }
    getElementsToTriggerPopup() {
      return this.#polyline;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  class PolygonAnnotationElement extends PolylineAnnotationElement {
    constructor(parameters) {
      super(parameters);
      this.containerClassName = "polygonAnnotation";
      this.svgElementName = "svg:polygon";
    }
  }
  class CaretAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true
      });
    }
    render() {
      this.container.classList.add("caretAnnotation");
      if (!this.data.popupRef && this.hasPopupData) {
        this._createPopup();
      }
      return this.container;
    }
  }
  class InkAnnotationElement extends AnnotationElement {
    #polylinesGroupElement = null;
    #polylines = [];
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true
      });
      this.containerClassName = "inkAnnotation";
      this.svgElementName = "svg:polyline";
      this.annotationEditorType = this.data.it === "InkHighlight" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;
    }
    #getTransform(rotation, rect) {
      switch (rotation) {
        case 90:
          return {
            transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,
            width: rect[3] - rect[1],
            height: rect[2] - rect[0]
          };
        case 180:
          return {
            transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,
            width: rect[2] - rect[0],
            height: rect[3] - rect[1]
          };
        case 270:
          return {
            transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,
            width: rect[3] - rect[1],
            height: rect[2] - rect[0]
          };
        default:
          return {
            transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,
            width: rect[2] - rect[0],
            height: rect[3] - rect[1]
          };
      }
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const {
        data: {
          rect,
          rotation,
          inkLists,
          borderStyle,
          popupRef
        }
      } = this;
      const {
        transform,
        width,
        height
      } = this.#getTransform(rotation, rect);
      const svg = this.svgFactory.create(width, height, true);
      const g = this.#polylinesGroupElement = this.svgFactory.createElement("svg:g");
      svg.append(g);
      g.setAttribute("stroke-width", borderStyle.width || 1);
      g.setAttribute("stroke-linecap", "round");
      g.setAttribute("stroke-linejoin", "round");
      g.setAttribute("stroke-miterlimit", 10);
      g.setAttribute("stroke", "transparent");
      g.setAttribute("fill", "transparent");
      g.setAttribute("transform", transform);
      for (let i = 0, ii = inkLists.length; i < ii; i++) {
        const polyline = this.svgFactory.createElement(this.svgElementName);
        this.#polylines.push(polyline);
        polyline.setAttribute("points", inkLists[i].join(","));
        g.append(polyline);
      }
      if (!popupRef && this.hasPopupData) {
        this._createPopup();
      }
      this.container.append(svg);
      this._editOnDoubleClick();
      return this.container;
    }
    updateEdited(params) {
      super.updateEdited(params);
      const {
        thickness,
        points,
        rect
      } = params;
      const g = this.#polylinesGroupElement;
      if (thickness >= 0) {
        g.setAttribute("stroke-width", thickness || 1);
      }
      if (points) {
        for (let i = 0, ii = this.#polylines.length; i < ii; i++) {
          this.#polylines[i].setAttribute("points", points[i].join(","));
        }
      }
      if (rect) {
        const {
          transform,
          width,
          height
        } = this.#getTransform(this.data.rotation, rect);
        const root = g.parentElement;
        root.setAttribute("viewBox", `0 0 ${width} ${height}`);
        g.setAttribute("transform", transform);
      }
    }
    getElementsToTriggerPopup() {
      return this.#polylines;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
    get commentButtonPosition() {
      const {
        inkLists,
        rect
      } = this.data;
      if (inkLists?.length >= 1) {
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (const inkList of inkLists) {
          for (let i = 0, ii = inkList.length; i < ii; i += 2) {
            if (inkList[i + 1] > maxY) {
              maxY = inkList[i + 1];
              maxX = inkList[i];
            } else if (inkList[i + 1] === maxY) {
              maxX = Math.max(maxX, inkList[i]);
            }
          }
        }
        if (maxX !== Infinity) {
          return [maxX, maxY];
        }
      }
      if (rect) {
        return [rect[2], rect[3]];
      }
      return null;
    }
  }
  class HighlightAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
      this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;
    }
    render() {
      const {
        data: {
          overlaidText,
          popupRef
        }
      } = this;
      if (!popupRef && this.hasPopupData) {
        this._createPopup();
      }
      this.container.classList.add("highlightAnnotation");
      this._editOnDoubleClick();
      if (overlaidText) {
        const mark = document.createElement("mark");
        mark.classList.add("overlaidText");
        mark.textContent = overlaidText;
        this.container.append(mark);
      }
      return this.container;
    }
  }
  class UnderlineAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }
    render() {
      const {
        data: {
          overlaidText,
          popupRef
        }
      } = this;
      if (!popupRef && this.hasPopupData) {
        this._createPopup();
      }
      this.container.classList.add("underlineAnnotation");
      if (overlaidText) {
        const underline = document.createElement("u");
        underline.classList.add("overlaidText");
        underline.textContent = overlaidText;
        this.container.append(underline);
      }
      return this.container;
    }
  }
  class SquigglyAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }
    render() {
      const {
        data: {
          overlaidText,
          popupRef
        }
      } = this;
      if (!popupRef && this.hasPopupData) {
        this._createPopup();
      }
      this.container.classList.add("squigglyAnnotation");
      if (overlaidText) {
        const underline = document.createElement("u");
        underline.classList.add("overlaidText");
        underline.textContent = overlaidText;
        this.container.append(underline);
      }
      return this.container;
    }
  }
  class StrikeOutAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }
    render() {
      const {
        data: {
          overlaidText,
          popupRef
        }
      } = this;
      if (!popupRef && this.hasPopupData) {
        this._createPopup();
      }
      this.container.classList.add("strikeoutAnnotation");
      if (overlaidText) {
        const strikeout = document.createElement("s");
        strikeout.classList.add("overlaidText");
        strikeout.textContent = overlaidText;
        this.container.append(strikeout);
      }
      return this.container;
    }
  }
  class StampAnnotationElement extends AnnotationElement {
    constructor(parameters) {
      super(parameters, {
        isRenderable: true,
        ignoreBorder: true
      });
      this.annotationEditorType = AnnotationEditorType.STAMP;
    }
    render() {
      this.container.classList.add("stampAnnotation");
      this.container.setAttribute("role", "img");
      if (!this.data.popupRef && this.hasPopupData) {
        this._createPopup();
      }
      this._editOnDoubleClick();
      return this.container;
    }
  }
  class FileAttachmentAnnotationElement extends AnnotationElement {
    #trigger = null;
    constructor(parameters) {
      super(parameters, {
        isRenderable: true
      });
      const {
        file
      } = this.data;
      this.filename = file.filename;
      this.content = file.content;
      this.linkService.eventBus?.dispatch("fileattachmentannotation", {
        source: this,
        ...file
      });
    }
    render() {
      this.container.classList.add("fileAttachmentAnnotation");
      const {
        container,
        data
      } = this;
      let trigger;
      if (data.hasAppearance || data.fillAlpha === 0) {
        trigger = document.createElement("div");
      } else {
        trigger = document.createElement("img");
        trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
        if (data.fillAlpha && data.fillAlpha < 1) {
          trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
        }
      }
      trigger.addEventListener("dblclick", this.#download.bind(this));
      this.#trigger = trigger;
      const {
        isMac
      } = util_FeatureTest.platform;
      container.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
          this.#download();
        }
      });
      if (!data.popupRef && this.hasPopupData) {
        this._createPopup();
      } else {
        trigger.classList.add("popupTriggerArea");
      }
      container.append(trigger);
      return container;
    }
    getElementsToTriggerPopup() {
      return this.#trigger;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
    #download() {
      this.downloadManager?.openOrDownloadData(this.content, this.filename);
    }
  }
  class AnnotationLayer {
    #accessibilityManager = null;
    #annotationCanvasMap = null;
    #editableAnnotations = /* @__PURE__ */ new Map();
    #structTreeLayer = null;
    constructor({
      div,
      accessibilityManager,
      annotationCanvasMap,
      annotationEditorUIManager,
      page,
      viewport,
      structTreeLayer
    }) {
      this.div = div;
      this.#accessibilityManager = accessibilityManager;
      this.#annotationCanvasMap = annotationCanvasMap;
      this.#structTreeLayer = structTreeLayer || null;
      this.page = page;
      this.viewport = viewport;
      this.zIndex = 0;
      this._annotationEditorUIManager = annotationEditorUIManager;
    }
    hasEditableAnnotations() {
      return this.#editableAnnotations.size > 0;
    }
    async #appendElement(element, id, popupElements) {
      const contentElement = element.firstChild || element;
      const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;
      const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);
      if (ariaAttributes) {
        for (const [key, value] of ariaAttributes) {
          contentElement.setAttribute(key, value);
        }
      }
      if (popupElements) {
        popupElements.at(-1).container.after(element);
      } else {
        this.div.append(element);
        this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);
      }
    }
    async render(params) {
      const {
        annotations
      } = params;
      const layer = this.div;
      setLayerDimensions(layer, this.viewport);
      const popupToElements = /* @__PURE__ */ new Map();
      const elementParams = {
        data: null,
        layer,
        linkService: params.linkService,
        downloadManager: params.downloadManager,
        imageResourcesPath: params.imageResourcesPath || "",
        renderForms: params.renderForms !== false,
        svgFactory: new DOMSVGFactory(),
        annotationStorage: params.annotationStorage || new AnnotationStorage(),
        enableComment: params.enableComment === true,
        enableScripting: params.enableScripting === true,
        hasJSActions: params.hasJSActions,
        fieldObjects: params.fieldObjects,
        parent: this,
        elements: null
      };
      for (const data of annotations) {
        if (data.noHTML) {
          continue;
        }
        const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
        if (!isPopupAnnotation) {
          if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {
            continue;
          }
        } else {
          const elements = popupToElements.get(data.id);
          if (!elements) {
            continue;
          }
          elementParams.elements = elements;
        }
        elementParams.data = data;
        const element = AnnotationElementFactory.create(elementParams);
        if (!element.isRenderable) {
          continue;
        }
        if (!isPopupAnnotation && data.popupRef) {
          const elements = popupToElements.get(data.popupRef);
          if (!elements) {
            popupToElements.set(data.popupRef, [element]);
          } else {
            elements.push(element);
          }
        }
        const rendered = element.render();
        if (data.hidden) {
          rendered.style.visibility = "hidden";
        }
        await this.#appendElement(rendered, data.id, elementParams.elements);
        if (element._isEditable) {
          this.#editableAnnotations.set(element.data.id, element);
          this._annotationEditorUIManager?.renderAnnotationElement(element);
        }
      }
      this.#setAnnotationCanvasMap();
    }
    async addLinkAnnotations(annotations, linkService) {
      const elementParams = {
        data: null,
        layer: this.div,
        linkService,
        svgFactory: new DOMSVGFactory(),
        parent: this
      };
      for (const data of annotations) {
        data.borderStyle ||= AnnotationLayer._defaultBorderStyle;
        elementParams.data = data;
        const element = AnnotationElementFactory.create(elementParams);
        if (!element.isRenderable) {
          continue;
        }
        const rendered = element.render();
        await this.#appendElement(rendered, data.id, null);
      }
    }
    update({
      viewport
    }) {
      const layer = this.div;
      this.viewport = viewport;
      setLayerDimensions(layer, {
        rotation: viewport.rotation
      });
      this.#setAnnotationCanvasMap();
      layer.hidden = false;
    }
    #setAnnotationCanvasMap() {
      if (!this.#annotationCanvasMap) {
        return;
      }
      const layer = this.div;
      for (const [id, canvas] of this.#annotationCanvasMap) {
        const element = layer.querySelector(`[data-annotation-id="${id}"]`);
        if (!element) {
          continue;
        }
        canvas.className = "annotationContent";
        const {
          firstChild
        } = element;
        if (!firstChild) {
          element.append(canvas);
        } else if (firstChild.nodeName === "CANVAS") {
          firstChild.replaceWith(canvas);
        } else if (!firstChild.classList.contains("annotationContent")) {
          firstChild.before(canvas);
        } else {
          firstChild.after(canvas);
        }
        const editableAnnotation = this.#editableAnnotations.get(id);
        if (!editableAnnotation) {
          continue;
        }
        if (editableAnnotation._hasNoCanvas) {
          this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);
          editableAnnotation._hasNoCanvas = false;
        } else {
          editableAnnotation.canvas = canvas;
        }
      }
      this.#annotationCanvasMap.clear();
    }
    getEditableAnnotations() {
      return Array.from(this.#editableAnnotations.values());
    }
    getEditableAnnotation(id) {
      return this.#editableAnnotations.get(id);
    }
    static get _defaultBorderStyle() {
      return shadow(this, "_defaultBorderStyle", Object.freeze({
        width: 1,
        rawWidth: 1,
        style: AnnotationBorderStyleType.SOLID,
        dashArray: [3],
        horizontalCornerRadius: 0,
        verticalCornerRadius: 0
      }));
    }
  }
  const EOL_PATTERN = /\r\n?|\n/g;
  class FreeTextEditor extends AnnotationEditor {
    #color;
    #content = "";
    #editorDivId = `${this.id}-editor`;
    #editModeAC = null;
    #fontSize;
    _colorPicker = null;
    static _freeTextDefaultContent = "";
    static _internalPadding = 0;
    static _defaultColor = null;
    static _defaultFontSize = 10;
    static get _keyboardManager() {
      const proto = FreeTextEditor.prototype;
      const arrowChecker = (self2) => self2.isEmpty();
      const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
      const big = AnnotationEditorUIManager.TRANSLATE_BIG;
      return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
        bubbles: true
      }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
        args: [-small, 0],
        checker: arrowChecker
      }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
        args: [-big, 0],
        checker: arrowChecker
      }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
        args: [small, 0],
        checker: arrowChecker
      }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
        args: [big, 0],
        checker: arrowChecker
      }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
        args: [0, -small],
        checker: arrowChecker
      }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
        args: [0, -big],
        checker: arrowChecker
      }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
        args: [0, small],
        checker: arrowChecker
      }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
        args: [0, big],
        checker: arrowChecker
      }]]));
    }
    static _type = "freetext";
    static _editorType = AnnotationEditorType.FREETEXT;
    constructor(params) {
      super({
        ...params,
        name: "freeTextEditor"
      });
      this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;
      this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;
      if (!this.annotationElementId) {
        this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
      }
    }
    static initialize(l10n, uiManager) {
      AnnotationEditor.initialize(l10n, uiManager);
      const style = getComputedStyle(document.documentElement);
      this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
    }
    static updateDefaultParams(type, value) {
      switch (type) {
        case AnnotationEditorParamsType.FREETEXT_SIZE:
          FreeTextEditor._defaultFontSize = value;
          break;
        case AnnotationEditorParamsType.FREETEXT_COLOR:
          FreeTextEditor._defaultColor = value;
          break;
      }
    }
    updateParams(type, value) {
      switch (type) {
        case AnnotationEditorParamsType.FREETEXT_SIZE:
          this.#updateFontSize(value);
          break;
        case AnnotationEditorParamsType.FREETEXT_COLOR:
          this.#updateColor(value);
          break;
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
    }
    get propertiesToUpdate() {
      return [[AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];
    }
    get toolbarButtons() {
      this._colorPicker ||= new BasicColorPicker(this);
      return [["colorPicker", this._colorPicker]];
    }
    get colorType() {
      return AnnotationEditorParamsType.FREETEXT_COLOR;
    }
    get colorValue() {
      return this.#color;
    }
    #updateFontSize(fontSize) {
      const setFontsize = (size) => {
        this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;
        this.translate(0, -(size - this.#fontSize) * this.parentScale);
        this.#fontSize = size;
        this.#setEditorDimensions();
      };
      const savedFontsize = this.#fontSize;
      this.addCommands({
        cmd: setFontsize.bind(this, fontSize),
        undo: setFontsize.bind(this, savedFontsize),
        post: this._uiManager.updateUI.bind(this._uiManager, this),
        mustExec: true,
        type: AnnotationEditorParamsType.FREETEXT_SIZE,
        overwriteIfSameType: true,
        keepUndo: true
      });
    }
    #updateColor(color) {
      const setColor = (col) => {
        this.#color = this.editorDiv.style.color = col;
        this._colorPicker?.update(col);
      };
      const savedColor = this.#color;
      this.addCommands({
        cmd: setColor.bind(this, color),
        undo: setColor.bind(this, savedColor),
        post: this._uiManager.updateUI.bind(this._uiManager, this),
        mustExec: true,
        type: AnnotationEditorParamsType.FREETEXT_COLOR,
        overwriteIfSameType: true,
        keepUndo: true
      });
    }
    _translateEmpty(x, y) {
      this._uiManager.translateSelectedEditors(x, y, true);
    }
    getInitialTranslation() {
      const scale = this.parentScale;
      return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];
    }
    rebuild() {
      if (!this.parent) {
        return;
      }
      super.rebuild();
      if (this.div === null) {
        return;
      }
      if (!this.isAttachedToDOM) {
        this.parent.add(this);
      }
    }
    enableEditMode() {
      if (!super.enableEditMode()) {
        return false;
      }
      this.overlayDiv.classList.remove("enabled");
      this.editorDiv.contentEditable = true;
      this._isDraggable = false;
      this.div.removeAttribute("aria-activedescendant");
      this.#editModeAC = new AbortController();
      const signal = this._uiManager.combinedSignal(this.#editModeAC);
      this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
        signal
      });
      this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
        signal
      });
      this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
        signal
      });
      this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
        signal
      });
      this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
        signal
      });
      return true;
    }
    disableEditMode() {
      if (!super.disableEditMode()) {
        return false;
      }
      this.overlayDiv.classList.add("enabled");
      this.editorDiv.contentEditable = false;
      this.div.setAttribute("aria-activedescendant", this.#editorDivId);
      this._isDraggable = true;
      this.#editModeAC?.abort();
      this.#editModeAC = null;
      this.div.focus({
        preventScroll: true
      });
      this.isEditing = false;
      this.parent.div.classList.add("freetextEditing");
      return true;
    }
    focusin(event) {
      if (!this._focusEventsAllowed) {
        return;
      }
      super.focusin(event);
      if (event.target !== this.editorDiv) {
        this.editorDiv.focus();
      }
    }
    onceAdded(focus) {
      if (this.width) {
        return;
      }
      this.enableEditMode();
      if (focus) {
        this.editorDiv.focus();
      }
      if (this._initialOptions?.isCentered) {
        this.center();
      }
      this._initialOptions = null;
    }
    isEmpty() {
      return !this.editorDiv || this.editorDiv.innerText.trim() === "";
    }
    remove() {
      this.isEditing = false;
      if (this.parent) {
        this.parent.setEditingState(true);
        this.parent.div.classList.add("freetextEditing");
      }
      super.remove();
    }
    #extractText() {
      const buffer = [];
      this.editorDiv.normalize();
      let prevChild = null;
      for (const child of this.editorDiv.childNodes) {
        if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === "BR") {
          continue;
        }
        buffer.push(FreeTextEditor.#getNodeContent(child));
        prevChild = child;
      }
      return buffer.join("\n");
    }
    #setEditorDimensions() {
      const [parentWidth, parentHeight] = this.parentDimensions;
      let rect;
      if (this.isAttachedToDOM) {
        rect = this.div.getBoundingClientRect();
      } else {
        const {
          currentLayer,
          div
        } = this;
        const savedDisplay = div.style.display;
        const savedVisibility = div.classList.contains("hidden");
        div.classList.remove("hidden");
        div.style.display = "hidden";
        currentLayer.div.append(this.div);
        rect = div.getBoundingClientRect();
        div.remove();
        div.style.display = savedDisplay;
        div.classList.toggle("hidden", savedVisibility);
      }
      if (this.rotation % 180 === this.parentRotation % 180) {
        this.width = rect.width / parentWidth;
        this.height = rect.height / parentHeight;
      } else {
        this.width = rect.height / parentWidth;
        this.height = rect.width / parentHeight;
      }
      this.fixAndSetPosition();
    }
    commit() {
      if (!this.isInEditMode()) {
        return;
      }
      super.commit();
      this.disableEditMode();
      const savedText = this.#content;
      const newText = this.#content = this.#extractText().trimEnd();
      if (savedText === newText) {
        return;
      }
      const setText = (text) => {
        this.#content = text;
        if (!text) {
          this.remove();
          return;
        }
        this.#setContent();
        this._uiManager.rebuild(this);
        this.#setEditorDimensions();
      };
      this.addCommands({
        cmd: () => {
          setText(newText);
        },
        undo: () => {
          setText(savedText);
        },
        mustExec: false
      });
      this.#setEditorDimensions();
    }
    shouldGetKeyboardEvents() {
      return this.isInEditMode();
    }
    enterInEditMode() {
      this.enableEditMode();
      this.editorDiv.focus();
    }
    keydown(event) {
      if (event.target === this.div && event.key === "Enter") {
        this.enterInEditMode();
        event.preventDefault();
      }
    }
    editorDivKeydown(event) {
      FreeTextEditor._keyboardManager.exec(this, event);
    }
    editorDivFocus(event) {
      this.isEditing = true;
    }
    editorDivBlur(event) {
      this.isEditing = false;
    }
    editorDivInput(event) {
      this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
    }
    disableEditing() {
      this.editorDiv.setAttribute("role", "comment");
      this.editorDiv.removeAttribute("aria-multiline");
    }
    enableEditing() {
      this.editorDiv.setAttribute("role", "textbox");
      this.editorDiv.setAttribute("aria-multiline", true);
    }
    get canChangeContent() {
      return true;
    }
    render() {
      if (this.div) {
        return this.div;
      }
      let baseX, baseY;
      if (this._isCopy || this.annotationElementId) {
        baseX = this.x;
        baseY = this.y;
      }
      super.render();
      this.editorDiv = document.createElement("div");
      this.editorDiv.className = "internal";
      this.editorDiv.setAttribute("id", this.#editorDivId);
      this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2");
      this.editorDiv.setAttribute("data-l10n-attrs", "default-content");
      this.enableEditing();
      this.editorDiv.contentEditable = true;
      const {
        style
      } = this.editorDiv;
      style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;
      style.color = this.#color;
      this.div.append(this.editorDiv);
      this.overlayDiv = document.createElement("div");
      this.overlayDiv.classList.add("overlay", "enabled");
      this.div.append(this.overlayDiv);
      if (this._isCopy || this.annotationElementId) {
        const [parentWidth, parentHeight] = this.parentDimensions;
        if (this.annotationElementId) {
          const {
            position
          } = this._initialData;
          let [tx, ty] = this.getInitialTranslation();
          [tx, ty] = this.pageTranslationToScreen(tx, ty);
          const [pageWidth, pageHeight] = this.pageDimensions;
          const [pageX, pageY] = this.pageTranslation;
          let posX, posY;
          switch (this.rotation) {
            case 0:
              posX = baseX + (position[0] - pageX) / pageWidth;
              posY = baseY + this.height - (position[1] - pageY) / pageHeight;
              break;
            case 90:
              posX = baseX + (position[0] - pageX) / pageWidth;
              posY = baseY - (position[1] - pageY) / pageHeight;
              [tx, ty] = [ty, -tx];
              break;
            case 180:
              posX = baseX - this.width + (position[0] - pageX) / pageWidth;
              posY = baseY - (position[1] - pageY) / pageHeight;
              [tx, ty] = [-tx, -ty];
              break;
            case 270:
              posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
              posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
              [tx, ty] = [-ty, tx];
              break;
          }
          this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
        } else {
          this._moveAfterPaste(baseX, baseY);
        }
        this.#setContent();
        this._isDraggable = true;
        this.editorDiv.contentEditable = false;
      } else {
        this._isDraggable = false;
        this.editorDiv.contentEditable = true;
      }
      return this.div;
    }
    static #getNodeContent(node) {
      return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
    }
    editorDivPaste(event) {
      const clipboardData = event.clipboardData || window.clipboardData;
      const {
        types
      } = clipboardData;
      if (types.length === 1 && types[0] === "text/plain") {
        return;
      }
      event.preventDefault();
      const paste = FreeTextEditor.#deserializeContent(clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
      if (!paste) {
        return;
      }
      const selection = window.getSelection();
      if (!selection.rangeCount) {
        return;
      }
      this.editorDiv.normalize();
      selection.deleteFromDocument();
      const range = selection.getRangeAt(0);
      if (!paste.includes("\n")) {
        range.insertNode(document.createTextNode(paste));
        this.editorDiv.normalize();
        selection.collapseToStart();
        return;
      }
      const {
        startContainer,
        startOffset
      } = range;
      const bufferBefore = [];
      const bufferAfter = [];
      if (startContainer.nodeType === Node.TEXT_NODE) {
        const parent = startContainer.parentElement;
        bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
        if (parent !== this.editorDiv) {
          let buffer = bufferBefore;
          for (const child of this.editorDiv.childNodes) {
            if (child === parent) {
              buffer = bufferAfter;
              continue;
            }
            buffer.push(FreeTextEditor.#getNodeContent(child));
          }
        }
        bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, ""));
      } else if (startContainer === this.editorDiv) {
        let buffer = bufferBefore;
        let i = 0;
        for (const child of this.editorDiv.childNodes) {
          if (i++ === startOffset) {
            buffer = bufferAfter;
          }
          buffer.push(FreeTextEditor.#getNodeContent(child));
        }
      }
      this.#content = `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`;
      this.#setContent();
      const newRange = new Range();
      let beforeLength = Math.sumPrecise(bufferBefore.map((line) => line.length));
      for (const {
        firstChild
      } of this.editorDiv.childNodes) {
        if (firstChild.nodeType === Node.TEXT_NODE) {
          const length = firstChild.nodeValue.length;
          if (beforeLength <= length) {
            newRange.setStart(firstChild, beforeLength);
            newRange.setEnd(firstChild, beforeLength);
            break;
          }
          beforeLength -= length;
        }
      }
      selection.removeAllRanges();
      selection.addRange(newRange);
    }
    #setContent() {
      this.editorDiv.replaceChildren();
      if (!this.#content) {
        return;
      }
      for (const line of this.#content.split("\n")) {
        const div = document.createElement("div");
        div.append(line ? document.createTextNode(line) : document.createElement("br"));
        this.editorDiv.append(div);
      }
    }
    #serializeContent() {
      return this.#content.replaceAll("", " ");
    }
    static #deserializeContent(content) {
      return content.replaceAll(" ", "");
    }
    get contentDiv() {
      return this.editorDiv;
    }
    getPDFRect() {
      const padding = FreeTextEditor._internalPadding * this.parentScale;
      return this.getRect(padding, padding);
    }
    static async deserialize(data, parent, uiManager) {
      let initialData = null;
      if (data instanceof FreeTextAnnotationElement) {
        const {
          data: {
            defaultAppearanceData: {
              fontSize,
              fontColor
            },
            rect,
            rotation,
            id,
            popupRef,
            contentsObj
          },
          textContent,
          textPosition,
          parent: {
            page: {
              pageNumber
            }
          }
        } = data;
        if (!textContent || textContent.length === 0) {
          return null;
        }
        initialData = data = {
          annotationType: AnnotationEditorType.FREETEXT,
          color: Array.from(fontColor),
          fontSize,
          value: textContent.join("\n"),
          position: textPosition,
          pageIndex: pageNumber - 1,
          rect: rect.slice(0),
          rotation,
          annotationElementId: id,
          id,
          deleted: false,
          popupRef,
          comment: contentsObj?.str || null
        };
      }
      const editor = await super.deserialize(data, parent, uiManager);
      editor.#fontSize = data.fontSize;
      editor.#color = Util.makeHexColor(...data.color);
      editor.#content = FreeTextEditor.#deserializeContent(data.value);
      editor._initialData = initialData;
      if (data.comment) {
        editor.setCommentData(data.comment);
      }
      return editor;
    }
    serialize(isForCopying = false) {
      if (this.isEmpty()) {
        return null;
      }
      if (this.deleted) {
        return this.serializeDeleted();
      }
      const rect = this.getPDFRect();
      const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);
      const serialized = {
        annotationType: AnnotationEditorType.FREETEXT,
        color,
        fontSize: this.#fontSize,
        value: this.#serializeContent(),
        pageIndex: this.pageIndex,
        rect,
        rotation: this.rotation,
        structTreeParentId: this._structTreeParentId
      };
      this.addComment(serialized);
      if (isForCopying) {
        serialized.isCopy = true;
        return serialized;
      }
      if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
        return null;
      }
      serialized.id = this.annotationElementId;
      return serialized;
    }
    #hasElementChanged(serialized) {
      const {
        value,
        fontSize,
        color,
        pageIndex
      } = this._initialData;
      return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;
    }
    renderAnnotationElement(annotation) {
      const content = super.renderAnnotationElement(annotation);
      if (!content) {
        return null;
      }
      const {
        style
      } = content;
      style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;
      style.color = this.#color;
      content.replaceChildren();
      for (const line of this.#content.split("\n")) {
        const div = document.createElement("div");
        div.append(line ? document.createTextNode(line) : document.createElement("br"));
        content.append(div);
      }
      const params = {
        rect: this.getPDFRect()
      };
      params.popup = this.hasEditedComment ? this.comment : {
        text: this.#content
      };
      annotation.updateEdited(params);
      return content;
    }
    resetAnnotationElement(annotation) {
      super.resetAnnotationElement(annotation);
      annotation.resetEdited();
    }
  }
  class Outline {
    static PRECISION = 1e-4;
    toSVGPath() {
      unreachable("Abstract method `toSVGPath` must be implemented.");
    }
    get box() {
      unreachable("Abstract getter `box` must be implemented.");
    }
    serialize(_bbox, _rotation) {
      unreachable("Abstract method `serialize` must be implemented.");
    }
    static _rescale(src, tx, ty, sx, sy, dest) {
      dest ||= new Float32Array(src.length);
      for (let i = 0, ii = src.length; i < ii; i += 2) {
        dest[i] = tx + src[i] * sx;
        dest[i + 1] = ty + src[i + 1] * sy;
      }
      return dest;
    }
    static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {
      dest ||= new Float32Array(src.length);
      for (let i = 0, ii = src.length; i < ii; i += 2) {
        dest[i] = tx + src[i + 1] * sx;
        dest[i + 1] = ty + src[i] * sy;
      }
      return dest;
    }
    static _translate(src, tx, ty, dest) {
      dest ||= new Float32Array(src.length);
      for (let i = 0, ii = src.length; i < ii; i += 2) {
        dest[i] = tx + src[i];
        dest[i + 1] = ty + src[i + 1];
      }
      return dest;
    }
    static svgRound(x) {
      return Math.round(x * 1e4);
    }
    static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {
      switch (rotation) {
        case 90:
          return [1 - y / parentWidth, x / parentHeight];
        case 180:
          return [1 - x / parentWidth, 1 - y / parentHeight];
        case 270:
          return [y / parentWidth, 1 - x / parentHeight];
        default:
          return [x / parentWidth, y / parentHeight];
      }
    }
    static _normalizePagePoint(x, y, rotation) {
      switch (rotation) {
        case 90:
          return [1 - y, x];
        case 180:
          return [1 - x, 1 - y];
        case 270:
          return [y, 1 - x];
        default:
          return [x, y];
      }
    }
    static createBezierPoints(x1, y1, x2, y2, x3, y3) {
      return [(x1 + 5 * x2) / 6, (y1 + 5 * y2) / 6, (5 * x2 + x3) / 6, (5 * y2 + y3) / 6, (x2 + x3) / 2, (y2 + y3) / 2];
    }
  }
  class FreeDrawOutliner {
    #box;
    #bottom = [];
    #innerMargin;
    #isLTR;
    #top = [];
    #last = new Float32Array(18);
    #lastX;
    #lastY;
    #min;
    #min_dist;
    #scaleFactor;
    #thickness;
    #points = [];
    static #MIN_DIST = 8;
    static #MIN_DIFF = 2;
    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;
    constructor({
      x,
      y
    }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
      this.#box = box;
      this.#thickness = thickness * scaleFactor;
      this.#isLTR = isLTR;
      this.#last.set([NaN, NaN, NaN, NaN, x, y], 6);
      this.#innerMargin = innerMargin;
      this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;
      this.#min = FreeDrawOutliner.#MIN * scaleFactor;
      this.#scaleFactor = scaleFactor;
      this.#points.push(x, y);
    }
    isEmpty() {
      return isNaN(this.#last[8]);
    }
    #getLastCoords() {
      const lastTop = this.#last.subarray(4, 6);
      const lastBottom = this.#last.subarray(16, 18);
      const [x, y, width, height] = this.#box;
      return [(this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width, (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height, (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width, (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height];
    }
    add({
      x,
      y
    }) {
      this.#lastX = x;
      this.#lastY = y;
      const [layerX, layerY, layerWidth, layerHeight] = this.#box;
      let [x1, y1, x2, y2] = this.#last.subarray(8, 12);
      const diffX = x - x2;
      const diffY = y - y2;
      const d = Math.hypot(diffX, diffY);
      if (d < this.#min) {
        return false;
      }
      const diffD = d - this.#min_dist;
      const K = diffD / d;
      const shiftX = K * diffX;
      const shiftY = K * diffY;
      let x0 = x1;
      let y0 = y1;
      x1 = x2;
      y1 = y2;
      x2 += shiftX;
      y2 += shiftY;
      this.#points?.push(x, y);
      const nX = -shiftY / diffD;
      const nY = shiftX / diffD;
      const thX = nX * this.#thickness;
      const thY = nY * this.#thickness;
      this.#last.set(this.#last.subarray(2, 8), 0);
      this.#last.set([x2 + thX, y2 + thY], 4);
      this.#last.set(this.#last.subarray(14, 18), 12);
      this.#last.set([x2 - thX, y2 - thY], 16);
      if (isNaN(this.#last[6])) {
        if (this.#top.length === 0) {
          this.#last.set([x1 + thX, y1 + thY], 2);
          this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
          this.#last.set([x1 - thX, y1 - thY], 14);
          this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
        }
        this.#last.set([x0, y0, x1, y1, x2, y2], 6);
        return !this.isEmpty();
      }
      this.#last.set([x0, y0, x1, y1, x2, y2], 6);
      const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
      if (angle < Math.PI / 2) {
        [x1, y1, x2, y2] = this.#last.subarray(2, 6);
        this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
        [x1, y1, x0, y0] = this.#last.subarray(14, 18);
        this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
        return true;
      }
      [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);
      this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
      [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);
      this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
      return true;
    }
    toSVGPath() {
      if (this.isEmpty()) {
        return "";
      }
      const top = this.#top;
      const bottom = this.#bottom;
      if (isNaN(this.#last[6]) && !this.isEmpty()) {
        return this.#toSVGPathTwoPoints();
      }
      const buffer = [];
      buffer.push(`M${top[4]} ${top[5]}`);
      for (let i = 6; i < top.length; i += 6) {
        if (isNaN(top[i])) {
          buffer.push(`L${top[i + 4]} ${top[i + 5]}`);
        } else {
          buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);
        }
      }
      this.#toSVGPathEnd(buffer);
      for (let i = bottom.length - 6; i >= 6; i -= 6) {
        if (isNaN(bottom[i])) {
          buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);
        } else {
          buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);
        }
      }
      this.#toSVGPathStart(buffer);
      return buffer.join(" ");
    }
    #toSVGPathTwoPoints() {
      const [x, y, width, height] = this.#box;
      const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
      return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;
    }
    #toSVGPathStart(buffer) {
      const bottom = this.#bottom;
      buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
    }
    #toSVGPathEnd(buffer) {
      const [x, y, width, height] = this.#box;
      const lastTop = this.#last.subarray(4, 6);
      const lastBottom = this.#last.subarray(16, 18);
      const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
      buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);
    }
    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
      return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
    }
    getOutlines() {
      const top = this.#top;
      const bottom = this.#bottom;
      const last = this.#last;
      const [layerX, layerY, layerWidth, layerHeight] = this.#box;
      const points = new Float32Array((this.#points?.length ?? 0) + 2);
      for (let i = 0, ii = points.length - 2; i < ii; i += 2) {
        points[i] = (this.#points[i] - layerX) / layerWidth;
        points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;
      }
      points[points.length - 2] = (this.#lastX - layerX) / layerWidth;
      points[points.length - 1] = (this.#lastY - layerY) / layerHeight;
      if (isNaN(last[6]) && !this.isEmpty()) {
        return this.#getOutlineTwoPoints(points);
      }
      const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);
      let N = top.length;
      for (let i = 0; i < N; i += 2) {
        if (isNaN(top[i])) {
          outline[i] = outline[i + 1] = NaN;
          continue;
        }
        outline[i] = top[i];
        outline[i + 1] = top[i + 1];
      }
      N = this.#getOutlineEnd(outline, N);
      for (let i = bottom.length - 6; i >= 6; i -= 6) {
        for (let j = 0; j < 6; j += 2) {
          if (isNaN(bottom[i + j])) {
            outline[N] = outline[N + 1] = NaN;
            N += 2;
            continue;
          }
          outline[N] = bottom[i + j];
          outline[N + 1] = bottom[i + j + 1];
          N += 2;
        }
      }
      this.#getOutlineStart(outline, N);
      return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
    }
    #getOutlineTwoPoints(points) {
      const last = this.#last;
      const [layerX, layerY, layerWidth, layerHeight] = this.#box;
      const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
      const outline = new Float32Array(36);
      outline.set([NaN, NaN, NaN, NaN, (last[2] - layerX) / layerWidth, (last[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[4] - layerX) / layerWidth, (last[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last[16] - layerX) / layerWidth, (last[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[14] - layerX) / layerWidth, (last[15] - layerY) / layerHeight], 0);
      return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
    }
    #getOutlineStart(outline, pos) {
      const bottom = this.#bottom;
      outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], pos);
      return pos += 6;
    }
    #getOutlineEnd(outline, pos) {
      const lastTop = this.#last.subarray(4, 6);
      const lastBottom = this.#last.subarray(16, 18);
      const [layerX, layerY, layerWidth, layerHeight] = this.#box;
      const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
      outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], pos);
      return pos += 24;
    }
  }
  class FreeDrawOutline extends Outline {
    #box;
    #bbox = new Float32Array(4);
    #innerMargin;
    #isLTR;
    #points;
    #scaleFactor;
    #outline;
    constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {
      super();
      this.#outline = outline;
      this.#points = points;
      this.#box = box;
      this.#scaleFactor = scaleFactor;
      this.#innerMargin = innerMargin;
      this.#isLTR = isLTR;
      this.lastPoint = [NaN, NaN];
      this.#computeMinMax(isLTR);
      const [x, y, width, height] = this.#bbox;
      for (let i = 0, ii = outline.length; i < ii; i += 2) {
        outline[i] = (outline[i] - x) / width;
        outline[i + 1] = (outline[i + 1] - y) / height;
      }
      for (let i = 0, ii = points.length; i < ii; i += 2) {
        points[i] = (points[i] - x) / width;
        points[i + 1] = (points[i + 1] - y) / height;
      }
    }
    toSVGPath() {
      const buffer = [`M${this.#outline[4]} ${this.#outline[5]}`];
      for (let i = 6, ii = this.#outline.length; i < ii; i += 6) {
        if (isNaN(this.#outline[i])) {
          buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
          continue;
        }
        buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
      }
      buffer.push("Z");
      return buffer.join(" ");
    }
    serialize([blX, blY, trX, trY], rotation) {
      const width = trX - blX;
      const height = trY - blY;
      let outline;
      let points;
      switch (rotation) {
        case 0:
          outline = Outline._rescale(this.#outline, blX, trY, width, -height);
          points = Outline._rescale(this.#points, blX, trY, width, -height);
          break;
        case 90:
          outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);
          points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);
          break;
        case 180:
          outline = Outline._rescale(this.#outline, trX, blY, -width, height);
          points = Outline._rescale(this.#points, trX, blY, -width, height);
          break;
        case 270:
          outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);
          points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);
          break;
      }
      return {
        outline: Array.from(outline),
        points: [Array.from(points)]
      };
    }
    #computeMinMax(isLTR) {
      const outline = this.#outline;
      let lastX = outline[4];
      let lastY = outline[5];
      const minMax = [lastX, lastY, lastX, lastY];
      let lastPointX = lastX;
      let lastPointY = lastY;
      const ltrCallback = isLTR ? Math.max : Math.min;
      for (let i = 6, ii = outline.length; i < ii; i += 6) {
        const x = outline[i + 4], y = outline[i + 5];
        if (isNaN(outline[i])) {
          Util.pointBoundingBox(x, y, minMax);
          if (lastPointY < y) {
            lastPointX = x;
            lastPointY = y;
          } else if (lastPointY === y) {
            lastPointX = ltrCallback(lastPointX, x);
          }
        } else {
          const bbox2 = [Infinity, Infinity, -Infinity, -Infinity];
          Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bbox2);
          Util.rectBoundingBox(...bbox2, minMax);
          if (lastPointY < bbox2[3]) {
            lastPointX = bbox2[2];
            lastPointY = bbox2[3];
          } else if (lastPointY === bbox2[3]) {
            lastPointX = ltrCallback(lastPointX, bbox2[2]);
          }
        }
        lastX = x;
        lastY = y;
      }
      const bbox = this.#bbox;
      bbox[0] = minMax[0] - this.#innerMargin;
      bbox[1] = minMax[1] - this.#innerMargin;
      bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;
      bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;
      this.lastPoint = [lastPointX, lastPointY];
    }
    get box() {
      return this.#bbox;
    }
    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
      return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
    }
    getNewOutline(thickness, innerMargin) {
      const [x, y, width, height] = this.#bbox;
      const [layerX, layerY, layerWidth, layerHeight] = this.#box;
      const sx = width * layerWidth;
      const sy = height * layerHeight;
      const tx = x * layerWidth + layerX;
      const ty = y * layerHeight + layerY;
      const outliner = this.newOutliner({
        x: this.#points[0] * sx + tx,
        y: this.#points[1] * sy + ty
      }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);
      for (let i = 2; i < this.#points.length; i += 2) {
        outliner.add({
          x: this.#points[i] * sx + tx,
          y: this.#points[i + 1] * sy + ty
        });
      }
      return outliner.getOutlines();
    }
  }
  class HighlightOutliner {
    #box;
    #lastPoint;
    #verticalEdges = [];
    #intervals = [];
    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {
      const minMax = [Infinity, Infinity, -Infinity, -Infinity];
      const EPSILON = 10 ** -4;
      for (const {
        x,
        y,
        width,
        height
      } of boxes) {
        const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;
        const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;
        const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;
        const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;
        const left = [x1, y1, y2, true];
        const right = [x2, y1, y2, false];
        this.#verticalEdges.push(left, right);
        Util.rectBoundingBox(x1, y1, x2, y2, minMax);
      }
      const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;
      const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;
      const shiftedMinX = minMax[0] - innerMargin;
      const shiftedMinY = minMax[1] - innerMargin;
      const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);
      const lastPoint = [lastEdge[0], lastEdge[2]];
      for (const edge of this.#verticalEdges) {
        const [x, y1, y2] = edge;
        edge[0] = (x - shiftedMinX) / bboxWidth;
        edge[1] = (y1 - shiftedMinY) / bboxHeight;
        edge[2] = (y2 - shiftedMinY) / bboxHeight;
      }
      this.#box = new Float32Array([shiftedMinX, shiftedMinY, bboxWidth, bboxHeight]);
      this.#lastPoint = lastPoint;
    }
    getOutlines() {
      this.#verticalEdges.sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);
      const outlineVerticalEdges = [];
      for (const edge of this.#verticalEdges) {
        if (edge[3]) {
          outlineVerticalEdges.push(...this.#breakEdge(edge));
          this.#insert(edge);
        } else {
          this.#remove(edge);
          outlineVerticalEdges.push(...this.#breakEdge(edge));
        }
      }
      return this.#getOutlines(outlineVerticalEdges);
    }
    #getOutlines(outlineVerticalEdges) {
      const edges = [];
      const allEdges = /* @__PURE__ */ new Set();
      for (const edge of outlineVerticalEdges) {
        const [x, y1, y2] = edge;
        edges.push([x, y1, edge], [x, y2, edge]);
      }
      edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);
      for (let i = 0, ii = edges.length; i < ii; i += 2) {
        const edge1 = edges[i][2];
        const edge2 = edges[i + 1][2];
        edge1.push(edge2);
        edge2.push(edge1);
        allEdges.add(edge1);
        allEdges.add(edge2);
      }
      const outlines = [];
      let outline;
      while (allEdges.size > 0) {
        const edge = allEdges.values().next().value;
        let [x, y1, y2, edge1, edge2] = edge;
        allEdges.delete(edge);
        let lastPointX = x;
        let lastPointY = y1;
        outline = [x, y2];
        outlines.push(outline);
        while (true) {
          let e;
          if (allEdges.has(edge1)) {
            e = edge1;
          } else if (allEdges.has(edge2)) {
            e = edge2;
          } else {
            break;
          }
          allEdges.delete(e);
          [x, y1, y2, edge1, edge2] = e;
          if (lastPointX !== x) {
            outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);
            lastPointX = x;
          }
          lastPointY = lastPointY === y1 ? y2 : y1;
        }
        outline.push(lastPointX, lastPointY);
      }
      return new HighlightOutline(outlines, this.#box, this.#lastPoint);
    }
    #binarySearch(y) {
      const array = this.#intervals;
      let start = 0;
      let end = array.length - 1;
      while (start <= end) {
        const middle = start + end >> 1;
        const y1 = array[middle][0];
        if (y1 === y) {
          return middle;
        }
        if (y1 < y) {
          start = middle + 1;
        } else {
          end = middle - 1;
        }
      }
      return end + 1;
    }
    #insert([, y1, y2]) {
      const index = this.#binarySearch(y1);
      this.#intervals.splice(index, 0, [y1, y2]);
    }
    #remove([, y1, y2]) {
      const index = this.#binarySearch(y1);
      for (let i = index; i < this.#intervals.length; i++) {
        const [start, end] = this.#intervals[i];
        if (start !== y1) {
          break;
        }
        if (start === y1 && end === y2) {
          this.#intervals.splice(i, 1);
          return;
        }
      }
      for (let i = index - 1; i >= 0; i--) {
        const [start, end] = this.#intervals[i];
        if (start !== y1) {
          break;
        }
        if (start === y1 && end === y2) {
          this.#intervals.splice(i, 1);
          return;
        }
      }
    }
    #breakEdge(edge) {
      const [x, y1, y2] = edge;
      const results = [[x, y1, y2]];
      const index = this.#binarySearch(y2);
      for (let i = 0; i < index; i++) {
        const [start, end] = this.#intervals[i];
        for (let j = 0, jj = results.length; j < jj; j++) {
          const [, y3, y4] = results[j];
          if (end <= y3 || y4 <= start) {
            continue;
          }
          if (y3 >= start) {
            if (y4 > end) {
              results[j][1] = end;
            } else {
              if (jj === 1) {
                return [];
              }
              results.splice(j, 1);
              j--;
              jj--;
            }
            continue;
          }
          results[j][2] = start;
          if (y4 > end) {
            results.push([x, end, y4]);
          }
        }
      }
      return results;
    }
  }
  class HighlightOutline extends Outline {
    #box;
    #outlines;
    constructor(outlines, box, lastPoint) {
      super();
      this.#outlines = outlines;
      this.#box = box;
      this.lastPoint = lastPoint;
    }
    toSVGPath() {
      const buffer = [];
      for (const polygon of this.#outlines) {
        let [prevX, prevY] = polygon;
        buffer.push(`M${prevX} ${prevY}`);
        for (let i = 2; i < polygon.length; i += 2) {
          const x = polygon[i];
          const y = polygon[i + 1];
          if (x === prevX) {
            buffer.push(`V${y}`);
            prevY = y;
          } else if (y === prevY) {
            buffer.push(`H${x}`);
            prevX = x;
          }
        }
        buffer.push("Z");
      }
      return buffer.join(" ");
    }
    serialize([blX, blY, trX, trY], _rotation) {
      const outlines = [];
      const width = trX - blX;
      const height = trY - blY;
      for (const outline of this.#outlines) {
        const points = new Array(outline.length);
        for (let i = 0; i < outline.length; i += 2) {
          points[i] = blX + outline[i] * width;
          points[i + 1] = trY - outline[i + 1] * height;
        }
        outlines.push(points);
      }
      return outlines;
    }
    get box() {
      return this.#box;
    }
    get classNamesForOutlining() {
      return ["highlightOutline"];
    }
  }
  class FreeHighlightOutliner extends FreeDrawOutliner {
    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
      return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
    }
  }
  class FreeHighlightOutline extends FreeDrawOutline {
    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
      return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
    }
  }
  class HighlightEditor extends AnnotationEditor {
    #anchorNode = null;
    #anchorOffset = 0;
    #boxes;
    #clipPathId = null;
    #colorPicker = null;
    #focusOutlines = null;
    #focusNode = null;
    #focusOffset = 0;
    #highlightDiv = null;
    #highlightOutlines = null;
    #id = null;
    #isFreeHighlight = false;
    #lastPoint = null;
    #opacity;
    #outlineId = null;
    #text = "";
    #thickness;
    #methodOfCreation = "";
    static _defaultColor = null;
    static _defaultOpacity = 1;
    static _defaultThickness = 12;
    static _type = "highlight";
    static _editorType = AnnotationEditorType.HIGHLIGHT;
    static _freeHighlightId = -1;
    static _freeHighlight = null;
    static _freeHighlightClipId = "";
    static get _keyboardManager() {
      const proto = HighlightEditor.prototype;
      return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, {
        args: [0]
      }], [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, {
        args: [1]
      }], [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, {
        args: [2]
      }], [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, {
        args: [3]
      }]]));
    }
    constructor(params) {
      super({
        ...params,
        name: "highlightEditor"
      });
      this.color = params.color || HighlightEditor._defaultColor;
      this.#thickness = params.thickness || HighlightEditor._defaultThickness;
      this.#opacity = params.opacity || HighlightEditor._defaultOpacity;
      this.#boxes = params.boxes || null;
      this.#methodOfCreation = params.methodOfCreation || "";
      this.#text = params.text || "";
      this._isDraggable = false;
      this.defaultL10nId = "pdfjs-editor-highlight-editor";
      if (params.highlightId > -1) {
        this.#isFreeHighlight = true;
        this.#createFreeOutlines(params);
        this.#addToDrawLayer();
      } else if (this.#boxes) {
        this.#anchorNode = params.anchorNode;
        this.#anchorOffset = params.anchorOffset;
        this.#focusNode = params.focusNode;
        this.#focusOffset = params.focusOffset;
        this.#createOutlines();
        this.#addToDrawLayer();
        this.rotate(this.rotation);
      }
      if (!this.annotationElementId) {
        this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
      }
    }
    get telemetryInitialData() {
      return {
        action: "added",
        type: this.#isFreeHighlight ? "free_highlight" : "highlight",
        color: this._uiManager.getNonHCMColorName(this.color),
        thickness: this.#thickness,
        methodOfCreation: this.#methodOfCreation
      };
    }
    get telemetryFinalData() {
      return {
        type: "highlight",
        color: this._uiManager.getNonHCMColorName(this.color)
      };
    }
    get commentColor() {
      return this.color;
    }
    static computeTelemetryFinalData(data) {
      return {
        numberOfColors: data.get("color").size
      };
    }
    #createOutlines() {
      const outliner = new HighlightOutliner(this.#boxes, 1e-3);
      this.#highlightOutlines = outliner.getOutlines();
      [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;
      const outlinerForOutline = new HighlightOutliner(this.#boxes, 25e-4, 1e-3, this._uiManager.direction === "ltr");
      this.#focusOutlines = outlinerForOutline.getOutlines();
      const {
        lastPoint
      } = this.#focusOutlines;
      this.#lastPoint = [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height];
    }
    #createFreeOutlines({
      highlightOutlines,
      highlightId,
      clipPathId
    }) {
      this.#highlightOutlines = highlightOutlines;
      const extraThickness = 1.5;
      this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 25e-4);
      if (highlightId >= 0) {
        this.#id = highlightId;
        this.#clipPathId = clipPathId;
        this.parent.drawLayer.finalizeDraw(highlightId, {
          bbox: highlightOutlines.box,
          path: {
            d: highlightOutlines.toSVGPath()
          }
        });
        this.#outlineId = this.parent.drawLayer.drawOutline({
          rootClass: {
            highlightOutline: true,
            free: true
          },
          bbox: this.#focusOutlines.box,
          path: {
            d: this.#focusOutlines.toSVGPath()
          }
        }, true);
      } else if (this.parent) {
        const angle = this.parent.viewport.rotation;
        this.parent.drawLayer.updateProperties(this.#id, {
          bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),
          path: {
            d: highlightOutlines.toSVGPath()
          }
        });
        this.parent.drawLayer.updateProperties(this.#outlineId, {
          bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
          path: {
            d: this.#focusOutlines.toSVGPath()
          }
        });
      }
      const [x, y, width, height] = highlightOutlines.box;
      switch (this.rotation) {
        case 0:
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          break;
        case 90: {
          const [pageWidth, pageHeight] = this.parentDimensions;
          this.x = y;
          this.y = 1 - x;
          this.width = width * pageHeight / pageWidth;
          this.height = height * pageWidth / pageHeight;
          break;
        }
        case 180:
          this.x = 1 - x;
          this.y = 1 - y;
          this.width = width;
          this.height = height;
          break;
        case 270: {
          const [pageWidth, pageHeight] = this.parentDimensions;
          this.x = 1 - y;
          this.y = x;
          this.width = width * pageHeight / pageWidth;
          this.height = height * pageWidth / pageHeight;
          break;
        }
      }
      const {
        lastPoint
      } = this.#focusOutlines;
      this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];
    }
    static initialize(l10n, uiManager) {
      AnnotationEditor.initialize(l10n, uiManager);
      HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || "#fff066";
    }
    static updateDefaultParams(type, value) {
      switch (type) {
        case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
          HighlightEditor._defaultColor = value;
          break;
        case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
          HighlightEditor._defaultThickness = value;
          break;
      }
    }
    translateInPage(x, y) {
    }
    get toolbarPosition() {
      return this.#lastPoint;
    }
    updateParams(type, value) {
      switch (type) {
        case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
          this.#updateColor(value);
          break;
        case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
          this.#updateThickness(value);
          break;
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, HighlightEditor._defaultThickness]];
    }
    get propertiesToUpdate() {
      return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, this.#thickness || HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight]];
    }
    #updateColor(color) {
      const setColorAndOpacity = (col, opa) => {
        this.color = col;
        this.#opacity = opa;
        this.parent?.drawLayer.updateProperties(this.#id, {
          root: {
            fill: col,
            "fill-opacity": opa
          }
        });
        this.#colorPicker?.updateColor(col);
      };
      const savedColor = this.color;
      const savedOpacity = this.#opacity;
      this.addCommands({
        cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),
        undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),
        post: this._uiManager.updateUI.bind(this._uiManager, this),
        mustExec: true,
        type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
        overwriteIfSameType: true,
        keepUndo: true
      });
      this._reportTelemetry({
        action: "color_changed",
        color: this._uiManager.getNonHCMColorName(color)
      }, true);
    }
    #updateThickness(thickness) {
      const savedThickness = this.#thickness;
      const setThickness = (th) => {
        this.#thickness = th;
        this.#changeThickness(th);
      };
      this.addCommands({
        cmd: setThickness.bind(this, thickness),
        undo: setThickness.bind(this, savedThickness),
        post: this._uiManager.updateUI.bind(this._uiManager, this),
        mustExec: true,
        type: AnnotationEditorParamsType.INK_THICKNESS,
        overwriteIfSameType: true,
        keepUndo: true
      });
      this._reportTelemetry({
        action: "thickness_changed",
        thickness
      }, true);
    }
    get toolbarButtons() {
      if (this._uiManager.highlightColors) {
        const colorPicker = this.#colorPicker = new ColorPicker({
          editor: this
        });
        return [["colorPicker", colorPicker]];
      }
      return super.toolbarButtons;
    }
    disableEditing() {
      super.disableEditing();
      this.div.classList.toggle("disabled", true);
    }
    enableEditing() {
      super.enableEditing();
      this.div.classList.toggle("disabled", false);
    }
    fixAndSetPosition() {
      return super.fixAndSetPosition(this.#getRotation());
    }
    getBaseTranslation() {
      return [0, 0];
    }
    getRect(tx, ty) {
      return super.getRect(tx, ty, this.#getRotation());
    }
    onceAdded(focus) {
      if (!this.annotationElementId) {
        this.parent.addUndoableEditor(this);
      }
      if (focus) {
        this.div.focus();
      }
    }
    remove() {
      this.#cleanDrawLayer();
      this._reportTelemetry({
        action: "deleted"
      });
      super.remove();
    }
    rebuild() {
      if (!this.parent) {
        return;
      }
      super.rebuild();
      if (this.div === null) {
        return;
      }
      this.#addToDrawLayer();
      if (!this.isAttachedToDOM) {
        this.parent.add(this);
      }
    }
    setParent(parent) {
      let mustBeSelected = false;
      if (this.parent && !parent) {
        this.#cleanDrawLayer();
      } else if (parent) {
        this.#addToDrawLayer(parent);
        mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
      }
      super.setParent(parent);
      this.show(this._isVisible);
      if (mustBeSelected) {
        this.select();
      }
    }
    #changeThickness(thickness) {
      if (!this.#isFreeHighlight) {
        return;
      }
      this.#createFreeOutlines({
        highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)
      });
      this.fixAndSetPosition();
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setDims(this.width * parentWidth, this.height * parentHeight);
    }
    #cleanDrawLayer() {
      if (this.#id === null || !this.parent) {
        return;
      }
      this.parent.drawLayer.remove(this.#id);
      this.#id = null;
      this.parent.drawLayer.remove(this.#outlineId);
      this.#outlineId = null;
    }
    #addToDrawLayer(parent = this.parent) {
      if (this.#id !== null) {
        return;
      }
      ({
        id: this.#id,
        clipPathId: this.#clipPathId
      } = parent.drawLayer.draw({
        bbox: this.#highlightOutlines.box,
        root: {
          viewBox: "0 0 1 1",
          fill: this.color,
          "fill-opacity": this.#opacity
        },
        rootClass: {
          highlight: true,
          free: this.#isFreeHighlight
        },
        path: {
          d: this.#highlightOutlines.toSVGPath()
        }
      }, false, true));
      this.#outlineId = parent.drawLayer.drawOutline({
        rootClass: {
          highlightOutline: true,
          free: this.#isFreeHighlight
        },
        bbox: this.#focusOutlines.box,
        path: {
          d: this.#focusOutlines.toSVGPath()
        }
      }, this.#isFreeHighlight);
      if (this.#highlightDiv) {
        this.#highlightDiv.style.clipPath = this.#clipPathId;
      }
    }
    static #rotateBbox([x, y, width, height], angle) {
      switch (angle) {
        case 90:
          return [1 - y - height, x, height, width];
        case 180:
          return [1 - x - width, 1 - y - height, width, height];
        case 270:
          return [y, 1 - x - width, height, width];
      }
      return [x, y, width, height];
    }
    rotate(angle) {
      const {
        drawLayer
      } = this.parent;
      let box;
      if (this.#isFreeHighlight) {
        angle = (angle - this.rotation + 360) % 360;
        box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
      } else {
        box = HighlightEditor.#rotateBbox([this.x, this.y, this.width, this.height], angle);
      }
      drawLayer.updateProperties(this.#id, {
        bbox: box,
        root: {
          "data-main-rotation": angle
        }
      });
      drawLayer.updateProperties(this.#outlineId, {
        bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
        root: {
          "data-main-rotation": angle
        }
      });
    }
    render() {
      if (this.div) {
        return this.div;
      }
      const div = super.render();
      if (this.#text) {
        div.setAttribute("aria-label", this.#text);
        div.setAttribute("role", "mark");
      }
      if (this.#isFreeHighlight) {
        div.classList.add("free");
      } else {
        this.div.addEventListener("keydown", this.#keydown.bind(this), {
          signal: this._uiManager._signal
        });
      }
      const highlightDiv = this.#highlightDiv = document.createElement("div");
      div.append(highlightDiv);
      highlightDiv.setAttribute("aria-hidden", "true");
      highlightDiv.className = "internal";
      highlightDiv.style.clipPath = this.#clipPathId;
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setDims(this.width * parentWidth, this.height * parentHeight);
      bindEvents(this, this.#highlightDiv, ["pointerover", "pointerleave"]);
      this.enableEditing();
      return div;
    }
    pointerover() {
      if (!this.isSelected) {
        this.parent?.drawLayer.updateProperties(this.#outlineId, {
          rootClass: {
            hovered: true
          }
        });
      }
    }
    pointerleave() {
      if (!this.isSelected) {
        this.parent?.drawLayer.updateProperties(this.#outlineId, {
          rootClass: {
            hovered: false
          }
        });
      }
    }
    #keydown(event) {
      HighlightEditor._keyboardManager.exec(this, event);
    }
    _moveCaret(direction) {
      this.parent.unselect(this);
      switch (direction) {
        case 0:
        case 2:
          this.#setCaret(true);
          break;
        case 1:
        case 3:
          this.#setCaret(false);
          break;
      }
    }
    #setCaret(start) {
      if (!this.#anchorNode) {
        return;
      }
      const selection = window.getSelection();
      if (start) {
        selection.setPosition(this.#anchorNode, this.#anchorOffset);
      } else {
        selection.setPosition(this.#focusNode, this.#focusOffset);
      }
    }
    select() {
      super.select();
      if (!this.#outlineId) {
        return;
      }
      this.parent?.drawLayer.updateProperties(this.#outlineId, {
        rootClass: {
          hovered: false,
          selected: true
        }
      });
    }
    unselect() {
      super.unselect();
      if (!this.#outlineId) {
        return;
      }
      this.parent?.drawLayer.updateProperties(this.#outlineId, {
        rootClass: {
          selected: false
        }
      });
      if (!this.#isFreeHighlight) {
        this.#setCaret(false);
      }
    }
    get _mustFixPosition() {
      return !this.#isFreeHighlight;
    }
    show(visible = this._isVisible) {
      super.show(visible);
      if (this.parent) {
        this.parent.drawLayer.updateProperties(this.#id, {
          rootClass: {
            hidden: !visible
          }
        });
        this.parent.drawLayer.updateProperties(this.#outlineId, {
          rootClass: {
            hidden: !visible
          }
        });
      }
    }
    #getRotation() {
      return this.#isFreeHighlight ? this.rotation : 0;
    }
    #serializeBoxes() {
      if (this.#isFreeHighlight) {
        return null;
      }
      const [pageWidth, pageHeight] = this.pageDimensions;
      const [pageX, pageY] = this.pageTranslation;
      const boxes = this.#boxes;
      const quadPoints = new Float32Array(boxes.length * 8);
      let i = 0;
      for (const {
        x,
        y,
        width,
        height
      } of boxes) {
        const sx = x * pageWidth + pageX;
        const sy = (1 - y) * pageHeight + pageY;
        quadPoints[i] = quadPoints[i + 4] = sx;
        quadPoints[i + 1] = quadPoints[i + 3] = sy;
        quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
        quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;
        i += 8;
      }
      return quadPoints;
    }
    #serializeOutlines(rect) {
      return this.#highlightOutlines.serialize(rect, this.#getRotation());
    }
    static startHighlighting(parent, isLTR, {
      target: textLayer,
      x,
      y
    }) {
      const {
        x: layerX,
        y: layerY,
        width: parentWidth,
        height: parentHeight
      } = textLayer.getBoundingClientRect();
      const ac = new AbortController();
      const signal = parent.combinedSignal(ac);
      const pointerUpCallback = (e) => {
        ac.abort();
        this.#endHighlight(parent, e);
      };
      window.addEventListener("blur", pointerUpCallback, {
        signal
      });
      window.addEventListener("pointerup", pointerUpCallback, {
        signal
      });
      window.addEventListener("pointerdown", stopEvent, {
        capture: true,
        passive: false,
        signal
      });
      window.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      textLayer.addEventListener("pointermove", this.#highlightMove.bind(this, parent), {
        signal
      });
      this._freeHighlight = new FreeHighlightOutliner({
        x,
        y
      }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 1e-3);
      ({
        id: this._freeHighlightId,
        clipPathId: this._freeHighlightClipId
      } = parent.drawLayer.draw({
        bbox: [0, 0, 1, 1],
        root: {
          viewBox: "0 0 1 1",
          fill: this._defaultColor,
          "fill-opacity": this._defaultOpacity
        },
        rootClass: {
          highlight: true,
          free: true
        },
        path: {
          d: this._freeHighlight.toSVGPath()
        }
      }, true, true));
    }
    static #highlightMove(parent, event) {
      if (this._freeHighlight.add(event)) {
        parent.drawLayer.updateProperties(this._freeHighlightId, {
          path: {
            d: this._freeHighlight.toSVGPath()
          }
        });
      }
    }
    static #endHighlight(parent, event) {
      if (!this._freeHighlight.isEmpty()) {
        parent.createAndAddNewEditor(event, false, {
          highlightId: this._freeHighlightId,
          highlightOutlines: this._freeHighlight.getOutlines(),
          clipPathId: this._freeHighlightClipId,
          methodOfCreation: "main_toolbar"
        });
      } else {
        parent.drawLayer.remove(this._freeHighlightId);
      }
      this._freeHighlightId = -1;
      this._freeHighlight = null;
      this._freeHighlightClipId = "";
    }
    static async deserialize(data, parent, uiManager) {
      let initialData = null;
      if (data instanceof HighlightAnnotationElement) {
        const {
          data: {
            quadPoints: quadPoints2,
            rect,
            rotation,
            id,
            color: color2,
            opacity: opacity2,
            popupRef,
            contentsObj
          },
          parent: {
            page: {
              pageNumber
            }
          }
        } = data;
        initialData = data = {
          annotationType: AnnotationEditorType.HIGHLIGHT,
          color: Array.from(color2),
          opacity: opacity2,
          quadPoints: quadPoints2,
          boxes: null,
          pageIndex: pageNumber - 1,
          rect: rect.slice(0),
          rotation,
          annotationElementId: id,
          id,
          deleted: false,
          popupRef,
          comment: contentsObj?.str || null
        };
      } else if (data instanceof InkAnnotationElement) {
        const {
          data: {
            inkLists: inkLists2,
            rect,
            rotation,
            id,
            color: color2,
            borderStyle: {
              rawWidth: thickness
            },
            popupRef,
            contentsObj
          },
          parent: {
            page: {
              pageNumber
            }
          }
        } = data;
        initialData = data = {
          annotationType: AnnotationEditorType.HIGHLIGHT,
          color: Array.from(color2),
          thickness,
          inkLists: inkLists2,
          boxes: null,
          pageIndex: pageNumber - 1,
          rect: rect.slice(0),
          rotation,
          annotationElementId: id,
          id,
          deleted: false,
          popupRef,
          comment: contentsObj?.str || null
        };
      }
      const {
        color,
        quadPoints,
        inkLists,
        opacity
      } = data;
      const editor = await super.deserialize(data, parent, uiManager);
      editor.color = Util.makeHexColor(...color);
      editor.#opacity = opacity || 1;
      if (inkLists) {
        editor.#thickness = data.thickness;
      }
      editor._initialData = initialData;
      if (data.comment) {
        editor.setCommentData(data.comment);
      }
      const [pageWidth, pageHeight] = editor.pageDimensions;
      const [pageX, pageY] = editor.pageTranslation;
      if (quadPoints) {
        const boxes = editor.#boxes = [];
        for (let i = 0; i < quadPoints.length; i += 8) {
          boxes.push({
            x: (quadPoints[i] - pageX) / pageWidth,
            y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,
            width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
            height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight
          });
        }
        editor.#createOutlines();
        editor.#addToDrawLayer();
        editor.rotate(editor.rotation);
      } else if (inkLists) {
        editor.#isFreeHighlight = true;
        const points = inkLists[0];
        const point = {
          x: points[0] - pageX,
          y: pageHeight - (points[1] - pageY)
        };
        const outliner = new FreeHighlightOutliner(point, [0, 0, pageWidth, pageHeight], 1, editor.#thickness / 2, true, 1e-3);
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          point.x = points[i] - pageX;
          point.y = pageHeight - (points[i + 1] - pageY);
          outliner.add(point);
        }
        const {
          id,
          clipPathId
        } = parent.drawLayer.draw({
          bbox: [0, 0, 1, 1],
          root: {
            viewBox: "0 0 1 1",
            fill: editor.color,
            "fill-opacity": editor._defaultOpacity
          },
          rootClass: {
            highlight: true,
            free: true
          },
          path: {
            d: outliner.toSVGPath()
          }
        }, true, true);
        editor.#createFreeOutlines({
          highlightOutlines: outliner.getOutlines(),
          highlightId: id,
          clipPathId
        });
        editor.#addToDrawLayer();
        editor.rotate(editor.parentRotation);
      }
      return editor;
    }
    serialize(isForCopying = false) {
      if (this.isEmpty() || isForCopying) {
        return null;
      }
      if (this.deleted) {
        return this.serializeDeleted();
      }
      const rect = this.getPDFRect();
      const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
      const serialized = {
        annotationType: AnnotationEditorType.HIGHLIGHT,
        color,
        opacity: this.#opacity,
        thickness: this.#thickness,
        quadPoints: this.#serializeBoxes(),
        outlines: this.#serializeOutlines(rect),
        pageIndex: this.pageIndex,
        rect,
        rotation: this.#getRotation(),
        structTreeParentId: this._structTreeParentId
      };
      this.addComment(serialized);
      if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
        return null;
      }
      serialized.id = this.annotationElementId;
      return serialized;
    }
    #hasElementChanged(serialized) {
      const {
        color
      } = this._initialData;
      return this.hasEditedComment || serialized.color.some((c, i) => c !== color[i]);
    }
    renderAnnotationElement(annotation) {
      if (this.deleted) {
        annotation.hide();
        return null;
      }
      const params = {
        rect: this.getPDFRect()
      };
      if (this.hasEditedComment) {
        params.popup = this.comment;
      }
      annotation.updateEdited(params);
      return null;
    }
    static canCreateNewEmptyEditor() {
      return false;
    }
  }
  class DrawingOptions {
    #svgProperties = /* @__PURE__ */ Object.create(null);
    updateProperty(name, value) {
      this[name] = value;
      this.updateSVGProperty(name, value);
    }
    updateProperties(properties) {
      if (!properties) {
        return;
      }
      for (const [name, value] of Object.entries(properties)) {
        if (!name.startsWith("_")) {
          this.updateProperty(name, value);
        }
      }
    }
    updateSVGProperty(name, value) {
      this.#svgProperties[name] = value;
    }
    toSVGProperties() {
      const root = this.#svgProperties;
      this.#svgProperties = /* @__PURE__ */ Object.create(null);
      return {
        root
      };
    }
    reset() {
      this.#svgProperties = /* @__PURE__ */ Object.create(null);
    }
    updateAll(options = this) {
      this.updateProperties(options);
    }
    clone() {
      unreachable("Not implemented");
    }
  }
  class DrawingEditor extends AnnotationEditor {
    #drawOutlines = null;
    #mustBeCommitted;
    _colorPicker = null;
    _drawId = null;
    static _currentDrawId = -1;
    static _currentParent = null;
    static #currentDraw = null;
    static #currentDrawingAC = null;
    static #currentDrawingOptions = null;
    static #currentPointerId = NaN;
    static #currentPointerType = null;
    static #currentPointerIds = null;
    static #currentMoveTimestamp = NaN;
    static _INNER_MARGIN = 3;
    constructor(params) {
      super(params);
      this.#mustBeCommitted = params.mustBeCommitted || false;
      this._addOutlines(params);
    }
    _addOutlines(params) {
      if (params.drawOutlines) {
        this.#createDrawOutlines(params);
        this.#addToDrawLayer();
      }
    }
    #createDrawOutlines({
      drawOutlines,
      drawId,
      drawingOptions
    }) {
      this.#drawOutlines = drawOutlines;
      this._drawingOptions ||= drawingOptions;
      if (!this.annotationElementId) {
        this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);
      }
      if (drawId >= 0) {
        this._drawId = drawId;
        this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);
      } else {
        this._drawId = this.#createDrawing(drawOutlines, this.parent);
      }
      this.#updateBbox(drawOutlines.box);
    }
    #createDrawing(drawOutlines, parent) {
      const {
        id
      } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);
      return id;
    }
    static _mergeSVGProperties(p1, p2) {
      const p1Keys = new Set(Object.keys(p1));
      for (const [key, value] of Object.entries(p2)) {
        if (p1Keys.has(key)) {
          Object.assign(p1[key], value);
        } else {
          p1[key] = value;
        }
      }
      return p1;
    }
    static getDefaultDrawingOptions(_options) {
      unreachable("Not implemented");
    }
    static get typesMap() {
      unreachable("Not implemented");
    }
    static get isDrawer() {
      return true;
    }
    static get supportMultipleDrawings() {
      return false;
    }
    static updateDefaultParams(type, value) {
      const propertyName = this.typesMap.get(type);
      if (propertyName) {
        this._defaultDrawingOptions.updateProperty(propertyName, value);
      }
      if (this._currentParent) {
        DrawingEditor.#currentDraw.updateProperty(propertyName, value);
        this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
      }
    }
    updateParams(type, value) {
      const propertyName = this.constructor.typesMap.get(type);
      if (propertyName) {
        this._updateProperty(type, propertyName, value);
      }
    }
    static get defaultPropertiesToUpdate() {
      const properties = [];
      const options = this._defaultDrawingOptions;
      for (const [type, name] of this.typesMap) {
        properties.push([type, options[name]]);
      }
      return properties;
    }
    get propertiesToUpdate() {
      const properties = [];
      const {
        _drawingOptions
      } = this;
      for (const [type, name] of this.constructor.typesMap) {
        properties.push([type, _drawingOptions[name]]);
      }
      return properties;
    }
    _updateProperty(type, name, value) {
      const options = this._drawingOptions;
      const savedValue = options[name];
      const setter = (val) => {
        options.updateProperty(name, val);
        const bbox = this.#drawOutlines.updateProperty(name, val);
        if (bbox) {
          this.#updateBbox(bbox);
        }
        this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());
        if (type === this.colorType) {
          this._colorPicker?.update(val);
        }
      };
      this.addCommands({
        cmd: setter.bind(this, value),
        undo: setter.bind(this, savedValue),
        post: this._uiManager.updateUI.bind(this._uiManager, this),
        mustExec: true,
        type,
        overwriteIfSameType: true,
        keepUndo: true
      });
    }
    _onResizing() {
      this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {
        bbox: this.#rotateBox()
      }));
    }
    _onResized() {
      this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {
        bbox: this.#rotateBox()
      }));
    }
    _onTranslating(_x, _y) {
      this.parent?.drawLayer.updateProperties(this._drawId, {
        bbox: this.#rotateBox()
      });
    }
    _onTranslated() {
      this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {
        bbox: this.#rotateBox()
      }));
    }
    _onStartDragging() {
      this.parent?.drawLayer.updateProperties(this._drawId, {
        rootClass: {
          moving: true
        }
      });
    }
    _onStopDragging() {
      this.parent?.drawLayer.updateProperties(this._drawId, {
        rootClass: {
          moving: false
        }
      });
    }
    commit() {
      super.commit();
      this.disableEditMode();
      this.disableEditing();
    }
    disableEditing() {
      super.disableEditing();
      this.div.classList.toggle("disabled", true);
    }
    enableEditing() {
      super.enableEditing();
      this.div.classList.toggle("disabled", false);
    }
    getBaseTranslation() {
      return [0, 0];
    }
    get isResizable() {
      return true;
    }
    onceAdded(focus) {
      if (!this.annotationElementId) {
        this.parent.addUndoableEditor(this);
      }
      this._isDraggable = true;
      if (this.#mustBeCommitted) {
        this.#mustBeCommitted = false;
        this.commit();
        this.parent.setSelected(this);
        if (focus && this.isOnScreen) {
          this.div.focus();
        }
      }
    }
    remove() {
      this.#cleanDrawLayer();
      super.remove();
    }
    rebuild() {
      if (!this.parent) {
        return;
      }
      super.rebuild();
      if (this.div === null) {
        return;
      }
      this.#addToDrawLayer();
      this.#updateBbox(this.#drawOutlines.box);
      if (!this.isAttachedToDOM) {
        this.parent.add(this);
      }
    }
    setParent(parent) {
      let mustBeSelected = false;
      if (this.parent && !parent) {
        this._uiManager.removeShouldRescale(this);
        this.#cleanDrawLayer();
      } else if (parent) {
        this._uiManager.addShouldRescale(this);
        this.#addToDrawLayer(parent);
        mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
      }
      super.setParent(parent);
      if (mustBeSelected) {
        this.select();
      }
    }
    #cleanDrawLayer() {
      if (this._drawId === null || !this.parent) {
        return;
      }
      this.parent.drawLayer.remove(this._drawId);
      this._drawId = null;
      this._drawingOptions.reset();
    }
    #addToDrawLayer(parent = this.parent) {
      if (this._drawId !== null && this.parent === parent) {
        return;
      }
      if (this._drawId !== null) {
        this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);
        return;
      }
      this._drawingOptions.updateAll();
      this._drawId = this.#createDrawing(this.#drawOutlines, parent);
    }
    #convertToParentSpace([x, y, width, height]) {
      const {
        parentDimensions: [pW, pH],
        rotation
      } = this;
      switch (rotation) {
        case 90:
          return [y, 1 - x, width * (pH / pW), height * (pW / pH)];
        case 180:
          return [1 - x, 1 - y, width, height];
        case 270:
          return [1 - y, x, width * (pH / pW), height * (pW / pH)];
        default:
          return [x, y, width, height];
      }
    }
    #convertToDrawSpace() {
      const {
        x,
        y,
        width,
        height,
        parentDimensions: [pW, pH],
        rotation
      } = this;
      switch (rotation) {
        case 90:
          return [1 - y, x, width * (pW / pH), height * (pH / pW)];
        case 180:
          return [1 - x, 1 - y, width, height];
        case 270:
          return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
        default:
          return [x, y, width, height];
      }
    }
    #updateBbox(bbox) {
      [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);
      if (this.div) {
        this.fixAndSetPosition();
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(this.width * parentWidth, this.height * parentHeight);
      }
      this._onResized();
    }
    #rotateBox() {
      const {
        x,
        y,
        width,
        height,
        rotation,
        parentRotation,
        parentDimensions: [pW, pH]
      } = this;
      switch ((rotation * 4 + parentRotation) / 90) {
        case 1:
          return [1 - y - height, x, height, width];
        case 2:
          return [1 - x - width, 1 - y - height, width, height];
        case 3:
          return [y, 1 - x - width, height, width];
        case 4:
          return [x, y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
        case 5:
          return [1 - y, x, width * (pW / pH), height * (pH / pW)];
        case 6:
          return [1 - x - height * (pH / pW), 1 - y, height * (pH / pW), width * (pW / pH)];
        case 7:
          return [y - width * (pW / pH), 1 - x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
        case 8:
          return [x - width, y - height, width, height];
        case 9:
          return [1 - y, x - width, height, width];
        case 10:
          return [1 - x, 1 - y, width, height];
        case 11:
          return [y - height, 1 - x, height, width];
        case 12:
          return [x - height * (pH / pW), y, height * (pH / pW), width * (pW / pH)];
        case 13:
          return [1 - y - width * (pW / pH), x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
        case 14:
          return [1 - x, 1 - y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
        case 15:
          return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
        default:
          return [x, y, width, height];
      }
    }
    rotate() {
      if (!this.parent) {
        return;
      }
      this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({
        bbox: this.#rotateBox()
      }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));
    }
    onScaleChanging() {
      if (!this.parent) {
        return;
      }
      this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));
    }
    static onScaleChangingWhenDrawing() {
    }
    render() {
      if (this.div) {
        return this.div;
      }
      let baseX, baseY;
      if (this._isCopy) {
        baseX = this.x;
        baseY = this.y;
      }
      const div = super.render();
      div.classList.add("draw");
      const drawDiv = document.createElement("div");
      div.append(drawDiv);
      drawDiv.setAttribute("aria-hidden", "true");
      drawDiv.className = "internal";
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setDims(this.width * parentWidth, this.height * parentHeight);
      this._uiManager.addShouldRescale(this);
      this.disableEditing();
      if (this._isCopy) {
        this._moveAfterPaste(baseX, baseY);
      }
      return div;
    }
    static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {
      unreachable("Not implemented");
    }
    static startDrawing(parent, uiManager, _isLTR, event) {
      const {
        target,
        offsetX: x,
        offsetY: y,
        pointerId,
        pointerType
      } = event;
      if (DrawingEditor.#currentPointerType && DrawingEditor.#currentPointerType !== pointerType) {
        return;
      }
      const {
        viewport: {
          rotation
        }
      } = parent;
      const {
        width: parentWidth,
        height: parentHeight
      } = target.getBoundingClientRect();
      const ac = DrawingEditor.#currentDrawingAC = new AbortController();
      const signal = parent.combinedSignal(ac);
      DrawingEditor.#currentPointerId ||= pointerId;
      DrawingEditor.#currentPointerType ??= pointerType;
      window.addEventListener("pointerup", (e) => {
        if (DrawingEditor.#currentPointerId === e.pointerId) {
          this._endDraw(e);
        } else {
          DrawingEditor.#currentPointerIds?.delete(e.pointerId);
        }
      }, {
        signal
      });
      window.addEventListener("pointercancel", (e) => {
        if (DrawingEditor.#currentPointerId === e.pointerId) {
          this._currentParent.endDrawingSession();
        } else {
          DrawingEditor.#currentPointerIds?.delete(e.pointerId);
        }
      }, {
        signal
      });
      window.addEventListener("pointerdown", (e) => {
        if (DrawingEditor.#currentPointerType !== e.pointerType) {
          return;
        }
        (DrawingEditor.#currentPointerIds ||= /* @__PURE__ */ new Set()).add(e.pointerId);
        if (DrawingEditor.#currentDraw.isCancellable()) {
          DrawingEditor.#currentDraw.removeLastElement();
          if (DrawingEditor.#currentDraw.isEmpty()) {
            this._currentParent.endDrawingSession(true);
          } else {
            this._endDraw(null);
          }
        }
      }, {
        capture: true,
        passive: false,
        signal
      });
      window.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      target.addEventListener("pointermove", this._drawMove.bind(this), {
        signal
      });
      target.addEventListener("touchmove", (e) => {
        if (e.timeStamp === DrawingEditor.#currentMoveTimestamp) {
          stopEvent(e);
        }
      }, {
        signal
      });
      parent.toggleDrawing();
      uiManager._editorUndoBar?.hide();
      if (DrawingEditor.#currentDraw) {
        parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));
        return;
      }
      uiManager.updateUIForDefaultProperties(this);
      DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);
      DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();
      this._currentParent = parent;
      ({
        id: this._currentDrawId
      } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));
    }
    static _drawMove(event) {
      DrawingEditor.#currentMoveTimestamp = -1;
      if (!DrawingEditor.#currentDraw) {
        return;
      }
      const {
        offsetX,
        offsetY,
        pointerId
      } = event;
      if (DrawingEditor.#currentPointerId !== pointerId) {
        return;
      }
      if (DrawingEditor.#currentPointerIds?.size >= 1) {
        this._endDraw(event);
        return;
      }
      this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));
      DrawingEditor.#currentMoveTimestamp = event.timeStamp;
      stopEvent(event);
    }
    static _cleanup(all) {
      if (all) {
        this._currentDrawId = -1;
        this._currentParent = null;
        DrawingEditor.#currentDraw = null;
        DrawingEditor.#currentDrawingOptions = null;
        DrawingEditor.#currentPointerType = null;
        DrawingEditor.#currentMoveTimestamp = NaN;
      }
      if (DrawingEditor.#currentDrawingAC) {
        DrawingEditor.#currentDrawingAC.abort();
        DrawingEditor.#currentDrawingAC = null;
        DrawingEditor.#currentPointerId = NaN;
        DrawingEditor.#currentPointerIds = null;
      }
    }
    static _endDraw(event) {
      const parent = this._currentParent;
      if (!parent) {
        return;
      }
      parent.toggleDrawing(true);
      this._cleanup(false);
      if (event?.target === parent.div) {
        parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));
      }
      if (this.supportMultipleDrawings) {
        const draw = DrawingEditor.#currentDraw;
        const drawId = this._currentDrawId;
        const lastElement = draw.getLastElement();
        parent.addCommands({
          cmd: () => {
            parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));
          },
          undo: () => {
            parent.drawLayer.updateProperties(drawId, draw.removeLastElement());
          },
          mustExec: false,
          type: AnnotationEditorParamsType.DRAW_STEP
        });
        return;
      }
      this.endDrawing(false);
    }
    static endDrawing(isAborted) {
      const parent = this._currentParent;
      if (!parent) {
        return null;
      }
      parent.toggleDrawing(true);
      parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);
      if (!DrawingEditor.#currentDraw.isEmpty()) {
        const {
          pageDimensions: [pageWidth, pageHeight],
          scale
        } = parent;
        const editor = parent.createAndAddNewEditor({
          offsetX: 0,
          offsetY: 0
        }, false, {
          drawId: this._currentDrawId,
          drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),
          drawingOptions: DrawingEditor.#currentDrawingOptions,
          mustBeCommitted: !isAborted
        });
        this._cleanup(true);
        return editor;
      }
      parent.drawLayer.remove(this._currentDrawId);
      this._cleanup(true);
      return null;
    }
    createDrawingOptions(_data) {
    }
    static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {
      unreachable("Not implemented");
    }
    static async deserialize(data, parent, uiManager) {
      const {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      } = parent.viewport;
      const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);
      const editor = await super.deserialize(data, parent, uiManager);
      editor.createDrawingOptions(data);
      editor.#createDrawOutlines({
        drawOutlines
      });
      editor.#addToDrawLayer();
      editor.onScaleChanging();
      editor.rotate();
      return editor;
    }
    serializeDraw(isForCopying) {
      const [pageX, pageY] = this.pageTranslation;
      const [pageWidth, pageHeight] = this.pageDimensions;
      return this.#drawOutlines.serialize([pageX, pageY, pageWidth, pageHeight], isForCopying);
    }
    renderAnnotationElement(annotation) {
      annotation.updateEdited({
        rect: this.getPDFRect()
      });
      return null;
    }
    static canCreateNewEmptyEditor() {
      return false;
    }
  }
  class InkDrawOutliner {
    #last = new Float64Array(6);
    #line;
    #lines;
    #rotation;
    #thickness;
    #points;
    #lastSVGPath = "";
    #lastIndex = 0;
    #outlines = new InkDrawOutline();
    #parentWidth;
    #parentHeight;
    constructor(x, y, parentWidth, parentHeight, rotation, thickness) {
      this.#parentWidth = parentWidth;
      this.#parentHeight = parentHeight;
      this.#rotation = rotation;
      this.#thickness = thickness;
      [x, y] = this.#normalizePoint(x, y);
      const line = this.#line = [NaN, NaN, NaN, NaN, x, y];
      this.#points = [x, y];
      this.#lines = [{
        line,
        points: this.#points
      }];
      this.#last.set(line, 0);
    }
    updateProperty(name, value) {
      if (name === "stroke-width") {
        this.#thickness = value;
      }
    }
    #normalizePoint(x, y) {
      return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);
    }
    isEmpty() {
      return !this.#lines || this.#lines.length === 0;
    }
    isCancellable() {
      return this.#points.length <= 10;
    }
    add(x, y) {
      [x, y] = this.#normalizePoint(x, y);
      const [x1, y1, x2, y2] = this.#last.subarray(2, 6);
      const diffX = x - x2;
      const diffY = y - y2;
      const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);
      if (d <= 2) {
        return null;
      }
      this.#points.push(x, y);
      if (isNaN(x1)) {
        this.#last.set([x2, y2, x, y], 2);
        this.#line.push(NaN, NaN, NaN, NaN, x, y);
        return {
          path: {
            d: this.toSVGPath()
          }
        };
      }
      if (isNaN(this.#last[0])) {
        this.#line.splice(6, 6);
      }
      this.#last.set([x1, y1, x2, y2, x, y], 0);
      this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    end(x, y) {
      const change = this.add(x, y);
      if (change) {
        return change;
      }
      if (this.#points.length === 2) {
        return {
          path: {
            d: this.toSVGPath()
          }
        };
      }
      return null;
    }
    startNew(x, y, parentWidth, parentHeight, rotation) {
      this.#parentWidth = parentWidth;
      this.#parentHeight = parentHeight;
      this.#rotation = rotation;
      [x, y] = this.#normalizePoint(x, y);
      const line = this.#line = [NaN, NaN, NaN, NaN, x, y];
      this.#points = [x, y];
      const last = this.#lines.at(-1);
      if (last) {
        last.line = new Float32Array(last.line);
        last.points = new Float32Array(last.points);
      }
      this.#lines.push({
        line,
        points: this.#points
      });
      this.#last.set(line, 0);
      this.#lastIndex = 0;
      this.toSVGPath();
      return null;
    }
    getLastElement() {
      return this.#lines.at(-1);
    }
    setLastElement(element) {
      if (!this.#lines) {
        return this.#outlines.setLastElement(element);
      }
      this.#lines.push(element);
      this.#line = element.line;
      this.#points = element.points;
      this.#lastIndex = 0;
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    removeLastElement() {
      if (!this.#lines) {
        return this.#outlines.removeLastElement();
      }
      this.#lines.pop();
      this.#lastSVGPath = "";
      for (let i = 0, ii = this.#lines.length; i < ii; i++) {
        const {
          line,
          points
        } = this.#lines[i];
        this.#line = line;
        this.#points = points;
        this.#lastIndex = 0;
        this.toSVGPath();
      }
      return {
        path: {
          d: this.#lastSVGPath
        }
      };
    }
    toSVGPath() {
      const firstX = Outline.svgRound(this.#line[4]);
      const firstY = Outline.svgRound(this.#line[5]);
      if (this.#points.length === 2) {
        this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;
        return this.#lastSVGPath;
      }
      if (this.#points.length <= 6) {
        const i = this.#lastSVGPath.lastIndexOf("M");
        this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;
        this.#lastIndex = 6;
      }
      if (this.#points.length === 4) {
        const secondX = Outline.svgRound(this.#line[10]);
        const secondY = Outline.svgRound(this.#line[11]);
        this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;
        this.#lastIndex = 12;
        return this.#lastSVGPath;
      }
      const buffer = [];
      if (this.#lastIndex === 0) {
        buffer.push(`M ${firstX} ${firstY}`);
        this.#lastIndex = 6;
      }
      for (let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6) {
        const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);
        buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
      }
      this.#lastSVGPath += buffer.join(" ");
      this.#lastIndex = this.#line.length;
      return this.#lastSVGPath;
    }
    getOutlines(parentWidth, parentHeight, scale, innerMargin) {
      const last = this.#lines.at(-1);
      last.line = new Float32Array(last.line);
      last.points = new Float32Array(last.points);
      this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);
      this.#last = null;
      this.#line = null;
      this.#lines = null;
      this.#lastSVGPath = null;
      return this.#outlines;
    }
    get defaultSVGProperties() {
      return {
        root: {
          viewBox: "0 0 10000 10000"
        },
        rootClass: {
          draw: true
        },
        bbox: [0, 0, 1, 1]
      };
    }
  }
  class InkDrawOutline extends Outline {
    #bbox;
    #currentRotation = 0;
    #innerMargin;
    #lines;
    #parentWidth;
    #parentHeight;
    #parentScale;
    #rotation;
    #thickness;
    build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {
      this.#parentWidth = parentWidth;
      this.#parentHeight = parentHeight;
      this.#parentScale = parentScale;
      this.#rotation = rotation;
      this.#thickness = thickness;
      this.#innerMargin = innerMargin ?? 0;
      this.#lines = lines;
      this.#computeBbox();
    }
    get thickness() {
      return this.#thickness;
    }
    setLastElement(element) {
      this.#lines.push(element);
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    removeLastElement() {
      this.#lines.pop();
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    toSVGPath() {
      const buffer = [];
      for (const {
        line
      } of this.#lines) {
        buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);
        if (line.length === 6) {
          buffer.push("Z");
          continue;
        }
        if (line.length === 12 && isNaN(line[6])) {
          buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);
          continue;
        }
        for (let i = 6, ii = line.length; i < ii; i += 6) {
          const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);
          buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
        }
      }
      return buffer.join("");
    }
    serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {
      const serializedLines = [];
      const serializedPoints = [];
      const [x, y, width, height] = this.#getBBoxWithNoMargin();
      let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;
      switch (this.#rotation) {
        case 0:
          rescaleFn = Outline._rescale;
          tx = pageX;
          ty = pageY + pageHeight;
          sx = pageWidth;
          sy = -pageHeight;
          x1 = pageX + x * pageWidth;
          y1 = pageY + (1 - y - height) * pageHeight;
          x2 = pageX + (x + width) * pageWidth;
          y2 = pageY + (1 - y) * pageHeight;
          break;
        case 90:
          rescaleFn = Outline._rescaleAndSwap;
          tx = pageX;
          ty = pageY;
          sx = pageWidth;
          sy = pageHeight;
          x1 = pageX + y * pageWidth;
          y1 = pageY + x * pageHeight;
          x2 = pageX + (y + height) * pageWidth;
          y2 = pageY + (x + width) * pageHeight;
          break;
        case 180:
          rescaleFn = Outline._rescale;
          tx = pageX + pageWidth;
          ty = pageY;
          sx = -pageWidth;
          sy = pageHeight;
          x1 = pageX + (1 - x - width) * pageWidth;
          y1 = pageY + y * pageHeight;
          x2 = pageX + (1 - x) * pageWidth;
          y2 = pageY + (y + height) * pageHeight;
          break;
        case 270:
          rescaleFn = Outline._rescaleAndSwap;
          tx = pageX + pageWidth;
          ty = pageY + pageHeight;
          sx = -pageWidth;
          sy = -pageHeight;
          x1 = pageX + (1 - y - height) * pageWidth;
          y1 = pageY + (1 - x - width) * pageHeight;
          x2 = pageX + (1 - y) * pageWidth;
          y2 = pageY + (1 - x) * pageHeight;
          break;
      }
      for (const {
        line,
        points
      } of this.#lines) {
        serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));
        serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));
      }
      return {
        lines: serializedLines,
        points: serializedPoints,
        rect: [x1, y1, x2, y2]
      };
    }
    static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, {
      paths: {
        lines,
        points
      },
      rotation,
      thickness
    }) {
      const newLines = [];
      let tx, ty, sx, sy, rescaleFn;
      switch (rotation) {
        case 0:
          rescaleFn = Outline._rescale;
          tx = -pageX / pageWidth;
          ty = pageY / pageHeight + 1;
          sx = 1 / pageWidth;
          sy = -1 / pageHeight;
          break;
        case 90:
          rescaleFn = Outline._rescaleAndSwap;
          tx = -pageY / pageHeight;
          ty = -pageX / pageWidth;
          sx = 1 / pageHeight;
          sy = 1 / pageWidth;
          break;
        case 180:
          rescaleFn = Outline._rescale;
          tx = pageX / pageWidth + 1;
          ty = -pageY / pageHeight;
          sx = -1 / pageWidth;
          sy = 1 / pageHeight;
          break;
        case 270:
          rescaleFn = Outline._rescaleAndSwap;
          tx = pageY / pageHeight + 1;
          ty = pageX / pageWidth + 1;
          sx = -1 / pageHeight;
          sy = -1 / pageWidth;
          break;
      }
      if (!lines) {
        lines = [];
        for (const point of points) {
          const len = point.length;
          if (len === 2) {
            lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1]]));
            continue;
          }
          if (len === 4) {
            lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1], NaN, NaN, NaN, NaN, point[2], point[3]]));
            continue;
          }
          const line = new Float32Array(3 * (len - 2));
          lines.push(line);
          let [x1, y1, x2, y2] = point.subarray(0, 4);
          line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
          for (let i = 4; i < len; i += 2) {
            const x = point[i];
            const y = point[i + 1];
            line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
            [x1, y1, x2, y2] = [x2, y2, x, y];
          }
        }
      }
      for (let i = 0, ii = lines.length; i < ii; i++) {
        newLines.push({
          line: rescaleFn(lines[i].map((x) => x ?? NaN), tx, ty, sx, sy),
          points: rescaleFn(points[i].map((x) => x ?? NaN), tx, ty, sx, sy)
        });
      }
      const outlines = new this.prototype.constructor();
      outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);
      return outlines;
    }
    #getMarginComponents(thickness = this.#thickness) {
      const margin = this.#innerMargin + thickness / 2 * this.#parentScale;
      return this.#rotation % 180 === 0 ? [margin / this.#parentWidth, margin / this.#parentHeight] : [margin / this.#parentHeight, margin / this.#parentWidth];
    }
    #getBBoxWithNoMargin() {
      const [x, y, width, height] = this.#bbox;
      const [marginX, marginY] = this.#getMarginComponents(0);
      return [x + marginX, y + marginY, width - 2 * marginX, height - 2 * marginY];
    }
    #computeBbox() {
      const bbox = this.#bbox = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
      for (const {
        line
      } of this.#lines) {
        if (line.length <= 12) {
          for (let i = 4, ii = line.length; i < ii; i += 6) {
            Util.pointBoundingBox(line[i], line[i + 1], bbox);
          }
          continue;
        }
        let lastX = line[4], lastY = line[5];
        for (let i = 6, ii = line.length; i < ii; i += 6) {
          const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);
          Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);
          lastX = x;
          lastY = y;
        }
      }
      const [marginX, marginY] = this.#getMarginComponents();
      bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);
      bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);
      bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);
      bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);
      bbox[2] -= bbox[0];
      bbox[3] -= bbox[1];
    }
    get box() {
      return this.#bbox;
    }
    updateProperty(name, value) {
      if (name === "stroke-width") {
        return this.#updateThickness(value);
      }
      return null;
    }
    #updateThickness(thickness) {
      const [oldMarginX, oldMarginY] = this.#getMarginComponents();
      this.#thickness = thickness;
      const [newMarginX, newMarginY] = this.#getMarginComponents();
      const [diffMarginX, diffMarginY] = [newMarginX - oldMarginX, newMarginY - oldMarginY];
      const bbox = this.#bbox;
      bbox[0] -= diffMarginX;
      bbox[1] -= diffMarginY;
      bbox[2] += 2 * diffMarginX;
      bbox[3] += 2 * diffMarginY;
      return bbox;
    }
    updateParentDimensions([width, height], scale) {
      const [oldMarginX, oldMarginY] = this.#getMarginComponents();
      this.#parentWidth = width;
      this.#parentHeight = height;
      this.#parentScale = scale;
      const [newMarginX, newMarginY] = this.#getMarginComponents();
      const diffMarginX = newMarginX - oldMarginX;
      const diffMarginY = newMarginY - oldMarginY;
      const bbox = this.#bbox;
      bbox[0] -= diffMarginX;
      bbox[1] -= diffMarginY;
      bbox[2] += 2 * diffMarginX;
      bbox[3] += 2 * diffMarginY;
      return bbox;
    }
    updateRotation(rotation) {
      this.#currentRotation = rotation;
      return {
        path: {
          transform: this.rotationTransform
        }
      };
    }
    get viewBox() {
      return this.#bbox.map(Outline.svgRound).join(" ");
    }
    get defaultProperties() {
      const [x, y] = this.#bbox;
      return {
        root: {
          viewBox: this.viewBox
        },
        path: {
          "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`
        }
      };
    }
    get rotationTransform() {
      const [, , width, height] = this.#bbox;
      let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;
      switch (this.#currentRotation) {
        case 90:
          b = height / width;
          c = -width / height;
          e = width;
          break;
        case 180:
          a = -1;
          d = -1;
          e = width;
          f = height;
          break;
        case 270:
          b = -height / width;
          c = width / height;
          f = height;
          break;
        default:
          return "";
      }
      return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;
    }
    getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {
      const [marginX, marginY] = this.#getMarginComponents();
      const [x, y, width, height] = this.#bbox;
      if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
        const tx = newX + newWidth / 2 - (x + width / 2);
        const ty = newY + newHeight / 2 - (y + height / 2);
        return {
          path: {
            "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
            transform: `${this.rotationTransform} translate(${tx} ${ty})`
          }
        };
      }
      const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
      const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
      const s2x = width / newWidth;
      const s2y = height / newHeight;
      return {
        path: {
          "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,
          transform: `${this.rotationTransform} scale(${s2x} ${s2y}) translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`
        }
      };
    }
    getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {
      const [marginX, marginY] = this.#getMarginComponents();
      const bbox = this.#bbox;
      const [x, y, width, height] = bbox;
      bbox[0] = newX;
      bbox[1] = newY;
      bbox[2] = newWidth;
      bbox[3] = newHeight;
      if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
        const tx2 = newX + newWidth / 2 - (x + width / 2);
        const ty2 = newY + newHeight / 2 - (y + height / 2);
        for (const {
          line,
          points
        } of this.#lines) {
          Outline._translate(line, tx2, ty2, line);
          Outline._translate(points, tx2, ty2, points);
        }
        return {
          root: {
            viewBox: this.viewBox
          },
          path: {
            "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
            transform: this.rotationTransform || null,
            d: this.toSVGPath()
          }
        };
      }
      const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
      const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
      const tx = -s1x * (x + marginX) + newX + marginX;
      const ty = -s1y * (y + marginY) + newY + marginY;
      if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {
        for (const {
          line,
          points
        } of this.#lines) {
          Outline._rescale(line, tx, ty, s1x, s1y, line);
          Outline._rescale(points, tx, ty, s1x, s1y, points);
        }
      }
      return {
        root: {
          viewBox: this.viewBox
        },
        path: {
          "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
          transform: this.rotationTransform || null,
          d: this.toSVGPath()
        }
      };
    }
    getPathTranslatedSVGProperties([newX, newY], parentDimensions) {
      const [newParentWidth, newParentHeight] = parentDimensions;
      const bbox = this.#bbox;
      const tx = newX - bbox[0];
      const ty = newY - bbox[1];
      if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {
        for (const {
          line,
          points
        } of this.#lines) {
          Outline._translate(line, tx, ty, line);
          Outline._translate(points, tx, ty, points);
        }
      } else {
        const sx = this.#parentWidth / newParentWidth;
        const sy = this.#parentHeight / newParentHeight;
        this.#parentWidth = newParentWidth;
        this.#parentHeight = newParentHeight;
        for (const {
          line,
          points
        } of this.#lines) {
          Outline._rescale(line, tx, ty, sx, sy, line);
          Outline._rescale(points, tx, ty, sx, sy, points);
        }
        bbox[2] *= sx;
        bbox[3] *= sy;
      }
      bbox[0] = newX;
      bbox[1] = newY;
      return {
        root: {
          viewBox: this.viewBox
        },
        path: {
          d: this.toSVGPath(),
          "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`
        }
      };
    }
    get defaultSVGProperties() {
      const bbox = this.#bbox;
      return {
        root: {
          viewBox: this.viewBox
        },
        rootClass: {
          draw: true
        },
        path: {
          d: this.toSVGPath(),
          "transform-origin": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,
          transform: this.rotationTransform || null
        },
        bbox
      };
    }
  }
  class InkDrawingOptions extends DrawingOptions {
    constructor(viewerParameters) {
      super();
      this._viewParameters = viewerParameters;
      super.updateProperties({
        fill: "none",
        stroke: AnnotationEditor._defaultLineColor,
        "stroke-opacity": 1,
        "stroke-width": 1,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-miterlimit": 10
      });
    }
    updateSVGProperty(name, value) {
      if (name === "stroke-width") {
        value ??= this["stroke-width"];
        value *= this._viewParameters.realScale;
      }
      super.updateSVGProperty(name, value);
    }
    clone() {
      const clone = new InkDrawingOptions(this._viewParameters);
      clone.updateAll(this);
      return clone;
    }
  }
  class InkEditor extends DrawingEditor {
    static _type = "ink";
    static _editorType = AnnotationEditorType.INK;
    static _defaultDrawingOptions = null;
    constructor(params) {
      super({
        ...params,
        name: "inkEditor"
      });
      this._willKeepAspectRatio = true;
      this.defaultL10nId = "pdfjs-editor-ink-editor";
    }
    static initialize(l10n, uiManager) {
      AnnotationEditor.initialize(l10n, uiManager);
      this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);
    }
    static getDefaultDrawingOptions(options) {
      const clone = this._defaultDrawingOptions.clone();
      clone.updateProperties(options);
      return clone;
    }
    static get supportMultipleDrawings() {
      return true;
    }
    static get typesMap() {
      return shadow(this, "typesMap", /* @__PURE__ */ new Map([[AnnotationEditorParamsType.INK_THICKNESS, "stroke-width"], [AnnotationEditorParamsType.INK_COLOR, "stroke"], [AnnotationEditorParamsType.INK_OPACITY, "stroke-opacity"]]));
    }
    static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {
      return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions["stroke-width"]);
    }
    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
      return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
    }
    static async deserialize(data, parent, uiManager) {
      let initialData = null;
      if (data instanceof InkAnnotationElement) {
        const {
          data: {
            inkLists,
            rect,
            rotation,
            id,
            color,
            opacity,
            borderStyle: {
              rawWidth: thickness
            },
            popupRef,
            contentsObj
          },
          parent: {
            page: {
              pageNumber
            }
          }
        } = data;
        initialData = data = {
          annotationType: AnnotationEditorType.INK,
          color: Array.from(color),
          thickness,
          opacity,
          paths: {
            points: inkLists
          },
          boxes: null,
          pageIndex: pageNumber - 1,
          rect: rect.slice(0),
          rotation,
          annotationElementId: id,
          id,
          deleted: false,
          popupRef,
          comment: contentsObj?.str || null
        };
      }
      const editor = await super.deserialize(data, parent, uiManager);
      editor._initialData = initialData;
      if (data.comment) {
        editor.setCommentData(data.comment);
      }
      return editor;
    }
    get toolbarButtons() {
      this._colorPicker ||= new BasicColorPicker(this);
      return [["colorPicker", this._colorPicker]];
    }
    get colorType() {
      return AnnotationEditorParamsType.INK_COLOR;
    }
    get colorValue() {
      return this._drawingOptions.stroke;
    }
    onScaleChanging() {
      if (!this.parent) {
        return;
      }
      super.onScaleChanging();
      const {
        _drawId,
        _drawingOptions,
        parent
      } = this;
      _drawingOptions.updateSVGProperty("stroke-width");
      parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());
    }
    static onScaleChangingWhenDrawing() {
      const parent = this._currentParent;
      if (!parent) {
        return;
      }
      super.onScaleChangingWhenDrawing();
      this._defaultDrawingOptions.updateSVGProperty("stroke-width");
      parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
    }
    createDrawingOptions({
      color,
      thickness,
      opacity
    }) {
      this._drawingOptions = InkEditor.getDefaultDrawingOptions({
        stroke: Util.makeHexColor(...color),
        "stroke-width": thickness,
        "stroke-opacity": opacity
      });
    }
    serialize(isForCopying = false) {
      if (this.isEmpty()) {
        return null;
      }
      if (this.deleted) {
        return this.serializeDeleted();
      }
      const {
        lines,
        points,
        rect
      } = this.serializeDraw(isForCopying);
      const {
        _drawingOptions: {
          stroke,
          "stroke-opacity": opacity,
          "stroke-width": thickness
        }
      } = this;
      const serialized = {
        annotationType: AnnotationEditorType.INK,
        color: AnnotationEditor._colorManager.convert(stroke),
        opacity,
        thickness,
        paths: {
          lines,
          points
        },
        pageIndex: this.pageIndex,
        rect,
        rotation: this.rotation,
        structTreeParentId: this._structTreeParentId
      };
      this.addComment(serialized);
      if (isForCopying) {
        serialized.isCopy = true;
        return serialized;
      }
      if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
        return null;
      }
      serialized.id = this.annotationElementId;
      return serialized;
    }
    #hasElementChanged(serialized) {
      const {
        color,
        thickness,
        opacity,
        pageIndex
      } = this._initialData;
      return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i) => c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;
    }
    renderAnnotationElement(annotation) {
      if (this.deleted) {
        annotation.hide();
        return null;
      }
      const {
        points,
        rect
      } = this.serializeDraw(false);
      const params = {
        rect,
        thickness: this._drawingOptions["stroke-width"],
        points
      };
      if (this.hasEditedComment) {
        params.popup = this.comment;
      }
      annotation.updateEdited(params);
      return null;
    }
  }
  class ContourDrawOutline extends InkDrawOutline {
    toSVGPath() {
      let path = super.toSVGPath();
      if (!path.endsWith("Z")) {
        path += "Z";
      }
      return path;
    }
  }
  const BASE_HEADER_LENGTH = 8;
  const POINTS_PROPERTIES_NUMBER = 3;
  class SignatureExtractor {
    static #PARAMETERS = {
      maxDim: 512,
      sigmaSFactor: 0.02,
      sigmaR: 25,
      kernelSize: 16
    };
    static #neighborIndexToId(i0, j0, i, j) {
      i -= i0;
      j -= j0;
      if (i === 0) {
        return j > 0 ? 0 : 4;
      }
      if (i === 1) {
        return j + 6;
      }
      return 2 - j;
    }
    static #neighborIdToIndex = new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]);
    static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {
      const id = this.#neighborIndexToId(i0, j0, i, j);
      for (let k = 0; k < 8; k++) {
        const kk = (-k + id - offset + 16) % 8;
        const shiftI = this.#neighborIdToIndex[2 * kk];
        const shiftJ = this.#neighborIdToIndex[2 * kk + 1];
        if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
          return kk;
        }
      }
      return -1;
    }
    static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {
      const id = this.#neighborIndexToId(i0, j0, i, j);
      for (let k = 0; k < 8; k++) {
        const kk = (k + id + offset + 16) % 8;
        const shiftI = this.#neighborIdToIndex[2 * kk];
        const shiftJ = this.#neighborIdToIndex[2 * kk + 1];
        if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
          return kk;
        }
      }
      return -1;
    }
    static #findContours(buf, width, height, threshold) {
      const N = buf.length;
      const types = new Int32Array(N);
      for (let i = 0; i < N; i++) {
        types[i] = buf[i] <= threshold ? 1 : 0;
      }
      for (let i = 1; i < height - 1; i++) {
        types[i * width] = types[i * width + width - 1] = 0;
      }
      for (let i = 0; i < width; i++) {
        types[i] = types[width * height - 1 - i] = 0;
      }
      let nbd = 1;
      let lnbd;
      const contours = [];
      for (let i = 1; i < height - 1; i++) {
        lnbd = 1;
        for (let j = 1; j < width - 1; j++) {
          const ij = i * width + j;
          const pix = types[ij];
          if (pix === 0) {
            continue;
          }
          let i2 = i;
          let j2 = j;
          if (pix === 1 && types[ij - 1] === 0) {
            nbd += 1;
            j2 -= 1;
          } else if (pix >= 1 && types[ij + 1] === 0) {
            nbd += 1;
            j2 += 1;
            if (pix > 1) {
              lnbd = pix;
            }
          } else {
            if (pix !== 1) {
              lnbd = Math.abs(pix);
            }
            continue;
          }
          const points = [j, i];
          const isHole = j2 === j + 1;
          const contour = {
            isHole,
            points,
            id: nbd,
            parent: 0
          };
          contours.push(contour);
          let contour0;
          for (const c of contours) {
            if (c.id === lnbd) {
              contour0 = c;
              break;
            }
          }
          if (!contour0) {
            contour.parent = isHole ? lnbd : 0;
          } else if (contour0.isHole) {
            contour.parent = isHole ? contour0.parent : lnbd;
          } else {
            contour.parent = isHole ? lnbd : contour0.parent;
          }
          const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);
          if (k === -1) {
            types[ij] = -nbd;
            if (types[ij] !== 1) {
              lnbd = Math.abs(types[ij]);
            }
            continue;
          }
          let shiftI = this.#neighborIdToIndex[2 * k];
          let shiftJ = this.#neighborIdToIndex[2 * k + 1];
          const i1 = i + shiftI;
          const j1 = j + shiftJ;
          i2 = i1;
          j2 = j1;
          let i3 = i;
          let j3 = j;
          while (true) {
            const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);
            shiftI = this.#neighborIdToIndex[2 * kk];
            shiftJ = this.#neighborIdToIndex[2 * kk + 1];
            const i4 = i3 + shiftI;
            const j4 = j3 + shiftJ;
            points.push(j4, i4);
            const ij3 = i3 * width + j3;
            if (types[ij3 + 1] === 0) {
              types[ij3] = -nbd;
            } else if (types[ij3] === 1) {
              types[ij3] = nbd;
            }
            if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {
              if (types[ij] !== 1) {
                lnbd = Math.abs(types[ij]);
              }
              break;
            } else {
              i2 = i3;
              j2 = j3;
              i3 = i4;
              j3 = j4;
            }
          }
        }
      }
      return contours;
    }
    static #douglasPeuckerHelper(points, start, end, output) {
      if (end - start <= 4) {
        for (let i = start; i < end - 2; i += 2) {
          output.push(points[i], points[i + 1]);
        }
        return;
      }
      const ax = points[start];
      const ay = points[start + 1];
      const abx = points[end - 4] - ax;
      const aby = points[end - 3] - ay;
      const dist = Math.hypot(abx, aby);
      const nabx = abx / dist;
      const naby = aby / dist;
      const aa = nabx * ay - naby * ax;
      const m = aby / abx;
      const invS = 1 / dist;
      const phi = Math.atan(m);
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);
      const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));
      const poly = invS * (1 - tmax + tmax ** 2);
      const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));
      let dmax = 0;
      let index = start;
      for (let i = start + 2; i < end - 2; i += 2) {
        const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);
        if (d > dmax) {
          index = i;
          dmax = d;
        }
      }
      if (dmax > (dist * partialPhi) ** 2) {
        this.#douglasPeuckerHelper(points, start, index + 2, output);
        this.#douglasPeuckerHelper(points, index, end, output);
      } else {
        output.push(ax, ay);
      }
    }
    static #douglasPeucker(points) {
      const output = [];
      const len = points.length;
      this.#douglasPeuckerHelper(points, 0, len, output);
      output.push(points[len - 2], points[len - 1]);
      return output.length <= 4 ? null : output;
    }
    static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {
      const kernel = new Float32Array(kernelSize ** 2);
      const sigmaS2 = -2 * sigmaS ** 2;
      const halfSize = kernelSize >> 1;
      for (let i = 0; i < kernelSize; i++) {
        const x = (i - halfSize) ** 2;
        for (let j = 0; j < kernelSize; j++) {
          kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);
        }
      }
      const rangeValues = new Float32Array(256);
      const sigmaR2 = -2 * sigmaR ** 2;
      for (let i = 0; i < 256; i++) {
        rangeValues[i] = Math.exp(i ** 2 / sigmaR2);
      }
      const N = buf.length;
      const out = new Uint8Array(N);
      const histogram = new Uint32Array(256);
      for (let i = 0; i < height; i++) {
        for (let j = 0; j < width; j++) {
          const ij = i * width + j;
          const center = buf[ij];
          let sum = 0;
          let norm = 0;
          for (let k = 0; k < kernelSize; k++) {
            const y = i + k - halfSize;
            if (y < 0 || y >= height) {
              continue;
            }
            for (let l = 0; l < kernelSize; l++) {
              const x = j + l - halfSize;
              if (x < 0 || x >= width) {
                continue;
              }
              const neighbour = buf[y * width + x];
              const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];
              sum += neighbour * w;
              norm += w;
            }
          }
          const pix = out[ij] = Math.round(sum / norm);
          histogram[pix]++;
        }
      }
      return [out, histogram];
    }
    static #getHistogram(buf) {
      const histogram = new Uint32Array(256);
      for (const g of buf) {
        histogram[g]++;
      }
      return histogram;
    }
    static #toUint8(buf) {
      const N = buf.length;
      const out = new Uint8ClampedArray(N >> 2);
      let max = -Infinity;
      let min = Infinity;
      for (let i = 0, ii = out.length; i < ii; i++) {
        const pix = out[i] = buf[i << 2];
        max = Math.max(max, pix);
        min = Math.min(min, pix);
      }
      const ratio = 255 / (max - min);
      for (let i = 0, ii = out.length; i < ii; i++) {
        out[i] = (out[i] - min) * ratio;
      }
      return out;
    }
    static #guessThreshold(histogram) {
      let i;
      let M = -Infinity;
      let L = -Infinity;
      const min = histogram.findIndex((v) => v !== 0);
      let pos = min;
      let spos = min;
      for (i = min; i < 256; i++) {
        const v = histogram[i];
        if (v > M) {
          if (i - pos > L) {
            L = i - pos;
            spos = i - 1;
          }
          M = v;
          pos = i;
        }
      }
      for (i = spos - 1; i >= 0; i--) {
        if (histogram[i] > histogram[i + 1]) {
          break;
        }
      }
      return i;
    }
    static #getGrayPixels(bitmap) {
      const originalBitmap = bitmap;
      const {
        width,
        height
      } = bitmap;
      const {
        maxDim
      } = this.#PARAMETERS;
      let newWidth = width;
      let newHeight = height;
      if (width > maxDim || height > maxDim) {
        let prevWidth = width;
        let prevHeight = height;
        let steps = Math.log2(Math.max(width, height) / maxDim);
        const isteps = Math.floor(steps);
        steps = steps === isteps ? isteps - 1 : isteps;
        for (let i = 0; i < steps; i++) {
          newWidth = Math.ceil(prevWidth / 2);
          newHeight = Math.ceil(prevHeight / 2);
          const offscreen2 = new OffscreenCanvas(newWidth, newHeight);
          const ctx2 = offscreen2.getContext("2d");
          ctx2.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
          prevWidth = newWidth;
          prevHeight = newHeight;
          if (bitmap !== originalBitmap) {
            bitmap.close();
          }
          bitmap = offscreen2.transferToImageBitmap();
        }
        const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);
        newWidth = Math.round(newWidth * ratio);
        newHeight = Math.round(newHeight * ratio);
      }
      const offscreen = new OffscreenCanvas(newWidth, newHeight);
      const ctx = offscreen.getContext("2d", {
        willReadFrequently: true
      });
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, newWidth, newHeight);
      ctx.filter = "grayscale(1)";
      ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);
      const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;
      const uint8Buf = this.#toUint8(grayImage);
      return [uint8Buf, newWidth, newHeight];
    }
    static extractContoursFromText(text, {
      fontFamily,
      fontStyle,
      fontWeight
    }, pageWidth, pageHeight, rotation, innerMargin) {
      let canvas = new OffscreenCanvas(1, 1);
      let ctx = canvas.getContext("2d", {
        alpha: false
      });
      const fontSize = 200;
      const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
      const {
        actualBoundingBoxLeft,
        actualBoundingBoxRight,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent,
        fontBoundingBoxAscent,
        fontBoundingBoxDescent,
        width
      } = ctx.measureText(text);
      const SCALE = 1.5;
      const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);
      const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);
      canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
      ctx = canvas.getContext("2d", {
        alpha: true,
        willReadFrequently: true
      });
      ctx.font = font;
      ctx.filter = "grayscale(1)";
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = "black";
      ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);
      const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);
      const histogram = this.#getHistogram(uint8Buf);
      const threshold = this.#guessThreshold(histogram);
      const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);
      return this.processDrawnLines({
        lines: {
          curves: contourList,
          width: canvasWidth,
          height: canvasHeight
        },
        pageWidth,
        pageHeight,
        rotation,
        innerMargin,
        mustSmooth: true,
        areContours: true
      });
    }
    static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {
      const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);
      const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);
      const threshold = this.#guessThreshold(histogram);
      const contourList = this.#findContours(buffer, width, height, threshold);
      return this.processDrawnLines({
        lines: {
          curves: contourList,
          width,
          height
        },
        pageWidth,
        pageHeight,
        rotation,
        innerMargin,
        mustSmooth: true,
        areContours: true
      });
    }
    static processDrawnLines({
      lines,
      pageWidth,
      pageHeight,
      rotation,
      innerMargin,
      mustSmooth,
      areContours
    }) {
      if (rotation % 180 !== 0) {
        [pageWidth, pageHeight] = [pageHeight, pageWidth];
      }
      const {
        curves,
        width,
        height
      } = lines;
      const thickness = lines.thickness ?? 0;
      const linesAndPoints = [];
      const ratio = Math.min(pageWidth / width, pageHeight / height);
      const xScale = ratio / pageWidth;
      const yScale = ratio / pageHeight;
      const newCurves = [];
      for (const {
        points
      } of curves) {
        const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;
        if (!reducedPoints) {
          continue;
        }
        newCurves.push(reducedPoints);
        const len = reducedPoints.length;
        const newPoints = new Float32Array(len);
        const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));
        linesAndPoints.push({
          line,
          points: newPoints
        });
        if (len === 2) {
          newPoints[0] = reducedPoints[0] * xScale;
          newPoints[1] = reducedPoints[1] * yScale;
          line.set([NaN, NaN, NaN, NaN, newPoints[0], newPoints[1]], 0);
          continue;
        }
        let [x1, y1, x2, y2] = reducedPoints;
        x1 *= xScale;
        y1 *= yScale;
        x2 *= xScale;
        y2 *= yScale;
        newPoints.set([x1, y1, x2, y2], 0);
        line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
        for (let i = 4; i < len; i += 2) {
          const x = newPoints[i] = reducedPoints[i] * xScale;
          const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;
          line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
          [x1, y1, x2, y2] = [x2, y2, x, y];
        }
      }
      if (linesAndPoints.length === 0) {
        return null;
      }
      const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();
      outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);
      return {
        outline,
        newCurves,
        areContours,
        thickness,
        width,
        height
      };
    }
    static async compressSignature({
      outlines,
      areContours,
      thickness,
      width,
      height
    }) {
      let minDiff = Infinity;
      let maxDiff = -Infinity;
      let outlinesLength = 0;
      for (const points of outlines) {
        outlinesLength += points.length;
        for (let i = 2, ii = points.length; i < ii; i++) {
          const dx = points[i] - points[i - 2];
          minDiff = Math.min(minDiff, dx);
          maxDiff = Math.max(maxDiff, dx);
        }
      }
      let bufferType;
      if (minDiff >= -128 && maxDiff <= 127) {
        bufferType = Int8Array;
      } else if (minDiff >= -32768 && maxDiff <= 32767) {
        bufferType = Int16Array;
      } else {
        bufferType = Int32Array;
      }
      const len = outlines.length;
      const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;
      const header = new Uint32Array(headerLength);
      let offset = 0;
      header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;
      header[offset++] = 0;
      header[offset++] = width;
      header[offset++] = height;
      header[offset++] = areContours ? 0 : 1;
      header[offset++] = Math.max(0, Math.floor(thickness ?? 0));
      header[offset++] = len;
      header[offset++] = bufferType.BYTES_PER_ELEMENT;
      for (const points of outlines) {
        header[offset++] = points.length - 2;
        header[offset++] = points[0];
        header[offset++] = points[1];
      }
      const cs = new CompressionStream("deflate-raw");
      const writer = cs.writable.getWriter();
      await writer.ready;
      writer.write(header);
      const BufferCtor = bufferType.prototype.constructor;
      for (const points of outlines) {
        const diffs = new BufferCtor(points.length - 2);
        for (let i = 2, ii = points.length; i < ii; i++) {
          diffs[i - 2] = points[i] - points[i - 2];
        }
        writer.write(diffs);
      }
      writer.close();
      const buf = await new Response(cs.readable).arrayBuffer();
      const bytes = new Uint8Array(buf);
      return toBase64Util(bytes);
    }
    static async decompressSignature(signatureData) {
      try {
        const bytes = fromBase64Util(signatureData);
        const {
          readable,
          writable
        } = new DecompressionStream("deflate-raw");
        const writer = writable.getWriter();
        await writer.ready;
        writer.write(bytes).then(async () => {
          await writer.ready;
          await writer.close();
        }).catch(() => {
        });
        let data = null;
        let offset = 0;
        for await (const chunk of readable) {
          data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);
          data.set(chunk, offset);
          offset += chunk.length;
        }
        const header = new Uint32Array(data.buffer, 0, data.length >> 2);
        const version2 = header[1];
        if (version2 !== 0) {
          throw new Error(`Invalid version: ${version2}`);
        }
        const width = header[2];
        const height = header[3];
        const areContours = header[4] === 0;
        const thickness = header[5];
        const numberOfDrawings = header[6];
        const bufferType = header[7];
        const outlines = [];
        const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;
        let diffs;
        switch (bufferType) {
          case Int8Array.BYTES_PER_ELEMENT:
            diffs = new Int8Array(data.buffer, diffsOffset);
            break;
          case Int16Array.BYTES_PER_ELEMENT:
            diffs = new Int16Array(data.buffer, diffsOffset);
            break;
          case Int32Array.BYTES_PER_ELEMENT:
            diffs = new Int32Array(data.buffer, diffsOffset);
            break;
        }
        offset = 0;
        for (let i = 0; i < numberOfDrawings; i++) {
          const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];
          const points = new Float32Array(len + 2);
          outlines.push(points);
          for (let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++) {
            points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];
          }
          for (let j = 0; j < len; j++) {
            points[j + 2] = points[j] + diffs[offset++];
          }
        }
        return {
          areContours,
          thickness,
          outlines,
          width,
          height
        };
      } catch (e) {
        warn(`decompressSignature: ${e}`);
        return null;
      }
    }
  }
  class SignatureOptions extends DrawingOptions {
    constructor() {
      super();
      super.updateProperties({
        fill: AnnotationEditor._defaultLineColor,
        "stroke-width": 0
      });
    }
    clone() {
      const clone = new SignatureOptions();
      clone.updateAll(this);
      return clone;
    }
  }
  class DrawnSignatureOptions extends InkDrawingOptions {
    constructor(viewerParameters) {
      super(viewerParameters);
      super.updateProperties({
        stroke: AnnotationEditor._defaultLineColor,
        "stroke-width": 1
      });
    }
    clone() {
      const clone = new DrawnSignatureOptions(this._viewParameters);
      clone.updateAll(this);
      return clone;
    }
  }
  class SignatureEditor extends DrawingEditor {
    #isExtracted = false;
    #description = null;
    #signatureData = null;
    #signatureUUID = null;
    static _type = "signature";
    static _editorType = AnnotationEditorType.SIGNATURE;
    static _defaultDrawingOptions = null;
    constructor(params) {
      super({
        ...params,
        mustBeCommitted: true,
        name: "signatureEditor"
      });
      this._willKeepAspectRatio = true;
      this.#signatureData = params.signatureData || null;
      this.#description = null;
      this.defaultL10nId = "pdfjs-editor-signature-editor1";
    }
    static initialize(l10n, uiManager) {
      AnnotationEditor.initialize(l10n, uiManager);
      this._defaultDrawingOptions = new SignatureOptions();
      this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);
    }
    static getDefaultDrawingOptions(options) {
      const clone = this._defaultDrawingOptions.clone();
      clone.updateProperties(options);
      return clone;
    }
    static get supportMultipleDrawings() {
      return false;
    }
    static get typesMap() {
      return shadow(this, "typesMap", /* @__PURE__ */ new Map());
    }
    static get isDrawer() {
      return false;
    }
    get telemetryFinalData() {
      return {
        type: "signature",
        hasDescription: !!this.#description
      };
    }
    static computeTelemetryFinalData(data) {
      const hasDescriptionStats = data.get("hasDescription");
      return {
        hasAltText: hasDescriptionStats.get(true) ?? 0,
        hasNoAltText: hasDescriptionStats.get(false) ?? 0
      };
    }
    get isResizable() {
      return true;
    }
    onScaleChanging() {
      if (this._drawId === null) {
        return;
      }
      super.onScaleChanging();
    }
    render() {
      if (this.div) {
        return this.div;
      }
      let baseX, baseY;
      const {
        _isCopy
      } = this;
      if (_isCopy) {
        this._isCopy = false;
        baseX = this.x;
        baseY = this.y;
      }
      super.render();
      if (this._drawId === null) {
        if (this.#signatureData) {
          const {
            lines,
            mustSmooth,
            areContours,
            description,
            uuid,
            heightInPage
          } = this.#signatureData;
          const {
            rawDims: {
              pageWidth,
              pageHeight
            },
            rotation
          } = this.parent.viewport;
          const outline = SignatureExtractor.processDrawnLines({
            lines,
            pageWidth,
            pageHeight,
            rotation,
            innerMargin: SignatureEditor._INNER_MARGIN,
            mustSmooth,
            areContours
          });
          this.addSignature(outline, heightInPage, description, uuid);
        } else {
          this.div.setAttribute("data-l10n-args", JSON.stringify({
            description: ""
          }));
          this.div.hidden = true;
          this._uiManager.getSignature(this);
        }
      } else {
        this.div.setAttribute("data-l10n-args", JSON.stringify({
          description: this.#description || ""
        }));
      }
      if (_isCopy) {
        this._isCopy = true;
        this._moveAfterPaste(baseX, baseY);
      }
      return this.div;
    }
    setUuid(uuid) {
      this.#signatureUUID = uuid;
      this.addEditToolbar();
    }
    getUuid() {
      return this.#signatureUUID;
    }
    get description() {
      return this.#description;
    }
    set description(description) {
      this.#description = description;
      if (!this.div) {
        return;
      }
      this.div.setAttribute("data-l10n-args", JSON.stringify({
        description
      }));
      super.addEditToolbar().then((toolbar) => {
        toolbar?.updateEditSignatureButton(description);
      });
    }
    getSignaturePreview() {
      const {
        newCurves,
        areContours,
        thickness,
        width,
        height
      } = this.#signatureData;
      const maxDim = Math.max(width, height);
      const outlineData = SignatureExtractor.processDrawnLines({
        lines: {
          curves: newCurves.map((points) => ({
            points
          })),
          thickness,
          width,
          height
        },
        pageWidth: maxDim,
        pageHeight: maxDim,
        rotation: 0,
        innerMargin: 0,
        mustSmooth: false,
        areContours
      });
      return {
        areContours,
        outline: outlineData.outline
      };
    }
    get toolbarButtons() {
      if (this._uiManager.signatureManager) {
        return [["editSignature", this._uiManager.signatureManager]];
      }
      return super.toolbarButtons;
    }
    addSignature(data, heightInPage, description, uuid) {
      const {
        x: savedX,
        y: savedY
      } = this;
      const {
        outline
      } = this.#signatureData = data;
      this.#isExtracted = outline instanceof ContourDrawOutline;
      this.description = description;
      let drawingOptions;
      if (this.#isExtracted) {
        drawingOptions = SignatureEditor.getDefaultDrawingOptions();
      } else {
        drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();
        drawingOptions.updateProperties({
          "stroke-width": outline.thickness
        });
      }
      this._addOutlines({
        drawOutlines: outline,
        drawingOptions
      });
      const [parentWidth, parentHeight] = this.parentDimensions;
      const [, pageHeight] = this.pageDimensions;
      let newHeight = heightInPage / pageHeight;
      newHeight = newHeight >= 1 ? 0.5 : newHeight;
      this.width *= newHeight / this.height;
      if (this.width >= 1) {
        newHeight *= 0.9 / this.width;
        this.width = 0.9;
      }
      this.height = newHeight;
      this.setDims(parentWidth * this.width, parentHeight * this.height);
      this.x = savedX;
      this.y = savedY;
      this.center();
      this._onResized();
      this.onScaleChanging();
      this.rotate();
      this._uiManager.addToAnnotationStorage(this);
      this.setUuid(uuid);
      this._reportTelemetry({
        action: "pdfjs.signature.inserted",
        data: {
          hasBeenSaved: !!uuid,
          hasDescription: !!description
        }
      });
      this.div.hidden = false;
    }
    getFromImage(bitmap) {
      const {
        rawDims: {
          pageWidth,
          pageHeight
        },
        rotation
      } = this.parent.viewport;
      return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);
    }
    getFromText(text, fontInfo) {
      const {
        rawDims: {
          pageWidth,
          pageHeight
        },
        rotation
      } = this.parent.viewport;
      return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);
    }
    getDrawnSignature(curves) {
      const {
        rawDims: {
          pageWidth,
          pageHeight
        },
        rotation
      } = this.parent.viewport;
      return SignatureExtractor.processDrawnLines({
        lines: curves,
        pageWidth,
        pageHeight,
        rotation,
        innerMargin: SignatureEditor._INNER_MARGIN,
        mustSmooth: false,
        areContours: false
      });
    }
    createDrawingOptions({
      areContours,
      thickness
    }) {
      if (areContours) {
        this._drawingOptions = SignatureEditor.getDefaultDrawingOptions();
      } else {
        this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();
        this._drawingOptions.updateProperties({
          "stroke-width": thickness
        });
      }
    }
    serialize(isForCopying = false) {
      if (this.isEmpty()) {
        return null;
      }
      const {
        lines,
        points,
        rect
      } = this.serializeDraw(isForCopying);
      const {
        _drawingOptions: {
          "stroke-width": thickness
        }
      } = this;
      const serialized = {
        annotationType: AnnotationEditorType.SIGNATURE,
        isSignature: true,
        areContours: this.#isExtracted,
        color: [0, 0, 0],
        thickness: this.#isExtracted ? 0 : thickness,
        pageIndex: this.pageIndex,
        rect,
        rotation: this.rotation,
        structTreeParentId: this._structTreeParentId
      };
      this.addComment(serialized);
      if (isForCopying) {
        serialized.paths = {
          lines,
          points
        };
        serialized.uuid = this.#signatureUUID;
        serialized.isCopy = true;
      } else {
        serialized.lines = lines;
      }
      if (this.#description) {
        serialized.accessibilityData = {
          type: "Figure",
          alt: this.#description
        };
      }
      return serialized;
    }
    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
      if (data.areContours) {
        return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
      }
      return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
    }
    static async deserialize(data, parent, uiManager) {
      const editor = await super.deserialize(data, parent, uiManager);
      editor.#isExtracted = data.areContours;
      editor.description = data.accessibilityData?.alt || "";
      editor.#signatureUUID = data.uuid;
      return editor;
    }
  }
  class StampEditor extends AnnotationEditor {
    #bitmap = null;
    #bitmapId = null;
    #bitmapPromise = null;
    #bitmapUrl = null;
    #bitmapFile = null;
    #bitmapFileName = "";
    #canvas = null;
    #missingCanvas = false;
    #resizeTimeoutId = null;
    #isSvg = false;
    #hasBeenAddedInUndoStack = false;
    static _type = "stamp";
    static _editorType = AnnotationEditorType.STAMP;
    constructor(params) {
      super({
        ...params,
        name: "stampEditor"
      });
      this.#bitmapUrl = params.bitmapUrl;
      this.#bitmapFile = params.bitmapFile;
      this.defaultL10nId = "pdfjs-editor-stamp-editor";
    }
    static initialize(l10n, uiManager) {
      AnnotationEditor.initialize(l10n, uiManager);
    }
    static isHandlingMimeForPasting(mime) {
      return SupportedImageMimeTypes.includes(mime);
    }
    static paste(item, parent) {
      parent.pasteEditor({
        mode: AnnotationEditorType.STAMP
      }, {
        bitmapFile: item.getAsFile()
      });
    }
    altTextFinish() {
      if (this._uiManager.useNewAltTextFlow) {
        this.div.hidden = false;
      }
      super.altTextFinish();
    }
    get telemetryFinalData() {
      return {
        type: "stamp",
        hasAltText: !!this.altTextData?.altText
      };
    }
    static computeTelemetryFinalData(data) {
      const hasAltTextStats = data.get("hasAltText");
      return {
        hasAltText: hasAltTextStats.get(true) ?? 0,
        hasNoAltText: hasAltTextStats.get(false) ?? 0
      };
    }
    #getBitmapFetched(data, fromId = false) {
      if (!data) {
        this.remove();
        return;
      }
      this.#bitmap = data.bitmap;
      if (!fromId) {
        this.#bitmapId = data.id;
        this.#isSvg = data.isSvg;
      }
      if (data.file) {
        this.#bitmapFileName = data.file.name;
      }
      this.#createCanvas();
    }
    #getBitmapDone() {
      this.#bitmapPromise = null;
      this._uiManager.enableWaiting(false);
      if (!this.#canvas) {
        return;
      }
      if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
        this.addEditToolbar().then(() => {
          this._editToolbar.hide();
          this._uiManager.editAltText(this, true);
        });
        return;
      }
      if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
        this._reportTelemetry({
          action: "pdfjs.image.image_added",
          data: {
            alt_text_modal: false,
            alt_text_type: "empty"
          }
        });
        try {
          this.mlGuessAltText();
        } catch {
        }
      }
      this.div.focus();
    }
    async mlGuessAltText(imageData = null, updateAltTextData = true) {
      if (this.hasAltTextData()) {
        return null;
      }
      const {
        mlManager
      } = this._uiManager;
      if (!mlManager) {
        throw new Error("No ML.");
      }
      if (!await mlManager.isEnabledFor("altText")) {
        throw new Error("ML isn't enabled for alt text.");
      }
      const {
        data,
        width,
        height
      } = imageData || this.copyCanvas(null, null, true).imageData;
      const response = await mlManager.guess({
        name: "altText",
        request: {
          data,
          width,
          height,
          channels: data.length / (width * height)
        }
      });
      if (!response) {
        throw new Error("No response from the AI service.");
      }
      if (response.error) {
        throw new Error("Error from the AI service.");
      }
      if (response.cancel) {
        return null;
      }
      if (!response.output) {
        throw new Error("No valid response from the AI service.");
      }
      const altText = response.output;
      await this.setGuessedAltText(altText);
      if (updateAltTextData && !this.hasAltTextData()) {
        this.altTextData = {
          alt: altText,
          decorative: false
        };
      }
      return altText;
    }
    #getBitmap() {
      if (this.#bitmapId) {
        this._uiManager.enableWaiting(true);
        this._uiManager.imageManager.getFromId(this.#bitmapId).then((data) => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());
        return;
      }
      if (this.#bitmapUrl) {
        const url = this.#bitmapUrl;
        this.#bitmapUrl = null;
        this._uiManager.enableWaiting(true);
        this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data) => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
        return;
      }
      if (this.#bitmapFile) {
        const file = this.#bitmapFile;
        this.#bitmapFile = null;
        this._uiManager.enableWaiting(true);
        this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data) => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
        return;
      }
      const input = document.createElement("input");
      input.type = "file";
      input.accept = SupportedImageMimeTypes.join(",");
      const signal = this._uiManager._signal;
      this.#bitmapPromise = new Promise((resolve) => {
        input.addEventListener("change", async () => {
          if (!input.files || input.files.length === 0) {
            this.remove();
          } else {
            this._uiManager.enableWaiting(true);
            const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
            this._reportTelemetry({
              action: "pdfjs.image.image_selected",
              data: {
                alt_text_modal: this._uiManager.useNewAltTextFlow
              }
            });
            this.#getBitmapFetched(data);
          }
          resolve();
        }, {
          signal
        });
        input.addEventListener("cancel", () => {
          this.remove();
          resolve();
        }, {
          signal
        });
      }).finally(() => this.#getBitmapDone());
      input.click();
    }
    remove() {
      if (this.#bitmapId) {
        this.#bitmap = null;
        this._uiManager.imageManager.deleteId(this.#bitmapId);
        this.#canvas?.remove();
        this.#canvas = null;
        if (this.#resizeTimeoutId) {
          clearTimeout(this.#resizeTimeoutId);
          this.#resizeTimeoutId = null;
        }
      }
      super.remove();
    }
    rebuild() {
      if (!this.parent) {
        if (this.#bitmapId) {
          this.#getBitmap();
        }
        return;
      }
      super.rebuild();
      if (this.div === null) {
        return;
      }
      if (this.#bitmapId && this.#canvas === null) {
        this.#getBitmap();
      }
      if (!this.isAttachedToDOM) {
        this.parent.add(this);
      }
    }
    onceAdded(focus) {
      this._isDraggable = true;
      if (focus) {
        this.div.focus();
      }
    }
    isEmpty() {
      return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);
    }
    get toolbarButtons() {
      return [["altText", this.createAltText()]];
    }
    get isResizable() {
      return true;
    }
    render() {
      if (this.div) {
        return this.div;
      }
      let baseX, baseY;
      if (this._isCopy) {
        baseX = this.x;
        baseY = this.y;
      }
      super.render();
      this.div.hidden = true;
      this.createAltText();
      if (!this.#missingCanvas) {
        if (this.#bitmap) {
          this.#createCanvas();
        } else {
          this.#getBitmap();
        }
      }
      if (this._isCopy) {
        this._moveAfterPaste(baseX, baseY);
      }
      this._uiManager.addShouldRescale(this);
      return this.div;
    }
    setCanvas(annotationElementId, canvas) {
      const {
        id: bitmapId,
        bitmap
      } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);
      canvas.remove();
      if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {
        this.#bitmapId = bitmapId;
        if (bitmap) {
          this.#bitmap = bitmap;
        }
        this.#missingCanvas = false;
        this.#createCanvas();
      }
    }
    _onResized() {
      this.onScaleChanging();
    }
    onScaleChanging() {
      if (!this.parent) {
        return;
      }
      if (this.#resizeTimeoutId !== null) {
        clearTimeout(this.#resizeTimeoutId);
      }
      const TIME_TO_WAIT = 200;
      this.#resizeTimeoutId = setTimeout(() => {
        this.#resizeTimeoutId = null;
        this.#drawBitmap();
      }, TIME_TO_WAIT);
    }
    #createCanvas() {
      const {
        div
      } = this;
      let {
        width,
        height
      } = this.#bitmap;
      const [pageWidth, pageHeight] = this.pageDimensions;
      const MAX_RATIO = 0.75;
      if (this.width) {
        width = this.width * pageWidth;
        height = this.height * pageHeight;
      } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
        const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
        width *= factor;
        height *= factor;
      }
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);
      this._uiManager.enableWaiting(false);
      const canvas = this.#canvas = document.createElement("canvas");
      canvas.setAttribute("role", "img");
      this.addContainer(canvas);
      this.width = width / pageWidth;
      this.height = height / pageHeight;
      if (this._initialOptions?.isCentered) {
        this.center();
      } else {
        this.fixAndSetPosition();
      }
      this._initialOptions = null;
      if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {
        div.hidden = false;
      }
      this.#drawBitmap();
      if (!this.#hasBeenAddedInUndoStack) {
        this.parent.addUndoableEditor(this);
        this.#hasBeenAddedInUndoStack = true;
      }
      this._reportTelemetry({
        action: "inserted_image"
      });
      if (this.#bitmapFileName) {
        this.div.setAttribute("aria-description", this.#bitmapFileName);
      }
      if (!this.annotationElementId) {
        this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
      }
    }
    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {
      if (!maxDataDimension) {
        maxDataDimension = 224;
      }
      const {
        width: bitmapWidth,
        height: bitmapHeight
      } = this.#bitmap;
      const outputScale = new OutputScale();
      let bitmap = this.#bitmap;
      let width = bitmapWidth, height = bitmapHeight;
      let canvas = null;
      if (maxPreviewDimension) {
        if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {
          const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);
          width = Math.floor(bitmapWidth * ratio);
          height = Math.floor(bitmapHeight * ratio);
        }
        canvas = document.createElement("canvas");
        const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);
        const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);
        if (!this.#isSvg) {
          bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);
        }
        const ctx = canvas.getContext("2d");
        ctx.filter = this._uiManager.hcmFilter;
        let white = "white", black = "#cfcfd8";
        if (this._uiManager.hcmFilter !== "none") {
          black = "black";
        } else if (window.matchMedia?.("(prefers-color-scheme: dark)").matches) {
          white = "#8f8f9d";
          black = "#42414d";
        }
        const boxDim = 15;
        const boxDimWidth = boxDim * outputScale.sx;
        const boxDimHeight = boxDim * outputScale.sy;
        const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);
        const patternCtx = pattern.getContext("2d");
        patternCtx.fillStyle = white;
        patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);
        patternCtx.fillStyle = black;
        patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);
        patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);
        ctx.fillStyle = ctx.createPattern(pattern, "repeat");
        ctx.fillRect(0, 0, scaledWidth, scaledHeight);
        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
      }
      let imageData = null;
      if (createImageData) {
        let dataWidth, dataHeight;
        if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {
          dataWidth = bitmap.width;
          dataHeight = bitmap.height;
        } else {
          bitmap = this.#bitmap;
          if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {
            const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);
            dataWidth = Math.floor(bitmapWidth * ratio);
            dataHeight = Math.floor(bitmapHeight * ratio);
            if (!this.#isSvg) {
              bitmap = this.#scaleBitmap(dataWidth, dataHeight);
            }
          }
        }
        const offscreen = new OffscreenCanvas(dataWidth, dataHeight);
        const offscreenCtx = offscreen.getContext("2d", {
          willReadFrequently: true
        });
        offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);
        imageData = {
          width: dataWidth,
          height: dataHeight,
          data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data
        };
      }
      return {
        canvas,
        width,
        height,
        imageData
      };
    }
    #scaleBitmap(width, height) {
      const {
        width: bitmapWidth,
        height: bitmapHeight
      } = this.#bitmap;
      let newWidth = bitmapWidth;
      let newHeight = bitmapHeight;
      let bitmap = this.#bitmap;
      while (newWidth > 2 * width || newHeight > 2 * height) {
        const prevWidth = newWidth;
        const prevHeight = newHeight;
        if (newWidth > 2 * width) {
          newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
        }
        if (newHeight > 2 * height) {
          newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
        }
        const offscreen = new OffscreenCanvas(newWidth, newHeight);
        const ctx = offscreen.getContext("2d");
        ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
        bitmap = offscreen.transferToImageBitmap();
      }
      return bitmap;
    }
    #drawBitmap() {
      const [parentWidth, parentHeight] = this.parentDimensions;
      const {
        width,
        height
      } = this;
      const outputScale = new OutputScale();
      const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);
      const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);
      const canvas = this.#canvas;
      if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {
        return;
      }
      canvas.width = scaledWidth;
      canvas.height = scaledHeight;
      const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);
      const ctx = canvas.getContext("2d");
      ctx.filter = this._uiManager.hcmFilter;
      ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
    }
    #serializeBitmap(toUrl) {
      if (toUrl) {
        if (this.#isSvg) {
          const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);
          if (url) {
            return url;
          }
        }
        const canvas = document.createElement("canvas");
        ({
          width: canvas.width,
          height: canvas.height
        } = this.#bitmap);
        const ctx = canvas.getContext("2d");
        ctx.drawImage(this.#bitmap, 0, 0);
        return canvas.toDataURL();
      }
      if (this.#isSvg) {
        const [pageWidth, pageHeight] = this.pageDimensions;
        const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);
        const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);
        const offscreen = new OffscreenCanvas(width, height);
        const ctx = offscreen.getContext("2d");
        ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);
        return offscreen.transferToImageBitmap();
      }
      return structuredClone(this.#bitmap);
    }
    static async deserialize(data, parent, uiManager) {
      let initialData = null;
      let missingCanvas = false;
      if (data instanceof StampAnnotationElement) {
        const {
          data: {
            rect: rect2,
            rotation,
            id,
            structParent,
            popupRef,
            contentsObj
          },
          container,
          parent: {
            page: {
              pageNumber
            }
          },
          canvas
        } = data;
        let bitmapId2, bitmap2;
        if (canvas) {
          delete data.canvas;
          ({
            id: bitmapId2,
            bitmap: bitmap2
          } = uiManager.imageManager.getFromCanvas(container.id, canvas));
          canvas.remove();
        } else {
          missingCanvas = true;
          data._hasNoCanvas = true;
        }
        const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get("aria-label") || "";
        initialData = data = {
          annotationType: AnnotationEditorType.STAMP,
          bitmapId: bitmapId2,
          bitmap: bitmap2,
          pageIndex: pageNumber - 1,
          rect: rect2.slice(0),
          rotation,
          annotationElementId: id,
          id,
          deleted: false,
          accessibilityData: {
            decorative: false,
            altText
          },
          isSvg: false,
          structParent,
          popupRef,
          comment: contentsObj?.str || null
        };
      }
      const editor = await super.deserialize(data, parent, uiManager);
      const {
        rect,
        bitmap,
        bitmapUrl,
        bitmapId,
        isSvg,
        accessibilityData
      } = data;
      if (missingCanvas) {
        uiManager.addMissingCanvas(data.id, editor);
        editor.#missingCanvas = true;
      } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
        editor.#bitmapId = bitmapId;
        if (bitmap) {
          editor.#bitmap = bitmap;
        }
      } else {
        editor.#bitmapUrl = bitmapUrl;
      }
      editor.#isSvg = isSvg;
      const [parentWidth, parentHeight] = editor.pageDimensions;
      editor.width = (rect[2] - rect[0]) / parentWidth;
      editor.height = (rect[3] - rect[1]) / parentHeight;
      if (accessibilityData) {
        editor.altTextData = accessibilityData;
      }
      editor._initialData = initialData;
      if (data.comment) {
        editor.setCommentData(data.comment);
      }
      editor.#hasBeenAddedInUndoStack = !!initialData;
      return editor;
    }
    serialize(isForCopying = false, context = null) {
      if (this.isEmpty()) {
        return null;
      }
      if (this.deleted) {
        return this.serializeDeleted();
      }
      const serialized = {
        annotationType: AnnotationEditorType.STAMP,
        bitmapId: this.#bitmapId,
        pageIndex: this.pageIndex,
        rect: this.getPDFRect(),
        rotation: this.rotation,
        isSvg: this.#isSvg,
        structTreeParentId: this._structTreeParentId
      };
      this.addComment(serialized);
      if (isForCopying) {
        serialized.bitmapUrl = this.#serializeBitmap(true);
        serialized.accessibilityData = this.serializeAltText(true);
        serialized.isCopy = true;
        return serialized;
      }
      const {
        decorative,
        altText
      } = this.serializeAltText(false);
      if (!decorative && altText) {
        serialized.accessibilityData = {
          type: "Figure",
          alt: altText
        };
      }
      if (this.annotationElementId) {
        const changes = this.#hasElementChanged(serialized);
        if (changes.isSame) {
          return null;
        }
        if (changes.isSameAltText) {
          delete serialized.accessibilityData;
        } else {
          serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;
        }
      }
      serialized.id = this.annotationElementId;
      if (context === null) {
        return serialized;
      }
      context.stamps ||= /* @__PURE__ */ new Map();
      const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
      if (!context.stamps.has(this.#bitmapId)) {
        context.stamps.set(this.#bitmapId, {
          area,
          serialized
        });
        serialized.bitmap = this.#serializeBitmap(false);
      } else if (this.#isSvg) {
        const prevData = context.stamps.get(this.#bitmapId);
        if (area > prevData.area) {
          prevData.area = area;
          prevData.serialized.bitmap.close();
          prevData.serialized.bitmap = this.#serializeBitmap(false);
        }
      }
      return serialized;
    }
    #hasElementChanged(serialized) {
      const {
        pageIndex,
        accessibilityData: {
          altText
        }
      } = this._initialData;
      const isSamePageIndex = serialized.pageIndex === pageIndex;
      const isSameAltText = (serialized.accessibilityData?.alt || "") === altText;
      return {
        isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,
        isSameAltText
      };
    }
    renderAnnotationElement(annotation) {
      if (this.deleted) {
        annotation.hide();
        return null;
      }
      const params = {
        rect: this.getPDFRect()
      };
      if (this.hasEditedComment) {
        params.popup = this.comment;
      }
      annotation.updateEdited(params);
      return null;
    }
  }
  class AnnotationEditorLayer {
    #accessibilityManager;
    #allowClick = false;
    #annotationLayer = null;
    #clickAC = null;
    #editorFocusTimeoutId = null;
    #editors = /* @__PURE__ */ new Map();
    #hadPointerDown = false;
    #isDisabling = false;
    #isEnabling = false;
    #drawingAC = null;
    #focusedElement = null;
    #textLayer = null;
    #textSelectionAC = null;
    #textLayerDblClickAC = null;
    #lastPointerDownTimestamp = -1;
    #uiManager;
    static _initialized = false;
    static #editorTypes = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map((type) => [type._editorType, type]));
    constructor({
      uiManager,
      pageIndex,
      div,
      structTreeLayer,
      accessibilityManager,
      annotationLayer,
      drawLayer,
      textLayer,
      viewport,
      l10n
    }) {
      const editorTypes = [...AnnotationEditorLayer.#editorTypes.values()];
      if (!AnnotationEditorLayer._initialized) {
        AnnotationEditorLayer._initialized = true;
        for (const editorType of editorTypes) {
          editorType.initialize(l10n, uiManager);
        }
      }
      uiManager.registerEditorTypes(editorTypes);
      this.#uiManager = uiManager;
      this.pageIndex = pageIndex;
      this.div = div;
      this.#accessibilityManager = accessibilityManager;
      this.#annotationLayer = annotationLayer;
      this.viewport = viewport;
      this.#textLayer = textLayer;
      this.drawLayer = drawLayer;
      this._structTree = structTreeLayer;
      this.#uiManager.addLayer(this);
    }
    get isEmpty() {
      return this.#editors.size === 0;
    }
    get isInvisible() {
      return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;
    }
    updateToolbar(options) {
      this.#uiManager.updateToolbar(options);
    }
    updateMode(mode = this.#uiManager.getMode()) {
      this.#cleanup();
      switch (mode) {
        case AnnotationEditorType.NONE:
          this.disableTextSelection();
          this.togglePointerEvents(false);
          this.toggleAnnotationLayerPointerEvents(true);
          this.disableClick();
          return;
        case AnnotationEditorType.INK:
          this.disableTextSelection();
          this.togglePointerEvents(true);
          this.enableClick();
          break;
        case AnnotationEditorType.HIGHLIGHT:
          this.enableTextSelection();
          this.togglePointerEvents(false);
          this.disableClick();
          break;
        default:
          this.disableTextSelection();
          this.togglePointerEvents(true);
          this.enableClick();
      }
      this.toggleAnnotationLayerPointerEvents(false);
      const {
        classList
      } = this.div;
      for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
        classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);
      }
      this.div.hidden = false;
    }
    hasTextLayer(textLayer) {
      return textLayer === this.#textLayer?.div;
    }
    setEditingState(isEditing) {
      this.#uiManager.setEditingState(isEditing);
    }
    addCommands(params) {
      this.#uiManager.addCommands(params);
    }
    cleanUndoStack(type) {
      this.#uiManager.cleanUndoStack(type);
    }
    toggleDrawing(enabled = false) {
      this.div.classList.toggle("drawing", !enabled);
    }
    togglePointerEvents(enabled = false) {
      this.div.classList.toggle("disabled", !enabled);
    }
    toggleAnnotationLayerPointerEvents(enabled = false) {
      this.#annotationLayer?.div.classList.toggle("disabled", !enabled);
    }
    async enable() {
      this.#isEnabling = true;
      this.div.tabIndex = 0;
      this.togglePointerEvents(true);
      this.#textLayerDblClickAC?.abort();
      this.#textLayerDblClickAC = null;
      const annotationElementIds = /* @__PURE__ */ new Set();
      for (const editor of this.#editors.values()) {
        editor.enableEditing();
        editor.show(true);
        if (editor.annotationElementId) {
          this.#uiManager.removeChangedExistingAnnotation(editor);
          annotationElementIds.add(editor.annotationElementId);
        }
      }
      if (!this.#annotationLayer) {
        this.#isEnabling = false;
        return;
      }
      const editables = this.#annotationLayer.getEditableAnnotations();
      for (const editable of editables) {
        editable.hide();
        if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {
          continue;
        }
        if (annotationElementIds.has(editable.data.id)) {
          continue;
        }
        const editor = await this.deserialize(editable);
        if (!editor) {
          continue;
        }
        this.addOrRebuild(editor);
        editor.enableEditing();
      }
      this.#isEnabling = false;
    }
    disable() {
      this.#isDisabling = true;
      this.div.tabIndex = -1;
      this.togglePointerEvents(false);
      if (this.#textLayer && !this.#textLayerDblClickAC) {
        this.#textLayerDblClickAC = new AbortController();
        const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);
        this.#textLayer.div.addEventListener("pointerdown", (e) => {
          const DBL_CLICK_THRESHOLD = 500;
          const {
            clientX,
            clientY,
            timeStamp
          } = e;
          const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;
          if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {
            this.#lastPointerDownTimestamp = timeStamp;
            return;
          }
          this.#lastPointerDownTimestamp = -1;
          const {
            classList: classList2
          } = this.div;
          classList2.toggle("getElements", true);
          const elements = document.elementsFromPoint(clientX, clientY);
          classList2.toggle("getElements", false);
          if (!this.div.contains(elements[0])) {
            return;
          }
          let id;
          const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);
          for (const element of elements) {
            if (regex.test(element.id)) {
              id = element.id;
              break;
            }
          }
          if (!id) {
            return;
          }
          const editor = this.#editors.get(id);
          if (editor?.annotationElementId === null) {
            e.stopPropagation();
            e.preventDefault();
            editor.dblclick();
          }
        }, {
          signal,
          capture: true
        });
      }
      const changedAnnotations = /* @__PURE__ */ new Map();
      const resetAnnotations = /* @__PURE__ */ new Map();
      for (const editor of this.#editors.values()) {
        editor.disableEditing();
        if (!editor.annotationElementId) {
          continue;
        }
        if (editor.serialize() !== null) {
          changedAnnotations.set(editor.annotationElementId, editor);
          continue;
        } else {
          resetAnnotations.set(editor.annotationElementId, editor);
        }
        this.getEditableAnnotation(editor.annotationElementId)?.show();
        editor.remove();
      }
      if (this.#annotationLayer) {
        const editables = this.#annotationLayer.getEditableAnnotations();
        for (const editable of editables) {
          const {
            id
          } = editable.data;
          if (this.#uiManager.isDeletedAnnotationElement(id)) {
            editable.updateEdited({
              deleted: true
            });
            continue;
          }
          let editor = resetAnnotations.get(id);
          if (editor) {
            editor.resetAnnotationElement(editable);
            editor.show(false);
            editable.show();
            continue;
          }
          editor = changedAnnotations.get(id);
          if (editor) {
            this.#uiManager.addChangedExistingAnnotation(editor);
            if (editor.renderAnnotationElement(editable)) {
              editor.show(false);
            }
          }
          editable.show();
        }
      }
      this.#cleanup();
      if (this.isEmpty) {
        this.div.hidden = true;
      }
      const {
        classList
      } = this.div;
      for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
        classList.remove(`${editorType._type}Editing`);
      }
      this.disableTextSelection();
      this.toggleAnnotationLayerPointerEvents(true);
      this.#isDisabling = false;
    }
    getEditableAnnotation(id) {
      return this.#annotationLayer?.getEditableAnnotation(id) || null;
    }
    setActiveEditor(editor) {
      const currentActive = this.#uiManager.getActive();
      if (currentActive === editor) {
        return;
      }
      this.#uiManager.setActiveEditor(editor);
    }
    enableTextSelection() {
      this.div.tabIndex = -1;
      if (this.#textLayer?.div && !this.#textSelectionAC) {
        this.#textSelectionAC = new AbortController();
        const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);
        this.#textLayer.div.addEventListener("pointerdown", this.#textLayerPointerDown.bind(this), {
          signal
        });
        this.#textLayer.div.classList.add("highlighting");
      }
    }
    disableTextSelection() {
      this.div.tabIndex = 0;
      if (this.#textLayer?.div && this.#textSelectionAC) {
        this.#textSelectionAC.abort();
        this.#textSelectionAC = null;
        this.#textLayer.div.classList.remove("highlighting");
      }
    }
    #textLayerPointerDown(event) {
      this.#uiManager.unselectAll();
      const {
        target
      } = event;
      if (target === this.#textLayer.div || (target.getAttribute("role") === "img" || target.classList.contains("endOfContent")) && this.#textLayer.div.contains(target)) {
        const {
          isMac
        } = util_FeatureTest.platform;
        if (event.button !== 0 || event.ctrlKey && isMac) {
          return;
        }
        this.#uiManager.showAllEditors("highlight", true, true);
        this.#textLayer.div.classList.add("free");
        this.toggleDrawing();
        HighlightEditor.startHighlighting(this, this.#uiManager.direction === "ltr", {
          target: this.#textLayer.div,
          x: event.x,
          y: event.y
        });
        this.#textLayer.div.addEventListener("pointerup", () => {
          this.#textLayer.div.classList.remove("free");
          this.toggleDrawing(true);
        }, {
          once: true,
          signal: this.#uiManager._signal
        });
        event.preventDefault();
      }
    }
    enableClick() {
      if (this.#clickAC) {
        return;
      }
      this.#clickAC = new AbortController();
      const signal = this.#uiManager.combinedSignal(this.#clickAC);
      this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
        signal
      });
      const pointerup = this.pointerup.bind(this);
      this.div.addEventListener("pointerup", pointerup, {
        signal
      });
      this.div.addEventListener("pointercancel", pointerup, {
        signal
      });
    }
    disableClick() {
      this.#clickAC?.abort();
      this.#clickAC = null;
    }
    attach(editor) {
      this.#editors.set(editor.id, editor);
      const {
        annotationElementId
      } = editor;
      if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {
        this.#uiManager.removeDeletedAnnotationElement(editor);
      }
    }
    detach(editor) {
      this.#editors.delete(editor.id);
      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
      if (!this.#isDisabling && editor.annotationElementId) {
        this.#uiManager.addDeletedAnnotationElement(editor);
      }
    }
    remove(editor) {
      this.detach(editor);
      this.#uiManager.removeEditor(editor);
      editor.div.remove();
      editor.isAttachedToDOM = false;
    }
    changeParent(editor) {
      if (editor.parent === this) {
        return;
      }
      if (editor.parent && editor.annotationElementId) {
        this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);
        AnnotationEditor.deleteAnnotationElement(editor);
        editor.annotationElementId = null;
      }
      this.attach(editor);
      editor.parent?.detach(editor);
      editor.setParent(this);
      if (editor.div && editor.isAttachedToDOM) {
        editor.div.remove();
        this.div.append(editor.div);
      }
    }
    add(editor) {
      if (editor.parent === this && editor.isAttachedToDOM) {
        return;
      }
      this.changeParent(editor);
      this.#uiManager.addEditor(editor);
      this.attach(editor);
      if (!editor.isAttachedToDOM) {
        const div = editor.render();
        this.div.append(div);
        editor.isAttachedToDOM = true;
      }
      editor.fixAndSetPosition();
      editor.onceAdded(!this.#isEnabling);
      this.#uiManager.addToAnnotationStorage(editor);
      editor._reportTelemetry(editor.telemetryInitialData);
    }
    moveEditorInDOM(editor) {
      if (!editor.isAttachedToDOM) {
        return;
      }
      const {
        activeElement
      } = document;
      if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {
        editor._focusEventsAllowed = false;
        this.#editorFocusTimeoutId = setTimeout(() => {
          this.#editorFocusTimeoutId = null;
          if (!editor.div.contains(document.activeElement)) {
            editor.div.addEventListener("focusin", () => {
              editor._focusEventsAllowed = true;
            }, {
              once: true,
              signal: this.#uiManager._signal
            });
            activeElement.focus();
          } else {
            editor._focusEventsAllowed = true;
          }
        }, 0);
      }
      editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
    }
    addOrRebuild(editor) {
      if (editor.needsToBeRebuilt()) {
        editor.parent ||= this;
        editor.rebuild();
        editor.show();
      } else {
        this.add(editor);
      }
    }
    addUndoableEditor(editor) {
      const cmd = () => editor._uiManager.rebuild(editor);
      const undo = () => {
        editor.remove();
      };
      this.addCommands({
        cmd,
        undo,
        mustExec: false
      });
    }
    getNextId() {
      return this.#uiManager.getId();
    }
    get #currentEditorType() {
      return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());
    }
    combinedSignal(ac) {
      return this.#uiManager.combinedSignal(ac);
    }
    #createNewEditor(params) {
      const editorType = this.#currentEditorType;
      return editorType ? new editorType.prototype.constructor(params) : null;
    }
    canCreateNewEmptyEditor() {
      return this.#currentEditorType?.canCreateNewEmptyEditor();
    }
    async pasteEditor(options, params) {
      this.updateToolbar(options);
      await this.#uiManager.updateMode(options.mode);
      const {
        offsetX,
        offsetY
      } = this.#getCenterPoint();
      const id = this.getNextId();
      const editor = this.#createNewEditor({
        parent: this,
        id,
        x: offsetX,
        y: offsetY,
        uiManager: this.#uiManager,
        isCentered: true,
        ...params
      });
      if (editor) {
        this.add(editor);
      }
    }
    async deserialize(data) {
      return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;
    }
    createAndAddNewEditor(event, isCentered, data = {}) {
      const id = this.getNextId();
      const editor = this.#createNewEditor({
        parent: this,
        id,
        x: event.offsetX,
        y: event.offsetY,
        uiManager: this.#uiManager,
        isCentered,
        ...data
      });
      if (editor) {
        this.add(editor);
      }
      return editor;
    }
    #getCenterPoint() {
      const {
        x,
        y,
        width,
        height
      } = this.div.getBoundingClientRect();
      const tlX = Math.max(0, x);
      const tlY = Math.max(0, y);
      const brX = Math.min(window.innerWidth, x + width);
      const brY = Math.min(window.innerHeight, y + height);
      const centerX = (tlX + brX) / 2 - x;
      const centerY = (tlY + brY) / 2 - y;
      const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
      return {
        offsetX,
        offsetY
      };
    }
    addNewEditor(data = {}) {
      this.createAndAddNewEditor(this.#getCenterPoint(), true, data);
    }
    setSelected(editor) {
      this.#uiManager.setSelected(editor);
    }
    toggleSelected(editor) {
      this.#uiManager.toggleSelected(editor);
    }
    unselect(editor) {
      this.#uiManager.unselect(editor);
    }
    pointerup(event) {
      const {
        isMac
      } = util_FeatureTest.platform;
      if (event.button !== 0 || event.ctrlKey && isMac) {
        return;
      }
      if (event.target !== this.div) {
        return;
      }
      if (!this.#hadPointerDown) {
        return;
      }
      this.#hadPointerDown = false;
      if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {
        return;
      }
      if (!this.#allowClick) {
        this.#allowClick = true;
        return;
      }
      const currentMode = this.#uiManager.getMode();
      if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {
        this.#uiManager.unselectAll();
        return;
      }
      this.createAndAddNewEditor(event, false);
    }
    pointerdown(event) {
      if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {
        this.enableTextSelection();
      }
      if (this.#hadPointerDown) {
        this.#hadPointerDown = false;
        return;
      }
      const {
        isMac
      } = util_FeatureTest.platform;
      if (event.button !== 0 || event.ctrlKey && isMac) {
        return;
      }
      if (event.target !== this.div) {
        return;
      }
      this.#hadPointerDown = true;
      if (this.#currentEditorType?.isDrawer) {
        this.startDrawingSession(event);
        return;
      }
      const editor = this.#uiManager.getActive();
      this.#allowClick = !editor || editor.isEmpty();
    }
    startDrawingSession(event) {
      this.div.focus({
        preventScroll: true
      });
      if (this.#drawingAC) {
        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
        return;
      }
      this.#uiManager.setCurrentDrawingSession(this);
      this.#drawingAC = new AbortController();
      const signal = this.#uiManager.combinedSignal(this.#drawingAC);
      this.div.addEventListener("blur", ({
        relatedTarget
      }) => {
        if (relatedTarget && !this.div.contains(relatedTarget)) {
          this.#focusedElement = null;
          this.commitOrRemove();
        }
      }, {
        signal
      });
      this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
    }
    pause(on) {
      if (on) {
        const {
          activeElement
        } = document;
        if (this.div.contains(activeElement)) {
          this.#focusedElement = activeElement;
        }
        return;
      }
      if (this.#focusedElement) {
        setTimeout(() => {
          this.#focusedElement?.focus();
          this.#focusedElement = null;
        }, 0);
      }
    }
    endDrawingSession(isAborted = false) {
      if (!this.#drawingAC) {
        return null;
      }
      this.#uiManager.setCurrentDrawingSession(null);
      this.#drawingAC.abort();
      this.#drawingAC = null;
      this.#focusedElement = null;
      return this.#currentEditorType.endDrawing(isAborted);
    }
    findNewParent(editor, x, y) {
      const layer = this.#uiManager.findParent(x, y);
      if (layer === null || layer === this) {
        return false;
      }
      layer.changeParent(editor);
      return true;
    }
    commitOrRemove() {
      if (this.#drawingAC) {
        this.endDrawingSession();
        return true;
      }
      return false;
    }
    onScaleChanging() {
      if (!this.#drawingAC) {
        return;
      }
      this.#currentEditorType.onScaleChangingWhenDrawing(this);
    }
    destroy() {
      this.commitOrRemove();
      if (this.#uiManager.getActive()?.parent === this) {
        this.#uiManager.commitOrRemove();
        this.#uiManager.setActiveEditor(null);
      }
      if (this.#editorFocusTimeoutId) {
        clearTimeout(this.#editorFocusTimeoutId);
        this.#editorFocusTimeoutId = null;
      }
      for (const editor of this.#editors.values()) {
        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
        editor.setParent(null);
        editor.isAttachedToDOM = false;
        editor.div.remove();
      }
      this.div = null;
      this.#editors.clear();
      this.#uiManager.removeLayer(this);
    }
    #cleanup() {
      for (const editor of this.#editors.values()) {
        if (editor.isEmpty()) {
          editor.remove();
        }
      }
    }
    render({
      viewport
    }) {
      this.viewport = viewport;
      setLayerDimensions(this.div, viewport);
      for (const editor of this.#uiManager.getEditors(this.pageIndex)) {
        this.add(editor);
        editor.rebuild();
      }
      this.updateMode();
    }
    update({
      viewport
    }) {
      this.#uiManager.commitOrRemove();
      this.#cleanup();
      const oldRotation = this.viewport.rotation;
      const rotation = viewport.rotation;
      this.viewport = viewport;
      setLayerDimensions(this.div, {
        rotation
      });
      if (oldRotation !== rotation) {
        for (const editor of this.#editors.values()) {
          editor.rotate(rotation);
        }
      }
    }
    get pageDimensions() {
      const {
        pageWidth,
        pageHeight
      } = this.viewport.rawDims;
      return [pageWidth, pageHeight];
    }
    get scale() {
      return this.#uiManager.viewParameters.realScale;
    }
  }
  class DrawLayer {
    #parent = null;
    #mapping = /* @__PURE__ */ new Map();
    #toUpdate = /* @__PURE__ */ new Map();
    static #id = 0;
    constructor({
      pageIndex
    }) {
      this.pageIndex = pageIndex;
    }
    setParent(parent) {
      if (!this.#parent) {
        this.#parent = parent;
        return;
      }
      if (this.#parent !== parent) {
        if (this.#mapping.size > 0) {
          for (const root of this.#mapping.values()) {
            root.remove();
            parent.append(root);
          }
        }
        this.#parent = parent;
      }
    }
    static get _svgFactory() {
      return shadow(this, "_svgFactory", new DOMSVGFactory());
    }
    static #setBox(element, [x, y, width, height]) {
      const {
        style
      } = element;
      style.top = `${100 * y}%`;
      style.left = `${100 * x}%`;
      style.width = `${100 * width}%`;
      style.height = `${100 * height}%`;
    }
    #createSVG() {
      const svg = DrawLayer._svgFactory.create(1, 1, true);
      this.#parent.append(svg);
      svg.setAttribute("aria-hidden", true);
      return svg;
    }
    #createClipPath(defs, pathId) {
      const clipPath = DrawLayer._svgFactory.createElement("clipPath");
      defs.append(clipPath);
      const clipPathId = `clip_${pathId}`;
      clipPath.setAttribute("id", clipPathId);
      clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
      const clipPathUse = DrawLayer._svgFactory.createElement("use");
      clipPath.append(clipPathUse);
      clipPathUse.setAttribute("href", `#${pathId}`);
      clipPathUse.classList.add("clip");
      return clipPathId;
    }
    #updateProperties(element, properties) {
      for (const [key, value] of Object.entries(properties)) {
        if (value === null) {
          element.removeAttribute(key);
        } else {
          element.setAttribute(key, value);
        }
      }
    }
    draw(properties, isPathUpdatable = false, hasClip = false) {
      const id = DrawLayer.#id++;
      const root = this.#createSVG();
      const defs = DrawLayer._svgFactory.createElement("defs");
      root.append(defs);
      const path = DrawLayer._svgFactory.createElement("path");
      defs.append(path);
      const pathId = `path_p${this.pageIndex}_${id}`;
      path.setAttribute("id", pathId);
      path.setAttribute("vector-effect", "non-scaling-stroke");
      if (isPathUpdatable) {
        this.#toUpdate.set(id, path);
      }
      const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;
      const use = DrawLayer._svgFactory.createElement("use");
      root.append(use);
      use.setAttribute("href", `#${pathId}`);
      this.updateProperties(root, properties);
      this.#mapping.set(id, root);
      return {
        id,
        clipPathId: `url(#${clipPathId})`
      };
    }
    drawOutline(properties, mustRemoveSelfIntersections) {
      const id = DrawLayer.#id++;
      const root = this.#createSVG();
      const defs = DrawLayer._svgFactory.createElement("defs");
      root.append(defs);
      const path = DrawLayer._svgFactory.createElement("path");
      defs.append(path);
      const pathId = `path_p${this.pageIndex}_${id}`;
      path.setAttribute("id", pathId);
      path.setAttribute("vector-effect", "non-scaling-stroke");
      let maskId;
      if (mustRemoveSelfIntersections) {
        const mask = DrawLayer._svgFactory.createElement("mask");
        defs.append(mask);
        maskId = `mask_p${this.pageIndex}_${id}`;
        mask.setAttribute("id", maskId);
        mask.setAttribute("maskUnits", "objectBoundingBox");
        const rect = DrawLayer._svgFactory.createElement("rect");
        mask.append(rect);
        rect.setAttribute("width", "1");
        rect.setAttribute("height", "1");
        rect.setAttribute("fill", "white");
        const use = DrawLayer._svgFactory.createElement("use");
        mask.append(use);
        use.setAttribute("href", `#${pathId}`);
        use.setAttribute("stroke", "none");
        use.setAttribute("fill", "black");
        use.setAttribute("fill-rule", "nonzero");
        use.classList.add("mask");
      }
      const use1 = DrawLayer._svgFactory.createElement("use");
      root.append(use1);
      use1.setAttribute("href", `#${pathId}`);
      if (maskId) {
        use1.setAttribute("mask", `url(#${maskId})`);
      }
      const use2 = use1.cloneNode();
      root.append(use2);
      use1.classList.add("mainOutline");
      use2.classList.add("secondaryOutline");
      this.updateProperties(root, properties);
      this.#mapping.set(id, root);
      return id;
    }
    finalizeDraw(id, properties) {
      this.#toUpdate.delete(id);
      this.updateProperties(id, properties);
    }
    updateProperties(elementOrId, properties) {
      if (!properties) {
        return;
      }
      const {
        root,
        bbox,
        rootClass,
        path
      } = properties;
      const element = typeof elementOrId === "number" ? this.#mapping.get(elementOrId) : elementOrId;
      if (!element) {
        return;
      }
      if (root) {
        this.#updateProperties(element, root);
      }
      if (bbox) {
        DrawLayer.#setBox(element, bbox);
      }
      if (rootClass) {
        const {
          classList
        } = element;
        for (const [className, value] of Object.entries(rootClass)) {
          classList.toggle(className, value);
        }
      }
      if (path) {
        const defs = element.firstChild;
        const pathElement = defs.firstChild;
        this.#updateProperties(pathElement, path);
      }
    }
    updateParent(id, layer) {
      if (layer === this) {
        return;
      }
      const root = this.#mapping.get(id);
      if (!root) {
        return;
      }
      layer.#parent.append(root);
      this.#mapping.delete(id);
      layer.#mapping.set(id, root);
    }
    remove(id) {
      this.#toUpdate.delete(id);
      if (this.#parent === null) {
        return;
      }
      this.#mapping.get(id).remove();
      this.#mapping.delete(id);
    }
    destroy() {
      this.#parent = null;
      for (const root of this.#mapping.values()) {
        root.remove();
      }
      this.#mapping.clear();
      this.#toUpdate.clear();
    }
  }
  {
    globalThis._pdfjsTestingUtils = {
      HighlightOutliner
    };
  }
  globalThis.pdfjsLib = {
    AbortException,
    AnnotationEditorLayer,
    AnnotationEditorParamsType,
    AnnotationEditorType,
    AnnotationEditorUIManager,
    AnnotationLayer,
    AnnotationMode,
    AnnotationType,
    build,
    ColorPicker,
    createValidAbsoluteUrl,
    DOMSVGFactory,
    DrawLayer,
    FeatureTest: util_FeatureTest,
    fetchData,
    getDocument,
    getFilenameFromUrl,
    getPdfFilenameFromUrl,
    getRGB,
    getUuid,
    getXfaPageViewport,
    GlobalWorkerOptions,
    ImageKind: util_ImageKind,
    InvalidPDFException,
    isDataScheme,
    isPdfFile,
    isValidExplicitDest,
    MathClamp,
    noContextMenu,
    normalizeUnicode,
    OPS,
    OutputScale,
    PasswordResponses,
    PDFDataRangeTransport,
    PDFDateString,
    PDFWorker,
    PermissionFlag,
    PixelsPerInch,
    RenderingCancelledException,
    ResponseException,
    setLayerDimensions,
    shadow,
    SignatureExtractor,
    stopEvent,
    SupportedImageMimeTypes,
    TextLayer,
    TouchManager,
    updateUrlHash,
    Util,
    VerbosityLevel,
    version,
    XfaLayer
  };
  const pdfjs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AbortException,
    AnnotationEditorLayer,
    AnnotationEditorParamsType,
    AnnotationEditorType,
    AnnotationEditorUIManager,
    AnnotationLayer,
    AnnotationMode,
    AnnotationType,
    ColorPicker,
    DOMSVGFactory,
    DrawLayer,
    FeatureTest: util_FeatureTest,
    GlobalWorkerOptions,
    ImageKind: util_ImageKind,
    InvalidPDFException,
    MathClamp,
    OPS,
    OutputScale,
    PDFDataRangeTransport,
    PDFDateString,
    PDFWorker,
    PasswordResponses,
    PermissionFlag,
    PixelsPerInch,
    RenderingCancelledException,
    ResponseException,
    SignatureExtractor,
    SupportedImageMimeTypes,
    TextLayer,
    TouchManager,
    Util,
    VerbosityLevel,
    XfaLayer,
    build,
    createValidAbsoluteUrl,
    fetchData,
    getDocument,
    getFilenameFromUrl,
    getPdfFilenameFromUrl,
    getRGB,
    getUuid,
    getXfaPageViewport,
    isDataScheme,
    isPdfFile,
    isValidExplicitDest,
    noContextMenu,
    normalizeUnicode,
    setLayerDimensions,
    shadow,
    stopEvent,
    updateUrlHash,
    version
  }, Symbol.toStringTag, { value: "Module" }));
  class Shape {
    static tolerance = 2;
    static applyTransform(p, m) {
      const xt = p[0] * m[0] + p[1] * m[2] + m[4];
      const yt = p[0] * m[1] + p[1] * m[3] + m[5];
      return [xt, yt];
    }
  }
  class Point extends Shape {
    x;
    y;
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
    }
    equal(point) {
      return point.x === this.x && point.y === this.y;
    }
    transform(matrix) {
      const p = Shape.applyTransform([this.x, this.y], matrix);
      this.x = p[0];
      this.y = p[1];
      return this;
    }
  }
  var LineDirection = /* @__PURE__ */ ((LineDirection2) => {
    LineDirection2[LineDirection2["None"] = 0] = "None";
    LineDirection2[LineDirection2["Horizontal"] = 1] = "Horizontal";
    LineDirection2[LineDirection2["Vertical"] = 2] = "Vertical";
    return LineDirection2;
  })(LineDirection || {});
  class Line extends Shape {
    from;
    to;
    direction = 0;
    length = 0;
    intersections = [];
    gaps = [];
    constructor(from, to) {
      super();
      this.from = from;
      this.to = to;
      this.init();
    }
    init() {
      let from = this.from;
      let to = this.to;
      if (Math.abs(from.y - to.y) < Shape.tolerance) {
        this.direction = 1;
        to.y = from.y;
        if (from.x > to.x) {
          const temp = from;
          from = to;
          to = temp;
        }
        this.length = to.x - from.x;
      } else if (Math.abs(from.x - to.x) < Shape.tolerance) {
        this.direction = 2;
        to.x = from.x;
        if (from.y > to.y) {
          const temp = from;
          from = to;
          to = temp;
        }
        this.length = to.y - from.y;
      }
      this.from = from;
      this.to = to;
    }
    _valid = void 0;
    get valid() {
      if (this._valid === void 0) {
        this._valid = this.direction !== 0 && this.length > Shape.tolerance;
      }
      return this._valid;
    }
    get normalized() {
      if (this.direction === 1) {
        return new Line(new Point(this.from.x - Shape.tolerance, this.from.y), new Point(this.to.x + Shape.tolerance, this.from.y));
      } else if (this.direction === 2) {
        return new Line(new Point(this.from.x, this.from.y - Shape.tolerance), new Point(this.from.x, this.to.y + Shape.tolerance));
      }
      return this;
    }
    addGap(line) {
      this.gaps.push(line);
    }
    containsPoint(p) {
      if (this.direction === 2) {
        return this.from.x === p.x && p.y >= this.from.y && p.y <= this.to.y;
      } else if (this.direction === 1) {
        return this.from.y === p.y && p.x >= this.from.x && p.x <= this.to.x;
      }
      return false;
    }
    // // todo implement
    // public containsLine(l:Line):boolean{
    //     if(this.direction === LineDirection.Vertical && l.direction === LineDirection.Vertical){
    //         return this.from.x === l.from.x
    //     }
    //     else if(this.direction === LineDirection.Horizontal && l.direction === LineDirection.Horizontal){
    //         return this.from.y === l.from.y
    //     }
    //     return false
    // }
    addIntersectionPoint(point) {
      for (const intPoint of this.intersections) {
        if (intPoint.equal(point)) return;
      }
      this.intersections.push(point);
    }
    intersection(line) {
      let result;
      if (!this.valid || !line.valid) {
        return result;
      }
      const thisNormalized = this.normalized;
      const lineNormalized = line.normalized;
      if (this.direction === 1 && line.direction === 2) {
        const x = lineNormalized.from.x;
        const y = thisNormalized.from.y;
        const isOk = x > thisNormalized.from.x && x < thisNormalized.to.x && y > lineNormalized.from.y && y < lineNormalized.to.y;
        if (isOk) {
          const intPoint = new Point(x, y);
          this.addIntersectionPoint(intPoint);
          line.addIntersectionPoint(intPoint);
          result = intPoint;
        }
      } else if (this.direction === 2 && line.direction === 1) {
        const x = thisNormalized.from.x;
        const y = lineNormalized.from.y;
        const isOk = x > lineNormalized.from.x && x < lineNormalized.to.x && y > thisNormalized.from.y && y < thisNormalized.to.y;
        if (isOk) {
          const intPoint = new Point(x, y);
          this.addIntersectionPoint(intPoint);
          line.addIntersectionPoint(intPoint);
          result = intPoint;
        }
      }
      return result;
    }
    transform(matrix) {
      const p1 = this.from.transform(matrix);
      const p2 = this.to.transform(matrix);
      const x = Math.min(p1.x, p2.x);
      const y = Math.min(p1.y, p2.y);
      const width = Math.abs(p1.x - p2.x);
      const height = Math.abs(p1.y - p2.y);
      this.from = new Point(x, y);
      this.to = new Point(x + width, y + height);
      this.init();
      return this;
    }
  }
  class TableData {
    minXY;
    maxXY;
    rows;
    rowPivots;
    colPivots;
    constructor(minXY, maxXY, rowPivots, colPivots) {
      this.minXY = minXY;
      this.maxXY = maxXY;
      this.rows = [];
      this.rowPivots = rowPivots;
      this.colPivots = colPivots;
    }
    findCell(x, y) {
      if (x >= this.minXY.x && y >= this.minXY.y && x <= this.maxXY.x && y <= this.maxXY.y) {
        for (const row of this.rows) {
          for (const cell of row) {
            if (cell.minXY.x <= x && cell.minXY.y <= y && cell.maxXY.x >= x && cell.maxXY.y >= y) {
              return cell;
            }
          }
        }
      }
      return void 0;
    }
    get cellCount() {
      return this.rows.reduce((acc, row) => acc + row.length, 0);
    }
    get rowCount() {
      return this.rows.length;
    }
    check() {
      const virtualCellCount = (this.colPivots.length - 1) * (this.rowPivots.length - 1);
      let allCellCount = 0;
      for (const row of this.rows) {
        for (const cell of row) {
          const count = (cell.colspan || 1) * (cell.rowspan || 1);
          allCellCount += count;
        }
      }
      if (virtualCellCount !== allCellCount) {
        return false;
      }
      return true;
    }
    toArray() {
      const tableArr = [];
      for (const row of this.rows) {
        const rowArr = [];
        for (const cell of row) {
          let text = cell.text.join("");
          text = text.replace(/^[\s]+|[\s]+$/g, "");
          text = text.trim();
          rowArr.push(text);
        }
        tableArr.push(rowArr);
      }
      return tableArr;
    }
  }
  class Table {
    hLines = [];
    vLines = [];
    constructor(line) {
      if (line.direction === LineDirection.Horizontal) {
        this.hLines.push(line);
      } else if (line.direction === LineDirection.Vertical) {
        this.vLines.push(line);
      }
    }
    get isValid() {
      return this.hLines.length + this.vLines.length > 4;
    }
    get rowPivots() {
      const rowSet = /* @__PURE__ */ new Set();
      for (const line of this.hLines) {
        rowSet.add(line.from.y);
      }
      return [...rowSet].sort((a, b) => a - b);
    }
    get colPivots() {
      const colSet = /* @__PURE__ */ new Set();
      for (const line of this.vLines) {
        colSet.add(line.from.x);
      }
      return [...colSet].sort((a, b) => a - b);
    }
    add(line) {
      const hasIntersection = this.intersection(line);
      if (hasIntersection) {
        if (line.direction === LineDirection.Horizontal) {
          this.hLines.push(line);
          return true;
        } else if (line.direction === LineDirection.Vertical) {
          this.vLines.push(line);
          return true;
        }
      }
      return false;
    }
    intersection(line) {
      let flag = false;
      if (!line.valid) return flag;
      if (line.direction === LineDirection.Horizontal) {
        for (const vLine of this.vLines) {
          const p = line.intersection(vLine);
          if (p) {
            flag = true;
          }
        }
      } else if (line.direction === LineDirection.Vertical) {
        for (const hLine of this.hLines) {
          const p = line.intersection(hLine);
          if (p) {
            flag = true;
          }
        }
      }
      return flag;
    }
    getSameHorizontal(line) {
      const same = [line];
      const other = [];
      while (this.hLines.length > 0) {
        const hLine = this.hLines.shift();
        if (!hLine) continue;
        if (hLine.from.y === line.from.y) {
          same.push(hLine);
        } else {
          other.push(hLine);
        }
      }
      this.hLines = other;
      return same;
    }
    getSameVertical(line) {
      const same = [line];
      const other = [];
      while (this.vLines.length > 0) {
        const vLine = this.vLines.shift();
        if (!vLine) continue;
        if (vLine.from.x === line.from.x) {
          same.push(vLine);
        } else {
          other.push(vLine);
        }
      }
      this.vLines = other;
      return same;
    }
    mergeHorizontalLines(lines) {
      lines.sort((l1, l2) => l1.from.x - l2.from.x);
      const minX = lines[0].from.x;
      const maxX = lines[lines.length - 1].to.x;
      const resultLine = new Line(new Point(minX, lines[0].from.y), new Point(maxX, lines[0].from.y));
      for (let i = 1; i < lines.length; i++) {
        const prevLine = lines[i - 1];
        const currLine = lines[i];
        if (Math.abs(prevLine.to.x - currLine.from.x) > Shape.tolerance) {
          const gapLine = new Line(new Point(prevLine.to.x, prevLine.from.y), new Point(currLine.from.x, currLine.from.y));
          resultLine.addGap(gapLine);
        }
      }
      return resultLine;
    }
    mergeVerticalLines(lines) {
      lines.sort((l1, l2) => l1.from.y - l2.from.y);
      const minY = lines[0].from.y;
      const maxY = lines[lines.length - 1].to.y;
      const resultLine = new Line(new Point(lines[0].from.x, minY), new Point(lines[0].from.x, maxY));
      for (let i = 1; i < lines.length; i++) {
        const prevLine = lines[i - 1];
        const currLine = lines[i];
        if (Math.abs(prevLine.to.y - currLine.from.y) > Shape.tolerance) {
          const gapLine = new Line(new Point(prevLine.to.x, prevLine.to.y), new Point(prevLine.to.x, currLine.from.y));
          resultLine.addGap(gapLine);
        }
      }
      return resultLine;
    }
    normalize() {
      this.hLines = this.hLines.filter((l) => l.intersections.length > 1);
      this.vLines = this.vLines.filter((l) => l.intersections.length > 1);
      this.hLines.sort((l1, l2) => l1.from.y - l2.from.y);
      this.vLines.sort((l1, l2) => l1.from.x - l2.from.x);
      const newHLines = [];
      while (this.hLines.length > 0) {
        const line = this.hLines.shift();
        if (!line) continue;
        const lines = this.getSameHorizontal(line);
        const merged = this.mergeHorizontalLines(lines);
        newHLines.push(merged);
      }
      this.hLines = newHLines;
      const newVLines = [];
      while (this.vLines.length > 0) {
        const line = this.vLines.shift();
        if (!line) continue;
        const lines = this.getSameVertical(line);
        const merged = this.mergeVerticalLines(lines);
        newVLines.push(merged);
      }
      this.vLines = newVLines;
    }
    verticalExists(line, y1, y2) {
      if (line.direction !== LineDirection.Vertical) {
        throw new Error("Line is not vertical");
      }
      if (y1 >= y2) {
        throw new Error("y1 must be less than y2");
      }
      if (line.from.y <= y1 && line.to.y >= y2) {
        for (const gap of line.gaps) {
          if (gap.from.y <= y1 && gap.to.y >= y2) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    horizontalExists(line, x1, x2) {
      if (line.direction !== LineDirection.Horizontal) {
        throw new Error("Line is not horizontal");
      }
      if (x1 >= x2) {
        throw new Error("x1 must be less than x2");
      }
      if (line.from.x <= x1 && line.to.x >= x2) {
        for (const gap of line.gaps) {
          if (gap.from.x <= x1 && gap.to.x >= x2) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    findBottomLineIndex(h2Index, xMiddle) {
      for (let i = h2Index; i < this.hLines.length; i++) {
        const hLine = this.hLines[i];
        if (hLine.from.x <= xMiddle && hLine.to.x >= xMiddle) {
          return i;
        }
      }
      return -1;
    }
    findVerticalLineIndexs(topHLine, yMiddle) {
      const result = [];
      for (let i = 0; i < this.vLines.length; i++) {
        const vLine = this.vLines[i];
        if (vLine.from.y <= yMiddle && vLine.to.y >= yMiddle && topHLine.intersection(vLine)) {
          result.push(i);
        }
      }
      return result;
    }
    getRow(h1Index, h2Index, yMiddle) {
      const tableRow = [];
      const topHLine = this.hLines[h1Index];
      const vLineIndexes = this.findVerticalLineIndexs(topHLine, yMiddle);
      for (let i = 1; i < vLineIndexes.length; i++) {
        const leftVLine = this.vLines[vLineIndexes[i - 1]];
        const rightVLine = this.vLines[vLineIndexes[i]];
        const xMiddle = (leftVLine.from.x + rightVLine.from.x) / 2;
        const bottomHLineIndex = this.findBottomLineIndex(h2Index, xMiddle);
        const bottomHLine = this.hLines[bottomHLineIndex];
        const tableCell = {
          minXY: new Point(leftVLine.from.x, topHLine.from.y),
          maxXY: new Point(rightVLine.from.x, bottomHLine.from.y),
          width: rightVLine.from.x - leftVLine.from.x,
          height: bottomHLine.from.y - topHLine.from.y,
          text: []
        };
        const colSpan = vLineIndexes[i] - vLineIndexes[i - 1];
        const rowSpan = bottomHLineIndex - h1Index;
        if (colSpan > 1) {
          tableCell.colspan = colSpan;
        }
        if (rowSpan > 1) {
          tableCell.rowspan = rowSpan;
        }
        tableRow.push(tableCell);
      }
      return tableRow;
    }
    toData() {
      const rowPivots = this.rowPivots;
      const colPivots = this.colPivots;
      const minXY = new Point(colPivots[0], rowPivots[0]);
      const maxXY = new Point(colPivots[colPivots.length - 1], rowPivots[rowPivots.length - 1]);
      const result = new TableData(minXY, maxXY, rowPivots, colPivots);
      for (let h1 = 1; h1 < this.hLines.length; h1++) {
        const prevHLine = this.hLines[h1 - 1];
        const currHLine = this.hLines[h1];
        const YMiddle = (prevHLine.from.y + currHLine.from.y) / 2;
        const rowData = this.getRow(h1 - 1, h1, YMiddle);
        result.rows.push(rowData);
      }
      return result;
    }
  }
  class LineStore {
    hLines = [];
    vLines = [];
    add(line) {
      if (line.valid) {
        if (line.direction === LineDirection.Horizontal) {
          this.hLines.push(line);
        } else if (line.direction === LineDirection.Vertical) {
          this.vLines.push(line);
        }
      }
    }
    addRectangle(rect) {
      for (const line of rect.getLines()) {
        this.add(line);
      }
    }
    getTableData() {
      const result = [];
      const tables = this.getTables();
      for (const table of tables) {
        const data = table.toData();
        if (data) {
          result.push(data);
        }
      }
      return result;
    }
    getTables() {
      const result = [];
      while (this.hLines.length !== 0) {
        const hLine = this.hLines.shift();
        if (!hLine) continue;
        const filled = this.tryFill(result, hLine);
        if (filled) continue;
        const table = new Table(hLine);
        this.fillTable(table);
        result.push(table);
      }
      while (this.vLines.length !== 0) {
        const vLine = this.vLines.shift();
        if (!vLine) continue;
        const filled = this.tryFill(result, vLine);
        if (filled) continue;
        const table = new Table(vLine);
        this.fillTable(table);
        result.push(table);
      }
      const validTables = result.filter((t) => t.isValid);
      for (const table of validTables) {
        table.normalize();
      }
      return validTables;
    }
    normalize() {
      this.normalizeHorizontal();
      this.normalizeVertical();
    }
    normalizeHorizontal() {
      this.hLines.sort((l1, l2) => l1.from.y - l2.from.y);
      const newLines = [];
      let sameY = [];
      for (const line of this.hLines) {
        if (sameY.length === 0) {
          sameY.push(line);
        } else if (Math.abs(sameY[0]?.from.y - line.from.y) < Shape.tolerance) {
          sameY.push(line);
        } else {
          const merged = this.margeHorizontalLines(sameY);
          newLines.push(...merged);
          sameY = [line];
        }
      }
      if (sameY.length > 0) {
        const merged = this.margeHorizontalLines(sameY);
        newLines.push(...merged);
      }
      this.hLines = newLines;
    }
    normalizeVertical() {
      this.vLines.sort((l1, l2) => l1.from.x - l2.from.x);
      const newLines = [];
      let sameX = [];
      for (const line of this.vLines) {
        if (sameX.length === 0) {
          sameX.push(line);
        } else if (Math.abs(sameX[0]?.from.x - line.from.x) < Shape.tolerance) {
          sameX.push(line);
        } else {
          const merged = this.margeVerticalLines(sameX);
          newLines.push(...merged);
          sameX = [line];
        }
      }
      if (sameX.length > 0) {
        const merged = this.margeVerticalLines(sameX);
        newLines.push(...merged);
      }
      this.vLines = newLines;
    }
    fillTable(table) {
      const newVLines = [];
      const newHLines = [];
      for (const vLine of this.vLines) {
        if (!table.add(vLine)) {
          newVLines.push(vLine);
        }
      }
      for (const hLine of this.hLines) {
        if (!table.add(hLine)) {
          newHLines.push(hLine);
        }
      }
      this.hLines = newHLines;
      this.vLines = newVLines;
    }
    tryFill(tables, line) {
      for (const table of tables) {
        if (table.add(line)) {
          this.fillTable(table);
          return true;
        }
      }
      return false;
    }
    margeHorizontalLines(sameYLines) {
      const result = [];
      sameYLines.sort((l1, l2) => l1.from.x - l2.from.x);
      const sameY = sameYLines[0]?.from.y;
      if (sameY === void 0) return result;
      let minX = Number.MAX_SAFE_INTEGER;
      let maxX = Number.MIN_SAFE_INTEGER;
      for (const line of sameYLines) {
        if (line.from.x - maxX < Shape.tolerance) {
          if (line.from.x < minX) {
            minX = line.from.x;
          }
          if (line.to.x > maxX) {
            maxX = line.to.x;
          }
        } else {
          if (maxX > minX) {
            result.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));
          }
          minX = line.from.x;
          maxX = line.to.x;
        }
      }
      const last = result[result.length - 1];
      if (last) {
        if (last.from.x !== minX && last.to.x !== maxX) {
          result.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));
        }
      } else {
        result.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));
      }
      return result;
    }
    margeVerticalLines(sameXLines) {
      const result = [];
      sameXLines.sort((l1, l2) => l1.from.y - l2.from.y);
      const sameX = sameXLines[0]?.from.x;
      if (sameX === void 0) return result;
      let minY = Number.MAX_SAFE_INTEGER;
      let maxY = Number.MIN_SAFE_INTEGER;
      for (const line of sameXLines) {
        if (line.from.y - maxY < Shape.tolerance) {
          if (line.from.y < minY) {
            minY = line.from.y;
          }
          if (line.to.y > maxY) {
            maxY = line.to.y;
          }
        } else {
          if (maxY > minY) {
            result.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));
          }
          minY = line.from.y;
          maxY = line.to.y;
        }
      }
      const last = result[result.length - 1];
      if (last) {
        if (last.from.y !== minY && last.to.y !== maxY) {
          result.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));
        }
      } else {
        result.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));
      }
      return result;
    }
  }
  class Rectangle extends Shape {
    from;
    width;
    height;
    constructor(from, width, height) {
      super();
      this.from = from;
      this.width = width;
      this.height = height;
    }
    get to() {
      return new Point(this.from.x + this.width, this.from.y + this.height);
    }
    getLines() {
      const to = this.to;
      const lines = [
        new Line(this.from, new Point(to.x, this.from.y)),
        new Line(this.from, new Point(this.from.x, to.y)),
        new Line(new Point(to.x, this.from.y), to),
        new Line(new Point(this.from.x, to.y), to)
      ];
      return lines.filter((l) => l.valid);
    }
    transform(matrix) {
      const p1 = Shape.applyTransform([this.from.x, this.from.y], matrix);
      const p2 = Shape.applyTransform([this.from.x + this.width, this.from.y + this.height], matrix);
      const x = Math.min(p1[0], p2[0]);
      const y = Math.min(p1[1], p2[1]);
      const width = Math.abs(p1[0] - p2[0]);
      const height = Math.abs(p1[1] - p2[1]);
      this.from = new Point(x, y);
      this.width = width;
      this.height = height;
      return this;
    }
  }
  const ImageResultDefault = {
    getPageImage(num, name) {
      for (const pageData of this.pages) {
        if (pageData.pageNumber === num) {
          for (const img of pageData.images) {
            if (img.fileName === name) {
              return img;
            }
          }
        }
      }
      return null;
    },
    pages: [],
    total: 0,
    info: void 0,
    metadata: void 0
  };
  var PathGeometry = /* @__PURE__ */ ((PathGeometry2) => {
    PathGeometry2[PathGeometry2["undefined"] = 0] = "undefined";
    PathGeometry2[PathGeometry2["hline"] = 1] = "hline";
    PathGeometry2[PathGeometry2["vline"] = 2] = "vline";
    PathGeometry2[PathGeometry2["rectangle"] = 3] = "rectangle";
    return PathGeometry2;
  })(PathGeometry || {});
  const TextResultDefault = {
    getPageText(num) {
      for (const pageData of this.pages) {
        if (pageData.num === num) return pageData.text;
      }
      return "";
    },
    pages: [],
    total: 0,
    text: "",
    info: void 0,
    metadata: void 0
  };
  if (typeof globalThis.pdfjs === "undefined") {
    globalThis.pdfjs = pdfjs;
  }
  if (typeof window !== "undefined" && typeof document !== "undefined") {
    let workerUrl;
    if (typeof require !== "undefined") {
      workerUrl = require("pdfjs-dist/build/pdf.worker.min.mjs");
      if (GlobalWorkerOptions && !GlobalWorkerOptions.workerSrc) {
        GlobalWorkerOptions.workerSrc = workerUrl;
      }
    } else {
      (async () => {
        const workerModule = await Promise.resolve().then(() => pdf_worker_min$1);
        workerUrl = workerModule.default || workerModule;
        if (GlobalWorkerOptions && !GlobalWorkerOptions.workerSrc) {
          GlobalWorkerOptions.workerSrc = workerUrl;
        }
      })();
    }
  }
  class PDFParse {
    options;
    doc;
    constructor(options) {
      if (typeof options.data === "object" && "buffer" in options.data) {
        options.data = new Uint8Array(options.data);
      }
      options.verbosity = VerbosityLevel.ERRORS;
      this.options = options;
    }
    async GetText() {
      const result = { ...TextResultDefault };
      const infoData = await this.load();
      Object.assign(result, infoData);
      if (this.doc === void 0) {
        throw new Error("PDF document not loaded");
      }
      for (let i = 1; i <= result.total; i++) {
        if (this.shouldParse(i, result.total)) {
          const pageProxy = await this.doc.getPage(i);
          const text = await this.getPageText(pageProxy);
          result.pages.push({
            text,
            num: i
          });
          pageProxy.cleanup();
        }
      }
      await this.doc.destroy();
      this.doc = void 0;
      for (const page of result.pages) {
        result.text += `${page.text}

`;
      }
      return result;
    }
    async load() {
      const opts = { ...this.options };
      if (this.options.data instanceof Uint8Array) {
        opts.data = new Uint8Array(this.options.data);
      }
      const loadingTask = getDocument(opts);
      this.doc = await loadingTask.promise;
      const data = await this.doc.getMetadata();
      return {
        total: this.doc.numPages,
        info: data.info,
        metadata: data.metadata
      };
    }
    shouldParse(currentPage, totalPage) {
      let parseFlag = false;
      if (this.options.partial) {
        if (this.options.first && currentPage <= this.options.first) {
          parseFlag = true;
        }
        if (!parseFlag) {
          if (this.options.last && currentPage > totalPage - this.options.last) {
            parseFlag = true;
          }
        }
      } else {
        parseFlag = true;
      }
      return parseFlag;
    }
    async getPageText(page) {
      const textContent = await page.getTextContent({
        includeMarkedContent: false,
        disableNormalization: false
      });
      const strBuf = [];
      for (const item of textContent.items) {
        if (!("str" in item)) continue;
        strBuf.push(item.str);
        if (item.hasEOL) {
          strBuf.push("\n");
        }
      }
      return strBuf.join("");
    }
    async GetImage() {
      const result = { ...ImageResultDefault };
      const infoData = await this.load();
      Object.assign(result, infoData);
      if (this.doc === void 0) {
        throw new Error("PDF document not loaded");
      }
      for (let i = 1; i <= result.total; i++) {
        if (this.shouldParse(i, result.total)) {
          const page = await this.doc.getPage(i);
          const ops = await page.getOperatorList();
          const pageImages = { pageNumber: i, images: [] };
          result.pages.push(pageImages);
          for (let j = 0; j < ops.fnArray.length; j++) {
            if (ops.fnArray[j] === OPS.paintInlineImageXObject || ops.fnArray[j] === OPS.paintImageXObject) {
              const name = ops.argsArray[j][0];
              const isCommon = page.commonObjs.has(name);
              const imgPromise = isCommon ? this.resolveEmbeddedImage(page.commonObjs, name) : this.resolveEmbeddedImage(page.objs, name);
              const { width, height, kind, data } = await imgPromise;
              const canvasFactory = this.doc.canvasFactory;
              const canvasAndContext = canvasFactory.create(width, height);
              const context = canvasAndContext.context;
              let imgData = null;
              if (kind === util_ImageKind.RGBA_32BPP) {
                imgData = context.createImageData(width, height);
                imgData.data.set(data);
              } else {
                imgData = context.createImageData(width, height);
                this.convertToRGBA({
                  src: data,
                  dest: new Uint32Array(imgData.data.buffer),
                  width,
                  height,
                  kind
                });
              }
              context.putImageData(imgData, 0, 0);
              const buff = canvasAndContext.canvas.toBuffer("image/png");
              const base64 = buff.toString("base64");
              const dataUrl = `data:image/png;base64,${base64}`;
              pageImages.images.push({
                data: buff,
                dataUrl,
                fileName: name,
                height,
                width,
                kind
              });
            }
          }
        }
      }
      await this.doc.destroy();
      this.doc = void 0;
      return result;
    }
    convertToRGBA({ src, dest, width, height, kind }) {
      if (kind === util_ImageKind.RGB_24BPP) {
        for (let i = 0, j = 0; i < src.length; i += 3, j++) {
          const r = src[i];
          const g = src[i + 1];
          const b = src[i + 2];
          dest[j] = 255 << 24 | b << 16 | g << 8 | r;
        }
      } else if (kind === util_ImageKind.GRAYSCALE_1BPP) {
        let pixelIndex = 0;
        for (let i = 0; i < src.length; i++) {
          const byte = src[i];
          for (let bit = 7; bit >= 0; bit--) {
            if (pixelIndex >= width * height) break;
            const isWhite = (byte >> bit & 1) === 1;
            const gray = isWhite ? 255 : 0;
            dest[pixelIndex++] = 255 << 24 | gray << 16 | gray << 8 | gray;
          }
        }
      } else {
        throw new Error(`convertToRGBA: Unsupported image kind: ${kind}`);
      }
    }
    resolveEmbeddedImage(pdfObjects, name) {
      return new Promise((resolve, reject) => {
        pdfObjects.get(name, (imgData) => {
          if (imgData) {
            const dataBuff = new Uint8Array(imgData.data);
            resolve({ width: imgData.width, height: imgData.height, kind: imgData.kind, data: dataBuff });
          } else {
            reject(new Error(`Image object ${name} not found`));
          }
        });
      });
    }
    async PageToImage() {
      const result = { pages: [], total: 0 };
      const infoData = await this.load();
      Object.assign(result, infoData);
      if (this.doc === void 0) {
        throw new Error("PDF document not loaded");
      }
      for (let i = 1; i <= result.total; i++) {
        if (this.shouldParse(i, result.total)) {
          const page = await this.doc.getPage(i);
          const canvasFactory = this.doc.canvasFactory;
          const viewport = page.getViewport({ scale: 1 });
          const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);
          const renderContext = {
            canvasContext: canvasAndContext.context,
            viewport,
            canvas: canvasAndContext.canvas
          };
          const renderTask = page.render(renderContext);
          await renderTask.promise;
          const data = canvasAndContext.canvas.toBuffer("image/png");
          const base64 = data.toString("base64");
          const dataUrl = `data:image/png;base64,${base64}`;
          result.pages.push({
            data,
            dataUrl,
            pageNumber: i
          });
          page.cleanup();
        }
      }
      await this.doc.destroy();
      this.doc = void 0;
      return result;
    }
    async GetTable() {
      const infoData = await this.load();
      const result = { ...infoData, pages: [], mergedTables: [] };
      if (this.doc === void 0) {
        throw new Error("PDF document not loaded");
      }
      for (let i = 1; i <= result.total; i++) {
        if (this.shouldParse(i, result.total)) {
          const page = await this.doc.getPage(i);
          page.getViewport({ scale: 1 });
          const store = await this.getPageTables(page);
          store.normalize();
          const tableDataArr = store.getTableData();
          await this.fillPageTables(page, tableDataArr);
          for (const table of tableDataArr) {
            const pageTableResult = { num: i, tables: table.toArray() };
            result.pages.push(pageTableResult);
          }
          page.cleanup();
        }
      }
      await this.doc.destroy();
      return result;
    }
    getPathGeometry(mm) {
      const width = mm[2] - mm[0];
      const height = mm[3] - mm[1];
      if (mm[0] === Infinity) {
        return PathGeometry.undefined;
      }
      if (width > 5 && height > 5) {
        return PathGeometry.rectangle;
      } else if (width > 5 && height === 0) {
        return PathGeometry.hline;
      } else if (width === 0 && height > 5) {
        return PathGeometry.vline;
      }
      return PathGeometry.undefined;
    }
    async getPageTables(page) {
      const lineStore = new LineStore();
      const viewport = page.getViewport({ scale: 1 });
      let transformMatrix = [1, 0, 0, 1, 0, 0];
      const transformStack = [];
      const opList = await page.getOperatorList();
      for (let i = 0; i < opList.fnArray.length; i++) {
        const fn = opList.fnArray[i];
        const args = opList.argsArray[i];
        const op = args?.[0] ?? 0;
        const mm = args?.[2] ?? [Infinity, Infinity, -Infinity, -Infinity];
        if (fn === OPS.constructPath) {
          if (op === OPS.fill) ;
          if (op !== OPS.stroke) {
            continue;
          }
          const pg = this.getPathGeometry(mm);
          if (pg === PathGeometry.rectangle) {
            const rect = new Rectangle(new Point(mm[0], mm[1]), mm[2] - mm[0], mm[3] - mm[1]);
            rect.transform(transformMatrix);
            rect.transform(viewport.transform);
            lineStore.addRectangle(rect);
          } else if (pg === PathGeometry.hline || pg === PathGeometry.vline) {
            const from = new Point(mm[0], mm[1]);
            const to = new Point(mm[2], mm[3]);
            const line = new Line(from, to);
            line.transform(transformMatrix);
            line.transform(viewport.transform);
            lineStore.add(line);
          } else {
            debugger;
          }
        } else if (fn === OPS.setLineWidth) {
          debugger;
        } else if (fn === OPS.save) {
          transformStack.push(transformMatrix);
        } else if (fn === OPS.restore) {
          const restoredMatrix = transformStack.pop();
          if (restoredMatrix) {
            transformMatrix = restoredMatrix;
          }
        } else if (fn === OPS.transform) {
          transformMatrix = Util.transform(transformMatrix, args);
        }
      }
      return lineStore;
    }
    async getPageGeometry(page) {
      const lineStore = new LineStore();
      const opList = await page.getOperatorList();
      const viewport = page.getViewport({ scale: 1 });
      let transformMatrix = [1, 0, 0, 1, 0, 0];
      const transformStack = [];
      let current_x = 0;
      let current_y = 0;
      for (let j = 0; j < opList.fnArray.length; j++) {
        const fn = opList.fnArray[j];
        const args = opList.argsArray[j];
        if (fn === OPS.constructPath) {
          while (args[0].length) {
            const op = args[0].shift();
            const combinedMatrix = Util.transform(viewport.transform, transformMatrix);
            if (op === OPS.rectangle) {
              const x = args[1].shift();
              const y = args[1].shift();
              const width = args[1].shift();
              const height = args[1].shift();
              if (Math.min(width, height) <= 2) {
                debugger;
              }
              const rect = new Rectangle(new Point(x, y), width, height);
              rect.transform(combinedMatrix);
              lineStore.addRectangle(rect);
            } else if (op === OPS.moveTo) {
              current_x = args[1].shift();
              current_y = args[1].shift();
            } else if (op === OPS.lineTo) {
              const x = args[1].shift();
              const y = args[1].shift();
              const from = new Point(current_x, current_y);
              const to = new Point(x, y);
              const line = new Line(from, to);
              line.transform(combinedMatrix);
              lineStore.add(line);
              current_x = x;
              current_y = y;
            }
          }
        } else if (fn === OPS.save) {
          transformStack.push(transformMatrix);
        } else if (fn === OPS.restore) {
          const restoredMatrix = transformStack.pop();
          if (restoredMatrix) {
            transformMatrix = restoredMatrix;
          }
        } else if (fn === OPS.transform) {
          transformMatrix = Util.transform(transformMatrix, args);
        }
      }
      return lineStore;
    }
    async fillPageTables(page, pageTables) {
      const viewport = page.getViewport({ scale: 1 });
      const textContent = await page.getTextContent({
        includeMarkedContent: false,
        disableNormalization: false
      });
      for (const textItem of textContent.items) {
        if (!("str" in textItem)) continue;
        const tx = Util.transform(Util.transform(viewport.transform, textItem.transform), [1, 0, 0, -1, 0, 0]);
        for (const pageTable of pageTables) {
          const cell = pageTable.findCell(tx[4], tx[5]);
          if (cell) {
            cell.text.push(textItem.str);
            if (textItem.hasEOL) {
              cell.text.push("\n");
            }
            break;
          }
        }
      }
    }
  }
  async function pdf(data) {
    let parser;
    if (data instanceof URL) {
      parser = new PDFParse({ url: data });
    } else {
      parser = new PDFParse({ data });
    }
    const text = await parser.GetText();
    return text;
  }
  const pdf_worker_min = "data:text/javascript;base64,LyoqCiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZQogKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlCiAqCiAqIENvcHlyaWdodCAyMDI0IE1vemlsbGEgRm91bmRhdGlvbgogKgogKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgogKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKICoKICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAogKgogKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgogKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgogKgogKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGUKICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZQogKi8KLyoqCiAqIHBkZmpzVmVyc2lvbiA9IDUuNC4xNDkKICogcGRmanNCdWlsZCA9IDllMmU5ZTIwOQogKi9jb25zdCBlPSEoIm9iamVjdCIhPXR5cGVvZiBwcm9jZXNzfHxwcm9jZXNzKyIiIT0iW29iamVjdCBwcm9jZXNzXSJ8fHByb2Nlc3MudmVyc2lvbnMubnd8fHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24mJnByb2Nlc3MudHlwZSYmImJyb3dzZXIiIT09cHJvY2Vzcy50eXBlKSx0PVsuMDAxLDAsMCwuMDAxLDAsMF0sYT0xLjM1LHI9LjM1LGk9LjI1OTI1OTI1OTI1OTI1OTI0LG49MSxzPTIsbz00LGM9OCxsPTE2LGg9NjQsdT0xMjgsZD0yNTYsZj0icGRmanNfaW50ZXJuYWxfZWRpdG9yXyIsZz0zLHA9OSxtPTEzLGI9MTUseT0xMDEsdz17UFJJTlQ6NCxNT0RJRllfQ09OVEVOVFM6OCxDT1BZOjE2LE1PRElGWV9BTk5PVEFUSU9OUzozMixGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOjI1NixDT1BZX0ZPUl9BQ0NFU1NJQklMSVRZOjUxMixBU1NFTUJMRToxMDI0LFBSSU5UX0hJR0hfUVVBTElUWToyMDQ4fSx4PTAsUz00LGs9MSxDPTIsdj0zLEY9e1RFWFQ6MSxMSU5LOjIsRlJFRVRFWFQ6MyxMSU5FOjQsU1FVQVJFOjUsQ0lSQ0xFOjYsUE9MWUdPTjo3LFBPTFlMSU5FOjgsSElHSExJR0hUOjksVU5ERVJMSU5FOjEwLFNRVUlHR0xZOjExLFNUUklLRU9VVDoxMixTVEFNUDoxMyxDQVJFVDoxNCxJTks6MTUsUE9QVVA6MTYsRklMRUFUVEFDSE1FTlQ6MTcsU09VTkQ6MTgsTU9WSUU6MTksV0lER0VUOjIwLFNDUkVFTjoyMSxQUklOVEVSTUFSSzoyMixUUkFQTkVUOjIzLFdBVEVSTUFSSzoyNCxUSFJFRUQ6MjUsUkVEQUNUOjI2fSxUPSJHcm91cCIsTz0iUiIsTT0xLEQ9MixSPTQsTj0xNixFPTMyLEw9MTI4LGo9NTEyLF89MSxVPTIsWD00MDk2LHE9ODE5MixIPTMyNzY4LFc9NjU1MzYsej0xMzEwNzIsJD0xMDQ4NTc2LEc9MjA5NzE1MixWPTgzODg2MDgsSz0xNjc3NzIxNixKPTEsWT0yLFo9MyxRPTQsZWU9NSx0ZT17RToiTW91c2UgRW50ZXIiLFg6Ik1vdXNlIEV4aXQiLEQ6Ik1vdXNlIERvd24iLFU6Ik1vdXNlIFVwIixGbzoiRm9jdXMiLEJsOiJCbHVyIixQTzoiUGFnZU9wZW4iLFBDOiJQYWdlQ2xvc2UiLFBWOiJQYWdlVmlzaWJsZSIsUEk6IlBhZ2VJbnZpc2libGUiLEs6IktleXN0cm9rZSIsRjoiRm9ybWF0IixWOiJWYWxpZGF0ZSIsQzoiQ2FsY3VsYXRlIn0sYWU9e1dDOiJXaWxsQ2xvc2UiLFdTOiJXaWxsU2F2ZSIsRFM6IkRpZFNhdmUiLFdQOiJXaWxsUHJpbnQiLERQOiJEaWRQcmludCJ9LHJlPXtPOiJQYWdlT3BlbiIsQzoiUGFnZUNsb3NlIn0saWU9MSxuZT01LHNlPTEsb2U9MixjZT0zLGxlPTQsaGU9NSx1ZT02LGRlPTcsZmU9OCxnZT05LHBlPTEwLG1lPTExLGJlPTEyLHllPTEzLHdlPTE0LHhlPTE1LFNlPTE2LEFlPTE3LGtlPTE4LENlPTE5LHZlPTIwLEZlPTIxLEllPTIyLFRlPTIzLE9lPTI0LE1lPTI1LERlPTI2LEJlPTI3LFJlPTI4LE5lPTI5LEVlPTMwLFBlPTMxLExlPTMyLGplPTMzLF9lPTM0LFVlPTM1LFhlPTM2LHFlPTM3LEhlPTM4LFdlPTM5LHplPTQwLCRlPTQxLEdlPTQyLFZlPTQzLEtlPTQ0LEplPTQ1LFllPTQ2LFplPTQ3LFFlPTQ4LGV0PTQ5LHR0PTUwLGF0PTUxLHJ0PTUyLGl0PTUzLG50PTU0LHN0PTU1LG90PTU2LGN0PTU3LGx0PTU4LGh0PTU5LHV0PTYwLGR0PTYxLGZ0PTYyLGd0PTYzLHB0PTY0LG10PTY1LGJ0PTY2LHl0PTY3LHd0PTY4LHh0PTY5LFN0PTcwLEF0PTcxLGt0PTcyLEN0PTczLHZ0PTc0LEZ0PTc1LEl0PTc2LFR0PTc3LE90PTgwLE10PTgxLER0PTgzLEJ0PTg0LFJ0PTg1LE50PTg2LEV0PTg3LFB0PTg4LEx0PTg5LGp0PTkwLF90PTkxLFV0PTkyLFh0PTkzLHF0PTk0LEh0PTAsV3Q9MSx6dD0yLCR0PTMsR3Q9MSxWdD0yO2xldCBLdD1pZTtmdW5jdGlvbiBnZXRWZXJib3NpdHlMZXZlbCgpe3JldHVybiBLdH1mdW5jdGlvbiBpbmZvKGUpe0t0Pj1uZSYmY29uc29sZS5sb2coYEluZm86ICR7ZX1gKX1mdW5jdGlvbiB3YXJuKGUpe0t0Pj1pZSYmY29uc29sZS5sb2coYFdhcm5pbmc6ICR7ZX1gKX1mdW5jdGlvbiB1bnJlYWNoYWJsZShlKXt0aHJvdyBuZXcgRXJyb3IoZSl9ZnVuY3Rpb24gYXNzZXJ0KGUsdCl7ZXx8dW5yZWFjaGFibGUodCl9ZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybChlLHQ9bnVsbCxhPW51bGwpe2lmKCFlKXJldHVybiBudWxsO2lmKGEmJiJzdHJpbmciPT10eXBlb2YgZSl7aWYoYS5hZGREZWZhdWx0UHJvdG9jb2wmJmUuc3RhcnRzV2l0aCgid3d3LiIpKXtjb25zdCB0PWUubWF0Y2goL1wuL2cpO3Q/Lmxlbmd0aD49MiYmKGU9YGh0dHA6Ly8ke2V9YCl9aWYoYS50cnlDb252ZXJ0RW5jb2RpbmcpdHJ5e2U9c3RyaW5nVG9VVEY4U3RyaW5nKGUpfWNhdGNoe319Y29uc3Qgcj10P1VSTC5wYXJzZShlLHQpOlVSTC5wYXJzZShlKTtyZXR1cm4gZnVuY3Rpb24gX2lzVmFsaWRQcm90b2NvbChlKXtzd2l0Y2goZT8ucHJvdG9jb2wpe2Nhc2UiaHR0cDoiOmNhc2UiaHR0cHM6IjpjYXNlImZ0cDoiOmNhc2UibWFpbHRvOiI6Y2FzZSJ0ZWw6IjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX0ocik/cjpudWxsfWZ1bmN0aW9uIHNoYWRvdyhlLHQsYSxyPSExKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTphLGVudW1lcmFibGU6IXIsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiExfSk7cmV0dXJuIGF9Y29uc3QgSnQ9ZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKXtmdW5jdGlvbiBCYXNlRXhjZXB0aW9uKGUsdCl7dGhpcy5tZXNzYWdlPWU7dGhpcy5uYW1lPXR9QmFzZUV4Y2VwdGlvbi5wcm90b3R5cGU9bmV3IEVycm9yO0Jhc2VFeGNlcHRpb24uY29uc3RydWN0b3I9QmFzZUV4Y2VwdGlvbjtyZXR1cm4gQmFzZUV4Y2VwdGlvbn0oKTtjbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSwiUGFzc3dvcmRFeGNlcHRpb24iKTt0aGlzLmNvZGU9dH19Y2xhc3MgVW5rbm93bkVycm9yRXhjZXB0aW9uIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLCJVbmtub3duRXJyb3JFeGNlcHRpb24iKTt0aGlzLmRldGFpbHM9dH19Y2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIkludmFsaWRQREZFeGNlcHRpb24iKX19Y2xhc3MgUmVzcG9uc2VFeGNlcHRpb24gZXh0ZW5kcyBKdHtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoZSwiUmVzcG9uc2VFeGNlcHRpb24iKTt0aGlzLnN0YXR1cz10O3RoaXMubWlzc2luZz1hfX1jbGFzcyBGb3JtYXRFcnJvciBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIkZvcm1hdEVycm9yIil9fWNsYXNzIEFib3J0RXhjZXB0aW9uIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiQWJvcnRFeGNlcHRpb24iKX19ZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhlKXsib2JqZWN0Ij09dHlwZW9mIGUmJnZvaWQgMCE9PWU/Lmxlbmd0aHx8dW5yZWFjaGFibGUoIkludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmciKTtjb25zdCB0PWUubGVuZ3RoLGE9ODE5MjtpZih0PGEpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlKTtjb25zdCByPVtdO2ZvcihsZXQgaT0wO2k8dDtpKz1hKXtjb25zdCBuPU1hdGgubWluKGkrYSx0KSxzPWUuc3ViYXJyYXkoaSxuKTtyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHMpKX1yZXR1cm4gci5qb2luKCIiKX1mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKGUpeyJzdHJpbmciIT10eXBlb2YgZSYmdW5yZWFjaGFibGUoIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXMiKTtjb25zdCB0PWUubGVuZ3RoLGE9bmV3IFVpbnQ4QXJyYXkodCk7Zm9yKGxldCByPTA7cjx0OysrcilhW3JdPTI1NSZlLmNoYXJDb2RlQXQocik7cmV0dXJuIGF9ZnVuY3Rpb24gc3RyaW5nMzIoZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZT4+MjQmMjU1LGU+PjE2JjI1NSxlPj44JjI1NSwyNTUmZSl9ZnVuY3Rpb24gb2JqZWN0U2l6ZShlKXtyZXR1cm4gT2JqZWN0LmtleXMoZSkubGVuZ3RofWNsYXNzIEZlYXR1cmVUZXN0e3N0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKXtyZXR1cm4gc2hhZG93KHRoaXMsImlzTGl0dGxlRW5kaWFuIixmdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpe2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkoNCk7ZVswXT0xO3JldHVybiAxPT09bmV3IFVpbnQzMkFycmF5KGUuYnVmZmVyLDAsMSlbMF19KCkpfXN0YXRpYyBnZXQgaXNFdmFsU3VwcG9ydGVkKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJpc0V2YWxTdXBwb3J0ZWQiLGZ1bmN0aW9uIGlzRXZhbFN1cHBvcnRlZCgpe3RyeXtuZXcgRnVuY3Rpb24oIiIpO3JldHVybiEwfWNhdGNoe3JldHVybiExfX0oKSl9c3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpe3JldHVybiBzaGFkb3codGhpcywiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQiLCJ1bmRlZmluZWQiIT10eXBlb2YgT2Zmc2NyZWVuQ2FudmFzKX1zdGF0aWMgZ2V0IGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCIsInVuZGVmaW5lZCIhPXR5cGVvZiBJbWFnZURlY29kZXIpfXN0YXRpYyBnZXQgcGxhdGZvcm0oKXtjb25zdHtwbGF0Zm9ybTplLHVzZXJBZ2VudDp0fT1uYXZpZ2F0b3I7cmV0dXJuIHNoYWRvdyh0aGlzLCJwbGF0Zm9ybSIse2lzQW5kcm9pZDp0LmluY2x1ZGVzKCJBbmRyb2lkIiksaXNMaW51eDplLmluY2x1ZGVzKCJMaW51eCIpLGlzTWFjOmUuaW5jbHVkZXMoIk1hYyIpLGlzV2luZG93czplLmluY2x1ZGVzKCJXaW4iKSxpc0ZpcmVmb3g6dC5pbmNsdWRlcygiRmlyZWZveCIpfSl9c3RhdGljIGdldCBpc0NTU1JvdW5kU3VwcG9ydGVkKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJpc0NTU1JvdW5kU3VwcG9ydGVkIixnbG9iYWxUaGlzLkNTUz8uc3VwcG9ydHM/Ligid2lkdGg6IHJvdW5kKDEuNXB4LCAxcHgpIikpfX1jb25zdCBZdD1BcnJheS5mcm9tKEFycmF5KDI1Nikua2V5cygpLChlPT5lLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCIwIikpKTtjbGFzcyBVdGlse3N0YXRpYyBtYWtlSGV4Q29sb3IoZSx0LGEpe3JldHVybmAjJHtZdFtlXX0ke1l0W3RdfSR7WXRbYV19YH1zdGF0aWMgZG9tTWF0cml4VG9UcmFuc2Zvcm0oZSl7cmV0dXJuW2UuYSxlLmIsZS5jLGUuZCxlLmUsZS5mXX1zdGF0aWMgc2NhbGVNaW5NYXgoZSx0KXtsZXQgYTtpZihlWzBdKXtpZihlWzBdPDApe2E9dFswXTt0WzBdPXRbMl07dFsyXT1hfXRbMF0qPWVbMF07dFsyXSo9ZVswXTtpZihlWzNdPDApe2E9dFsxXTt0WzFdPXRbM107dFszXT1hfXRbMV0qPWVbM107dFszXSo9ZVszXX1lbHNle2E9dFswXTt0WzBdPXRbMV07dFsxXT1hO2E9dFsyXTt0WzJdPXRbM107dFszXT1hO2lmKGVbMV08MCl7YT10WzFdO3RbMV09dFszXTt0WzNdPWF9dFsxXSo9ZVsxXTt0WzNdKj1lWzFdO2lmKGVbMl08MCl7YT10WzBdO3RbMF09dFsyXTt0WzJdPWF9dFswXSo9ZVsyXTt0WzJdKj1lWzJdfXRbMF0rPWVbNF07dFsxXSs9ZVs1XTt0WzJdKz1lWzRdO3RbM10rPWVbNV19c3RhdGljIHRyYW5zZm9ybShlLHQpe3JldHVybltlWzBdKnRbMF0rZVsyXSp0WzFdLGVbMV0qdFswXStlWzNdKnRbMV0sZVswXSp0WzJdK2VbMl0qdFszXSxlWzFdKnRbMl0rZVszXSp0WzNdLGVbMF0qdFs0XStlWzJdKnRbNV0rZVs0XSxlWzFdKnRbNF0rZVszXSp0WzVdK2VbNV1dfXN0YXRpYyBtdWx0aXBseUJ5RE9NTWF0cml4KGUsdCl7cmV0dXJuW2VbMF0qdC5hK2VbMl0qdC5iLGVbMV0qdC5hK2VbM10qdC5iLGVbMF0qdC5jK2VbMl0qdC5kLGVbMV0qdC5jK2VbM10qdC5kLGVbMF0qdC5lK2VbMl0qdC5mK2VbNF0sZVsxXSp0LmUrZVszXSp0LmYrZVs1XV19c3RhdGljIGFwcGx5VHJhbnNmb3JtKGUsdCxhPTApe2NvbnN0IHI9ZVthXSxpPWVbYSsxXTtlW2FdPXIqdFswXStpKnRbMl0rdFs0XTtlW2ErMV09cip0WzFdK2kqdFszXSt0WzVdfXN0YXRpYyBhcHBseVRyYW5zZm9ybVRvQmV6aWVyKGUsdCxhPTApe2NvbnN0IHI9dFswXSxpPXRbMV0sbj10WzJdLHM9dFszXSxvPXRbNF0sYz10WzVdO2ZvcihsZXQgdD0wO3Q8Njt0Kz0yKXtjb25zdCBsPWVbYSt0XSxoPWVbYSt0KzFdO2VbYSt0XT1sKnIraCpuK287ZVthK3QrMV09bCppK2gqcytjfX1zdGF0aWMgYXBwbHlJbnZlcnNlVHJhbnNmb3JtKGUsdCl7Y29uc3QgYT1lWzBdLHI9ZVsxXSxpPXRbMF0qdFszXS10WzFdKnRbMl07ZVswXT0oYSp0WzNdLXIqdFsyXSt0WzJdKnRbNV0tdFs0XSp0WzNdKS9pO2VbMV09KC1hKnRbMV0rcip0WzBdK3RbNF0qdFsxXS10WzVdKnRbMF0pL2l9c3RhdGljIGF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGUsdCxhKXtjb25zdCByPXRbMF0saT10WzFdLG49dFsyXSxzPXRbM10sbz10WzRdLGM9dFs1XSxsPWVbMF0saD1lWzFdLHU9ZVsyXSxkPWVbM107bGV0IGY9cipsK28sZz1mLHA9cip1K28sbT1wLGI9cypoK2MseT1iLHc9cypkK2MseD13O2lmKDAhPT1pfHwwIT09bil7Y29uc3QgZT1pKmwsdD1pKnUsYT1uKmgscj1uKmQ7Zis9YTttKz1hO3ArPXI7Zys9cjtiKz1lO3grPWU7dys9dDt5Kz10fWFbMF09TWF0aC5taW4oYVswXSxmLHAsZyxtKTthWzFdPU1hdGgubWluKGFbMV0sYix3LHkseCk7YVsyXT1NYXRoLm1heChhWzJdLGYscCxnLG0pO2FbM109TWF0aC5tYXgoYVszXSxiLHcseSx4KX1zdGF0aWMgaW52ZXJzZVRyYW5zZm9ybShlKXtjb25zdCB0PWVbMF0qZVszXS1lWzFdKmVbMl07cmV0dXJuW2VbM10vdCwtZVsxXS90LC1lWzJdL3QsZVswXS90LChlWzJdKmVbNV0tZVs0XSplWzNdKS90LChlWzRdKmVbMV0tZVs1XSplWzBdKS90XX1zdGF0aWMgc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoZSx0KXtjb25zdCBhPWVbMF0scj1lWzFdLGk9ZVsyXSxuPWVbM10scz1hKioyK3IqKjIsbz1hKmkrcipuLGM9aSoqMituKioyLGw9KHMrYykvMixoPU1hdGguc3FydChsKioyLShzKmMtbyoqMikpO3RbMF09TWF0aC5zcXJ0KGwraHx8MSk7dFsxXT1NYXRoLnNxcnQobC1ofHwxKX1zdGF0aWMgbm9ybWFsaXplUmVjdChlKXtjb25zdCB0PWUuc2xpY2UoMCk7aWYoZVswXT5lWzJdKXt0WzBdPWVbMl07dFsyXT1lWzBdfWlmKGVbMV0+ZVszXSl7dFsxXT1lWzNdO3RbM109ZVsxXX1yZXR1cm4gdH1zdGF0aWMgaW50ZXJzZWN0KGUsdCl7Y29uc3QgYT1NYXRoLm1heChNYXRoLm1pbihlWzBdLGVbMl0pLE1hdGgubWluKHRbMF0sdFsyXSkpLHI9TWF0aC5taW4oTWF0aC5tYXgoZVswXSxlWzJdKSxNYXRoLm1heCh0WzBdLHRbMl0pKTtpZihhPnIpcmV0dXJuIG51bGw7Y29uc3QgaT1NYXRoLm1heChNYXRoLm1pbihlWzFdLGVbM10pLE1hdGgubWluKHRbMV0sdFszXSkpLG49TWF0aC5taW4oTWF0aC5tYXgoZVsxXSxlWzNdKSxNYXRoLm1heCh0WzFdLHRbM10pKTtyZXR1cm4gaT5uP251bGw6W2EsaSxyLG5dfXN0YXRpYyBwb2ludEJvdW5kaW5nQm94KGUsdCxhKXthWzBdPU1hdGgubWluKGFbMF0sZSk7YVsxXT1NYXRoLm1pbihhWzFdLHQpO2FbMl09TWF0aC5tYXgoYVsyXSxlKTthWzNdPU1hdGgubWF4KGFbM10sdCl9c3RhdGljIHJlY3RCb3VuZGluZ0JveChlLHQsYSxyLGkpe2lbMF09TWF0aC5taW4oaVswXSxlLGEpO2lbMV09TWF0aC5taW4oaVsxXSx0LHIpO2lbMl09TWF0aC5tYXgoaVsyXSxlLGEpO2lbM109TWF0aC5tYXgoaVszXSx0LHIpfXN0YXRpYyNlKGUsdCxhLHIsaSxuLHMsbyxjLGwpe2lmKGM8PTB8fGM+PTEpcmV0dXJuO2NvbnN0IGg9MS1jLHU9YypjLGQ9dSpjLGY9aCooaCooaCplKzMqYyp0KSszKnUqYSkrZCpyLGc9aCooaCooaCppKzMqYypuKSszKnUqcykrZCpvO2xbMF09TWF0aC5taW4obFswXSxmKTtsWzFdPU1hdGgubWluKGxbMV0sZyk7bFsyXT1NYXRoLm1heChsWzJdLGYpO2xbM109TWF0aC5tYXgobFszXSxnKX1zdGF0aWMjdChlLHQsYSxyLGksbixzLG8sYyxsLGgsdSl7aWYoTWF0aC5hYnMoYyk8MWUtMTIpe01hdGguYWJzKGwpPj0xZS0xMiYmdGhpcy4jZShlLHQsYSxyLGksbixzLG8sLWgvbCx1KTtyZXR1cm59Y29uc3QgZD1sKioyLTQqaCpjO2lmKGQ8MClyZXR1cm47Y29uc3QgZj1NYXRoLnNxcnQoZCksZz0yKmM7dGhpcy4jZShlLHQsYSxyLGksbixzLG8sKC1sK2YpL2csdSk7dGhpcy4jZShlLHQsYSxyLGksbixzLG8sKC1sLWYpL2csdSl9c3RhdGljIGJlemllckJvdW5kaW5nQm94KGUsdCxhLHIsaSxuLHMsbyxjKXtjWzBdPU1hdGgubWluKGNbMF0sZSxzKTtjWzFdPU1hdGgubWluKGNbMV0sdCxvKTtjWzJdPU1hdGgubWF4KGNbMl0sZSxzKTtjWzNdPU1hdGgubWF4KGNbM10sdCxvKTt0aGlzLiN0KGUsYSxpLHMsdCxyLG4sbywzKigzKihhLWkpLWUrcyksNiooZS0yKmEraSksMyooYS1lKSxjKTt0aGlzLiN0KGUsYSxpLHMsdCxyLG4sbywzKigzKihyLW4pLXQrbyksNioodC0yKnIrbiksMyooci10KSxjKX19Y29uc3QgWnQ9WzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDcyOCw3MTEsNzEwLDcyOSw3MzMsNzMxLDczMCw3MzIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsODIyNiw4MjI0LDgyMjUsODIzMCw4MjEyLDgyMTEsNDAyLDgyNjAsODI0OSw4MjUwLDg3MjIsODI0MCw4MjIyLDgyMjAsODIyMSw4MjE2LDgyMTcsODIxOCw4NDgyLDY0MjU3LDY0MjU4LDMyMSwzMzgsMzUyLDM3NiwzODEsMzA1LDMyMiwzMzksMzUzLDM4MiwwLDgzNjRdO2Z1bmN0aW9uIHN0cmluZ1RvUERGU3RyaW5nKGUsdD0hMSl7aWYoZVswXT49IsOvIil7bGV0IGE7aWYoIsO+Ij09PWVbMF0mJiLDvyI9PT1lWzFdKXthPSJ1dGYtMTZiZSI7ZS5sZW5ndGglMj09MSYmKGU9ZS5zbGljZSgwLC0xKSl9ZWxzZSBpZigiw78iPT09ZVswXSYmIsO+Ij09PWVbMV0pe2E9InV0Zi0xNmxlIjtlLmxlbmd0aCUyPT0xJiYoZT1lLnNsaWNlKDAsLTEpKX1lbHNlIsOvIj09PWVbMF0mJiLCuyI9PT1lWzFdJiYiwr8iPT09ZVsyXSYmKGE9InV0Zi04Iik7aWYoYSl0cnl7Y29uc3Qgcj1uZXcgVGV4dERlY29kZXIoYSx7ZmF0YWw6ITB9KSxpPXN0cmluZ1RvQnl0ZXMoZSksbj1yLmRlY29kZShpKTtyZXR1cm4gdHx8IW4uaW5jbHVkZXMoIhsiKT9uOm4ucmVwbGFjZUFsbCgvXHgxYlteXHgxYl0qKD86XHgxYnwkKS9nLCIiKX1jYXRjaChlKXt3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogIiR7ZX0iLmApfX1jb25zdCBhPVtdO2ZvcihsZXQgcj0wLGk9ZS5sZW5ndGg7cjxpO3IrKyl7Y29uc3Qgbj1lLmNoYXJDb2RlQXQocik7aWYoIXQmJjI3PT09bil7Zm9yKDsrK3I8aSYmMjchPT1lLmNoYXJDb2RlQXQocik7KTtjb250aW51ZX1jb25zdCBzPVp0W25dO2EucHVzaChzP1N0cmluZy5mcm9tQ2hhckNvZGUocyk6ZS5jaGFyQXQocikpfXJldHVybiBhLmpvaW4oIiIpfWZ1bmN0aW9uIHN0cmluZ1RvVVRGOFN0cmluZyhlKXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlKSl9ZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKGUpe3JldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoZSkpfWZ1bmN0aW9uIGlzQXJyYXlFcXVhbChlLHQpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBhPTAscj1lLmxlbmd0aDthPHI7YSsrKWlmKGVbYV0hPT10W2FdKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGdldE1vZGlmaWNhdGlvbkRhdGUoZT1uZXcgRGF0ZSl7ZSBpbnN0YW5jZW9mIERhdGV8fChlPW5ldyBEYXRlKGUpKTtyZXR1cm5bZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCksKGUuZ2V0VVRDTW9udGgoKSsxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIjAiKSxlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIjAiKSxlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCIwIiksZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCIwIiksZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCIwIildLmpvaW4oIiIpfWxldCBRdD1udWxsLGVhPW51bGw7ZnVuY3Rpb24gTWF0aENsYW1wKGUsdCxhKXtyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZSx0KSxhKX1mdW5jdGlvbiB0b0hleFV0aWwoZSl7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLnRvSGV4P2UudG9IZXgoKTpBcnJheS5mcm9tKGUsKGU9Pll0W2VdKSkuam9pbigiIil9ImZ1bmN0aW9uIiE9dHlwZW9mIFByb21pc2UudHJ5JiYoUHJvbWlzZS50cnk9ZnVuY3Rpb24oZSwuLi50KXtyZXR1cm4gbmV3IFByb21pc2UoKGE9PnthKGUoLi4udCkpfSkpfSk7ImZ1bmN0aW9uIiE9dHlwZW9mIE1hdGguc3VtUHJlY2lzZSYmKE1hdGguc3VtUHJlY2lzZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5yZWR1Y2UoKChlLHQpPT5lK3QpLDApfSk7Y29uc3QgdGE9U3ltYm9sKCJDSVJDVUxBUl9SRUYiKSxhYT1TeW1ib2woIkVPRiIpO2xldCByYT1PYmplY3QuY3JlYXRlKG51bGwpLGlhPU9iamVjdC5jcmVhdGUobnVsbCksbmE9T2JqZWN0LmNyZWF0ZShudWxsKTtjbGFzcyBOYW1le2NvbnN0cnVjdG9yKGUpe3RoaXMubmFtZT1lfXN0YXRpYyBnZXQoZSl7cmV0dXJuIGlhW2VdfHw9bmV3IE5hbWUoZSl9fWNsYXNzIENtZHtjb25zdHJ1Y3RvcihlKXt0aGlzLmNtZD1lfXN0YXRpYyBnZXQoZSl7cmV0dXJuIHJhW2VdfHw9bmV3IENtZChlKX19Y29uc3Qgc2E9ZnVuY3Rpb24gbm9uU2VyaWFsaXphYmxlQ2xvc3VyZSgpe3JldHVybiBzYX07Y2xhc3MgRGljdHtjb25zdHJ1Y3RvcihlPW51bGwpe3RoaXMuX21hcD1uZXcgTWFwO3RoaXMueHJlZj1lO3RoaXMub2JqSWQ9bnVsbDt0aGlzLnN1cHByZXNzRW5jcnlwdGlvbj0hMTt0aGlzLl9fbm9uU2VyaWFsaXphYmxlX189c2F9YXNzaWduWHJlZihlKXt0aGlzLnhyZWY9ZX1nZXQgc2l6ZSgpe3JldHVybiB0aGlzLl9tYXAuc2l6ZX1nZXQoZSx0LGEpe2xldCByPXRoaXMuX21hcC5nZXQoZSk7aWYodm9pZCAwPT09ciYmdm9pZCAwIT09dCl7cj10aGlzLl9tYXAuZ2V0KHQpO3ZvaWQgMD09PXImJnZvaWQgMCE9PWEmJihyPXRoaXMuX21hcC5nZXQoYSkpfXJldHVybiByIGluc3RhbmNlb2YgUmVmJiZ0aGlzLnhyZWY/dGhpcy54cmVmLmZldGNoKHIsdGhpcy5zdXBwcmVzc0VuY3J5cHRpb24pOnJ9YXN5bmMgZ2V0QXN5bmMoZSx0LGEpe2xldCByPXRoaXMuX21hcC5nZXQoZSk7aWYodm9pZCAwPT09ciYmdm9pZCAwIT09dCl7cj10aGlzLl9tYXAuZ2V0KHQpO3ZvaWQgMD09PXImJnZvaWQgMCE9PWEmJihyPXRoaXMuX21hcC5nZXQoYSkpfXJldHVybiByIGluc3RhbmNlb2YgUmVmJiZ0aGlzLnhyZWY/dGhpcy54cmVmLmZldGNoQXN5bmMocix0aGlzLnN1cHByZXNzRW5jcnlwdGlvbik6cn1nZXRBcnJheShlLHQsYSl7bGV0IHI9dGhpcy5fbWFwLmdldChlKTtpZih2b2lkIDA9PT1yJiZ2b2lkIDAhPT10KXtyPXRoaXMuX21hcC5nZXQodCk7dm9pZCAwPT09ciYmdm9pZCAwIT09YSYmKHI9dGhpcy5fbWFwLmdldChhKSl9ciBpbnN0YW5jZW9mIFJlZiYmdGhpcy54cmVmJiYocj10aGlzLnhyZWYuZmV0Y2gocix0aGlzLnN1cHByZXNzRW5jcnlwdGlvbikpO2lmKEFycmF5LmlzQXJyYXkocikpe3I9ci5zbGljZSgpO2ZvcihsZXQgZT0wLHQ9ci5sZW5ndGg7ZTx0O2UrKylyW2VdaW5zdGFuY2VvZiBSZWYmJnRoaXMueHJlZiYmKHJbZV09dGhpcy54cmVmLmZldGNoKHJbZV0sdGhpcy5zdXBwcmVzc0VuY3J5cHRpb24pKX1yZXR1cm4gcn1nZXRSYXcoZSl7cmV0dXJuIHRoaXMuX21hcC5nZXQoZSl9Z2V0S2V5cygpe3JldHVyblsuLi50aGlzLl9tYXAua2V5cygpXX1nZXRSYXdWYWx1ZXMoKXtyZXR1cm5bLi4udGhpcy5fbWFwLnZhbHVlcygpXX1zZXQoZSx0KXt0aGlzLl9tYXAuc2V0KGUsdCl9c2V0SWZOb3RFeGlzdHMoZSx0KXt0aGlzLmhhcyhlKXx8dGhpcy5zZXQoZSx0KX1zZXRJZk51bWJlcihlLHQpeyJudW1iZXIiPT10eXBlb2YgdCYmdGhpcy5zZXQoZSx0KX1zZXRJZkFycmF5KGUsdCl7KEFycmF5LmlzQXJyYXkodCl8fEFycmF5QnVmZmVyLmlzVmlldyh0KSkmJnRoaXMuc2V0KGUsdCl9c2V0SWZEZWZpbmVkKGUsdCl7bnVsbCE9dCYmdGhpcy5zZXQoZSx0KX1zZXRJZk5hbWUoZSx0KXsic3RyaW5nIj09dHlwZW9mIHQ/dGhpcy5zZXQoZSxOYW1lLmdldCh0KSk6dCBpbnN0YW5jZW9mIE5hbWUmJnRoaXMuc2V0KGUsdCl9aGFzKGUpe3JldHVybiB0aGlzLl9tYXAuaGFzKGUpfSpbU3ltYm9sLml0ZXJhdG9yXSgpe2Zvcihjb25zdFtlLHRdb2YgdGhpcy5fbWFwKXlpZWxkW2UsdCBpbnN0YW5jZW9mIFJlZiYmdGhpcy54cmVmP3RoaXMueHJlZi5mZXRjaCh0LHRoaXMuc3VwcHJlc3NFbmNyeXB0aW9uKTp0XX1zdGF0aWMgZ2V0IGVtcHR5KCl7Y29uc3QgZT1uZXcgRGljdChudWxsKTtlLnNldD0oZSx0KT0+e3VucmVhY2hhYmxlKCJTaG91bGQgbm90IGNhbGwgYHNldGAgb24gdGhlIGVtcHR5IGRpY3Rpb25hcnkuIil9O3JldHVybiBzaGFkb3codGhpcywiZW1wdHkiLGUpfXN0YXRpYyBtZXJnZSh7eHJlZjplLGRpY3RBcnJheTp0LG1lcmdlU3ViRGljdHM6YT0hMX0pe2NvbnN0IHI9bmV3IERpY3QoZSksaT1uZXcgTWFwO2Zvcihjb25zdCBlIG9mIHQpaWYoZSBpbnN0YW5jZW9mIERpY3QpZm9yKGNvbnN0W3Qscl1vZiBlLl9tYXApe2xldCBlPWkuZ2V0KHQpO2lmKHZvaWQgMD09PWUpe2U9W107aS5zZXQodCxlKX1lbHNlIGlmKCEoYSYmciBpbnN0YW5jZW9mIERpY3QpKWNvbnRpbnVlO2UucHVzaChyKX1mb3IoY29uc3RbdCxhXW9mIGkpe2lmKDE9PT1hLmxlbmd0aHx8IShhWzBdaW5zdGFuY2VvZiBEaWN0KSl7ci5fbWFwLnNldCh0LGFbMF0pO2NvbnRpbnVlfWNvbnN0IGk9bmV3IERpY3QoZSk7Zm9yKGNvbnN0IGUgb2YgYSlmb3IoY29uc3RbdCxhXW9mIGUuX21hcClpLl9tYXAuaGFzKHQpfHxpLl9tYXAuc2V0KHQsYSk7aS5zaXplPjAmJnIuX21hcC5zZXQodCxpKX1pLmNsZWFyKCk7cmV0dXJuIHIuc2l6ZT4wP3I6RGljdC5lbXB0eX1jbG9uZSgpe2NvbnN0IGU9bmV3IERpY3QodGhpcy54cmVmKTtmb3IoY29uc3QgdCBvZiB0aGlzLmdldEtleXMoKSllLnNldCh0LHRoaXMuZ2V0UmF3KHQpKTtyZXR1cm4gZX1kZWxldGUoZSl7ZGVsZXRlIHRoaXMuX21hcFtlXX19Y2xhc3MgUmVme2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5udW09ZTt0aGlzLmdlbj10fXRvU3RyaW5nKCl7cmV0dXJuIDA9PT10aGlzLmdlbj9gJHt0aGlzLm51bX1SYDpgJHt0aGlzLm51bX1SJHt0aGlzLmdlbn1gfXN0YXRpYyBmcm9tU3RyaW5nKGUpe2NvbnN0IHQ9bmFbZV07aWYodClyZXR1cm4gdDtjb25zdCBhPS9eKFxkKylSKFxkKikkLy5leGVjKGUpO3JldHVybiBhJiYiMCIhPT1hWzFdP25hW2VdPW5ldyBSZWYocGFyc2VJbnQoYVsxXSksYVsyXT9wYXJzZUludChhWzJdKTowKTpudWxsfXN0YXRpYyBnZXQoZSx0KXtjb25zdCBhPTA9PT10P2Ake2V9UmA6YCR7ZX1SJHt0fWA7cmV0dXJuIG5hW2FdfHw9bmV3IFJlZihlLHQpfX1jbGFzcyBSZWZTZXR7Y29uc3RydWN0b3IoZT1udWxsKXt0aGlzLl9zZXQ9bmV3IFNldChlPy5fc2V0KX1oYXMoZSl7cmV0dXJuIHRoaXMuX3NldC5oYXMoZS50b1N0cmluZygpKX1wdXQoZSl7dGhpcy5fc2V0LmFkZChlLnRvU3RyaW5nKCkpfXJlbW92ZShlKXt0aGlzLl9zZXQuZGVsZXRlKGUudG9TdHJpbmcoKSl9W1N5bWJvbC5pdGVyYXRvcl0oKXtyZXR1cm4gdGhpcy5fc2V0LnZhbHVlcygpfWNsZWFyKCl7dGhpcy5fc2V0LmNsZWFyKCl9fWNsYXNzIFJlZlNldENhY2hle2NvbnN0cnVjdG9yKCl7dGhpcy5fbWFwPW5ldyBNYXB9Z2V0IHNpemUoKXtyZXR1cm4gdGhpcy5fbWFwLnNpemV9Z2V0KGUpe3JldHVybiB0aGlzLl9tYXAuZ2V0KGUudG9TdHJpbmcoKSl9aGFzKGUpe3JldHVybiB0aGlzLl9tYXAuaGFzKGUudG9TdHJpbmcoKSl9cHV0KGUsdCl7dGhpcy5fbWFwLnNldChlLnRvU3RyaW5nKCksdCl9cHV0QWxpYXMoZSx0KXt0aGlzLl9tYXAuc2V0KGUudG9TdHJpbmcoKSx0aGlzLmdldCh0KSl9W1N5bWJvbC5pdGVyYXRvcl0oKXtyZXR1cm4gdGhpcy5fbWFwLnZhbHVlcygpfWNsZWFyKCl7dGhpcy5fbWFwLmNsZWFyKCl9KnZhbHVlcygpe3lpZWxkKnRoaXMuX21hcC52YWx1ZXMoKX0qaXRlbXMoKXtmb3IoY29uc3RbZSx0XW9mIHRoaXMuX21hcCl5aWVsZFtSZWYuZnJvbVN0cmluZyhlKSx0XX19ZnVuY3Rpb24gaXNOYW1lKGUsdCl7cmV0dXJuIGUgaW5zdGFuY2VvZiBOYW1lJiYodm9pZCAwPT09dHx8ZS5uYW1lPT09dCl9ZnVuY3Rpb24gaXNDbWQoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIENtZCYmKHZvaWQgMD09PXR8fGUuY21kPT09dCl9ZnVuY3Rpb24gaXNEaWN0KGUsdCl7cmV0dXJuIGUgaW5zdGFuY2VvZiBEaWN0JiYodm9pZCAwPT09dHx8aXNOYW1lKGUuZ2V0KCJUeXBlIiksdCkpfWZ1bmN0aW9uIGlzUmVmc0VxdWFsKGUsdCl7cmV0dXJuIGUubnVtPT09dC5udW0mJmUuZ2VuPT09dC5nZW59Y2xhc3MgQmFzZVN0cmVhbXtnZXQgbGVuZ3RoKCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IGdldHRlciBgbGVuZ3RoYCBhY2Nlc3NlZCIpfWdldCBpc0VtcHR5KCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IGdldHRlciBgaXNFbXB0eWAgYWNjZXNzZWQiKX1nZXQgaXNEYXRhTG9hZGVkKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJpc0RhdGFMb2FkZWQiLCEwKX1nZXRCeXRlKCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgZ2V0Qnl0ZWAgY2FsbGVkIil9Z2V0Qnl0ZXMoZSl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgZ2V0Qnl0ZXNgIGNhbGxlZCIpfWFzeW5jIGdldEltYWdlRGF0YShlLHQpe3JldHVybiB0aGlzLmdldEJ5dGVzKGUsdCl9YXN5bmMgYXN5bmNHZXRCeXRlcygpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBtZXRob2QgYGFzeW5jR2V0Qnl0ZXNgIGNhbGxlZCIpfWdldCBpc0FzeW5jKCl7cmV0dXJuITF9Z2V0IGlzQXN5bmNEZWNvZGVyKCl7cmV0dXJuITF9Z2V0IGNhbkFzeW5jRGVjb2RlSW1hZ2VGcm9tQnVmZmVyKCl7cmV0dXJuITF9YXN5bmMgZ2V0VHJhbnNmZXJhYmxlSW1hZ2UoKXtyZXR1cm4gbnVsbH1wZWVrQnl0ZSgpe2NvbnN0IGU9dGhpcy5nZXRCeXRlKCk7LTEhPT1lJiZ0aGlzLnBvcy0tO3JldHVybiBlfXBlZWtCeXRlcyhlKXtjb25zdCB0PXRoaXMuZ2V0Qnl0ZXMoZSk7dGhpcy5wb3MtPXQubGVuZ3RoO3JldHVybiB0fWdldFVpbnQxNigpe2NvbnN0IGU9dGhpcy5nZXRCeXRlKCksdD10aGlzLmdldEJ5dGUoKTtyZXR1cm4tMT09PWV8fC0xPT09dD8tMTooZTw8OCkrdH1nZXRJbnQzMigpe3JldHVybih0aGlzLmdldEJ5dGUoKTw8MjQpKyh0aGlzLmdldEJ5dGUoKTw8MTYpKyh0aGlzLmdldEJ5dGUoKTw8OCkrdGhpcy5nZXRCeXRlKCl9Z2V0Qnl0ZVJhbmdlKGUsdCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgZ2V0Qnl0ZVJhbmdlYCBjYWxsZWQiKX1nZXRTdHJpbmcoZSl7cmV0dXJuIGJ5dGVzVG9TdHJpbmcodGhpcy5nZXRCeXRlcyhlKSl9c2tpcChlKXt0aGlzLnBvcys9ZXx8MX1yZXNldCgpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBtZXRob2QgYHJlc2V0YCBjYWxsZWQiKX1tb3ZlU3RhcnQoKXt1bnJlYWNoYWJsZSgiQWJzdHJhY3QgbWV0aG9kIGBtb3ZlU3RhcnRgIGNhbGxlZCIpfW1ha2VTdWJTdHJlYW0oZSx0LGE9bnVsbCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgbWFrZVN1YlN0cmVhbWAgY2FsbGVkIil9Z2V0QmFzZVN0cmVhbXMoKXtyZXR1cm4gbnVsbH19Y29uc3Qgb2E9L15bMS05XVwuXGQkLyxjYT0yKiozMS0xLGxhPVsxLDAsMCwxLDAsMF0saGE9WyJDb2xvclNwYWNlIiwiRXh0R1N0YXRlIiwiRm9udCIsIlBhdHRlcm4iLCJQcm9wZXJ0aWVzIiwiU2hhZGluZyIsIlhPYmplY3QiXSx1YT1bIkV4dEdTdGF0ZSIsIkZvbnQiLCJQcm9wZXJ0aWVzIiwiWE9iamVjdCJdO2Z1bmN0aW9uIGdldExvb2t1cFRhYmxlRmFjdG9yeShlKXtsZXQgdDtyZXR1cm4gZnVuY3Rpb24oKXtpZihlKXt0PU9iamVjdC5jcmVhdGUobnVsbCk7ZSh0KTtlPW51bGx9cmV0dXJuIHR9fWNsYXNzIE1pc3NpbmdEYXRhRXhjZXB0aW9uIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihgTWlzc2luZyBkYXRhIFske2V9LCAke3R9KWAsIk1pc3NpbmdEYXRhRXhjZXB0aW9uIik7dGhpcy5iZWdpbj1lO3RoaXMuZW5kPXR9fWNsYXNzIFBhcnNlckVPRkV4Y2VwdGlvbiBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIlBhcnNlckVPRkV4Y2VwdGlvbiIpfX1jbGFzcyBYUmVmRW50cnlFeGNlcHRpb24gZXh0ZW5kcyBKdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJYUmVmRW50cnlFeGNlcHRpb24iKX19Y2xhc3MgWFJlZlBhcnNlRXhjZXB0aW9uIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiWFJlZlBhcnNlRXhjZXB0aW9uIil9fWZ1bmN0aW9uIGFycmF5QnVmZmVyc1RvQnl0ZXMoZSl7Y29uc3QgdD1lLmxlbmd0aDtpZigwPT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7aWYoMT09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KGVbMF0pO2xldCBhPTA7Zm9yKGxldCByPTA7cjx0O3IrKylhKz1lW3JdLmJ5dGVMZW5ndGg7Y29uc3Qgcj1uZXcgVWludDhBcnJheShhKTtsZXQgaT0wO2ZvcihsZXQgYT0wO2E8dDthKyspe2NvbnN0IHQ9bmV3IFVpbnQ4QXJyYXkoZVthXSk7ci5zZXQodCxpKTtpKz10LmJ5dGVMZW5ndGh9cmV0dXJuIHJ9YXN5bmMgZnVuY3Rpb24gZmV0Y2hCaW5hcnlEYXRhKGUpe2NvbnN0IHQ9YXdhaXQgZmV0Y2goZSk7aWYoIXQub2spdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZmlsZSAiJHtlfSIgd2l0aCAiJHt0LnN0YXR1c1RleHR9Ii5gKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdC5hcnJheUJ1ZmZlcigpKX1mdW5jdGlvbiBnZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0OmUsa2V5OnQsZ2V0QXJyYXk6YT0hMSxzdG9wV2hlbkZvdW5kOnI9ITB9KXtsZXQgaTtjb25zdCBuPW5ldyBSZWZTZXQ7Zm9yKDtlIGluc3RhbmNlb2YgRGljdCYmKCFlLm9iaklkfHwhbi5oYXMoZS5vYmpJZCkpOyl7ZS5vYmpJZCYmbi5wdXQoZS5vYmpJZCk7Y29uc3Qgcz1hP2UuZ2V0QXJyYXkodCk6ZS5nZXQodCk7aWYodm9pZCAwIT09cyl7aWYocilyZXR1cm4gczsoaXx8PVtdKS5wdXNoKHMpfWU9ZS5nZXQoIlBhcmVudCIpfXJldHVybiBpfWNvbnN0IGRhPVsiIiwiQyIsIkNDIiwiQ0NDIiwiQ0QiLCJEIiwiREMiLCJEQ0MiLCJEQ0NDIiwiQ00iLCIiLCJYIiwiWFgiLCJYWFgiLCJYTCIsIkwiLCJMWCIsIkxYWCIsIkxYWFgiLCJYQyIsIiIsIkkiLCJJSSIsIklJSSIsIklWIiwiViIsIlZJIiwiVklJIiwiVklJSSIsIklYIl07ZnVuY3Rpb24gdG9Sb21hbk51bWVyYWxzKGUsdD0hMSl7YXNzZXJ0KE51bWJlci5pc0ludGVnZXIoZSkmJmU+MCwiVGhlIG51bWJlciBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiIpO2NvbnN0IGE9Ik0iLnJlcGVhdChlLzFlM3wwKStkYVtlJTFlMy8xMDB8MF0rZGFbMTArKGUlMTAwLzEwfDApXStkYVsyMCtlJTEwXTtyZXR1cm4gdD9hLnRvTG93ZXJDYXNlKCk6YX1mdW5jdGlvbiBsb2cyKGUpe3JldHVybiBlPjA/TWF0aC5jZWlsKE1hdGgubG9nMihlKSk6MH1mdW5jdGlvbiByZWFkSW50OChlLHQpe3JldHVybiBlW3RdPDwyND4+MjR9ZnVuY3Rpb24gcmVhZEludDE2KGUsdCl7cmV0dXJuKGVbdF08PDI0fGVbdCsxXTw8MTYpPj4xNn1mdW5jdGlvbiByZWFkVWludDE2KGUsdCl7cmV0dXJuIGVbdF08PDh8ZVt0KzFdfWZ1bmN0aW9uIHJlYWRVaW50MzIoZSx0KXtyZXR1cm4oZVt0XTw8MjR8ZVt0KzFdPDwxNnxlW3QrMl08PDh8ZVt0KzNdKT4+PjB9ZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGUpe3JldHVybiAzMj09PWV8fDk9PT1lfHwxMz09PWV8fDEwPT09ZX1mdW5jdGlvbiBpc051bWJlckFycmF5KGUsdCl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/KG51bGw9PT10fHxlLmxlbmd0aD09PXQpJiZlLmV2ZXJ5KChlPT4ibnVtYmVyIj09dHlwZW9mIGUpKTpBcnJheUJ1ZmZlci5pc1ZpZXcoZSkmJiEoZSBpbnN0YW5jZW9mIEJpZ0ludDY0QXJyYXl8fGUgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheSkmJihudWxsPT09dHx8ZS5sZW5ndGg9PT10KX1mdW5jdGlvbiBsb29rdXBNYXRyaXgoZSx0KXtyZXR1cm4gaXNOdW1iZXJBcnJheShlLDYpP2U6dH1mdW5jdGlvbiBsb29rdXBSZWN0KGUsdCl7cmV0dXJuIGlzTnVtYmVyQXJyYXkoZSw0KT9lOnR9ZnVuY3Rpb24gbG9va3VwTm9ybWFsUmVjdChlLHQpe3JldHVybiBpc051bWJlckFycmF5KGUsNCk/VXRpbC5ub3JtYWxpemVSZWN0KGUpOnR9ZnVuY3Rpb24gcGFyc2VYRkFQYXRoKGUpe2NvbnN0IHQ9LyguKylcWyhcZCspXF0kLztyZXR1cm4gZS5zcGxpdCgiLiIpLm1hcCgoZT0+e2NvbnN0IGE9ZS5tYXRjaCh0KTtyZXR1cm4gYT97bmFtZTphWzFdLHBvczpwYXJzZUludChhWzJdLDEwKX06e25hbWU6ZSxwb3M6MH19KSl9ZnVuY3Rpb24gZXNjYXBlUERGTmFtZShlKXtjb25zdCB0PVtdO2xldCBhPTA7Zm9yKGxldCByPTAsaT1lLmxlbmd0aDtyPGk7cisrKXtjb25zdCBpPWUuY2hhckNvZGVBdChyKTtpZihpPDMzfHxpPjEyNnx8MzU9PT1pfHw0MD09PWl8fDQxPT09aXx8NjA9PT1pfHw2Mj09PWl8fDkxPT09aXx8OTM9PT1pfHwxMjM9PT1pfHwxMjU9PT1pfHw0Nz09PWl8fDM3PT09aSl7YTxyJiZ0LnB1c2goZS5zdWJzdHJpbmcoYSxyKSk7dC5wdXNoKGAjJHtpLnRvU3RyaW5nKDE2KX1gKTthPXIrMX19aWYoMD09PXQubGVuZ3RoKXJldHVybiBlO2E8ZS5sZW5ndGgmJnQucHVzaChlLnN1YnN0cmluZyhhLGUubGVuZ3RoKSk7cmV0dXJuIHQuam9pbigiIil9ZnVuY3Rpb24gZXNjYXBlU3RyaW5nKGUpe3JldHVybiBlLnJlcGxhY2VBbGwoLyhbKClcXFxuXHJdKS9nLChlPT4iXG4iPT09ZT8iXFxuIjoiXHIiPT09ZT8iXFxyIjpgXFwke2V9YCkpfWZ1bmN0aW9uIF9jb2xsZWN0SlMoZSx0LGEscil7aWYoIWUpcmV0dXJuO2xldCBpPW51bGw7aWYoZSBpbnN0YW5jZW9mIFJlZil7aWYoci5oYXMoZSkpcmV0dXJuO2k9ZTtyLnB1dChpKTtlPXQuZmV0Y2goZSl9aWYoQXJyYXkuaXNBcnJheShlKSlmb3IoY29uc3QgaSBvZiBlKV9jb2xsZWN0SlMoaSx0LGEscik7ZWxzZSBpZihlIGluc3RhbmNlb2YgRGljdCl7aWYoaXNOYW1lKGUuZ2V0KCJTIiksIkphdmFTY3JpcHQiKSl7Y29uc3QgdD1lLmdldCgiSlMiKTtsZXQgcjt0IGluc3RhbmNlb2YgQmFzZVN0cmVhbT9yPXQuZ2V0U3RyaW5nKCk6InN0cmluZyI9PXR5cGVvZiB0JiYocj10KTtyJiY9c3RyaW5nVG9QREZTdHJpbmcociwhMCkucmVwbGFjZUFsbCgiXDAiLCIiKTtyJiZhLnB1c2goci50cmltKCkpfV9jb2xsZWN0SlMoZS5nZXRSYXcoIk5leHQiKSx0LGEscil9aSYmci5yZW1vdmUoaSl9ZnVuY3Rpb24gY29sbGVjdEFjdGlvbnMoZSx0LGEpe2NvbnN0IHI9T2JqZWN0LmNyZWF0ZShudWxsKSxpPWdldEluaGVyaXRhYmxlUHJvcGVydHkoe2RpY3Q6dCxrZXk6IkFBIixzdG9wV2hlbkZvdW5kOiExfSk7aWYoaSlmb3IobGV0IHQ9aS5sZW5ndGgtMTt0Pj0wO3QtLSl7Y29uc3Qgbj1pW3RdO2lmKG4gaW5zdGFuY2VvZiBEaWN0KWZvcihjb25zdCB0IG9mIG4uZ2V0S2V5cygpKXtjb25zdCBpPWFbdF07aWYoIWkpY29udGludWU7Y29uc3Qgcz1bXTtfY29sbGVjdEpTKG4uZ2V0UmF3KHQpLGUscyxuZXcgUmVmU2V0KTtzLmxlbmd0aD4wJiYocltpXT1zKX19aWYodC5oYXMoIkEiKSl7Y29uc3QgYT1bXTtfY29sbGVjdEpTKHQuZ2V0KCJBIiksZSxhLG5ldyBSZWZTZXQpO2EubGVuZ3RoPjAmJihyLkFjdGlvbj1hKX1yZXR1cm4gb2JqZWN0U2l6ZShyKT4wP3I6bnVsbH1jb25zdCBmYT17NjA6IiZsdDsiLDYyOiImZ3Q7IiwzODoiJmFtcDsiLDM0OiImcXVvdDsiLDM5OiImYXBvczsifTtmdW5jdGlvbipjb2RlUG9pbnRJdGVyKGUpe2ZvcihsZXQgdD0wLGE9ZS5sZW5ndGg7dDxhO3QrKyl7Y29uc3QgYT1lLmNvZGVQb2ludEF0KHQpO2E+NTUyOTUmJihhPDU3MzQ0fHxhPjY1NTMzKSYmdCsrO3lpZWxkIGF9fWZ1bmN0aW9uIGVuY29kZVRvWG1sU3RyaW5nKGUpe2NvbnN0IHQ9W107bGV0IGE9MDtmb3IobGV0IHI9MCxpPWUubGVuZ3RoO3I8aTtyKyspe2NvbnN0IGk9ZS5jb2RlUG9pbnRBdChyKTtpZigzMjw9aSYmaTw9MTI2KXtjb25zdCBuPWZhW2ldO2lmKG4pe2E8ciYmdC5wdXNoKGUuc3Vic3RyaW5nKGEscikpO3QucHVzaChuKTthPXIrMX19ZWxzZXthPHImJnQucHVzaChlLnN1YnN0cmluZyhhLHIpKTt0LnB1c2goYCYjeCR7aS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX07YCk7aT41NTI5NSYmKGk8NTczNDR8fGk+NjU1MzMpJiZyKys7YT1yKzF9fWlmKDA9PT10Lmxlbmd0aClyZXR1cm4gZTthPGUubGVuZ3RoJiZ0LnB1c2goZS5zdWJzdHJpbmcoYSxlLmxlbmd0aCkpO3JldHVybiB0LmpvaW4oIiIpfWZ1bmN0aW9uIHZhbGlkYXRlRm9udE5hbWUoZSx0PSExKXtjb25zdCBhPS9eKCJ8JykuKigifCcpJC8uZXhlYyhlKTtpZihhJiZhWzFdPT09YVsyXSl7aWYobmV3IFJlZ0V4cChgW15cXFxcXSR7YVsxXX1gKS50ZXN0KGUuc2xpY2UoMSwtMSkpKXt0JiZ3YXJuKGBGb250RmFtaWx5IGNvbnRhaW5zIHVuZXNjYXBlZCAke2FbMV19OiAke2V9LmApO3JldHVybiExfX1lbHNlIGZvcihjb25zdCBhIG9mIGUuc3BsaXQoL1sgXHRdKy8pKWlmKC9eKFxkfCgtKFxkfC0pKSkvLnRlc3QoYSl8fCEvXltcdy1cXF0rJC8udGVzdChhKSl7dCYmd2FybihgRm9udEZhbWlseSBjb250YWlucyBpbnZhbGlkIDxjdXN0b20taWRlbnQ+OiAke2V9LmApO3JldHVybiExfXJldHVybiEwfWZ1bmN0aW9uIHZhbGlkYXRlQ1NTRm9udChlKXtjb25zdCB0PW5ldyBTZXQoWyIxMDAiLCIyMDAiLCIzMDAiLCI0MDAiLCI1MDAiLCI2MDAiLCI3MDAiLCI4MDAiLCI5MDAiLCIxMDAwIiwibm9ybWFsIiwiYm9sZCIsImJvbGRlciIsImxpZ2h0ZXIiXSkse2ZvbnRGYW1pbHk6YSxmb250V2VpZ2h0OnIsaXRhbGljQW5nbGU6aX09ZTtpZighdmFsaWRhdGVGb250TmFtZShhLCEwKSlyZXR1cm4hMTtjb25zdCBuPXI/ci50b1N0cmluZygpOiIiO2UuZm9udFdlaWdodD10LmhhcyhuKT9uOiI0MDAiO2NvbnN0IHM9cGFyc2VGbG9hdChpKTtlLml0YWxpY0FuZ2xlPWlzTmFOKHMpfHxzPC05MHx8cz45MD8iMTQiOmkudG9TdHJpbmcoKTtyZXR1cm4hMH1mdW5jdGlvbiByZWNvdmVySnNVUkwoZSl7Y29uc3QgdD1uZXcgUmVnRXhwKCJeXFxzKigiK1siYXBwLmxhdW5jaFVSTCIsIndpbmRvdy5vcGVuIiwieGZhLmhvc3QuZ290b1VSTCJdLmpvaW4oInwiKS5yZXBsYWNlQWxsKCIuIiwiXFwuIikrIilcXCgoPzonfFwiKShbXidcIl0qKSg/Oid8XCIpKD86LFxccyooXFx3KylcXCl8XFwpKSIsImkiKS5leGVjKGUpO3JldHVybiB0Py5bMl0/e3VybDp0WzJdLG5ld1dpbmRvdzoiYXBwLmxhdW5jaFVSTCI9PT10WzFdJiYidHJ1ZSI9PT10WzNdfTpudWxsfWZ1bmN0aW9uIG51bWJlclRvU3RyaW5nKGUpe2lmKE51bWJlci5pc0ludGVnZXIoZSkpcmV0dXJuIGUudG9TdHJpbmcoKTtjb25zdCB0PU1hdGgucm91bmQoMTAwKmUpO3JldHVybiB0JTEwMD09MD8odC8xMDApLnRvU3RyaW5nKCk6dCUxMD09MD9lLnRvRml4ZWQoMSk6ZS50b0ZpeGVkKDIpfWZ1bmN0aW9uIGdldE5ld0Fubm90YXRpb25zTWFwKGUpe2lmKCFlKXJldHVybiBudWxsO2NvbnN0IHQ9bmV3IE1hcDtmb3IoY29uc3RbYSxyXW9mIGUpe2lmKCFhLnN0YXJ0c1dpdGgoZikpY29udGludWU7bGV0IGU9dC5nZXQoci5wYWdlSW5kZXgpO2lmKCFlKXtlPVtdO3Quc2V0KHIucGFnZUluZGV4LGUpfWUucHVzaChyKX1yZXR1cm4gdC5zaXplPjA/dDpudWxsfWZ1bmN0aW9uIHN0cmluZ1RvQXNjaWlPclVURjE2QkUoZSl7cmV0dXJuIG51bGw9PWV8fGZ1bmN0aW9uIGlzQXNjaWkoZSl7aWYoInN0cmluZyIhPXR5cGVvZiBlKXJldHVybiExO3JldHVybiFlfHwvXltceDAwLVx4N0ZdKiQvLnRlc3QoZSl9KGUpP2U6c3RyaW5nVG9VVEYxNlN0cmluZyhlLCEwKX1mdW5jdGlvbiBzdHJpbmdUb1VURjE2SGV4U3RyaW5nKGUpe2NvbnN0IHQ9W107Zm9yKGxldCBhPTAscj1lLmxlbmd0aDthPHI7YSsrKXtjb25zdCByPWUuY2hhckNvZGVBdChhKTt0LnB1c2goWXRbcj4+OCYyNTVdLFl0WzI1NSZyXSl9cmV0dXJuIHQuam9pbigiIil9ZnVuY3Rpb24gc3RyaW5nVG9VVEYxNlN0cmluZyhlLHQ9ITEpe2NvbnN0IGE9W107dCYmYS5wdXNoKCLDvsO/Iik7Zm9yKGxldCB0PTAscj1lLmxlbmd0aDt0PHI7dCsrKXtjb25zdCByPWUuY2hhckNvZGVBdCh0KTthLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShyPj44JjI1NSksU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmcikpfXJldHVybiBhLmpvaW4oIiIpfWZ1bmN0aW9uIGdldFJvdGF0aW9uTWF0cml4KGUsdCxhKXtzd2l0Y2goZSl7Y2FzZSA5MDpyZXR1cm5bMCwxLC0xLDAsdCwwXTtjYXNlIDE4MDpyZXR1cm5bLTEsMCwwLC0xLHQsYV07Y2FzZSAyNzA6cmV0dXJuWzAsLTEsMSwwLDAsYV07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcm90YXRpb24iKX19ZnVuY3Rpb24gZ2V0U2l6ZUluQnl0ZXMoZSl7cmV0dXJuIE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5sb2cyKDErZSkpLzgpfWNsYXNzIFFDTVN7c3RhdGljI2E9bnVsbDtzdGF0aWMgX21lbW9yeT1udWxsO3N0YXRpYyBfbXVzdEFkZEFscGhhPSExO3N0YXRpYyBfZGVzdEJ1ZmZlcj1udWxsO3N0YXRpYyBfZGVzdE9mZnNldD0wO3N0YXRpYyBfZGVzdExlbmd0aD0wO3N0YXRpYyBfY3NzQ29sb3I9IiI7c3RhdGljIF9tYWtlSGV4Q29sb3I9bnVsbDtzdGF0aWMgZ2V0IF9tZW1vcnlBcnJheSgpe2NvbnN0IGU9dGhpcy4jYTtyZXR1cm4gZT8uYnl0ZUxlbmd0aD9lOnRoaXMuI2E9bmV3IFVpbnQ4QXJyYXkodGhpcy5fbWVtb3J5LmJ1ZmZlcil9fWxldCBnYTtjb25zdCBwYT0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcigidXRmLTgiLHtpZ25vcmVCT006ITAsZmF0YWw6ITB9KTp7ZGVjb2RlOigpPT57dGhyb3cgRXJyb3IoIlRleHREZWNvZGVyIG5vdCBhdmFpbGFibGUiKX19OyJ1bmRlZmluZWQiIT10eXBlb2YgVGV4dERlY29kZXImJnBhLmRlY29kZSgpO2xldCBtYT1udWxsO2Z1bmN0aW9uIGdldFVpbnQ4QXJyYXlNZW1vcnkwKCl7bnVsbCE9PW1hJiYwIT09bWEuYnl0ZUxlbmd0aHx8KG1hPW5ldyBVaW50OEFycmF5KGdhLm1lbW9yeS5idWZmZXIpKTtyZXR1cm4gbWF9bGV0IGJhPTA7ZnVuY3Rpb24gcGFzc0FycmF5OFRvV2FzbTAoZSx0KXtjb25zdCBhPXQoMSplLmxlbmd0aCwxKT4+PjA7Z2V0VWludDhBcnJheU1lbW9yeTAoKS5zZXQoZSxhLzEpO2JhPWUubGVuZ3RoO3JldHVybiBhfWNvbnN0IHlhPU9iamVjdC5mcmVlemUoe1JHQjg6MCwwOiJSR0I4IixSR0JBODoxLDE6IlJHQkE4IixCR1JBODoyLDI6IkJHUkE4IixHcmF5ODozLDM6IkdyYXk4IixHcmF5QTg6NCw0OiJHcmF5QTgiLENNWUs6NSw1OiJDTVlLIn0pLHdhPU9iamVjdC5mcmVlemUoe1BlcmNlcHR1YWw6MCwwOiJQZXJjZXB0dWFsIixSZWxhdGl2ZUNvbG9yaW1ldHJpYzoxLDE6IlJlbGF0aXZlQ29sb3JpbWV0cmljIixTYXR1cmF0aW9uOjIsMjoiU2F0dXJhdGlvbiIsQWJzb2x1dGVDb2xvcmltZXRyaWM6MywzOiJBYnNvbHV0ZUNvbG9yaW1ldHJpYyJ9KTtmdW5jdGlvbiBfX3diZ19nZXRfaW1wb3J0cygpe2NvbnN0IGU9e3diZzp7fX07ZS53YmcuX193YmdfY29weXJlc3VsdF9iMDhlZTdkMjczZjI5NWRkPWZ1bmN0aW9uKGUsdCl7IWZ1bmN0aW9uIGNvcHlfcmVzdWx0KGUsdCl7Y29uc3R7X211c3RBZGRBbHBoYTphLF9kZXN0QnVmZmVyOnIsX2Rlc3RPZmZzZXQ6aSxfZGVzdExlbmd0aDpuLF9tZW1vcnlBcnJheTpzfT1RQ01TO2lmKHQhPT1uKWlmKGEpZm9yKGxldCBhPWUsbj1lK3Qsbz1pO2E8bjthKz0zLG8rPTQpe3Jbb109c1thXTtyW28rMV09c1thKzFdO3JbbysyXT1zW2ErMl07cltvKzNdPTI1NX1lbHNlIGZvcihsZXQgYT1lLG49ZSt0LG89aTthPG47YSs9MyxvKz00KXtyW29dPXNbYV07cltvKzFdPXNbYSsxXTtyW28rMl09c1thKzJdfWVsc2Ugci5zZXQocy5zdWJhcnJheShlLGUrdCksaSl9KGU+Pj4wLHQ+Pj4wKX07ZS53YmcuX193YmdfY29weXJnYl9kNjBjZTE3YmIwNWQ5YjY3PWZ1bmN0aW9uKGUpeyFmdW5jdGlvbiBjb3B5X3JnYihlKXtjb25zdHtfZGVzdEJ1ZmZlcjp0LF9kZXN0T2Zmc2V0OmEsX21lbW9yeUFycmF5OnJ9PVFDTVM7dFthXT1yW2VdO3RbYSsxXT1yW2UrMV07dFthKzJdPXJbZSsyXX0oZT4+PjApfTtlLndiZy5fX3diZ19tYWtlY3NzUkdCXzg5M2JmMGNkOWZkYjMwMmQ9ZnVuY3Rpb24oZSl7IWZ1bmN0aW9uIG1ha2VfY3NzUkdCKGUpe2NvbnN0e19tZW1vcnlBcnJheTp0fT1RQ01TO1FDTVMuX2Nzc0NvbG9yPVFDTVMuX21ha2VIZXhDb2xvcih0W2VdLHRbZSsxXSx0W2UrMl0pfShlPj4+MCl9O2Uud2JnLl9fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGU9ZnVuY3Rpb24oKXtjb25zdCBlPWdhLl9fd2JpbmRnZW5fZXhwb3J0XzAsdD1lLmdyb3coNCk7ZS5zZXQoMCx2b2lkIDApO2Uuc2V0KHQrMCx2b2lkIDApO2Uuc2V0KHQrMSxudWxsKTtlLnNldCh0KzIsITApO2Uuc2V0KHQrMywhMSl9O2Uud2JnLl9fd2JpbmRnZW5fdGhyb3c9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgRXJyb3IoZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbVdhc20wKGUsdCl7ZT4+Pj0wO3JldHVybiBwYS5kZWNvZGUoZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zdWJhcnJheShlLGUrdCkpfShlLHQpKX07cmV0dXJuIGV9ZnVuY3Rpb24gX193YmdfZmluYWxpemVfaW5pdChlLHQpe2dhPWUuZXhwb3J0cztfX3diZ19pbml0Ll9fd2JpbmRnZW5fd2FzbV9tb2R1bGU9dDttYT1udWxsO2dhLl9fd2JpbmRnZW5fc3RhcnQoKTtyZXR1cm4gZ2F9YXN5bmMgZnVuY3Rpb24gX193YmdfaW5pdChlKXtpZih2b2lkIDAhPT1nYSlyZXR1cm4gZ2E7dm9pZCAwIT09ZSYmKE9iamVjdC5nZXRQcm90b3R5cGVPZihlKT09PU9iamVjdC5wcm90b3R5cGU/KHttb2R1bGVfb3JfcGF0aDplfT1lKTpjb25zb2xlLndhcm4oInVzaW5nIGRlcHJlY2F0ZWQgcGFyYW1ldGVycyBmb3IgdGhlIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uOyBwYXNzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIikpO2NvbnN0IHQ9X193YmdfZ2V0X2ltcG9ydHMoKTsoInN0cmluZyI9PXR5cGVvZiBlfHwiZnVuY3Rpb24iPT10eXBlb2YgUmVxdWVzdCYmZSBpbnN0YW5jZW9mIFJlcXVlc3R8fCJmdW5jdGlvbiI9PXR5cGVvZiBVUkwmJmUgaW5zdGFuY2VvZiBVUkwpJiYoZT1mZXRjaChlKSk7Y29uc3R7aW5zdGFuY2U6YSxtb2R1bGU6cn09YXdhaXQgYXN5bmMgZnVuY3Rpb24gX193YmdfbG9hZChlLHQpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBSZXNwb25zZSYmZSBpbnN0YW5jZW9mIFJlc3BvbnNlKXtpZigiZnVuY3Rpb24iPT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcpdHJ5e3JldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhlLHQpfWNhdGNoKHQpe2lmKCJhcHBsaWNhdGlvbi93YXNtIj09ZS5oZWFkZXJzLmdldCgiQ29udGVudC1UeXBlIikpdGhyb3cgdDtjb25zb2xlLndhcm4oImBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ2AgZmFpbGVkIGJlY2F1c2UgeW91ciBzZXJ2ZXIgZG9lcyBub3Qgc2VydmUgV2FzbSB3aXRoIGBhcHBsaWNhdGlvbi93YXNtYCBNSU1FIHR5cGUuIEZhbGxpbmcgYmFjayB0byBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVgIHdoaWNoIGlzIHNsb3dlci4gT3JpZ2luYWwgZXJyb3I6XG4iLHQpfWNvbnN0IGE9YXdhaXQgZS5hcnJheUJ1ZmZlcigpO3JldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShhLHQpfXtjb25zdCBhPWF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCk7cmV0dXJuIGEgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZT97aW5zdGFuY2U6YSxtb2R1bGU6ZX06YX19KGF3YWl0IGUsdCk7cmV0dXJuIF9fd2JnX2ZpbmFsaXplX2luaXQoYSxyKX1jbGFzcyBDb2xvclNwYWNle3N0YXRpYyNyPW5ldyBVaW50OENsYW1wZWRBcnJheSgzKTtjb25zdHJ1Y3RvcihlLHQpe3RoaXMubmFtZT1lO3RoaXMubnVtQ29tcHM9dH1nZXRSZ2IoZSx0LGE9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMpKXt0aGlzLmdldFJnYkl0ZW0oZSx0LGEsMCk7cmV0dXJuIGF9Z2V0UmdiSGV4KGUsdCl7Y29uc3QgYT10aGlzLmdldFJnYihlLHQsQ29sb3JTcGFjZS4jcik7cmV0dXJuIFV0aWwubWFrZUhleENvbG9yKGFbMF0sYVsxXSxhWzJdKX1nZXRSZ2JJdGVtKGUsdCxhLHIpe3VucmVhY2hhYmxlKCJTaG91bGQgbm90IGNhbGwgQ29sb3JTcGFjZS5nZXRSZ2JJdGVtIil9Z2V0UmdiQnVmZmVyKGUsdCxhLHIsaSxuLHMpe3VucmVhY2hhYmxlKCJTaG91bGQgbm90IGNhbGwgQ29sb3JTcGFjZS5nZXRSZ2JCdWZmZXIiKX1nZXRPdXRwdXRMZW5ndGgoZSx0KXt1bnJlYWNoYWJsZSgiU2hvdWxkIG5vdCBjYWxsIENvbG9yU3BhY2UuZ2V0T3V0cHV0TGVuZ3RoIil9aXNQYXNzdGhyb3VnaChlKXtyZXR1cm4hMX1pc0RlZmF1bHREZWNvZGUoZSx0KXtyZXR1cm4gQ29sb3JTcGFjZS5pc0RlZmF1bHREZWNvZGUoZSx0aGlzLm51bUNvbXBzKX1maWxsUmdiKGUsdCxhLHIsaSxuLHMsbyxjKXtjb25zdCBsPXQqYTtsZXQgaD1udWxsO2NvbnN0IHU9MTw8cyxkPWEhPT1pfHx0IT09cjtpZih0aGlzLmlzUGFzc3Rocm91Z2gocykpaD1vO2Vsc2UgaWYoMT09PXRoaXMubnVtQ29tcHMmJmw+dSYmIkRldmljZUdyYXkiIT09dGhpcy5uYW1lJiYiRGV2aWNlUkdCIiE9PXRoaXMubmFtZSl7Y29uc3QgdD1zPD04P25ldyBVaW50OEFycmF5KHUpOm5ldyBVaW50MTZBcnJheSh1KTtmb3IobGV0IGU9MDtlPHU7ZSsrKXRbZV09ZTtjb25zdCBhPW5ldyBVaW50OENsYW1wZWRBcnJheSgzKnUpO3RoaXMuZ2V0UmdiQnVmZmVyKHQsMCx1LGEsMCxzLDApO2lmKGQpe2g9bmV3IFVpbnQ4QXJyYXkoMypsKTtsZXQgZT0wO2ZvcihsZXQgdD0wO3Q8bDsrK3Qpe2NvbnN0IHI9MypvW3RdO2hbZSsrXT1hW3JdO2hbZSsrXT1hW3IrMV07aFtlKytdPWFbcisyXX19ZWxzZXtsZXQgdD0wO2ZvcihsZXQgcj0wO3I8bDsrK3Ipe2NvbnN0IGk9MypvW3JdO2VbdCsrXT1hW2ldO2VbdCsrXT1hW2krMV07ZVt0KytdPWFbaSsyXTt0Kz1jfX19ZWxzZSBpZihkKXtoPW5ldyBVaW50OENsYW1wZWRBcnJheSgzKmwpO3RoaXMuZ2V0UmdiQnVmZmVyKG8sMCxsLGgsMCxzLDApfWVsc2UgdGhpcy5nZXRSZ2JCdWZmZXIobywwLHIqbixlLDAscyxjKTtpZihoKWlmKGQpIWZ1bmN0aW9uIHJlc2l6ZVJnYkltYWdlKGUsdCxhLHIsaSxuLHMpe3M9MSE9PXM/MDpzO2NvbnN0IG89YS9pLGM9ci9uO2xldCBsLGg9MDtjb25zdCB1PW5ldyBVaW50MTZBcnJheShpKSxkPTMqYTtmb3IobGV0IGU9MDtlPGk7ZSsrKXVbZV09MypNYXRoLmZsb29yKGUqbyk7Zm9yKGxldCBhPTA7YTxuO2ErKyl7Y29uc3Qgcj1NYXRoLmZsb29yKGEqYykqZDtmb3IobGV0IGE9MDthPGk7YSsrKXtsPXIrdVthXTt0W2grK109ZVtsKytdO3RbaCsrXT1lW2wrK107dFtoKytdPWVbbCsrXTtoKz1zfX19KGgsZSx0LGEscixpLGMpO2Vsc2V7bGV0IHQ9MCxhPTA7Zm9yKGxldCBpPTAscz1yKm47aTxzO2krKyl7ZVt0KytdPWhbYSsrXTtlW3QrK109aFthKytdO2VbdCsrXT1oW2ErK107dCs9Y319fWdldCB1c2VzWmVyb1RvT25lUmFuZ2UoKXtyZXR1cm4gc2hhZG93KHRoaXMsInVzZXNaZXJvVG9PbmVSYW5nZSIsITApfXN0YXRpYyBpc0RlZmF1bHREZWNvZGUoZSx0KXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4hMDtpZigyKnQhPT1lLmxlbmd0aCl7d2FybigiVGhlIGRlY29kZSBtYXAgaXMgbm90IHRoZSBjb3JyZWN0IGxlbmd0aCIpO3JldHVybiEwfWZvcihsZXQgdD0wLGE9ZS5sZW5ndGg7dDxhO3QrPTIpaWYoMCE9PWVbdF18fDEhPT1lW3QrMV0pcmV0dXJuITE7cmV0dXJuITB9fWNsYXNzIEFsdGVybmF0ZUNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoIkFsdGVybmF0ZSIsZSk7dGhpcy5iYXNlPXQ7dGhpcy50aW50Rm49YTt0aGlzLnRtcEJ1Zj1uZXcgRmxvYXQzMkFycmF5KHQubnVtQ29tcHMpfWdldFJnYkl0ZW0oZSx0LGEscil7Y29uc3QgaT10aGlzLnRtcEJ1Zjt0aGlzLnRpbnRGbihlLHQsaSwwKTt0aGlzLmJhc2UuZ2V0UmdiSXRlbShpLDAsYSxyKX1nZXRSZ2JCdWZmZXIoZSx0LGEscixpLG4scyl7Y29uc3Qgbz10aGlzLnRpbnRGbixjPXRoaXMuYmFzZSxsPTEvKCgxPDxuKS0xKSxoPWMubnVtQ29tcHMsdT1jLnVzZXNaZXJvVG9PbmVSYW5nZSxkPShjLmlzUGFzc3Rocm91Z2goOCl8fCF1KSYmMD09PXM7bGV0IGY9ZD9pOjA7Y29uc3QgZz1kP3I6bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGgqYSkscD10aGlzLm51bUNvbXBzLG09bmV3IEZsb2F0MzJBcnJheShwKSxiPW5ldyBGbG9hdDMyQXJyYXkoaCk7bGV0IHksdztmb3IoeT0wO3k8YTt5Kyspe2Zvcih3PTA7dzxwO3crKyltW3ddPWVbdCsrXSpsO28obSwwLGIsMCk7aWYodSlmb3Iodz0wO3c8aDt3KyspZ1tmKytdPTI1NSpiW3ddO2Vsc2V7Yy5nZXRSZ2JJdGVtKGIsMCxnLGYpO2YrPWh9fWR8fGMuZ2V0UmdiQnVmZmVyKGcsMCxhLHIsaSw4LHMpfWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiB0aGlzLmJhc2UuZ2V0T3V0cHV0TGVuZ3RoKGUqdGhpcy5iYXNlLm51bUNvbXBzL3RoaXMubnVtQ29tcHMsdCl9fWNsYXNzIFBhdHRlcm5DUyBleHRlbmRzIENvbG9yU3BhY2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoIlBhdHRlcm4iLG51bGwpO3RoaXMuYmFzZT1lfWlzRGVmYXVsdERlY29kZShlLHQpe3VucmVhY2hhYmxlKCJTaG91bGQgbm90IGNhbGwgUGF0dGVybkNTLmlzRGVmYXVsdERlY29kZSIpfX1jbGFzcyBJbmRleGVkQ1MgZXh0ZW5kcyBDb2xvclNwYWNle2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcigiSW5kZXhlZCIsMSk7dGhpcy5iYXNlPWU7dGhpcy5oaWdoVmFsPXQ7Y29uc3Qgcj1lLm51bUNvbXBzKih0KzEpO3RoaXMubG9va3VwPW5ldyBVaW50OEFycmF5KHIpO2lmKGEgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKXtjb25zdCBlPWEuZ2V0Qnl0ZXMocik7dGhpcy5sb29rdXAuc2V0KGUpfWVsc2V7aWYoInN0cmluZyIhPXR5cGVvZiBhKXRocm93IG5ldyBGb3JtYXRFcnJvcihgSW5kZXhlZENTIC0gdW5yZWNvZ25pemVkIGxvb2t1cCB0YWJsZTogJHthfWApO2ZvcihsZXQgZT0wO2U8cjsrK2UpdGhpcy5sb29rdXBbZV09MjU1JmEuY2hhckNvZGVBdChlKX19Z2V0UmdiSXRlbShlLHQsYSxyKXtjb25zdHtiYXNlOmksaGlnaFZhbDpuLGxvb2t1cDpzfT10aGlzLG89TWF0aENsYW1wKE1hdGgucm91bmQoZVt0XSksMCxuKSppLm51bUNvbXBzO2kuZ2V0UmdiQnVmZmVyKHMsbywxLGEsciw4LDApfWdldFJnYkJ1ZmZlcihlLHQsYSxyLGksbixzKXtjb25zdHtiYXNlOm8saGlnaFZhbDpjLGxvb2t1cDpsfT10aGlzLHtudW1Db21wczpofT1vLHU9by5nZXRPdXRwdXRMZW5ndGgoaCxzKTtmb3IobGV0IG49MDtuPGE7KytuKXtjb25zdCBhPU1hdGhDbGFtcChNYXRoLnJvdW5kKGVbdCsrXSksMCxjKSpoO28uZ2V0UmdiQnVmZmVyKGwsYSwxLHIsaSw4LHMpO2krPXV9fWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiB0aGlzLmJhc2UuZ2V0T3V0cHV0TGVuZ3RoKGUqdGhpcy5iYXNlLm51bUNvbXBzLHQpfWlzRGVmYXVsdERlY29kZShlLHQpe2lmKCFBcnJheS5pc0FycmF5KGUpKXJldHVybiEwO2lmKDIhPT1lLmxlbmd0aCl7d2FybigiRGVjb2RlIG1hcCBsZW5ndGggaXMgbm90IGNvcnJlY3QiKTtyZXR1cm4hMH1pZighTnVtYmVyLmlzSW50ZWdlcih0KXx8dDwxKXt3YXJuKCJCaXRzIHBlciBjb21wb25lbnQgaXMgbm90IGNvcnJlY3QiKTtyZXR1cm4hMH1yZXR1cm4gMD09PWVbMF0mJmVbMV09PT0oMTw8dCktMX19Y2xhc3MgRGV2aWNlR3JheUNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCJEZXZpY2VHcmF5IiwxKX1nZXRSZ2JJdGVtKGUsdCxhLHIpe2NvbnN0IGk9MjU1KmVbdF07YVtyXT1hW3IrMV09YVtyKzJdPWl9Z2V0UmdiQnVmZmVyKGUsdCxhLHIsaSxuLHMpe2NvbnN0IG89MjU1LygoMTw8biktMSk7bGV0IGM9dCxsPWk7Zm9yKGxldCB0PTA7dDxhOysrdCl7Y29uc3QgdD1vKmVbYysrXTtyW2wrK109dDtyW2wrK109dDtyW2wrK109dDtsKz1zfX1nZXRPdXRwdXRMZW5ndGgoZSx0KXtyZXR1cm4gZSooMyt0KX19Y2xhc3MgRGV2aWNlUmdiQ1MgZXh0ZW5kcyBDb2xvclNwYWNle2NvbnN0cnVjdG9yKCl7c3VwZXIoIkRldmljZVJHQiIsMyl9Z2V0UmdiSXRlbShlLHQsYSxyKXthW3JdPTI1NSplW3RdO2FbcisxXT0yNTUqZVt0KzFdO2FbcisyXT0yNTUqZVt0KzJdfWdldFJnYkJ1ZmZlcihlLHQsYSxyLGksbixzKXtpZig4PT09biYmMD09PXMpe3Iuc2V0KGUuc3ViYXJyYXkodCx0KzMqYSksaSk7cmV0dXJufWNvbnN0IG89MjU1LygoMTw8biktMSk7bGV0IGM9dCxsPWk7Zm9yKGxldCB0PTA7dDxhOysrdCl7cltsKytdPW8qZVtjKytdO3JbbCsrXT1vKmVbYysrXTtyW2wrK109byplW2MrK107bCs9c319Z2V0T3V0cHV0TGVuZ3RoKGUsdCl7cmV0dXJuIGUqKDMrdCkvM3wwfWlzUGFzc3Rocm91Z2goZSl7cmV0dXJuIDg9PT1lfX1jbGFzcyBEZXZpY2VSZ2JhQ1MgZXh0ZW5kcyBDb2xvclNwYWNle2NvbnN0cnVjdG9yKCl7c3VwZXIoIkRldmljZVJHQkEiLDQpfWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiA0KmV9aXNQYXNzdGhyb3VnaChlKXtyZXR1cm4gOD09PWV9ZmlsbFJnYihlLHQsYSxyLGksbixzLG8sYyl7YSE9PWl8fHQhPT1yP2Z1bmN0aW9uIHJlc2l6ZVJnYmFJbWFnZShlLHQsYSxyLGksbixzKXtjb25zdCBvPWEvaSxjPXIvbjtsZXQgbD0wO2NvbnN0IGg9bmV3IFVpbnQxNkFycmF5KGkpO2lmKDE9PT1zKXtmb3IobGV0IGU9MDtlPGk7ZSsrKWhbZV09TWF0aC5mbG9vcihlKm8pO2NvbnN0IHI9bmV3IFVpbnQzMkFycmF5KGUuYnVmZmVyKSxzPW5ldyBVaW50MzJBcnJheSh0LmJ1ZmZlciksdT1GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbj8xNjc3NzIxNTo0Mjk0OTY3MDQwO2ZvcihsZXQgZT0wO2U8bjtlKyspe2NvbnN0IHQ9ci5zdWJhcnJheShNYXRoLmZsb29yKGUqYykqYSk7Zm9yKGxldCBlPTA7ZTxpO2UrKylzW2wrK118PXRbaFtlXV0mdX19ZWxzZXtjb25zdCByPTQscz1hKnI7Zm9yKGxldCBlPTA7ZTxpO2UrKyloW2VdPU1hdGguZmxvb3IoZSpvKSpyO2ZvcihsZXQgYT0wO2E8bjthKyspe2NvbnN0IHI9ZS5zdWJhcnJheShNYXRoLmZsb29yKGEqYykqcyk7Zm9yKGxldCBlPTA7ZTxpO2UrKyl7Y29uc3QgYT1oW2VdO3RbbCsrXT1yW2FdO3RbbCsrXT1yW2ErMV07dFtsKytdPXJbYSsyXX19fX0obyxlLHQsYSxyLGksYyk6ZnVuY3Rpb24gY29weVJnYmFJbWFnZShlLHQsYSl7aWYoMT09PWEpe2NvbnN0IGE9bmV3IFVpbnQzMkFycmF5KGUuYnVmZmVyKSxyPW5ldyBVaW50MzJBcnJheSh0LmJ1ZmZlciksaT1GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbj8xNjc3NzIxNTo0Mjk0OTY3MDQwO2ZvcihsZXQgZT0wLHQ9YS5sZW5ndGg7ZTx0O2UrKylyW2VdfD1hW2VdJml9ZWxzZXtsZXQgYT0wO2ZvcihsZXQgcj0wLGk9ZS5sZW5ndGg7cjxpO3IrPTQpe3RbYSsrXT1lW3JdO3RbYSsrXT1lW3IrMV07dFthKytdPWVbcisyXX19fShvLGUsYyl9fWNsYXNzIERldmljZUNteWtDUyBleHRlbmRzIENvbG9yU3BhY2V7Y29uc3RydWN0b3IoKXtzdXBlcigiRGV2aWNlQ01ZSyIsNCl9I2koZSx0LGEscixpKXtjb25zdCBuPWVbdF0qYSxzPWVbdCsxXSphLG89ZVt0KzJdKmEsYz1lW3QrM10qYTtyW2ldPTI1NStuKigtNC4zODczMzIzODQ2MDk5ODgqbis1NC40ODYxNTE5NDE4OTE3NipzKzE4LjgyMjkwNTAyMTY1MzAyKm8rMjEyLjI1NjYyNDUxNjM5NTg1KmMtMjg1LjIzMzEwMjYxMzcwMDQpK3MqKDEuNzE0OTc2MzQ3NzM2MjEzNCpzLTUuNjA5NjczNjkwNDA0NzMxNSpvKy0xNy44NzM4NzA4NjE0MTU0NDQqYy01LjQ5NzAwNjQyNzE5NjM2NikrbyooLTIuNTIxNzM0MDEzMTY4MzAzMypvLTIxLjI0ODkyMzMzNzM1MzA3MypjKzE3LjUxMTkyNzA4NDE4MTMpK2MqKC0yMS44NjEyMjE0NzQ2MzYwNSpjLTE4OS40ODE4MDgzNTkyMjc0Nyk7cltpKzFdPTI1NStuKig4Ljg0MTA0MTQyMjAzNjE0OSpuKzYwLjExODAyNzA0NTU5NzM2NipzKzYuODcxNDI1NTkyMDQ5MDA3Km8rMzEuMTU5MTAwMTMwMDU1OTIyKmMtNzkuMjk3MDg0NDgxNjU0OCkrcyooLTE1LjMxMDM2MTMwNjk2NzgxNypzKzE3LjU3NTI1MTI2MTEwOTQ4MipvKzEzMS4zNTI1MDkxMjQ5Mzk3NipjLTE5MC45NDUzMzAyNTg4OTUxKStvKig0LjQ0NDMzOTEwMjg1MjczOSpvKzkuODYzMjg2MTQ5MzQwNSpjLTI0Ljg2NzQxNTgyNTU1ODc4KStjKigtMjAuNzM3MzI1NDcxMTgxMDM0KmMtMTg3LjgwNDUzNzA5NzE5NTc4KTtyW2krMl09MjU1K24qKC44ODQyNTIyNDMwMDAzMjk2Km4rOC4wNzg2Nzc1MDMxMTI5MjgqcyszMC44OTk3ODMwOTcwMzcyOSpvLS4yMzg4MzIzODY4OTE3ODkzNCpjLTE0LjE4MzU3Njc5OTY3MzI4NikrcyooMTAuNDk1OTMyNzM0MzIwNzIqcys2My4wMjM3ODQ5NDc1NDA1MipvKzUwLjYwNjk1NzY1NjM2MDczNCpjLTExMi4yMzg4NDI1MzcxOTI0OCkrbyooLjAzMjk2MDQxMTE0ODczMjE3Km8rMTE1LjYwMzg0NDQ5NjQ2NjQxKmMtMTkzLjU4MjA5MzU2ODYxNTA1KStjKigtMjIuMzM4MTY4MDczMDk4ODYqYy0xODAuMTI2MTM5NzQ3MDgzNjcpfWdldFJnYkl0ZW0oZSx0LGEscil7dGhpcy4jaShlLHQsMSxhLHIpfWdldFJnYkJ1ZmZlcihlLHQsYSxyLGksbixzKXtjb25zdCBvPTEvKCgxPDxuKS0xKTtmb3IobGV0IG49MDtuPGE7bisrKXt0aGlzLiNpKGUsdCxvLHIsaSk7dCs9NDtpKz0zK3N9fWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiBlLzQqKDMrdCl8MH19Y2xhc3MgQ2FsR3JheUNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoIkNhbEdyYXkiLDEpO2lmKCFlKXRocm93IG5ldyBGb3JtYXRFcnJvcigiV2hpdGVQb2ludCBtaXNzaW5nIC0gcmVxdWlyZWQgZm9yIGNvbG9yIHNwYWNlIENhbEdyYXkiKTtbdGhpcy5YVyx0aGlzLllXLHRoaXMuWlddPWU7W3RoaXMuWEIsdGhpcy5ZQix0aGlzLlpCXT10fHxbMCwwLDBdO3RoaXMuRz1hfHwxO2lmKHRoaXMuWFc8MHx8dGhpcy5aVzwwfHwxIT09dGhpcy5ZVyl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgV2hpdGVQb2ludCBjb21wb25lbnRzIGZvciAke3RoaXMubmFtZX0sIG5vIGZhbGxiYWNrIGF2YWlsYWJsZWApO2lmKHRoaXMuWEI8MHx8dGhpcy5ZQjwwfHx0aGlzLlpCPDApe2luZm8oYEludmFsaWQgQmxhY2tQb2ludCBmb3IgJHt0aGlzLm5hbWV9LCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdC5gKTt0aGlzLlhCPXRoaXMuWUI9dGhpcy5aQj0wfTA9PT10aGlzLlhCJiYwPT09dGhpcy5ZQiYmMD09PXRoaXMuWkJ8fHdhcm4oYCR7dGhpcy5uYW1lfSwgQmxhY2tQb2ludDogWEI6ICR7dGhpcy5YQn0sIFlCOiAke3RoaXMuWUJ9LCBaQjogJHt0aGlzLlpCfSwgb25seSBkZWZhdWx0IHZhbHVlcyBhcmUgc3VwcG9ydGVkLmApO2lmKHRoaXMuRzwxKXtpbmZvKGBJbnZhbGlkIEdhbW1hOiAke3RoaXMuR30gZm9yICR7dGhpcy5uYW1lfSwgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHQuYCk7dGhpcy5HPTF9fSNpKGUsdCxhLHIsaSl7Y29uc3Qgbj0oZVt0XSppKSoqdGhpcy5HLHM9dGhpcy5ZVypuLG89TWF0aC5tYXgoMjk1LjgqcyoqLjMzMzMzMzMzMzMzMzMzMzMtNDAuOCwwKTthW3JdPW87YVtyKzFdPW87YVtyKzJdPW99Z2V0UmdiSXRlbShlLHQsYSxyKXt0aGlzLiNpKGUsdCxhLHIsMSl9Z2V0UmdiQnVmZmVyKGUsdCxhLHIsaSxuLHMpe2NvbnN0IG89MS8oKDE8PG4pLTEpO2ZvcihsZXQgbj0wO248YTsrK24pe3RoaXMuI2koZSx0LHIsaSxvKTt0Kz0xO2krPTMrc319Z2V0T3V0cHV0TGVuZ3RoKGUsdCl7cmV0dXJuIGUqKDMrdCl9fWNsYXNzIENhbFJHQkNTIGV4dGVuZHMgQ29sb3JTcGFjZXtzdGF0aWMjbj1uZXcgRmxvYXQzMkFycmF5KFsuODk1MSwuMjY2NCwtLjE2MTQsLS43NTAyLDEuNzEzNSwuMDM2NywuMDM4OSwtLjA2ODUsMS4wMjk2XSk7c3RhdGljI3M9bmV3IEZsb2F0MzJBcnJheShbLjk4Njk5MjksLS4xNDcwNTQzLC4xNTk5NjI3LC40MzIzMDUzLC41MTgzNjAzLC4wNDkyOTEyLC0uMDA4NTI4NywuMDQwMDQyOCwuOTY4NDg2N10pO3N0YXRpYyNvPW5ldyBGbG9hdDMyQXJyYXkoWzMuMjQwNDU0MiwtMS41MzcxMzg1LC0uNDk4NTMxNCwtLjk2OTI2NiwxLjg3NjAxMDgsLjA0MTU1NiwuMDU1NjQzNCwtLjIwNDAyNTksMS4wNTcyMjUyXSk7c3RhdGljI2M9bmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKTtzdGF0aWMjbD1uZXcgRmxvYXQzMkFycmF5KDMpO3N0YXRpYyNoPW5ldyBGbG9hdDMyQXJyYXkoMyk7c3RhdGljI3U9bmV3IEZsb2F0MzJBcnJheSgzKTtzdGF0aWMjZD0oMjQvMTE2KSoqMy84O2NvbnN0cnVjdG9yKGUsdCxhLHIpe3N1cGVyKCJDYWxSR0IiLDMpO2lmKCFlKXRocm93IG5ldyBGb3JtYXRFcnJvcigiV2hpdGVQb2ludCBtaXNzaW5nIC0gcmVxdWlyZWQgZm9yIGNvbG9yIHNwYWNlIENhbFJHQiIpO2NvbnN0W2ksbixzXT10aGlzLndoaXRlUG9pbnQ9ZSxbbyxjLGxdPXRoaXMuYmxhY2tQb2ludD10fHxuZXcgRmxvYXQzMkFycmF5KDMpO1t0aGlzLkdSLHRoaXMuR0csdGhpcy5HQl09YXx8bmV3IEZsb2F0MzJBcnJheShbMSwxLDFdKTtbdGhpcy5NWEEsdGhpcy5NWUEsdGhpcy5NWkEsdGhpcy5NWEIsdGhpcy5NWUIsdGhpcy5NWkIsdGhpcy5NWEMsdGhpcy5NWUMsdGhpcy5NWkNdPXJ8fG5ldyBGbG9hdDMyQXJyYXkoWzEsMCwwLDAsMSwwLDAsMCwxXSk7aWYoaTwwfHxzPDB8fDEhPT1uKXRocm93IG5ldyBGb3JtYXRFcnJvcihgSW52YWxpZCBXaGl0ZVBvaW50IGNvbXBvbmVudHMgZm9yICR7dGhpcy5uYW1lfSwgbm8gZmFsbGJhY2sgYXZhaWxhYmxlYCk7aWYobzwwfHxjPDB8fGw8MCl7aW5mbyhgSW52YWxpZCBCbGFja1BvaW50IGZvciAke3RoaXMubmFtZX0gWyR7b30sICR7Y30sICR7bH1dLCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdC5gKTt0aGlzLmJsYWNrUG9pbnQ9bmV3IEZsb2F0MzJBcnJheSgzKX1pZih0aGlzLkdSPDB8fHRoaXMuR0c8MHx8dGhpcy5HQjwwKXtpbmZvKGBJbnZhbGlkIEdhbW1hIFske3RoaXMuR1J9LCAke3RoaXMuR0d9LCAke3RoaXMuR0J9XSBmb3IgJHt0aGlzLm5hbWV9LCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdC5gKTt0aGlzLkdSPXRoaXMuR0c9dGhpcy5HQj0xfX0jZihlLHQsYSl7YVswXT1lWzBdKnRbMF0rZVsxXSp0WzFdK2VbMl0qdFsyXTthWzFdPWVbM10qdFswXStlWzRdKnRbMV0rZVs1XSp0WzJdO2FbMl09ZVs2XSp0WzBdK2VbN10qdFsxXStlWzhdKnRbMl19I2coZSx0LGEpe2FbMF09MSp0WzBdL2VbMF07YVsxXT0xKnRbMV0vZVsxXTthWzJdPTEqdFsyXS9lWzJdfSNwKGUsdCxhKXthWzBdPS45NTA0Nyp0WzBdL2VbMF07YVsxXT0xKnRbMV0vZVsxXTthWzJdPTEuMDg4ODMqdFsyXS9lWzJdfSNtKGUpe3JldHVybiBlPD0uMDAzMTMwOD9NYXRoQ2xhbXAoMTIuOTIqZSwwLDEpOmU+PS45OTU1NDUyNT8xOk1hdGhDbGFtcCgxLjA1NSplKiooMS8yLjQpLS4wNTUsMCwxKX0jYihlKXtyZXR1cm4gZTwwPy10aGlzLiNiKC1lKTplPjg/KChlKzE2KS8xMTYpKiozOmUqQ2FsUkdCQ1MuI2R9I3koZSx0LGEpe2lmKDA9PT1lWzBdJiYwPT09ZVsxXSYmMD09PWVbMl0pe2FbMF09dFswXTthWzFdPXRbMV07YVsyXT10WzJdO3JldHVybn1jb25zdCByPXRoaXMuI2IoMCksaT0oMS1yKS8oMS10aGlzLiNiKGVbMF0pKSxuPTEtaSxzPSgxLXIpLygxLXRoaXMuI2IoZVsxXSkpLG89MS1zLGM9KDEtcikvKDEtdGhpcy4jYihlWzJdKSksbD0xLWM7YVswXT10WzBdKmkrbjthWzFdPXRbMV0qcytvO2FbMl09dFsyXSpjK2x9I3coZSx0LGEpe2lmKDE9PT1lWzBdJiYxPT09ZVsyXSl7YVswXT10WzBdO2FbMV09dFsxXTthWzJdPXRbMl07cmV0dXJufWNvbnN0IHI9YTt0aGlzLiNmKENhbFJHQkNTLiNuLHQscik7Y29uc3QgaT1DYWxSR0JDUy4jbDt0aGlzLiNnKGUscixpKTt0aGlzLiNmKENhbFJHQkNTLiNzLGksYSl9I3goZSx0LGEpe2NvbnN0IHI9YTt0aGlzLiNmKENhbFJHQkNTLiNuLHQscik7Y29uc3QgaT1DYWxSR0JDUy4jbDt0aGlzLiNwKGUscixpKTt0aGlzLiNmKENhbFJHQkNTLiNzLGksYSl9I2koZSx0LGEscixpKXtjb25zdCBuPU1hdGhDbGFtcChlW3RdKmksMCwxKSxzPU1hdGhDbGFtcChlW3QrMV0qaSwwLDEpLG89TWF0aENsYW1wKGVbdCsyXSppLDAsMSksYz0xPT09bj8xOm4qKnRoaXMuR1IsbD0xPT09cz8xOnMqKnRoaXMuR0csaD0xPT09bz8xOm8qKnRoaXMuR0IsdT10aGlzLk1YQSpjK3RoaXMuTVhCKmwrdGhpcy5NWEMqaCxkPXRoaXMuTVlBKmMrdGhpcy5NWUIqbCt0aGlzLk1ZQypoLGY9dGhpcy5NWkEqYyt0aGlzLk1aQipsK3RoaXMuTVpDKmgsZz1DYWxSR0JDUy4jaDtnWzBdPXU7Z1sxXT1kO2dbMl09Zjtjb25zdCBwPUNhbFJHQkNTLiN1O3RoaXMuI3codGhpcy53aGl0ZVBvaW50LGcscCk7Y29uc3QgbT1DYWxSR0JDUy4jaDt0aGlzLiN5KHRoaXMuYmxhY2tQb2ludCxwLG0pO2NvbnN0IGI9Q2FsUkdCQ1MuI3U7dGhpcy4jeChDYWxSR0JDUy4jYyxtLGIpO2NvbnN0IHk9Q2FsUkdCQ1MuI2g7dGhpcy4jZihDYWxSR0JDUy4jbyxiLHkpO2Fbcl09MjU1KnRoaXMuI20oeVswXSk7YVtyKzFdPTI1NSp0aGlzLiNtKHlbMV0pO2FbcisyXT0yNTUqdGhpcy4jbSh5WzJdKX1nZXRSZ2JJdGVtKGUsdCxhLHIpe3RoaXMuI2koZSx0LGEsciwxKX1nZXRSZ2JCdWZmZXIoZSx0LGEscixpLG4scyl7Y29uc3Qgbz0xLygoMTw8biktMSk7Zm9yKGxldCBuPTA7bjxhOysrbil7dGhpcy4jaShlLHQscixpLG8pO3QrPTM7aSs9MytzfX1nZXRPdXRwdXRMZW5ndGgoZSx0KXtyZXR1cm4gZSooMyt0KS8zfDB9fWNsYXNzIExhYkNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoIkxhYiIsMyk7aWYoIWUpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJXaGl0ZVBvaW50IG1pc3NpbmcgLSByZXF1aXJlZCBmb3IgY29sb3Igc3BhY2UgTGFiIik7W3RoaXMuWFcsdGhpcy5ZVyx0aGlzLlpXXT1lO1t0aGlzLmFtaW4sdGhpcy5hbWF4LHRoaXMuYm1pbix0aGlzLmJtYXhdPWF8fFstMTAwLDEwMCwtMTAwLDEwMF07W3RoaXMuWEIsdGhpcy5ZQix0aGlzLlpCXT10fHxbMCwwLDBdO2lmKHRoaXMuWFc8MHx8dGhpcy5aVzwwfHwxIT09dGhpcy5ZVyl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkludmFsaWQgV2hpdGVQb2ludCBjb21wb25lbnRzLCBubyBmYWxsYmFjayBhdmFpbGFibGUiKTtpZih0aGlzLlhCPDB8fHRoaXMuWUI8MHx8dGhpcy5aQjwwKXtpbmZvKCJJbnZhbGlkIEJsYWNrUG9pbnQsIGZhbGxpbmcgYmFjayB0byBkZWZhdWx0Iik7dGhpcy5YQj10aGlzLllCPXRoaXMuWkI9MH1pZih0aGlzLmFtaW4+dGhpcy5hbWF4fHx0aGlzLmJtaW4+dGhpcy5ibWF4KXtpbmZvKCJJbnZhbGlkIFJhbmdlLCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdHMiKTt0aGlzLmFtaW49LTEwMDt0aGlzLmFtYXg9MTAwO3RoaXMuYm1pbj0tMTAwO3RoaXMuYm1heD0xMDB9fSNTKGUpe3JldHVybiBlPj02LzI5P2UqKjM6MTA4Lzg0MSooZS00LzI5KX0jQShlLHQsYSxyKXtyZXR1cm4gYStlKihyLWEpL3R9I2koZSx0LGEscixpKXtsZXQgbj1lW3RdLHM9ZVt0KzFdLG89ZVt0KzJdO2lmKCExIT09YSl7bj10aGlzLiNBKG4sYSwwLDEwMCk7cz10aGlzLiNBKHMsYSx0aGlzLmFtaW4sdGhpcy5hbWF4KTtvPXRoaXMuI0EobyxhLHRoaXMuYm1pbix0aGlzLmJtYXgpfXM+dGhpcy5hbWF4P3M9dGhpcy5hbWF4OnM8dGhpcy5hbWluJiYocz10aGlzLmFtaW4pO28+dGhpcy5ibWF4P289dGhpcy5ibWF4Om88dGhpcy5ibWluJiYobz10aGlzLmJtaW4pO2NvbnN0IGM9KG4rMTYpLzExNixsPWMrcy81MDAsaD1jLW8vMjAwLHU9dGhpcy5YVyp0aGlzLiNTKGwpLGQ9dGhpcy5ZVyp0aGlzLiNTKGMpLGY9dGhpcy5aVyp0aGlzLiNTKGgpO2xldCBnLHAsbTtpZih0aGlzLlpXPDEpe2c9My4xMzM5KnUrLTEuNjE3KmQrLS40OTA2KmY7cD0tLjk3ODUqdSsxLjkxNipkKy4wMzMzKmY7bT0uMDcyKnUrLS4yMjkqZCsxLjQwNTcqZn1lbHNle2c9My4yNDA2KnUrLTEuNTM3MipkKy0uNDk4NipmO3A9LS45Njg5KnUrMS44NzU4KmQrLjA0MTUqZjttPS4wNTU3KnUrLS4yMDQqZCsxLjA1NypmfXJbaV09MjU1Kk1hdGguc3FydChnKTtyW2krMV09MjU1Kk1hdGguc3FydChwKTtyW2krMl09MjU1Kk1hdGguc3FydChtKX1nZXRSZ2JJdGVtKGUsdCxhLHIpe3RoaXMuI2koZSx0LCExLGEscil9Z2V0UmdiQnVmZmVyKGUsdCxhLHIsaSxuLHMpe2NvbnN0IG89KDE8PG4pLTE7Zm9yKGxldCBuPTA7bjxhO24rKyl7dGhpcy4jaShlLHQsbyxyLGkpO3QrPTM7aSs9MytzfX1nZXRPdXRwdXRMZW5ndGgoZSx0KXtyZXR1cm4gZSooMyt0KS8zfDB9aXNEZWZhdWx0RGVjb2RlKGUsdCl7cmV0dXJuITB9Z2V0IHVzZXNaZXJvVG9PbmVSYW5nZSgpe3JldHVybiBzaGFkb3codGhpcywidXNlc1plcm9Ub09uZVJhbmdlIiwhMSl9fWZ1bmN0aW9uIGZldGNoU3luYyhlKXtjb25zdCB0PW5ldyBYTUxIdHRwUmVxdWVzdDt0Lm9wZW4oIkdFVCIsZSwhMSk7dC5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIjt0LnNlbmQobnVsbCk7cmV0dXJuIHQucmVzcG9uc2V9Y2xhc3MgSWNjQ29sb3JTcGFjZSBleHRlbmRzIENvbG9yU3BhY2V7I2s7I0M7c3RhdGljI3Y9ITA7c3RhdGljI0Y9bnVsbDtzdGF0aWMjST1udWxsO2NvbnN0cnVjdG9yKGUsdCxhKXtpZighSWNjQ29sb3JTcGFjZS5pc1VzYWJsZSl0aHJvdyBuZXcgRXJyb3IoIk5vIElDQyBjb2xvciBzcGFjZSBzdXBwb3J0Iik7c3VwZXIodCxhKTtsZXQgcjtzd2l0Y2goYSl7Y2FzZSAxOnI9eWEuR3JheTg7dGhpcy4jQz0oZSx0LGEpPT5mdW5jdGlvbiBxY21zX2NvbnZlcnRfb25lKGUsdCxhKXtnYS5xY21zX2NvbnZlcnRfb25lKGUsdCxhKX0odGhpcy4jaywyNTUqZVt0XSxhKTticmVhaztjYXNlIDM6cj15YS5SR0I4O3RoaXMuI0M9KGUsdCxhKT0+ZnVuY3Rpb24gcWNtc19jb252ZXJ0X3RocmVlKGUsdCxhLHIsaSl7Z2EucWNtc19jb252ZXJ0X3RocmVlKGUsdCxhLHIsaSl9KHRoaXMuI2ssMjU1KmVbdF0sMjU1KmVbdCsxXSwyNTUqZVt0KzJdLGEpO2JyZWFrO2Nhc2UgNDpyPXlhLkNNWUs7dGhpcy4jQz0oZSx0LGEpPT5mdW5jdGlvbiBxY21zX2NvbnZlcnRfZm91cihlLHQsYSxyLGksbil7Z2EucWNtc19jb252ZXJ0X2ZvdXIoZSx0LGEscixpLG4pfSh0aGlzLiNrLDI1NSplW3RdLDI1NSplW3QrMV0sMjU1KmVbdCsyXSwyNTUqZVt0KzNdLGEpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBudW1iZXIgb2YgY29tcG9uZW50czogJHthfWApfXRoaXMuI2s9ZnVuY3Rpb24gcWNtc190cmFuc2Zvcm1lcl9mcm9tX21lbW9yeShlLHQsYSl7Y29uc3Qgcj1wYXNzQXJyYXk4VG9XYXNtMChlLGdhLl9fd2JpbmRnZW5fbWFsbG9jKSxpPWJhO3JldHVybiBnYS5xY21zX3RyYW5zZm9ybWVyX2Zyb21fbWVtb3J5KHIsaSx0LGEpPj4+MH0oZSxyLHdhLlBlcmNlcHR1YWwpO2lmKCF0aGlzLiNrKXRocm93IG5ldyBFcnJvcigiRmFpbGVkIHRvIGNyZWF0ZSBJQ0MgY29sb3Igc3BhY2UiKTtJY2NDb2xvclNwYWNlLiNJfHw9bmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChlPT57IWZ1bmN0aW9uIHFjbXNfZHJvcF90cmFuc2Zvcm1lcihlKXtnYS5xY21zX2Ryb3BfdHJhbnNmb3JtZXIoZSl9KGUpfSkpO0ljY0NvbG9yU3BhY2UuI0kucmVnaXN0ZXIodGhpcyx0aGlzLiNrKX1nZXRSZ2JIZXgoZSx0KXt0aGlzLiNDKGUsdCwhMCk7cmV0dXJuIFFDTVMuX2Nzc0NvbG9yfWdldFJnYkl0ZW0oZSx0LGEscil7UUNNUy5fZGVzdEJ1ZmZlcj1hO1FDTVMuX2Rlc3RPZmZzZXQ9cjtRQ01TLl9kZXN0TGVuZ3RoPTM7dGhpcy4jQyhlLHQsITEpO1FDTVMuX2Rlc3RCdWZmZXI9bnVsbH1nZXRSZ2JCdWZmZXIoZSx0LGEscixpLG4scyl7ZT1lLnN1YmFycmF5KHQsdCthKnRoaXMubnVtQ29tcHMpO2lmKDghPT1uKXtjb25zdCB0PTI1NS8oKDE8PG4pLTEpO2ZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyO2ErKyllW2FdKj10fVFDTVMuX211c3RBZGRBbHBoYT1zJiZyLmJ1ZmZlcj09PWUuYnVmZmVyO1FDTVMuX2Rlc3RCdWZmZXI9cjtRQ01TLl9kZXN0T2Zmc2V0PWk7UUNNUy5fZGVzdExlbmd0aD1hKigzK3MpOyFmdW5jdGlvbiBxY21zX2NvbnZlcnRfYXJyYXkoZSx0KXtjb25zdCBhPXBhc3NBcnJheThUb1dhc20wKHQsZ2EuX193YmluZGdlbl9tYWxsb2MpLHI9YmE7Z2EucWNtc19jb252ZXJ0X2FycmF5KGUsYSxyKX0odGhpcy4jayxlKTtRQ01TLl9tdXN0QWRkQWxwaGE9ITE7UUNNUy5fZGVzdEJ1ZmZlcj1udWxsfWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiBlL3RoaXMubnVtQ29tcHMqKDMrdCl8MH1zdGF0aWMgc2V0T3B0aW9ucyh7dXNlV2FzbTplLHVzZVdvcmtlckZldGNoOnQsd2FzbVVybDphfSl7aWYodCl7dGhpcy4jdj1lO3RoaXMuI0Y9YX1lbHNlIHRoaXMuI3Y9ITF9c3RhdGljIGdldCBpc1VzYWJsZSgpe2xldCBlPSExO2lmKHRoaXMuI3YpaWYodGhpcy4jRil0cnl7dGhpcy5fbW9kdWxlPWZ1bmN0aW9uIGluaXRTeW5jKGUpe2lmKHZvaWQgMCE9PWdhKXJldHVybiBnYTt2b2lkIDAhPT1lJiYoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpPT09T2JqZWN0LnByb3RvdHlwZT8oe21vZHVsZTplfT1lKTpjb25zb2xlLndhcm4oInVzaW5nIGRlcHJlY2F0ZWQgcGFyYW1ldGVycyBmb3IgYGluaXRTeW5jKClgOyBwYXNzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIikpO2NvbnN0IHQ9X193YmdfZ2V0X2ltcG9ydHMoKTtlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlfHwoZT1uZXcgV2ViQXNzZW1ibHkuTW9kdWxlKGUpKTtyZXR1cm4gX193YmdfZmluYWxpemVfaW5pdChuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZSx0KSxlKX0oe21vZHVsZTpmZXRjaFN5bmMoYCR7dGhpcy4jRn1xY21zX2JnLndhc21gKX0pO2U9ISF0aGlzLl9tb2R1bGU7UUNNUy5fbWVtb3J5PXRoaXMuX21vZHVsZS5tZW1vcnk7UUNNUy5fbWFrZUhleENvbG9yPVV0aWwubWFrZUhleENvbG9yfWNhdGNoKGUpe3dhcm4oYElDQ0Jhc2VkIGNvbG9yIHNwYWNlOiAiJHtlfSIuYCl9ZWxzZSB3YXJuKCJObyBJQ0MgY29sb3Igc3BhY2Ugc3VwcG9ydCBkdWUgdG8gbWlzc2luZyBgd2FzbVVybGAgQVBJIG9wdGlvbiIpO3JldHVybiBzaGFkb3codGhpcywiaXNVc2FibGUiLGUpfX1jbGFzcyBDbXlrSUNDQmFzZWRDUyBleHRlbmRzIEljY0NvbG9yU3BhY2V7c3RhdGljI1Q7Y29uc3RydWN0b3IoKXtzdXBlcihuZXcgVWludDhBcnJheShmZXRjaFN5bmMoYCR7Q215a0lDQ0Jhc2VkQ1MuI1R9Q0dBVFMwMDFDb21wYXQtdjItbWljcm8uaWNjYCkpLCJEZXZpY2VDTVlLIiw0KX1zdGF0aWMgc2V0T3B0aW9ucyh7aWNjVXJsOmV9KXt0aGlzLiNUPWV9c3RhdGljIGdldCBpc1VzYWJsZSgpe2xldCBlPSExO0ljY0NvbG9yU3BhY2UuaXNVc2FibGUmJih0aGlzLiNUP2U9ITA6d2FybigiTm8gQ01ZSyBJQ0MgcHJvZmlsZSBzdXBwb3J0IGR1ZSB0byBtaXNzaW5nIGBpY2NVcmxgIEFQSSBvcHRpb24iKSk7cmV0dXJuIHNoYWRvdyh0aGlzLCJpc1VzYWJsZSIsZSl9fWNsYXNzIFN0cmVhbSBleHRlbmRzIEJhc2VTdHJlYW17Y29uc3RydWN0b3IoZSx0LGEscil7c3VwZXIoKTt0aGlzLmJ5dGVzPWUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSk7dGhpcy5zdGFydD10fHwwO3RoaXMucG9zPXRoaXMuc3RhcnQ7dGhpcy5lbmQ9dCthfHx0aGlzLmJ5dGVzLmxlbmd0aDt0aGlzLmRpY3Q9cn1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuZW5kLXRoaXMuc3RhcnR9Z2V0IGlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMubGVuZ3RofWdldEJ5dGUoKXtyZXR1cm4gdGhpcy5wb3M+PXRoaXMuZW5kPy0xOnRoaXMuYnl0ZXNbdGhpcy5wb3MrK119Z2V0Qnl0ZXMoZSl7Y29uc3QgdD10aGlzLmJ5dGVzLGE9dGhpcy5wb3Mscj10aGlzLmVuZDtpZighZSlyZXR1cm4gdC5zdWJhcnJheShhLHIpO2xldCBpPWErZTtpPnImJihpPXIpO3RoaXMucG9zPWk7cmV0dXJuIHQuc3ViYXJyYXkoYSxpKX1nZXRCeXRlUmFuZ2UoZSx0KXtlPDAmJihlPTApO3Q+dGhpcy5lbmQmJih0PXRoaXMuZW5kKTtyZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheShlLHQpfXJlc2V0KCl7dGhpcy5wb3M9dGhpcy5zdGFydH1tb3ZlU3RhcnQoKXt0aGlzLnN0YXJ0PXRoaXMucG9zfW1ha2VTdWJTdHJlYW0oZSx0LGE9bnVsbCl7cmV0dXJuIG5ldyBTdHJlYW0odGhpcy5ieXRlcy5idWZmZXIsZSx0LGEpfX1jbGFzcyBTdHJpbmdTdHJlYW0gZXh0ZW5kcyBTdHJlYW17Y29uc3RydWN0b3IoZSl7c3VwZXIoc3RyaW5nVG9CeXRlcyhlKSl9fWNsYXNzIE51bGxTdHJlYW0gZXh0ZW5kcyBTdHJlYW17Y29uc3RydWN0b3IoKXtzdXBlcihuZXcgVWludDhBcnJheSgwKSl9fWNsYXNzIENodW5rZWRTdHJlYW0gZXh0ZW5kcyBTdHJlYW17Y29uc3RydWN0b3IoZSx0LGEpe3N1cGVyKG5ldyBVaW50OEFycmF5KGUpLDAsZSxudWxsKTt0aGlzLmNodW5rU2l6ZT10O3RoaXMuX2xvYWRlZENodW5rcz1uZXcgU2V0O3RoaXMubnVtQ2h1bmtzPU1hdGguY2VpbChlL3QpO3RoaXMubWFuYWdlcj1hO3RoaXMucHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoPTA7dGhpcy5sYXN0U3VjY2Vzc2Z1bEVuc3VyZUJ5dGVDaHVuaz0tMX1nZXRNaXNzaW5nQ2h1bmtzKCl7Y29uc3QgZT1bXTtmb3IobGV0IHQ9MCxhPXRoaXMubnVtQ2h1bmtzO3Q8YTsrK3QpdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyh0KXx8ZS5wdXNoKHQpO3JldHVybiBlfWdldCBudW1DaHVua3NMb2FkZWQoKXtyZXR1cm4gdGhpcy5fbG9hZGVkQ2h1bmtzLnNpemV9Z2V0IGlzRGF0YUxvYWRlZCgpe3JldHVybiB0aGlzLm51bUNodW5rc0xvYWRlZD09PXRoaXMubnVtQ2h1bmtzfW9uUmVjZWl2ZURhdGEoZSx0KXtjb25zdCBhPXRoaXMuY2h1bmtTaXplO2lmKGUlYSE9MCl0aHJvdyBuZXcgRXJyb3IoYEJhZCBiZWdpbiBvZmZzZXQ6ICR7ZX1gKTtjb25zdCByPWUrdC5ieXRlTGVuZ3RoO2lmKHIlYSE9MCYmciE9PXRoaXMuYnl0ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgQmFkIGVuZCBvZmZzZXQ6ICR7cn1gKTt0aGlzLmJ5dGVzLnNldChuZXcgVWludDhBcnJheSh0KSxlKTtjb25zdCBpPU1hdGguZmxvb3IoZS9hKSxuPU1hdGguZmxvb3IoKHItMSkvYSkrMTtmb3IobGV0IGU9aTtlPG47KytlKXRoaXMuX2xvYWRlZENodW5rcy5hZGQoZSl9b25SZWNlaXZlUHJvZ3Jlc3NpdmVEYXRhKGUpe2xldCB0PXRoaXMucHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoO2NvbnN0IGE9TWF0aC5mbG9vcih0L3RoaXMuY2h1bmtTaXplKTt0aGlzLmJ5dGVzLnNldChuZXcgVWludDhBcnJheShlKSx0KTt0Kz1lLmJ5dGVMZW5ndGg7dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGg9dDtjb25zdCByPXQ+PXRoaXMuZW5kP3RoaXMubnVtQ2h1bmtzOk1hdGguZmxvb3IodC90aGlzLmNodW5rU2l6ZSk7Zm9yKGxldCBlPWE7ZTxyOysrZSl0aGlzLl9sb2FkZWRDaHVua3MuYWRkKGUpfWVuc3VyZUJ5dGUoZSl7aWYoZTx0aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aClyZXR1cm47Y29uc3QgdD1NYXRoLmZsb29yKGUvdGhpcy5jaHVua1NpemUpO2lmKCEodD50aGlzLm51bUNodW5rcykmJnQhPT10aGlzLmxhc3RTdWNjZXNzZnVsRW5zdXJlQnl0ZUNodW5rKXtpZighdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyh0KSl0aHJvdyBuZXcgTWlzc2luZ0RhdGFFeGNlcHRpb24oZSxlKzEpO3RoaXMubGFzdFN1Y2Nlc3NmdWxFbnN1cmVCeXRlQ2h1bms9dH19ZW5zdXJlUmFuZ2UoZSx0KXtpZihlPj10KXJldHVybjtpZih0PD10aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aClyZXR1cm47Y29uc3QgYT1NYXRoLmZsb29yKGUvdGhpcy5jaHVua1NpemUpO2lmKGE+dGhpcy5udW1DaHVua3MpcmV0dXJuO2NvbnN0IHI9TWF0aC5taW4oTWF0aC5mbG9vcigodC0xKS90aGlzLmNodW5rU2l6ZSkrMSx0aGlzLm51bUNodW5rcyk7Zm9yKGxldCBpPWE7aTxyOysraSlpZighdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyhpKSl0aHJvdyBuZXcgTWlzc2luZ0RhdGFFeGNlcHRpb24oZSx0KX1uZXh0RW1wdHlDaHVuayhlKXtjb25zdCB0PXRoaXMubnVtQ2h1bmtzO2ZvcihsZXQgYT0wO2E8dDsrK2Epe2NvbnN0IHI9KGUrYSkldDtpZighdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyhyKSlyZXR1cm4gcn1yZXR1cm4gbnVsbH1oYXNDaHVuayhlKXtyZXR1cm4gdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyhlKX1nZXRCeXRlKCl7Y29uc3QgZT10aGlzLnBvcztpZihlPj10aGlzLmVuZClyZXR1cm4tMTtlPj10aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aCYmdGhpcy5lbnN1cmVCeXRlKGUpO3JldHVybiB0aGlzLmJ5dGVzW3RoaXMucG9zKytdfWdldEJ5dGVzKGUpe2NvbnN0IHQ9dGhpcy5ieXRlcyxhPXRoaXMucG9zLHI9dGhpcy5lbmQ7aWYoIWUpe3I+dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgmJnRoaXMuZW5zdXJlUmFuZ2UoYSxyKTtyZXR1cm4gdC5zdWJhcnJheShhLHIpfWxldCBpPWErZTtpPnImJihpPXIpO2k+dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgmJnRoaXMuZW5zdXJlUmFuZ2UoYSxpKTt0aGlzLnBvcz1pO3JldHVybiB0LnN1YmFycmF5KGEsaSl9Z2V0Qnl0ZVJhbmdlKGUsdCl7ZTwwJiYoZT0wKTt0PnRoaXMuZW5kJiYodD10aGlzLmVuZCk7dD50aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aCYmdGhpcy5lbnN1cmVSYW5nZShlLHQpO3JldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KGUsdCl9bWFrZVN1YlN0cmVhbShlLHQsYT1udWxsKXt0P2UrdD50aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aCYmdGhpcy5lbnN1cmVSYW5nZShlLGUrdCk6ZT49dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgmJnRoaXMuZW5zdXJlQnl0ZShlKTtmdW5jdGlvbiBDaHVua2VkU3RyZWFtU3Vic3RyZWFtKCl7fUNodW5rZWRTdHJlYW1TdWJzdHJlYW0ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodGhpcyk7Q2h1bmtlZFN0cmVhbVN1YnN0cmVhbS5wcm90b3R5cGUuZ2V0TWlzc2luZ0NodW5rcz1mdW5jdGlvbigpe2NvbnN0IGU9dGhpcy5jaHVua1NpemUsdD1NYXRoLmZsb29yKHRoaXMuc3RhcnQvZSksYT1NYXRoLmZsb29yKCh0aGlzLmVuZC0xKS9lKSsxLHI9W107Zm9yKGxldCBlPXQ7ZTxhOysrZSl0aGlzLl9sb2FkZWRDaHVua3MuaGFzKGUpfHxyLnB1c2goZSk7cmV0dXJuIHJ9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShDaHVua2VkU3RyZWFtU3Vic3RyZWFtLnByb3RvdHlwZSwiaXNEYXRhTG9hZGVkIix7Z2V0KCl7cmV0dXJuIHRoaXMubnVtQ2h1bmtzTG9hZGVkPT09dGhpcy5udW1DaHVua3N8fDA9PT10aGlzLmdldE1pc3NpbmdDaHVua3MoKS5sZW5ndGh9LGNvbmZpZ3VyYWJsZTohMH0pO2NvbnN0IHI9bmV3IENodW5rZWRTdHJlYW1TdWJzdHJlYW07ci5wb3M9ci5zdGFydD1lO3IuZW5kPWUrdHx8dGhpcy5lbmQ7ci5kaWN0PWE7cmV0dXJuIHJ9Z2V0QmFzZVN0cmVhbXMoKXtyZXR1cm5bdGhpc119fWNsYXNzIENodW5rZWRTdHJlYW1NYW5hZ2Vye2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5sZW5ndGg9dC5sZW5ndGg7dGhpcy5jaHVua1NpemU9dC5yYW5nZUNodW5rU2l6ZTt0aGlzLnN0cmVhbT1uZXcgQ2h1bmtlZFN0cmVhbSh0aGlzLmxlbmd0aCx0aGlzLmNodW5rU2l6ZSx0aGlzKTt0aGlzLnBkZk5ldHdvcmtTdHJlYW09ZTt0aGlzLmRpc2FibGVBdXRvRmV0Y2g9dC5kaXNhYmxlQXV0b0ZldGNoO3RoaXMubXNnSGFuZGxlcj10Lm1zZ0hhbmRsZXI7dGhpcy5jdXJyUmVxdWVzdElkPTA7dGhpcy5fY2h1bmtzTmVlZGVkQnlSZXF1ZXN0PW5ldyBNYXA7dGhpcy5fcmVxdWVzdHNCeUNodW5rPW5ldyBNYXA7dGhpcy5fcHJvbWlzZXNCeVJlcXVlc3Q9bmV3IE1hcDt0aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aD0wO3RoaXMuYWJvcnRlZD0hMTt0aGlzLl9sb2FkZWRTdHJlYW1DYXBhYmlsaXR5PVByb21pc2Uud2l0aFJlc29sdmVycygpfXNlbmRSZXF1ZXN0KGUsdCl7Y29uc3QgYT10aGlzLnBkZk5ldHdvcmtTdHJlYW0uZ2V0UmFuZ2VSZWFkZXIoZSx0KTthLmlzU3RyZWFtaW5nU3VwcG9ydGVkfHwoYS5vblByb2dyZXNzPXRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMpKTtsZXQgcj1bXSxpPTA7cmV0dXJuIG5ldyBQcm9taXNlKCgoZSx0KT0+e2NvbnN0IHJlYWRDaHVuaz0oe3ZhbHVlOm4sZG9uZTpzfSk9Pnt0cnl7aWYocyl7Y29uc3QgdD1hcnJheUJ1ZmZlcnNUb0J5dGVzKHIpO3I9bnVsbDtlKHQpO3JldHVybn1pKz1uLmJ5dGVMZW5ndGg7YS5pc1N0cmVhbWluZ1N1cHBvcnRlZCYmdGhpcy5vblByb2dyZXNzKHtsb2FkZWQ6aX0pO3IucHVzaChuKTthLnJlYWQoKS50aGVuKHJlYWRDaHVuayx0KX1jYXRjaChlKXt0KGUpfX07YS5yZWFkKCkudGhlbihyZWFkQ2h1bmssdCl9KSkudGhlbigodD0+e3RoaXMuYWJvcnRlZHx8dGhpcy5vblJlY2VpdmVEYXRhKHtjaHVuazp0LGJlZ2luOmV9KX0pKX1yZXF1ZXN0QWxsQ2h1bmtzKGU9ITEpe2lmKCFlKXtjb25zdCBlPXRoaXMuc3RyZWFtLmdldE1pc3NpbmdDaHVua3MoKTt0aGlzLl9yZXF1ZXN0Q2h1bmtzKGUpfXJldHVybiB0aGlzLl9sb2FkZWRTdHJlYW1DYXBhYmlsaXR5LnByb21pc2V9X3JlcXVlc3RDaHVua3MoZSl7Y29uc3QgdD10aGlzLmN1cnJSZXF1ZXN0SWQrKyxhPW5ldyBTZXQ7dGhpcy5fY2h1bmtzTmVlZGVkQnlSZXF1ZXN0LnNldCh0LGEpO2Zvcihjb25zdCB0IG9mIGUpdGhpcy5zdHJlYW0uaGFzQ2h1bmsodCl8fGEuYWRkKHQpO2lmKDA9PT1hLnNpemUpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2NvbnN0IHI9UHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7dGhpcy5fcHJvbWlzZXNCeVJlcXVlc3Quc2V0KHQscik7Y29uc3QgaT1bXTtmb3IoY29uc3QgZSBvZiBhKXtsZXQgYT10aGlzLl9yZXF1ZXN0c0J5Q2h1bmsuZ2V0KGUpO2lmKCFhKXthPVtdO3RoaXMuX3JlcXVlc3RzQnlDaHVuay5zZXQoZSxhKTtpLnB1c2goZSl9YS5wdXNoKHQpfWlmKGkubGVuZ3RoPjApe2NvbnN0IGU9dGhpcy5ncm91cENodW5rcyhpKTtmb3IoY29uc3QgdCBvZiBlKXtjb25zdCBlPXQuYmVnaW5DaHVuayp0aGlzLmNodW5rU2l6ZSxhPU1hdGgubWluKHQuZW5kQ2h1bmsqdGhpcy5jaHVua1NpemUsdGhpcy5sZW5ndGgpO3RoaXMuc2VuZFJlcXVlc3QoZSxhKS5jYXRjaChyLnJlamVjdCl9fXJldHVybiByLnByb21pc2UuY2F0Y2goKGU9PntpZighdGhpcy5hYm9ydGVkKXRocm93IGV9KSl9Z2V0U3RyZWFtKCl7cmV0dXJuIHRoaXMuc3RyZWFtfXJlcXVlc3RSYW5nZShlLHQpe3Q9TWF0aC5taW4odCx0aGlzLmxlbmd0aCk7Y29uc3QgYT10aGlzLmdldEJlZ2luQ2h1bmsoZSkscj10aGlzLmdldEVuZENodW5rKHQpLGk9W107Zm9yKGxldCBlPWE7ZTxyOysrZSlpLnB1c2goZSk7cmV0dXJuIHRoaXMuX3JlcXVlc3RDaHVua3MoaSl9cmVxdWVzdFJhbmdlcyhlPVtdKXtjb25zdCB0PVtdO2Zvcihjb25zdCBhIG9mIGUpe2NvbnN0IGU9dGhpcy5nZXRCZWdpbkNodW5rKGEuYmVnaW4pLHI9dGhpcy5nZXRFbmRDaHVuayhhLmVuZCk7Zm9yKGxldCBhPWU7YTxyOysrYSl0LmluY2x1ZGVzKGEpfHx0LnB1c2goYSl9dC5zb3J0KCgoZSx0KT0+ZS10KSk7cmV0dXJuIHRoaXMuX3JlcXVlc3RDaHVua3ModCl9Z3JvdXBDaHVua3MoZSl7Y29uc3QgdD1bXTtsZXQgYT0tMSxyPS0xO2ZvcihsZXQgaT0wLG49ZS5sZW5ndGg7aTxuOysraSl7Y29uc3Qgbj1lW2ldO2E8MCYmKGE9bik7aWYocj49MCYmcisxIT09bil7dC5wdXNoKHtiZWdpbkNodW5rOmEsZW5kQ2h1bms6cisxfSk7YT1ufWkrMT09PWUubGVuZ3RoJiZ0LnB1c2goe2JlZ2luQ2h1bms6YSxlbmRDaHVuazpuKzF9KTtyPW59cmV0dXJuIHR9b25Qcm9ncmVzcyhlKXt0aGlzLm1zZ0hhbmRsZXIuc2VuZCgiRG9jUHJvZ3Jlc3MiLHtsb2FkZWQ6dGhpcy5zdHJlYW0ubnVtQ2h1bmtzTG9hZGVkKnRoaXMuY2h1bmtTaXplK2UubG9hZGVkLHRvdGFsOnRoaXMubGVuZ3RofSl9b25SZWNlaXZlRGF0YShlKXtjb25zdCB0PWUuY2h1bmssYT12b2lkIDA9PT1lLmJlZ2luLHI9YT90aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aDplLmJlZ2luLGk9cit0LmJ5dGVMZW5ndGgsbj1NYXRoLmZsb29yKHIvdGhpcy5jaHVua1NpemUpLHM9aTx0aGlzLmxlbmd0aD9NYXRoLmZsb29yKGkvdGhpcy5jaHVua1NpemUpOk1hdGguY2VpbChpL3RoaXMuY2h1bmtTaXplKTtpZihhKXt0aGlzLnN0cmVhbS5vblJlY2VpdmVQcm9ncmVzc2l2ZURhdGEodCk7dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGg9aX1lbHNlIHRoaXMuc3RyZWFtLm9uUmVjZWl2ZURhdGEocix0KTt0aGlzLnN0cmVhbS5pc0RhdGFMb2FkZWQmJnRoaXMuX2xvYWRlZFN0cmVhbUNhcGFiaWxpdHkucmVzb2x2ZSh0aGlzLnN0cmVhbSk7Y29uc3Qgbz1bXTtmb3IobGV0IGU9bjtlPHM7KytlKXtjb25zdCB0PXRoaXMuX3JlcXVlc3RzQnlDaHVuay5nZXQoZSk7aWYodCl7dGhpcy5fcmVxdWVzdHNCeUNodW5rLmRlbGV0ZShlKTtmb3IoY29uc3QgYSBvZiB0KXtjb25zdCB0PXRoaXMuX2NodW5rc05lZWRlZEJ5UmVxdWVzdC5nZXQoYSk7dC5oYXMoZSkmJnQuZGVsZXRlKGUpO3Quc2l6ZT4wfHxvLnB1c2goYSl9fX1pZighdGhpcy5kaXNhYmxlQXV0b0ZldGNoJiYwPT09dGhpcy5fcmVxdWVzdHNCeUNodW5rLnNpemUpe2xldCBlO2lmKDE9PT10aGlzLnN0cmVhbS5udW1DaHVua3NMb2FkZWQpe2NvbnN0IHQ9dGhpcy5zdHJlYW0ubnVtQ2h1bmtzLTE7dGhpcy5zdHJlYW0uaGFzQ2h1bmsodCl8fChlPXQpfWVsc2UgZT10aGlzLnN0cmVhbS5uZXh0RW1wdHlDaHVuayhzKTtOdW1iZXIuaXNJbnRlZ2VyKGUpJiZ0aGlzLl9yZXF1ZXN0Q2h1bmtzKFtlXSl9Zm9yKGNvbnN0IGUgb2Ygbyl7Y29uc3QgdD10aGlzLl9wcm9taXNlc0J5UmVxdWVzdC5nZXQoZSk7dGhpcy5fcHJvbWlzZXNCeVJlcXVlc3QuZGVsZXRlKGUpO3QucmVzb2x2ZSgpfXRoaXMubXNnSGFuZGxlci5zZW5kKCJEb2NQcm9ncmVzcyIse2xvYWRlZDp0aGlzLnN0cmVhbS5udW1DaHVua3NMb2FkZWQqdGhpcy5jaHVua1NpemUsdG90YWw6dGhpcy5sZW5ndGh9KX1vbkVycm9yKGUpe3RoaXMuX2xvYWRlZFN0cmVhbUNhcGFiaWxpdHkucmVqZWN0KGUpfWdldEJlZ2luQ2h1bmsoZSl7cmV0dXJuIE1hdGguZmxvb3IoZS90aGlzLmNodW5rU2l6ZSl9Z2V0RW5kQ2h1bmsoZSl7cmV0dXJuIE1hdGguZmxvb3IoKGUtMSkvdGhpcy5jaHVua1NpemUpKzF9YWJvcnQoZSl7dGhpcy5hYm9ydGVkPSEwO3RoaXMucGRmTmV0d29ya1N0cmVhbT8uY2FuY2VsQWxsUmVxdWVzdHMoZSk7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fcHJvbWlzZXNCeVJlcXVlc3QudmFsdWVzKCkpdC5yZWplY3QoZSl9fWZ1bmN0aW9uIGNvbnZlcnRUb1JHQkEoZSl7c3dpdGNoKGUua2luZCl7Y2FzZSBrOnJldHVybiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQShlKTtjYXNlIEM6cmV0dXJuIGZ1bmN0aW9uIGNvbnZlcnRSR0JUb1JHQkEoe3NyYzplLHNyY1Bvczp0PTAsZGVzdDphLGRlc3RQb3M6cj0wLHdpZHRoOmksaGVpZ2h0Om59KXtsZXQgcz0wO2NvbnN0IG89aSpuKjMsYz1vPj4yLGw9bmV3IFVpbnQzMkFycmF5KGUuYnVmZmVyLHQsYyk7aWYoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pe2Zvcig7czxjLTI7cys9MyxyKz00KXtjb25zdCBlPWxbc10sdD1sW3MrMV0saT1sW3MrMl07YVtyXT00Mjc4MTkwMDgwfGU7YVtyKzFdPWU+Pj4yNHx0PDw4fDQyNzgxOTAwODA7YVtyKzJdPXQ+Pj4xNnxpPDwxNnw0Mjc4MTkwMDgwO2FbciszXT1pPj4+OHw0Mjc4MTkwMDgwfWZvcihsZXQgaT00KnMsbj10K287aTxuO2krPTMpYVtyKytdPWVbaV18ZVtpKzFdPDw4fGVbaSsyXTw8MTZ8NDI3ODE5MDA4MH1lbHNle2Zvcig7czxjLTI7cys9MyxyKz00KXtjb25zdCBlPWxbc10sdD1sW3MrMV0saT1sW3MrMl07YVtyXT0yNTV8ZTthW3IrMV09ZTw8MjR8dD4+Pjh8MjU1O2FbcisyXT10PDwxNnxpPj4+MTZ8MjU1O2FbciszXT1pPDw4fDI1NX1mb3IobGV0IGk9NCpzLG49dCtvO2k8bjtpKz0zKWFbcisrXT1lW2ldPDwyNHxlW2krMV08PDE2fGVbaSsyXTw8OHwyNTV9cmV0dXJue3NyY1Bvczp0K28sZGVzdFBvczpyfX0oZSl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe3NyYzplLHNyY1Bvczp0PTAsZGVzdDphLHdpZHRoOnIsaGVpZ2h0Omksbm9uQmxhY2tDb2xvcjpuPTQyOTQ5NjcyOTUsaW52ZXJzZURlY29kZTpzPSExfSl7Y29uc3Qgbz1GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbj80Mjc4MTkwMDgwOjI1NSxbYyxsXT1zP1tuLG9dOltvLG5dLGg9cj4+Myx1PTcmcixkPWUubGVuZ3RoO2E9bmV3IFVpbnQzMkFycmF5KGEuYnVmZmVyKTtsZXQgZj0wO2ZvcihsZXQgcj0wO3I8aTtyKyspe2Zvcihjb25zdCByPXQraDt0PHI7dCsrKXtjb25zdCByPXQ8ZD9lW3RdOjI1NTthW2YrK109MTI4JnI/bDpjO2FbZisrXT02NCZyP2w6YzthW2YrK109MzImcj9sOmM7YVtmKytdPTE2JnI/bDpjO2FbZisrXT04JnI/bDpjO2FbZisrXT00JnI/bDpjO2FbZisrXT0yJnI/bDpjO2FbZisrXT0xJnI/bDpjfWlmKDA9PT11KWNvbnRpbnVlO2NvbnN0IHI9dDxkP2VbdCsrXToyNTU7Zm9yKGxldCBlPTA7ZTx1O2UrKylhW2YrK109ciYxPDw3LWU/bDpjfXJldHVybntzcmNQb3M6dCxkZXN0UG9zOmZ9fWNsYXNzIEltYWdlUmVzaXplcntzdGF0aWMjTz0yMDQ4O3N0YXRpYyNNPUZlYXR1cmVUZXN0LmlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkO2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5faW1nRGF0YT1lO3RoaXMuX2lzTWFzaz10fXN0YXRpYyBnZXQgY2FuVXNlSW1hZ2VEZWNvZGVyKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJjYW5Vc2VJbWFnZURlY29kZXIiLHRoaXMuI00/SW1hZ2VEZWNvZGVyLmlzVHlwZVN1cHBvcnRlZCgiaW1hZ2UvYm1wIik6UHJvbWlzZS5yZXNvbHZlKCExKSl9c3RhdGljIG5lZWRzVG9CZVJlc2l6ZWQoZSx0KXtpZihlPD10aGlzLiNPJiZ0PD10aGlzLiNPKXJldHVybiExO2NvbnN0e01BWF9ESU06YX09dGhpcztpZihlPmF8fHQ+YSlyZXR1cm4hMDtjb25zdCByPWUqdDtpZih0aGlzLl9oYXNNYXhBcmVhKXJldHVybiByPnRoaXMuTUFYX0FSRUE7aWYocjx0aGlzLiNPKioyKXJldHVybiExO2lmKHRoaXMuX2FyZUdvb2REaW1zKGUsdCkpe3RoaXMuI089TWF0aC5tYXgodGhpcy4jTyxNYXRoLmZsb29yKE1hdGguc3FydChlKnQpKSk7cmV0dXJuITF9dGhpcy4jTz10aGlzLl9ndWVzc01heCh0aGlzLiNPLGEsMTI4LDApO3JldHVybiByPih0aGlzLk1BWF9BUkVBPXRoaXMuI08qKjIpfXN0YXRpYyBnZXRSZWR1Y2VQb3dlckZvckpQWChlLHQsYSl7Y29uc3Qgcj1lKnQsaT0yKiozMC8oNCphKTtpZighdGhpcy5uZWVkc1RvQmVSZXNpemVkKGUsdCkpcmV0dXJuIHI+aT9NYXRoLmNlaWwoTWF0aC5sb2cyKHIvaSkpOjA7Y29uc3R7TUFYX0RJTTpuLE1BWF9BUkVBOnN9PXRoaXMsbz1NYXRoLm1heChlL24sdC9uLE1hdGguc3FydChyL01hdGgubWluKGkscykpKTtyZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nMihvKSl9c3RhdGljIGdldCBNQVhfRElNKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJNQVhfRElNIix0aGlzLl9ndWVzc01heCgyMDQ4LDY1NTM3LDAsMSkpfXN0YXRpYyBnZXQgTUFYX0FSRUEoKXt0aGlzLl9oYXNNYXhBcmVhPSEwO3JldHVybiBzaGFkb3codGhpcywiTUFYX0FSRUEiLHRoaXMuX2d1ZXNzTWF4KHRoaXMuI08sdGhpcy5NQVhfRElNLDEyOCwwKSoqMil9c3RhdGljIHNldCBNQVhfQVJFQShlKXtpZihlPj0wKXt0aGlzLl9oYXNNYXhBcmVhPSEwO3NoYWRvdyh0aGlzLCJNQVhfQVJFQSIsZSl9fXN0YXRpYyBzZXRPcHRpb25zKHtjYW52YXNNYXhBcmVhSW5CeXRlczplPS0xLGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkOnQ9ITF9KXt0aGlzLl9oYXNNYXhBcmVhfHwodGhpcy5NQVhfQVJFQT1lPj4yKTt0aGlzLiNNPXR9c3RhdGljIF9hcmVHb29kRGltcyhlLHQpe3RyeXtjb25zdCBhPW5ldyBPZmZzY3JlZW5DYW52YXMoZSx0KSxyPWEuZ2V0Q29udGV4dCgiMmQiKTtyLmZpbGxSZWN0KDAsMCwxLDEpO2NvbnN0IGk9ci5nZXRJbWFnZURhdGEoMCwwLDEsMSkuZGF0YVszXTthLndpZHRoPWEuaGVpZ2h0PTE7cmV0dXJuIDAhPT1pfWNhdGNoe3JldHVybiExfX1zdGF0aWMgX2d1ZXNzTWF4KGUsdCxhLHIpe2Zvcig7ZSthKzE8dDspe2NvbnN0IGE9TWF0aC5mbG9vcigoZSt0KS8yKSxpPXJ8fGE7dGhpcy5fYXJlR29vZERpbXMoYSxpKT9lPWE6dD1hfXJldHVybiBlfXN0YXRpYyBhc3luYyBjcmVhdGVJbWFnZShlLHQ9ITEpe3JldHVybiBuZXcgSW1hZ2VSZXNpemVyKGUsdCkuX2NyZWF0ZUltYWdlKCl9YXN5bmMgX2NyZWF0ZUltYWdlKCl7Y29uc3R7X2ltZ0RhdGE6ZX09dGhpcyx7d2lkdGg6dCxoZWlnaHQ6YX09ZTtpZih0KmEqND5jYSl7Y29uc3QgZT10aGlzLiNEKCk7aWYoZSlyZXR1cm4gZX1jb25zdCByPXRoaXMuX2VuY29kZUJNUCgpO2xldCBpLG47aWYoYXdhaXQgSW1hZ2VSZXNpemVyLmNhblVzZUltYWdlRGVjb2Rlcil7aT1uZXcgSW1hZ2VEZWNvZGVyKHtkYXRhOnIsdHlwZToiaW1hZ2UvYm1wIixwcmVmZXJBbmltYXRpb246ITEsdHJhbnNmZXI6W3IuYnVmZmVyXX0pO249aS5kZWNvZGUoKS5jYXRjaCgoZT0+e3dhcm4oYEJNUCBpbWFnZSBkZWNvZGluZyBmYWlsZWQ6ICR7ZX1gKTtyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAobmV3IEJsb2IoW3RoaXMuX2VuY29kZUJNUCgpLmJ1ZmZlcl0se3R5cGU6ImltYWdlL2JtcCJ9KSl9KSkuZmluYWxseSgoKCk9PntpLmNsb3NlKCl9KSl9ZWxzZSBuPWNyZWF0ZUltYWdlQml0bWFwKG5ldyBCbG9iKFtyLmJ1ZmZlcl0se3R5cGU6ImltYWdlL2JtcCJ9KSk7Y29uc3R7TUFYX0FSRUE6cyxNQVhfRElNOm99PUltYWdlUmVzaXplcixjPU1hdGgubWF4KHQvbyxhL28sTWF0aC5zcXJ0KHQqYS9zKSksbD1NYXRoLm1heChjLDIpLGg9TWF0aC5yb3VuZCgxMCooYysxLjI1KSkvMTAvbCx1PU1hdGguZmxvb3IoTWF0aC5sb2cyKGgpKSxkPW5ldyBBcnJheSh1KzIpLmZpbGwoMik7ZFswXT1sO2Quc3BsaWNlKC0xLDEsaC8oMTw8dSkpO2xldCBmPXQsZz1hO2NvbnN0IHA9YXdhaXQgbjtsZXQgbT1wLmltYWdlfHxwO2Zvcihjb25zdCBlIG9mIGQpe2NvbnN0IHQ9ZixhPWc7Zj1NYXRoLmZsb29yKGYvZSktMTtnPU1hdGguZmxvb3IoZy9lKS0xO2NvbnN0IHI9bmV3IE9mZnNjcmVlbkNhbnZhcyhmLGcpO3IuZ2V0Q29udGV4dCgiMmQiKS5kcmF3SW1hZ2UobSwwLDAsdCxhLDAsMCxmLGcpO20uY2xvc2UoKTttPXIudHJhbnNmZXJUb0ltYWdlQml0bWFwKCl9ZS5kYXRhPW51bGw7ZS5iaXRtYXA9bTtlLndpZHRoPWY7ZS5oZWlnaHQ9ZztyZXR1cm4gZX0jRCgpe2NvbnN0e19pbWdEYXRhOmV9PXRoaXMse2RhdGE6dCx3aWR0aDphLGhlaWdodDpyLGtpbmQ6aX09ZSxuPWEqcio0LHM9TWF0aC5jZWlsKE1hdGgubG9nMihuL2NhKSksbz1hPj5zLGM9cj4+cztsZXQgbCxoPXI7dHJ5e2w9bmV3IFVpbnQ4QXJyYXkobil9Y2F0Y2h7bGV0IGU9TWF0aC5mbG9vcihNYXRoLmxvZzIobisxKSk7Zm9yKDs7KXRyeXtsPW5ldyBVaW50OEFycmF5KDIqKmUtMSk7YnJlYWt9Y2F0Y2h7ZS09MX1oPU1hdGguZmxvb3IoKDIqKmUtMSkvKDQqYSkpO2NvbnN0IHQ9YSpoKjQ7dDxsLmxlbmd0aCYmKGw9bmV3IFVpbnQ4QXJyYXkodCkpfWNvbnN0IHU9bmV3IFVpbnQzMkFycmF5KGwuYnVmZmVyKSxkPW5ldyBVaW50MzJBcnJheShvKmMpO2xldCBmPTAsZz0wO2NvbnN0IHA9TWF0aC5jZWlsKHIvaCksbT1yJWg9PTA/cjpyJWg7Zm9yKGxldCBlPTA7ZTxwO2UrKyl7Y29uc3Qgcj1lPHAtMT9oOm07KHtzcmNQb3M6Zn09Y29udmVydFRvUkdCQSh7a2luZDppLHNyYzp0LGRlc3Q6dSx3aWR0aDphLGhlaWdodDpyLGludmVyc2VEZWNvZGU6dGhpcy5faXNNYXNrLHNyY1BvczpmfSkpO2ZvcihsZXQgZT0wLHQ9cj4+cztlPHQ7ZSsrKXtjb25zdCB0PXUuc3ViYXJyYXkoKGU8PHMpKmEpO2ZvcihsZXQgZT0wO2U8bztlKyspZFtnKytdPXRbZTw8c119fWlmKEltYWdlUmVzaXplci5uZWVkc1RvQmVSZXNpemVkKG8sYykpe2UuZGF0YT1kO2Uud2lkdGg9bztlLmhlaWdodD1jO2Uua2luZD12O3JldHVybiBudWxsfWNvbnN0IGI9bmV3IE9mZnNjcmVlbkNhbnZhcyhvLGMpO2IuZ2V0Q29udGV4dCgiMmQiLHt3aWxsUmVhZEZyZXF1ZW50bHk6ITB9KS5wdXRJbWFnZURhdGEobmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoZC5idWZmZXIpLG8sYyksMCwwKTtlLmRhdGE9bnVsbDtlLmJpdG1hcD1iLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO2Uud2lkdGg9bztlLmhlaWdodD1jO3JldHVybiBlfV9lbmNvZGVCTVAoKXtjb25zdHt3aWR0aDplLGhlaWdodDp0LGtpbmQ6YX09dGhpcy5faW1nRGF0YTtsZXQgcixpPXRoaXMuX2ltZ0RhdGEuZGF0YSxuPW5ldyBVaW50OEFycmF5KDApLHM9bixvPTA7c3dpdGNoKGEpe2Nhc2Ugazp7cj0xO249bmV3IFVpbnQ4QXJyYXkodGhpcy5faXNNYXNrP1syNTUsMjU1LDI1NSwyNTUsMCwwLDAsMF06WzAsMCwwLDAsMjU1LDI1NSwyNTUsMjU1XSk7Y29uc3QgYT1lKzc+PjMscz1hKzMmLTQ7aWYoYSE9PXMpe2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkocyp0KTtsZXQgcj0wO2ZvcihsZXQgbj0wLG89dCphO248bztuKz1hLHIrPXMpZS5zZXQoaS5zdWJhcnJheShuLG4rYSkscik7aT1lfWJyZWFrfWNhc2UgQzpyPTI0O2lmKDMmZSl7Y29uc3QgYT0zKmUscj1hKzMmLTQsbj1yLWEscz1uZXcgVWludDhBcnJheShyKnQpO2xldCBvPTA7Zm9yKGxldCBlPTAscj10KmE7ZTxyO2UrPWEpe2NvbnN0IHQ9aS5zdWJhcnJheShlLGUrYSk7Zm9yKGxldCBlPTA7ZTxhO2UrPTMpe3NbbysrXT10W2UrMl07c1tvKytdPXRbZSsxXTtzW28rK109dFtlXX1vKz1ufWk9c31lbHNlIGZvcihsZXQgZT0wLHQ9aS5sZW5ndGg7ZTx0O2UrPTMpe2NvbnN0IHQ9aVtlXTtpW2VdPWlbZSsyXTtpW2UrMl09dH1icmVhaztjYXNlIHY6cj0zMjtvPTM7cz1uZXcgVWludDhBcnJheSg2OCk7Y29uc3QgYT1uZXcgRGF0YVZpZXcocy5idWZmZXIpO2lmKEZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKXthLnNldFVpbnQzMigwLDI1NSwhMCk7YS5zZXRVaW50MzIoNCw2NTI4MCwhMCk7YS5zZXRVaW50MzIoOCwxNjcxMTY4MCwhMCk7YS5zZXRVaW50MzIoMTIsNDI3ODE5MDA4MCwhMCl9ZWxzZXthLnNldFVpbnQzMigwLDQyNzgxOTAwODAsITApO2Euc2V0VWludDMyKDQsMTY3MTE2ODAsITApO2Euc2V0VWludDMyKDgsNjUyODAsITApO2Euc2V0VWludDMyKDEyLDI1NSwhMCl9YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgZm9ybWF0Iil9bGV0IGM9MDtjb25zdCBsPTQwK3MubGVuZ3RoLGg9MTQrbCtuLmxlbmd0aCtpLmxlbmd0aCx1PW5ldyBVaW50OEFycmF5KGgpLGQ9bmV3IERhdGFWaWV3KHUuYnVmZmVyKTtkLnNldFVpbnQxNihjLDE5Nzc4LCEwKTtjKz0yO2Quc2V0VWludDMyKGMsaCwhMCk7Yys9NDtkLnNldFVpbnQzMihjLDAsITApO2MrPTQ7ZC5zZXRVaW50MzIoYywxNCtsK24ubGVuZ3RoLCEwKTtjKz00O2Quc2V0VWludDMyKGMsbCwhMCk7Yys9NDtkLnNldEludDMyKGMsZSwhMCk7Yys9NDtkLnNldEludDMyKGMsLXQsITApO2MrPTQ7ZC5zZXRVaW50MTYoYywxLCEwKTtjKz0yO2Quc2V0VWludDE2KGMsciwhMCk7Yys9MjtkLnNldFVpbnQzMihjLG8sITApO2MrPTQ7ZC5zZXRVaW50MzIoYywwLCEwKTtjKz00O2Quc2V0SW50MzIoYywwLCEwKTtjKz00O2Quc2V0SW50MzIoYywwLCEwKTtjKz00O2Quc2V0VWludDMyKGMsbi5sZW5ndGgvNCwhMCk7Yys9NDtkLnNldFVpbnQzMihjLDAsITApO2MrPTQ7dS5zZXQocyxjKTtjKz1zLmxlbmd0aDt1LnNldChuLGMpO2MrPW4ubGVuZ3RoO3Uuc2V0KGksYyk7cmV0dXJuIHV9fWNvbnN0IHhhPW5ldyBVaW50OEFycmF5KDApO2NsYXNzIERlY29kZVN0cmVhbSBleHRlbmRzIEJhc2VTdHJlYW17Y29uc3RydWN0b3IoZSl7c3VwZXIoKTt0aGlzLl9yYXdNaW5CdWZmZXJMZW5ndGg9ZXx8MDt0aGlzLnBvcz0wO3RoaXMuYnVmZmVyTGVuZ3RoPTA7dGhpcy5lb2Y9ITE7dGhpcy5idWZmZXI9eGE7dGhpcy5taW5CdWZmZXJMZW5ndGg9NTEyO2lmKGUpZm9yKDt0aGlzLm1pbkJ1ZmZlckxlbmd0aDxlOyl0aGlzLm1pbkJ1ZmZlckxlbmd0aCo9Mn1nZXQgaXNFbXB0eSgpe2Zvcig7IXRoaXMuZW9mJiYwPT09dGhpcy5idWZmZXJMZW5ndGg7KXRoaXMucmVhZEJsb2NrKCk7cmV0dXJuIDA9PT10aGlzLmJ1ZmZlckxlbmd0aH1lbnN1cmVCdWZmZXIoZSl7Y29uc3QgdD10aGlzLmJ1ZmZlcjtpZihlPD10LmJ5dGVMZW5ndGgpcmV0dXJuIHQ7bGV0IGE9dGhpcy5taW5CdWZmZXJMZW5ndGg7Zm9yKDthPGU7KWEqPTI7Y29uc3Qgcj1uZXcgVWludDhBcnJheShhKTtyLnNldCh0KTtyZXR1cm4gdGhpcy5idWZmZXI9cn1nZXRCeXRlKCl7Y29uc3QgZT10aGlzLnBvcztmb3IoO3RoaXMuYnVmZmVyTGVuZ3RoPD1lOyl7aWYodGhpcy5lb2YpcmV0dXJuLTE7dGhpcy5yZWFkQmxvY2soKX1yZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5wb3MrK119Z2V0Qnl0ZXMoZSx0PW51bGwpe2NvbnN0IGE9dGhpcy5wb3M7bGV0IHI7aWYoZSl7dGhpcy5lbnN1cmVCdWZmZXIoYStlKTtyPWErZTtmb3IoOyF0aGlzLmVvZiYmdGhpcy5idWZmZXJMZW5ndGg8cjspdGhpcy5yZWFkQmxvY2sodCk7Y29uc3QgaT10aGlzLmJ1ZmZlckxlbmd0aDtyPmkmJihyPWkpfWVsc2V7Zm9yKDshdGhpcy5lb2Y7KXRoaXMucmVhZEJsb2NrKHQpO3I9dGhpcy5idWZmZXJMZW5ndGh9dGhpcy5wb3M9cjtyZXR1cm4gdGhpcy5idWZmZXIuc3ViYXJyYXkoYSxyKX1hc3luYyBnZXRJbWFnZURhdGEoZSx0KXtpZighdGhpcy5jYW5Bc3luY0RlY29kZUltYWdlRnJvbUJ1ZmZlcilyZXR1cm4gdGhpcy5pc0FzeW5jRGVjb2Rlcj90aGlzLmRlY29kZUltYWdlKG51bGwsdCk6dGhpcy5nZXRCeXRlcyhlLHQpO2NvbnN0IGE9YXdhaXQgdGhpcy5zdHJlYW0uYXN5bmNHZXRCeXRlcygpO3JldHVybiB0aGlzLmRlY29kZUltYWdlKGEsdCl9cmVzZXQoKXt0aGlzLnBvcz0wfW1ha2VTdWJTdHJlYW0oZSx0LGE9bnVsbCl7aWYodm9pZCAwPT09dClmb3IoOyF0aGlzLmVvZjspdGhpcy5yZWFkQmxvY2soKTtlbHNle2NvbnN0IGE9ZSt0O2Zvcig7dGhpcy5idWZmZXJMZW5ndGg8PWEmJiF0aGlzLmVvZjspdGhpcy5yZWFkQmxvY2soKX1yZXR1cm4gbmV3IFN0cmVhbSh0aGlzLmJ1ZmZlcixlLHQsYSl9Z2V0QmFzZVN0cmVhbXMoKXtyZXR1cm4gdGhpcy5zdHI/dGhpcy5zdHIuZ2V0QmFzZVN0cmVhbXMoKTpudWxsfX1jbGFzcyBTdHJlYW1zU2VxdWVuY2VTdHJlYW0gZXh0ZW5kcyBEZWNvZGVTdHJlYW17Y29uc3RydWN0b3IoZSx0PW51bGwpe2U9ZS5maWx0ZXIoKGU9PmUgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKSk7bGV0IGE9MDtmb3IoY29uc3QgdCBvZiBlKWErPXQgaW5zdGFuY2VvZiBEZWNvZGVTdHJlYW0/dC5fcmF3TWluQnVmZmVyTGVuZ3RoOnQubGVuZ3RoO3N1cGVyKGEpO3RoaXMuc3RyZWFtcz1lO3RoaXMuX29uRXJyb3I9dH1yZWFkQmxvY2soKXtjb25zdCBlPXRoaXMuc3RyZWFtcztpZigwPT09ZS5sZW5ndGgpe3RoaXMuZW9mPSEwO3JldHVybn1jb25zdCB0PWUuc2hpZnQoKTtsZXQgYTt0cnl7YT10LmdldEJ5dGVzKCl9Y2F0Y2goZSl7aWYodGhpcy5fb25FcnJvcil7dGhpcy5fb25FcnJvcihlLHQuZGljdD8ub2JqSWQpO3JldHVybn10aHJvdyBlfWNvbnN0IHI9dGhpcy5idWZmZXJMZW5ndGgsaT1yK2EubGVuZ3RoO3RoaXMuZW5zdXJlQnVmZmVyKGkpLnNldChhLHIpO3RoaXMuYnVmZmVyTGVuZ3RoPWl9Z2V0QmFzZVN0cmVhbXMoKXtjb25zdCBlPVtdO2Zvcihjb25zdCB0IG9mIHRoaXMuc3RyZWFtcyl7Y29uc3QgYT10LmdldEJhc2VTdHJlYW1zKCk7YSYmZS5wdXNoKC4uLmEpfXJldHVybiBlLmxlbmd0aD4wP2U6bnVsbH19Y2xhc3MgQ29sb3JTcGFjZVV0aWxze3N0YXRpYyBwYXJzZSh7Y3M6ZSx4cmVmOnQscmVzb3VyY2VzOmE9bnVsbCxwZGZGdW5jdGlvbkZhY3Rvcnk6cixnbG9iYWxDb2xvclNwYWNlQ2FjaGU6aSxsb2NhbENvbG9yU3BhY2VDYWNoZTpuLGFzeW5jSWZOb3RDYWNoZWQ6cz0hMX0pe2NvbnN0IG89e3hyZWY6dCxyZXNvdXJjZXM6YSxwZGZGdW5jdGlvbkZhY3Rvcnk6cixnbG9iYWxDb2xvclNwYWNlQ2FjaGU6aSxsb2NhbENvbG9yU3BhY2VDYWNoZTpufTtsZXQgYyxsLGg7aWYoZSBpbnN0YW5jZW9mIFJlZil7bD1lO2NvbnN0IGE9aS5nZXRCeVJlZihsKXx8bi5nZXRCeVJlZihsKTtpZihhKXJldHVybiBhO2U9dC5mZXRjaChlKX1pZihlIGluc3RhbmNlb2YgTmFtZSl7Yz1lLm5hbWU7Y29uc3QgdD1uLmdldEJ5TmFtZShjKTtpZih0KXJldHVybiB0fXRyeXtoPXRoaXMuI0IoZSxvKX1jYXRjaChlKXtpZihzJiYhKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbikpcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO3Rocm93IGV9aWYoY3x8bCl7bi5zZXQoYyxsLGgpO2wmJmkuc2V0KG51bGwsbCxoKX1yZXR1cm4gcz9Qcm9taXNlLnJlc29sdmUoaCk6aH1zdGF0aWMjUihlLHQpe2NvbnN0e2dsb2JhbENvbG9yU3BhY2VDYWNoZTphfT10O2xldCByO2lmKGUgaW5zdGFuY2VvZiBSZWYpe3I9ZTtjb25zdCB0PWEuZ2V0QnlSZWYocik7aWYodClyZXR1cm4gdH1jb25zdCBpPXRoaXMuI0IoZSx0KTtyJiZhLnNldChudWxsLHIsaSk7cmV0dXJuIGl9c3RhdGljI0IoZSx0KXtjb25zdHt4cmVmOmEscmVzb3VyY2VzOnIscGRmRnVuY3Rpb25GYWN0b3J5OmksZ2xvYmFsQ29sb3JTcGFjZUNhY2hlOm59PXQ7aWYoKGU9YS5mZXRjaElmUmVmKGUpKWluc3RhbmNlb2YgTmFtZSlzd2l0Y2goZS5uYW1lKXtjYXNlIkciOmNhc2UiRGV2aWNlR3JheSI6cmV0dXJuIHRoaXMuZ3JheTtjYXNlIlJHQiI6Y2FzZSJEZXZpY2VSR0IiOnJldHVybiB0aGlzLnJnYjtjYXNlIkRldmljZVJHQkEiOnJldHVybiB0aGlzLnJnYmE7Y2FzZSJDTVlLIjpjYXNlIkRldmljZUNNWUsiOnJldHVybiB0aGlzLmNteWs7Y2FzZSJQYXR0ZXJuIjpyZXR1cm4gbmV3IFBhdHRlcm5DUyhudWxsKTtkZWZhdWx0OmlmKHIgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBhPXIuZ2V0KCJDb2xvclNwYWNlIik7aWYoYSBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IHI9YS5nZXQoZS5uYW1lKTtpZihyKXtpZihyIGluc3RhbmNlb2YgTmFtZSlyZXR1cm4gdGhpcy4jQihyLHQpO2U9cjticmVha319fXdhcm4oYFVucmVjb2duaXplZCBDb2xvclNwYWNlOiAke2UubmFtZX1gKTtyZXR1cm4gdGhpcy5ncmF5fWlmKEFycmF5LmlzQXJyYXkoZSkpe2NvbnN0IHI9YS5mZXRjaElmUmVmKGVbMF0pLm5hbWU7bGV0IHMsbyxjLGwsaCx1O3N3aXRjaChyKXtjYXNlIkciOmNhc2UiRGV2aWNlR3JheSI6cmV0dXJuIHRoaXMuZ3JheTtjYXNlIlJHQiI6Y2FzZSJEZXZpY2VSR0IiOnJldHVybiB0aGlzLnJnYjtjYXNlIkNNWUsiOmNhc2UiRGV2aWNlQ01ZSyI6cmV0dXJuIHRoaXMuY215aztjYXNlIkNhbEdyYXkiOnM9YS5mZXRjaElmUmVmKGVbMV0pO2w9cy5nZXRBcnJheSgiV2hpdGVQb2ludCIpO2g9cy5nZXRBcnJheSgiQmxhY2tQb2ludCIpO3U9cy5nZXQoIkdhbW1hIik7cmV0dXJuIG5ldyBDYWxHcmF5Q1MobCxoLHUpO2Nhc2UiQ2FsUkdCIjpzPWEuZmV0Y2hJZlJlZihlWzFdKTtsPXMuZ2V0QXJyYXkoIldoaXRlUG9pbnQiKTtoPXMuZ2V0QXJyYXkoIkJsYWNrUG9pbnQiKTt1PXMuZ2V0QXJyYXkoIkdhbW1hIik7Y29uc3QgZD1zLmdldEFycmF5KCJNYXRyaXgiKTtyZXR1cm4gbmV3IENhbFJHQkNTKGwsaCx1LGQpO2Nhc2UiSUNDQmFzZWQiOmNvbnN0IGY9ZVsxXWluc3RhbmNlb2YgUmVmO2lmKGYpe2NvbnN0IHQ9bi5nZXRCeVJlZihlWzFdKTtpZih0KXJldHVybiB0fWNvbnN0IGc9YS5mZXRjaElmUmVmKGVbMV0pLHA9Zy5kaWN0O289cC5nZXQoIk4iKTtpZihJY2NDb2xvclNwYWNlLmlzVXNhYmxlKXRyeXtjb25zdCB0PW5ldyBJY2NDb2xvclNwYWNlKGcuZ2V0Qnl0ZXMoKSwiSUNDQmFzZWQiLG8pO2YmJm4uc2V0KG51bGwsZVsxXSx0KTtyZXR1cm4gdH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgdDt3YXJuKGBJQ0NCYXNlZCBjb2xvciBzcGFjZSAoJHtlWzFdfSk6ICIke3R9Ii5gKX1jb25zdCBtPXAuZ2V0UmF3KCJBbHRlcm5hdGUiKTtpZihtKXtjb25zdCBlPXRoaXMuI1IobSx0KTtpZihlLm51bUNvbXBzPT09bylyZXR1cm4gZTt3YXJuKCJJQ0NCYXNlZCBjb2xvciBzcGFjZTogSWdub3JpbmcgaW5jb3JyZWN0IC9BbHRlcm5hdGUgZW50cnkuIil9aWYoMT09PW8pcmV0dXJuIHRoaXMuZ3JheTtpZigzPT09bylyZXR1cm4gdGhpcy5yZ2I7aWYoND09PW8pcmV0dXJuIHRoaXMuY215azticmVhaztjYXNlIlBhdHRlcm4iOmM9ZVsxXXx8bnVsbDtjJiYoYz10aGlzLiNSKGMsdCkpO3JldHVybiBuZXcgUGF0dGVybkNTKGMpO2Nhc2UiSSI6Y2FzZSJJbmRleGVkIjpjPXRoaXMuI1IoZVsxXSx0KTtjb25zdCBiPU1hdGhDbGFtcChhLmZldGNoSWZSZWYoZVsyXSksMCwyNTUpLHk9YS5mZXRjaElmUmVmKGVbM10pO3JldHVybiBuZXcgSW5kZXhlZENTKGMsYix5KTtjYXNlIlNlcGFyYXRpb24iOmNhc2UiRGV2aWNlTiI6Y29uc3Qgdz1hLmZldGNoSWZSZWYoZVsxXSk7bz1BcnJheS5pc0FycmF5KHcpP3cubGVuZ3RoOjE7Yz10aGlzLiNSKGVbMl0sdCk7Y29uc3QgeD1pLmNyZWF0ZShlWzNdKTtyZXR1cm4gbmV3IEFsdGVybmF0ZUNTKG8sYyx4KTtjYXNlIkxhYiI6cz1hLmZldGNoSWZSZWYoZVsxXSk7bD1zLmdldEFycmF5KCJXaGl0ZVBvaW50Iik7aD1zLmdldEFycmF5KCJCbGFja1BvaW50Iik7Y29uc3QgUz1zLmdldEFycmF5KCJSYW5nZSIpO3JldHVybiBuZXcgTGFiQ1MobCxoLFMpO2RlZmF1bHQ6d2FybihgVW5pbXBsZW1lbnRlZCBDb2xvclNwYWNlIG9iamVjdDogJHtyfWApO3JldHVybiB0aGlzLmdyYXl9fXdhcm4oYFVucmVjb2duaXplZCBDb2xvclNwYWNlIG9iamVjdDogJHtlfWApO3JldHVybiB0aGlzLmdyYXl9c3RhdGljIGdldCBncmF5KCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJncmF5IixuZXcgRGV2aWNlR3JheUNTKX1zdGF0aWMgZ2V0IHJnYigpe3JldHVybiBzaGFkb3codGhpcywicmdiIixuZXcgRGV2aWNlUmdiQ1MpfXN0YXRpYyBnZXQgcmdiYSgpe3JldHVybiBzaGFkb3codGhpcywicmdiYSIsbmV3IERldmljZVJnYmFDUyl9c3RhdGljIGdldCBjbXlrKCl7aWYoQ215a0lDQ0Jhc2VkQ1MuaXNVc2FibGUpdHJ5e3JldHVybiBzaGFkb3codGhpcywiY215ayIsbmV3IENteWtJQ0NCYXNlZENTKX1jYXRjaHt3YXJuKCJDTVlLIGZhbGxiYWNrOiBEZXZpY2VDTVlLIil9cmV0dXJuIHNoYWRvdyh0aGlzLCJjbXlrIixuZXcgRGV2aWNlQ215a0NTKX19Y2xhc3MgSnBlZ0Vycm9yIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiSnBlZ0Vycm9yIil9fWNsYXNzIEROTE1hcmtlckVycm9yIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLCJETkxNYXJrZXJFcnJvciIpO3RoaXMuc2NhbkxpbmVzPXR9fWNsYXNzIEVPSU1hcmtlckVycm9yIGV4dGVuZHMgSnR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiRU9JTWFya2VyRXJyb3IiKX19Y29uc3QgU2E9bmV3IFVpbnQ4QXJyYXkoWzAsMSw4LDE2LDksMiwzLDEwLDE3LDI0LDMyLDI1LDE4LDExLDQsNSwxMiwxOSwyNiwzMyw0MCw0OCw0MSwzNCwyNywyMCwxMyw2LDcsMTQsMjEsMjgsMzUsNDIsNDksNTYsNTcsNTAsNDMsMzYsMjksMjIsMTUsMjMsMzAsMzcsNDQsNTEsNTgsNTksNTIsNDUsMzgsMzEsMzksNDYsNTMsNjAsNjEsNTQsNDcsNTUsNjIsNjNdKSxBYT00MDE3LGthPTc5OSxDYT0zNDA2LHZhPTIyNzYsRmE9MTU2NyxJYT0zNzg0LFRhPTU3OTMsT2E9Mjg5NjtmdW5jdGlvbiBidWlsZEh1ZmZtYW5UYWJsZShlLHQpe2xldCBhLHIsaT0wLG49MTY7Zm9yKDtuPjAmJiFlW24tMV07KW4tLTtjb25zdCBzPVt7Y2hpbGRyZW46W10saW5kZXg6MH1dO2xldCBvLGM9c1swXTtmb3IoYT0wO2E8bjthKyspe2ZvcihyPTA7cjxlW2FdO3IrKyl7Yz1zLnBvcCgpO2MuY2hpbGRyZW5bYy5pbmRleF09dFtpXTtmb3IoO2MuaW5kZXg+MDspYz1zLnBvcCgpO2MuaW5kZXgrKztzLnB1c2goYyk7Zm9yKDtzLmxlbmd0aDw9YTspe3MucHVzaChvPXtjaGlsZHJlbjpbXSxpbmRleDowfSk7Yy5jaGlsZHJlbltjLmluZGV4XT1vLmNoaWxkcmVuO2M9b31pKyt9aWYoYSsxPG4pe3MucHVzaChvPXtjaGlsZHJlbjpbXSxpbmRleDowfSk7Yy5jaGlsZHJlbltjLmluZGV4XT1vLmNoaWxkcmVuO2M9b319cmV0dXJuIHNbMF0uY2hpbGRyZW59ZnVuY3Rpb24gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoZSx0LGEpe3JldHVybiA2NCooKGUuYmxvY2tzUGVyTGluZSsxKSp0K2EpfWZ1bmN0aW9uIGRlY29kZVNjYW4oZSx0LGEscixpLG4scyxvLGMsbD0hMSl7Y29uc3QgaD1hLm1jdXNQZXJMaW5lLHU9YS5wcm9ncmVzc2l2ZSxkPXQ7bGV0IGY9MCxnPTA7ZnVuY3Rpb24gcmVhZEJpdCgpe2lmKGc+MCl7Zy0tO3JldHVybiBmPj5nJjF9Zj1lW3QrK107aWYoMjU1PT09Zil7Y29uc3Qgcj1lW3QrK107aWYocil7aWYoMjIwPT09ciYmbCl7Y29uc3Qgcj1yZWFkVWludDE2KGUsdCs9Mik7dCs9MjtpZihyPjAmJnIhPT1hLnNjYW5MaW5lcyl0aHJvdyBuZXcgRE5MTWFya2VyRXJyb3IoIkZvdW5kIEROTCBtYXJrZXIgKDB4RkZEQykgd2hpbGUgcGFyc2luZyBzY2FuIGRhdGEiLHIpfWVsc2UgaWYoMjE3PT09cil7aWYobCl7Y29uc3QgZT15Kig4PT09YS5wcmVjaXNpb24/ODowKTtpZihlPjAmJk1hdGgucm91bmQoYS5zY2FuTGluZXMvZSk+PTUpdGhyb3cgbmV3IEROTE1hcmtlckVycm9yKCJGb3VuZCBFT0kgbWFya2VyICgweEZGRDkpIHdoaWxlIHBhcnNpbmcgc2NhbiBkYXRhLCBwb3NzaWJseSBjYXVzZWQgYnkgaW5jb3JyZWN0IGBzY2FuTGluZXNgIHBhcmFtZXRlciIsZSl9dGhyb3cgbmV3IEVPSU1hcmtlckVycm9yKCJGb3VuZCBFT0kgbWFya2VyICgweEZGRDkpIHdoaWxlIHBhcnNpbmcgc2NhbiBkYXRhIil9dGhyb3cgbmV3IEpwZWdFcnJvcihgdW5leHBlY3RlZCBtYXJrZXIgJHsoZjw8OHxyKS50b1N0cmluZygxNil9YCl9fWc9NztyZXR1cm4gZj4+Pjd9ZnVuY3Rpb24gZGVjb2RlSHVmZm1hbihlKXtsZXQgdD1lO2Zvcig7Oyl7dD10W3JlYWRCaXQoKV07c3dpdGNoKHR5cGVvZiB0KXtjYXNlIm51bWJlciI6cmV0dXJuIHQ7Y2FzZSJvYmplY3QiOmNvbnRpbnVlfXRocm93IG5ldyBKcGVnRXJyb3IoImludmFsaWQgaHVmZm1hbiBzZXF1ZW5jZSIpfX1mdW5jdGlvbiByZWNlaXZlKGUpe2xldCB0PTA7Zm9yKDtlPjA7KXt0PXQ8PDF8cmVhZEJpdCgpO2UtLX1yZXR1cm4gdH1mdW5jdGlvbiByZWNlaXZlQW5kRXh0ZW5kKGUpe2lmKDE9PT1lKXJldHVybiAxPT09cmVhZEJpdCgpPzE6LTE7Y29uc3QgdD1yZWNlaXZlKGUpO3JldHVybiB0Pj0xPDxlLTE/dDp0KygtMTw8ZSkrMX1sZXQgcD0wO2xldCBtLGI9MDtsZXQgeT0wO2Z1bmN0aW9uIGRlY29kZU1jdShlLHQsYSxyLGkpe2NvbnN0IG49YSVoO3k9KGEvaHwwKSplLnYrcjtjb25zdCBzPW4qZS5oK2k7dChlLGdldEJsb2NrQnVmZmVyT2Zmc2V0KGUseSxzKSl9ZnVuY3Rpb24gZGVjb2RlQmxvY2soZSx0LGEpe3k9YS9lLmJsb2Nrc1BlckxpbmV8MDtjb25zdCByPWElZS5ibG9ja3NQZXJMaW5lO3QoZSxnZXRCbG9ja0J1ZmZlck9mZnNldChlLHkscikpfWNvbnN0IHc9ci5sZW5ndGg7bGV0IHgsUyxrLEMsdixGO0Y9dT8wPT09bj8wPT09bz9mdW5jdGlvbiBkZWNvZGVEQ0ZpcnN0KGUsdCl7Y29uc3QgYT1kZWNvZGVIdWZmbWFuKGUuaHVmZm1hblRhYmxlREMpLHI9MD09PWE/MDpyZWNlaXZlQW5kRXh0ZW5kKGEpPDxjO2UuYmxvY2tEYXRhW3RdPWUucHJlZCs9cn06ZnVuY3Rpb24gZGVjb2RlRENTdWNjZXNzaXZlKGUsdCl7ZS5ibG9ja0RhdGFbdF18PXJlYWRCaXQoKTw8Y306MD09PW8/ZnVuY3Rpb24gZGVjb2RlQUNGaXJzdChlLHQpe2lmKHA+MCl7cC0tO3JldHVybn1sZXQgYT1uO2NvbnN0IHI9cztmb3IoO2E8PXI7KXtjb25zdCByPWRlY29kZUh1ZmZtYW4oZS5odWZmbWFuVGFibGVBQyksaT0xNSZyLG49cj4+NDtpZigwPT09aSl7aWYobjwxNSl7cD1yZWNlaXZlKG4pKygxPDxuKS0xO2JyZWFrfWErPTE2O2NvbnRpbnVlfWErPW47Y29uc3Qgcz1TYVthXTtlLmJsb2NrRGF0YVt0K3NdPXJlY2VpdmVBbmRFeHRlbmQoaSkqKDE8PGMpO2ErK319OmZ1bmN0aW9uIGRlY29kZUFDU3VjY2Vzc2l2ZShlLHQpe2xldCBhPW47Y29uc3Qgcj1zO2xldCBpLG8sbD0wO2Zvcig7YTw9cjspe2NvbnN0IHI9dCtTYVthXSxuPWUuYmxvY2tEYXRhW3JdPDA/LTE6MTtzd2l0Y2goYil7Y2FzZSAwOm89ZGVjb2RlSHVmZm1hbihlLmh1ZmZtYW5UYWJsZUFDKTtpPTE1Jm87bD1vPj40O2lmKDA9PT1pKWlmKGw8MTUpe3A9cmVjZWl2ZShsKSsoMTw8bCk7Yj00fWVsc2V7bD0xNjtiPTF9ZWxzZXtpZigxIT09aSl0aHJvdyBuZXcgSnBlZ0Vycm9yKCJpbnZhbGlkIEFDbiBlbmNvZGluZyIpO209cmVjZWl2ZUFuZEV4dGVuZChpKTtiPWw/MjozfWNvbnRpbnVlO2Nhc2UgMTpjYXNlIDI6aWYoZS5ibG9ja0RhdGFbcl0pZS5ibG9ja0RhdGFbcl0rPW4qKHJlYWRCaXQoKTw8Yyk7ZWxzZXtsLS07MD09PWwmJihiPTI9PT1iPzM6MCl9YnJlYWs7Y2FzZSAzOmlmKGUuYmxvY2tEYXRhW3JdKWUuYmxvY2tEYXRhW3JdKz1uKihyZWFkQml0KCk8PGMpO2Vsc2V7ZS5ibG9ja0RhdGFbcl09bTw8YztiPTB9YnJlYWs7Y2FzZSA0OmUuYmxvY2tEYXRhW3JdJiYoZS5ibG9ja0RhdGFbcl0rPW4qKHJlYWRCaXQoKTw8YykpfWErK31pZig0PT09Yil7cC0tOzA9PT1wJiYoYj0wKX19OmZ1bmN0aW9uIGRlY29kZUJhc2VsaW5lKGUsdCl7Y29uc3QgYT1kZWNvZGVIdWZmbWFuKGUuaHVmZm1hblRhYmxlREMpLHI9MD09PWE/MDpyZWNlaXZlQW5kRXh0ZW5kKGEpO2UuYmxvY2tEYXRhW3RdPWUucHJlZCs9cjtsZXQgaT0xO2Zvcig7aTw2NDspe2NvbnN0IGE9ZGVjb2RlSHVmZm1hbihlLmh1ZmZtYW5UYWJsZUFDKSxyPTE1JmEsbj1hPj40O2lmKDA9PT1yKXtpZihuPDE1KWJyZWFrO2krPTE2O2NvbnRpbnVlfWkrPW47Y29uc3Qgcz1TYVtpXTtlLmJsb2NrRGF0YVt0K3NdPXJlY2VpdmVBbmRFeHRlbmQocik7aSsrfX07bGV0IFQsTz0wO2NvbnN0IE09MT09PXc/clswXS5ibG9ja3NQZXJMaW5lKnJbMF0uYmxvY2tzUGVyQ29sdW1uOmgqYS5tY3VzUGVyQ29sdW1uO2xldCBELFI7Zm9yKDtPPD1NOyl7Y29uc3QgYT1pP01hdGgubWluKE0tTyxpKTpNO2lmKGE+MCl7Zm9yKFM9MDtTPHc7UysrKXJbU10ucHJlZD0wO3A9MDtpZigxPT09dyl7eD1yWzBdO2Zvcih2PTA7djxhO3YrKyl7ZGVjb2RlQmxvY2soeCxGLE8pO08rK319ZWxzZSBmb3Iodj0wO3Y8YTt2Kyspe2ZvcihTPTA7Uzx3O1MrKyl7eD1yW1NdO0Q9eC5oO1I9eC52O2ZvcihrPTA7azxSO2srKylmb3IoQz0wO0M8RDtDKyspZGVjb2RlTWN1KHgsRixPLGssQyl9TysrfX1nPTA7VD1maW5kTmV4dEZpbGVNYXJrZXIoZSx0KTtpZighVClicmVhaztpZihULmludmFsaWQpe3dhcm4oYGRlY29kZVNjYW4gLSAke2E+MD8idW5leHBlY3RlZCI6ImV4Y2Vzc2l2ZSJ9IE1DVSBkYXRhLCBjdXJyZW50IG1hcmtlciBpczogJHtULmludmFsaWR9YCk7dD1ULm9mZnNldH1pZighKFQubWFya2VyPj02NTQ4OCYmVC5tYXJrZXI8PTY1NDk1KSlicmVhazt0Kz0yfXJldHVybiB0LWR9ZnVuY3Rpb24gcXVhbnRpemVBbmRJbnZlcnNlKGUsdCxhKXtjb25zdCByPWUucXVhbnRpemF0aW9uVGFibGUsaT1lLmJsb2NrRGF0YTtsZXQgbixzLG8sYyxsLGgsdSxkLGYsZyxwLG0sYix5LHcseCxTO2lmKCFyKXRocm93IG5ldyBKcGVnRXJyb3IoIm1pc3NpbmcgcmVxdWlyZWQgUXVhbnRpemF0aW9uIFRhYmxlLiIpO2ZvcihsZXQgZT0wO2U8NjQ7ZSs9OCl7Zj1pW3QrZV07Zz1pW3QrZSsxXTtwPWlbdCtlKzJdO209aVt0K2UrM107Yj1pW3QrZSs0XTt5PWlbdCtlKzVdO3c9aVt0K2UrNl07eD1pW3QrZSs3XTtmKj1yW2VdO2lmKGd8cHxtfGJ8eXx3fHgpe2cqPXJbZSsxXTtwKj1yW2UrMl07bSo9cltlKzNdO2IqPXJbZSs0XTt5Kj1yW2UrNV07dyo9cltlKzZdO3gqPXJbZSs3XTtuPVRhKmYrMTI4Pj44O3M9VGEqYisxMjg+Pjg7bz1wO2M9dztsPU9hKihnLXgpKzEyOD4+ODtkPU9hKihnK3gpKzEyOD4+ODtoPW08PDQ7dT15PDw0O249bitzKzE+PjE7cz1uLXM7Uz1vKklhK2MqRmErMTI4Pj44O289bypGYS1jKklhKzEyOD4+ODtjPVM7bD1sK3UrMT4+MTt1PWwtdTtkPWQraCsxPj4xO2g9ZC1oO249bitjKzE+PjE7Yz1uLWM7cz1zK28rMT4+MTtvPXMtbztTPWwqdmErZCpDYSsyMDQ4Pj4xMjtsPWwqQ2EtZCp2YSsyMDQ4Pj4xMjtkPVM7Uz1oKmthK3UqQWErMjA0OD4+MTI7aD1oKkFhLXUqa2ErMjA0OD4+MTI7dT1TO2FbZV09bitkO2FbZSs3XT1uLWQ7YVtlKzFdPXMrdTthW2UrNl09cy11O2FbZSsyXT1vK2g7YVtlKzVdPW8taDthW2UrM109YytsO2FbZSs0XT1jLWx9ZWxzZXtTPVRhKmYrNTEyPj4xMDthW2VdPVM7YVtlKzFdPVM7YVtlKzJdPVM7YVtlKzNdPVM7YVtlKzRdPVM7YVtlKzVdPVM7YVtlKzZdPVM7YVtlKzddPVN9fWZvcihsZXQgZT0wO2U8ODsrK2Upe2Y9YVtlXTtnPWFbZSs4XTtwPWFbZSsxNl07bT1hW2UrMjRdO2I9YVtlKzMyXTt5PWFbZSs0MF07dz1hW2UrNDhdO3g9YVtlKzU2XTtpZihnfHB8bXxifHl8d3x4KXtuPVRhKmYrMjA0OD4+MTI7cz1UYSpiKzIwNDg+PjEyO289cDtjPXc7bD1PYSooZy14KSsyMDQ4Pj4xMjtkPU9hKihnK3gpKzIwNDg+PjEyO2g9bTt1PXk7bj00MTEyKyhuK3MrMT4+MSk7cz1uLXM7Uz1vKklhK2MqRmErMjA0OD4+MTI7bz1vKkZhLWMqSWErMjA0OD4+MTI7Yz1TO2w9bCt1KzE+PjE7dT1sLXU7ZD1kK2grMT4+MTtoPWQtaDtuPW4rYysxPj4xO2M9bi1jO3M9cytvKzE+PjE7bz1zLW87Uz1sKnZhK2QqQ2ErMjA0OD4+MTI7bD1sKkNhLWQqdmErMjA0OD4+MTI7ZD1TO1M9aCprYSt1KkFhKzIwNDg+PjEyO2g9aCpBYS11KmthKzIwNDg+PjEyO3U9UztmPW4rZDt4PW4tZDtnPXMrdTt3PXMtdTtwPW8raDt5PW8taDttPWMrbDtiPWMtbDtmPDE2P2Y9MDpmPj00MDgwP2Y9MjU1OmY+Pj00O2c8MTY/Zz0wOmc+PTQwODA/Zz0yNTU6Zz4+PTQ7cDwxNj9wPTA6cD49NDA4MD9wPTI1NTpwPj49NDttPDE2P209MDptPj00MDgwP209MjU1Om0+Pj00O2I8MTY/Yj0wOmI+PTQwODA/Yj0yNTU6Yj4+PTQ7eTwxNj95PTA6eT49NDA4MD95PTI1NTp5Pj49NDt3PDE2P3c9MDp3Pj00MDgwP3c9MjU1Onc+Pj00O3g8MTY/eD0wOng+PTQwODA/eD0yNTU6eD4+PTQ7aVt0K2VdPWY7aVt0K2UrOF09ZztpW3QrZSsxNl09cDtpW3QrZSsyNF09bTtpW3QrZSszMl09YjtpW3QrZSs0MF09eTtpW3QrZSs0OF09dztpW3QrZSs1Nl09eH1lbHNle1M9VGEqZis4MTkyPj4xNDtTPVM8LTIwNDA/MDpTPj0yMDI0PzI1NTpTKzIwNTY+PjQ7aVt0K2VdPVM7aVt0K2UrOF09UztpW3QrZSsxNl09UztpW3QrZSsyNF09UztpW3QrZSszMl09UztpW3QrZSs0MF09UztpW3QrZSs0OF09UztpW3QrZSs1Nl09U319fWZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50RGF0YShlLHQpe2NvbnN0IGE9dC5ibG9ja3NQZXJMaW5lLHI9dC5ibG9ja3NQZXJDb2x1bW4saT1uZXcgSW50MTZBcnJheSg2NCk7Zm9yKGxldCBlPTA7ZTxyO2UrKylmb3IobGV0IHI9MDtyPGE7cisrKXtxdWFudGl6ZUFuZEludmVyc2UodCxnZXRCbG9ja0J1ZmZlck9mZnNldCh0LGUsciksaSl9cmV0dXJuIHQuYmxvY2tEYXRhfWZ1bmN0aW9uIGZpbmROZXh0RmlsZU1hcmtlcihlLHQsYT10KXtjb25zdCByPWUubGVuZ3RoLTE7bGV0IGk9YTx0P2E6dDtpZih0Pj1yKXJldHVybiBudWxsO2NvbnN0IG49cmVhZFVpbnQxNihlLHQpO2lmKG4+PTY1NDcyJiZuPD02NTUzNClyZXR1cm57aW52YWxpZDpudWxsLG1hcmtlcjpuLG9mZnNldDp0fTtsZXQgcz1yZWFkVWludDE2KGUsaSk7Zm9yKDshKHM+PTY1NDcyJiZzPD02NTUzNCk7KXtpZigrK2k+PXIpcmV0dXJuIG51bGw7cz1yZWFkVWludDE2KGUsaSl9cmV0dXJue2ludmFsaWQ6bi50b1N0cmluZygxNiksbWFya2VyOnMsb2Zmc2V0Oml9fWZ1bmN0aW9uIHByZXBhcmVDb21wb25lbnRzKGUpe2NvbnN0IHQ9TWF0aC5jZWlsKGUuc2FtcGxlc1BlckxpbmUvOC9lLm1heEgpLGE9TWF0aC5jZWlsKGUuc2NhbkxpbmVzLzgvZS5tYXhWKTtmb3IoY29uc3QgciBvZiBlLmNvbXBvbmVudHMpe2NvbnN0IGk9TWF0aC5jZWlsKE1hdGguY2VpbChlLnNhbXBsZXNQZXJMaW5lLzgpKnIuaC9lLm1heEgpLG49TWF0aC5jZWlsKE1hdGguY2VpbChlLnNjYW5MaW5lcy84KSpyLnYvZS5tYXhWKSxzPXQqci5oLG89NjQqKGEqci52KSoocysxKTtyLmJsb2NrRGF0YT1uZXcgSW50MTZBcnJheShvKTtyLmJsb2Nrc1BlckxpbmU9aTtyLmJsb2Nrc1BlckNvbHVtbj1ufWUubWN1c1BlckxpbmU9dDtlLm1jdXNQZXJDb2x1bW49YX1mdW5jdGlvbiByZWFkRGF0YUJsb2NrKGUsdCl7Y29uc3QgYT1yZWFkVWludDE2KGUsdCk7bGV0IHI9KHQrPTIpK2EtMjtjb25zdCBpPWZpbmROZXh0RmlsZU1hcmtlcihlLHIsdCk7aWYoaT8uaW52YWxpZCl7d2FybigicmVhZERhdGFCbG9jayAtIGluY29ycmVjdCBsZW5ndGgsIGN1cnJlbnQgbWFya2VyIGlzOiAiK2kuaW52YWxpZCk7cj1pLm9mZnNldH1jb25zdCBuPWUuc3ViYXJyYXkodCxyKTtyZXR1cm57YXBwRGF0YTpuLG9sZE9mZnNldDp0LG5ld09mZnNldDp0K24ubGVuZ3RofX1mdW5jdGlvbiBza2lwRGF0YShlLHQpe2NvbnN0IGE9cmVhZFVpbnQxNihlLHQpLHI9KHQrPTIpK2EtMixpPWZpbmROZXh0RmlsZU1hcmtlcihlLHIsdCk7cmV0dXJuIGk/LmludmFsaWQ/aS5vZmZzZXQ6cn1jbGFzcyBKcGVnSW1hZ2V7Y29uc3RydWN0b3Ioe2RlY29kZVRyYW5zZm9ybTplPW51bGwsY29sb3JUcmFuc2Zvcm06dD0tMX09e30pe3RoaXMuX2RlY29kZVRyYW5zZm9ybT1lO3RoaXMuX2NvbG9yVHJhbnNmb3JtPXR9c3RhdGljIGNhblVzZUltYWdlRGVjb2RlcihlLHQ9LTEpe2xldCBhPW51bGwscj0wLGk9bnVsbCxuPXJlYWRVaW50MTYoZSxyKTtyKz0yO2lmKDY1NDk2IT09bil0aHJvdyBuZXcgSnBlZ0Vycm9yKCJTT0kgbm90IGZvdW5kIik7bj1yZWFkVWludDE2KGUscik7cis9MjtlOmZvcig7NjU0OTchPT1uOyl7c3dpdGNoKG4pe2Nhc2UgNjU1MDU6Y29uc3R7YXBwRGF0YTp0LG9sZE9mZnNldDpzLG5ld09mZnNldDpvfT1yZWFkRGF0YUJsb2NrKGUscik7cj1vO2lmKDY5PT09dFswXSYmMTIwPT09dFsxXSYmMTA1PT09dFsyXSYmMTAyPT09dFszXSYmMD09PXRbNF0mJjA9PT10WzVdKXtpZihhKXRocm93IG5ldyBKcGVnRXJyb3IoIkR1cGxpY2F0ZSBFWElGLWJsb2NrcyBmb3VuZC4iKTthPXtleGlmU3RhcnQ6cys2LGV4aWZFbmQ6b319bj1yZWFkVWludDE2KGUscik7cis9Mjtjb250aW51ZTtjYXNlIDY1NDcyOmNhc2UgNjU0NzM6Y2FzZSA2NTQ3NDppPWVbcis3XTticmVhayBlO2Nhc2UgNjU1MzU6MjU1IT09ZVtyXSYmci0tfXI9c2tpcERhdGEoZSxyKTtuPXJlYWRVaW50MTYoZSxyKTtyKz0yfXJldHVybiA0PT09aXx8Mz09PWkmJjA9PT10P251bGw6YXx8e319cGFyc2UoZSx7ZG5sU2NhbkxpbmVzOnQ9bnVsbH09e30pe2xldCBhLHIsaT0wLG49bnVsbCxzPW51bGwsbz0wO2NvbnN0IGM9W10sbD1bXSxoPVtdO2xldCB1PXJlYWRVaW50MTYoZSxpKTtpKz0yO2lmKDY1NDk2IT09dSl0aHJvdyBuZXcgSnBlZ0Vycm9yKCJTT0kgbm90IGZvdW5kIik7dT1yZWFkVWludDE2KGUsaSk7aSs9MjtlOmZvcig7NjU0OTchPT11Oyl7bGV0IGQsZixnO3N3aXRjaCh1KXtjYXNlIDY1NTA0OmNhc2UgNjU1MDU6Y2FzZSA2NTUwNjpjYXNlIDY1NTA3OmNhc2UgNjU1MDg6Y2FzZSA2NTUwOTpjYXNlIDY1NTEwOmNhc2UgNjU1MTE6Y2FzZSA2NTUxMjpjYXNlIDY1NTEzOmNhc2UgNjU1MTQ6Y2FzZSA2NTUxNTpjYXNlIDY1NTE2OmNhc2UgNjU1MTc6Y2FzZSA2NTUxODpjYXNlIDY1NTE5OmNhc2UgNjU1MzQ6Y29uc3R7YXBwRGF0YTpwLG5ld09mZnNldDptfT1yZWFkRGF0YUJsb2NrKGUsaSk7aT1tOzY1NTA0PT09dSYmNzQ9PT1wWzBdJiY3MD09PXBbMV0mJjczPT09cFsyXSYmNzA9PT1wWzNdJiYwPT09cFs0XSYmKG49e3ZlcnNpb246e21ham9yOnBbNV0sbWlub3I6cFs2XX0sZGVuc2l0eVVuaXRzOnBbN10seERlbnNpdHk6cFs4XTw8OHxwWzldLHlEZW5zaXR5OnBbMTBdPDw4fHBbMTFdLHRodW1iV2lkdGg6cFsxMl0sdGh1bWJIZWlnaHQ6cFsxM10sdGh1bWJEYXRhOnAuc3ViYXJyYXkoMTQsMTQrMypwWzEyXSpwWzEzXSl9KTs2NTUxOD09PXUmJjY1PT09cFswXSYmMTAwPT09cFsxXSYmMTExPT09cFsyXSYmOTg9PT1wWzNdJiYxMDE9PT1wWzRdJiYocz17dmVyc2lvbjpwWzVdPDw4fHBbNl0sZmxhZ3MwOnBbN108PDh8cFs4XSxmbGFnczE6cFs5XTw8OHxwWzEwXSx0cmFuc2Zvcm1Db2RlOnBbMTFdfSk7YnJlYWs7Y2FzZSA2NTQ5OTpjb25zdCBiPXJlYWRVaW50MTYoZSxpKTtpKz0yO2NvbnN0IHk9YitpLTI7bGV0IHc7Zm9yKDtpPHk7KXtjb25zdCB0PWVbaSsrXSxhPW5ldyBVaW50MTZBcnJheSg2NCk7aWYodD4+NCl7aWYodD4+NCE9MSl0aHJvdyBuZXcgSnBlZ0Vycm9yKCJEUVQgLSBpbnZhbGlkIHRhYmxlIHNwZWMiKTtmb3IoZj0wO2Y8NjQ7ZisrKXt3PVNhW2ZdO2Fbd109cmVhZFVpbnQxNihlLGkpO2krPTJ9fWVsc2UgZm9yKGY9MDtmPDY0O2YrKyl7dz1TYVtmXTthW3ddPWVbaSsrXX1jWzE1JnRdPWF9YnJlYWs7Y2FzZSA2NTQ3MjpjYXNlIDY1NDczOmNhc2UgNjU0NzQ6aWYoYSl0aHJvdyBuZXcgSnBlZ0Vycm9yKCJPbmx5IHNpbmdsZSBmcmFtZSBKUEVHcyBzdXBwb3J0ZWQiKTtpKz0yO2E9e307YS5leHRlbmRlZD02NTQ3Mz09PXU7YS5wcm9ncmVzc2l2ZT02NTQ3ND09PXU7YS5wcmVjaXNpb249ZVtpKytdO2NvbnN0IHg9cmVhZFVpbnQxNihlLGkpO2krPTI7YS5zY2FuTGluZXM9dHx8eDthLnNhbXBsZXNQZXJMaW5lPXJlYWRVaW50MTYoZSxpKTtpKz0yO2EuY29tcG9uZW50cz1bXTthLmNvbXBvbmVudElkcz17fTtjb25zdCBTPWVbaSsrXTtsZXQgaz0wLEM9MDtmb3IoZD0wO2Q8UztkKyspe2NvbnN0IHQ9ZVtpXSxyPWVbaSsxXT4+NCxuPTE1JmVbaSsxXTtrPHImJihrPXIpO0M8biYmKEM9bik7Y29uc3Qgcz1lW2krMl07Zz1hLmNvbXBvbmVudHMucHVzaCh7aDpyLHY6bixxdWFudGl6YXRpb25JZDpzLHF1YW50aXphdGlvblRhYmxlOm51bGx9KTthLmNvbXBvbmVudElkc1t0XT1nLTE7aSs9M31hLm1heEg9azthLm1heFY9QztwcmVwYXJlQ29tcG9uZW50cyhhKTticmVhaztjYXNlIDY1NDc2OmNvbnN0IHY9cmVhZFVpbnQxNihlLGkpO2krPTI7Zm9yKGQ9MjtkPHY7KXtjb25zdCB0PWVbaSsrXSxhPW5ldyBVaW50OEFycmF5KDE2KTtsZXQgcj0wO2ZvcihmPTA7ZjwxNjtmKyssaSsrKXIrPWFbZl09ZVtpXTtjb25zdCBuPW5ldyBVaW50OEFycmF5KHIpO2ZvcihmPTA7ZjxyO2YrKyxpKyspbltmXT1lW2ldO2QrPTE3K3I7KHQ+PjQ/bDpoKVsxNSZ0XT1idWlsZEh1ZmZtYW5UYWJsZShhLG4pfWJyZWFrO2Nhc2UgNjU1MDE6aSs9MjtyPXJlYWRVaW50MTYoZSxpKTtpKz0yO2JyZWFrO2Nhc2UgNjU0OTg6Y29uc3QgRj0xPT0rK28mJiF0O2krPTI7Y29uc3QgVD1lW2krK10sTz1bXTtmb3IoZD0wO2Q8VDtkKyspe2NvbnN0IHQ9ZVtpKytdLHI9YS5jb21wb25lbnRJZHNbdF0sbj1hLmNvbXBvbmVudHNbcl07bi5pbmRleD10O2NvbnN0IHM9ZVtpKytdO24uaHVmZm1hblRhYmxlREM9aFtzPj40XTtuLmh1ZmZtYW5UYWJsZUFDPWxbMTUmc107Ty5wdXNoKG4pfWNvbnN0IE09ZVtpKytdLEQ9ZVtpKytdLFI9ZVtpKytdO3RyeXtpKz1kZWNvZGVTY2FuKGUsaSxhLE8scixNLEQsUj4+NCwxNSZSLEYpfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBETkxNYXJrZXJFcnJvcil7d2FybihgJHt0Lm1lc3NhZ2V9IC0tIGF0dGVtcHRpbmcgdG8gcmUtcGFyc2UgdGhlIEpQRUcgaW1hZ2UuYCk7cmV0dXJuIHRoaXMucGFyc2UoZSx7ZG5sU2NhbkxpbmVzOnQuc2NhbkxpbmVzfSl9aWYodCBpbnN0YW5jZW9mIEVPSU1hcmtlckVycm9yKXt3YXJuKGAke3QubWVzc2FnZX0gLS0gaWdub3JpbmcgdGhlIHJlc3Qgb2YgdGhlIGltYWdlIGRhdGEuYCk7YnJlYWsgZX10aHJvdyB0fWJyZWFrO2Nhc2UgNjU1MDA6aSs9NDticmVhaztjYXNlIDY1NTM1OjI1NSE9PWVbaV0mJmktLTticmVhaztkZWZhdWx0OmNvbnN0IE49ZmluZE5leHRGaWxlTWFya2VyKGUsaS0yLGktMyk7aWYoTj8uaW52YWxpZCl7d2FybigiSnBlZ0ltYWdlLnBhcnNlIC0gdW5leHBlY3RlZCBkYXRhLCBjdXJyZW50IG1hcmtlciBpczogIitOLmludmFsaWQpO2k9Ti5vZmZzZXQ7YnJlYWt9aWYoIU58fGk+PWUubGVuZ3RoLTEpe3dhcm4oIkpwZWdJbWFnZS5wYXJzZSAtIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgaW1hZ2UgZGF0YSB3aXRob3V0IGZpbmRpbmcgYW4gRU9JIG1hcmtlciAoMHhGRkQ5KS4iKTticmVhayBlfXRocm93IG5ldyBKcGVnRXJyb3IoIkpwZWdJbWFnZS5wYXJzZSAtIHVua25vd24gbWFya2VyOiAiK3UudG9TdHJpbmcoMTYpKX11PXJlYWRVaW50MTYoZSxpKTtpKz0yfWlmKCFhKXRocm93IG5ldyBKcGVnRXJyb3IoIkpwZWdJbWFnZS5wYXJzZSAtIG5vIGZyYW1lIGRhdGEgZm91bmQuIik7dGhpcy53aWR0aD1hLnNhbXBsZXNQZXJMaW5lO3RoaXMuaGVpZ2h0PWEuc2NhbkxpbmVzO3RoaXMuamZpZj1uO3RoaXMuYWRvYmU9czt0aGlzLmNvbXBvbmVudHM9W107Zm9yKGNvbnN0IGUgb2YgYS5jb21wb25lbnRzKXtjb25zdCB0PWNbZS5xdWFudGl6YXRpb25JZF07dCYmKGUucXVhbnRpemF0aW9uVGFibGU9dCk7dGhpcy5jb21wb25lbnRzLnB1c2goe2luZGV4OmUuaW5kZXgsb3V0cHV0OmJ1aWxkQ29tcG9uZW50RGF0YSgwLGUpLHNjYWxlWDplLmgvYS5tYXhILHNjYWxlWTplLnYvYS5tYXhWLGJsb2Nrc1BlckxpbmU6ZS5ibG9ja3NQZXJMaW5lLGJsb2Nrc1BlckNvbHVtbjplLmJsb2Nrc1BlckNvbHVtbn0pfXRoaXMubnVtQ29tcG9uZW50cz10aGlzLmNvbXBvbmVudHMubGVuZ3RofV9nZXRMaW5lYXJpemVkQmxvY2tEYXRhKGUsdCxhPSExKXtjb25zdCByPXRoaXMud2lkdGgvZSxpPXRoaXMuaGVpZ2h0L3Q7bGV0IG4scyxvLGMsbCxoLHUsZCxmLGcscCxtPTA7Y29uc3QgYj10aGlzLmNvbXBvbmVudHMubGVuZ3RoLHk9ZSp0KmIsdz1uZXcgVWludDhDbGFtcGVkQXJyYXkoeSkseD1uZXcgVWludDMyQXJyYXkoZSksUz00Mjk0OTY3Mjg4O2xldCBrO2Zvcih1PTA7dTxiO3UrKyl7bj10aGlzLmNvbXBvbmVudHNbdV07cz1uLnNjYWxlWCpyO289bi5zY2FsZVkqaTttPXU7cD1uLm91dHB1dDtjPW4uYmxvY2tzUGVyTGluZSsxPDwzO2lmKHMhPT1rKXtmb3IobD0wO2w8ZTtsKyspe2Q9MHxsKnM7eFtsXT0oZCZTKTw8M3w3JmR9az1zfWZvcihoPTA7aDx0O2grKyl7ZD0wfGgqbztnPWMqKGQmUyl8KDcmZCk8PDM7Zm9yKGw9MDtsPGU7bCsrKXt3W21dPXBbZyt4W2xdXTttKz1ifX19bGV0IEM9dGhpcy5fZGVjb2RlVHJhbnNmb3JtO2F8fDQhPT1ifHxDfHwoQz1uZXcgSW50MzJBcnJheShbLTI1NiwyNTUsLTI1NiwyNTUsLTI1NiwyNTUsLTI1NiwyNTVdKSk7aWYoQylmb3IodT0wO3U8eTspZm9yKGQ9MCxmPTA7ZDxiO2QrKyx1KyssZis9Mil3W3VdPSh3W3VdKkNbZl0+PjgpK0NbZisxXTtyZXR1cm4gd31nZXQgX2lzQ29sb3JDb252ZXJzaW9uTmVlZGVkKCl7cmV0dXJuIHRoaXMuYWRvYmU/ISF0aGlzLmFkb2JlLnRyYW5zZm9ybUNvZGU6Mz09PXRoaXMubnVtQ29tcG9uZW50cz8wIT09dGhpcy5fY29sb3JUcmFuc2Zvcm0mJig4MiE9PXRoaXMuY29tcG9uZW50c1swXS5pbmRleHx8NzEhPT10aGlzLmNvbXBvbmVudHNbMV0uaW5kZXh8fDY2IT09dGhpcy5jb21wb25lbnRzWzJdLmluZGV4KToxPT09dGhpcy5fY29sb3JUcmFuc2Zvcm19X2NvbnZlcnRZY2NUb1JnYihlKXtsZXQgdCxhLHI7Zm9yKGxldCBpPTAsbj1lLmxlbmd0aDtpPG47aSs9Myl7dD1lW2ldO2E9ZVtpKzFdO3I9ZVtpKzJdO2VbaV09dC0xNzkuNDU2KzEuNDAyKnI7ZVtpKzFdPXQrMTM1LjQ1OS0uMzQ0KmEtLjcxNCpyO2VbaSsyXT10LTIyNi44MTYrMS43NzIqYX1yZXR1cm4gZX1fY29udmVydFljY1RvUmdiYShlLHQpe2ZvcihsZXQgYT0wLHI9MCxpPWUubGVuZ3RoO2E8aTthKz0zLHIrPTQpe2NvbnN0IGk9ZVthXSxuPWVbYSsxXSxzPWVbYSsyXTt0W3JdPWktMTc5LjQ1NisxLjQwMipzO3RbcisxXT1pKzEzNS40NTktLjM0NCpuLS43MTQqczt0W3IrMl09aS0yMjYuODE2KzEuNzcyKm47dFtyKzNdPTI1NX1yZXR1cm4gdH1fY29udmVydFljY2tUb1JnYihlKXt0aGlzLl9jb252ZXJ0WWNja1RvQ215ayhlKTtyZXR1cm4gdGhpcy5fY29udmVydENteWtUb1JnYihlKX1fY29udmVydFljY2tUb1JnYmEoZSl7dGhpcy5fY29udmVydFljY2tUb0NteWsoZSk7cmV0dXJuIHRoaXMuX2NvbnZlcnRDbXlrVG9SZ2JhKGUpfV9jb252ZXJ0WWNja1RvQ215ayhlKXtsZXQgdCxhLHI7Zm9yKGxldCBpPTAsbj1lLmxlbmd0aDtpPG47aSs9NCl7dD1lW2ldO2E9ZVtpKzFdO3I9ZVtpKzJdO2VbaV09NDM0LjQ1Ni10LTEuNDAyKnI7ZVtpKzFdPTExOS41NDEtdCsuMzQ0KmErLjcxNCpyO2VbaSsyXT00ODEuODE2LXQtMS43NzIqYX1yZXR1cm4gZX1fY29udmVydENteWtUb1JnYihlKXtjb25zdCB0PWUubGVuZ3RoLzQ7Q29sb3JTcGFjZVV0aWxzLmNteWsuZ2V0UmdiQnVmZmVyKGUsMCx0LGUsMCw4LDApO3JldHVybiBlLnN1YmFycmF5KDAsMyp0KX1fY29udmVydENteWtUb1JnYmEoZSl7Q29sb3JTcGFjZVV0aWxzLmNteWsuZ2V0UmdiQnVmZmVyKGUsMCxlLmxlbmd0aC80LGUsMCw4LDEpO2lmKENvbG9yU3BhY2VVdGlscy5jbXlrIGluc3RhbmNlb2YgRGV2aWNlQ215a0NTKWZvcihsZXQgdD0zLGE9ZS5sZW5ndGg7dDxhO3QrPTQpZVt0XT0yNTU7cmV0dXJuIGV9Z2V0RGF0YSh7d2lkdGg6ZSxoZWlnaHQ6dCxmb3JjZVJHQkE6YT0hMSxmb3JjZVJHQjpyPSExLGlzU291cmNlUERGOmk9ITF9KXtpZih0aGlzLm51bUNvbXBvbmVudHM+NCl0aHJvdyBuZXcgSnBlZ0Vycm9yKCJVbnN1cHBvcnRlZCBjb2xvciBtb2RlIik7Y29uc3Qgbj10aGlzLl9nZXRMaW5lYXJpemVkQmxvY2tEYXRhKGUsdCxpKTtpZigxPT09dGhpcy5udW1Db21wb25lbnRzJiYoYXx8cikpe2NvbnN0IGU9bi5sZW5ndGgqKGE/NDozKSx0PW5ldyBVaW50OENsYW1wZWRBcnJheShlKTtsZXQgcj0wO2lmKGEpIWZ1bmN0aW9uIGdyYXlUb1JHQkEoZSx0KXtpZihGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbilmb3IobGV0IGE9MCxyPWUubGVuZ3RoO2E8cjthKyspdFthXT02NTc5MyplW2FdfDQyNzgxOTAwODA7ZWxzZSBmb3IobGV0IGE9MCxyPWUubGVuZ3RoO2E8cjthKyspdFthXT0xNjg0MzAwOCplW2FdfDI1NX0obixuZXcgVWludDMyQXJyYXkodC5idWZmZXIpKTtlbHNlIGZvcihjb25zdCBlIG9mIG4pe3RbcisrXT1lO3RbcisrXT1lO3RbcisrXT1lfXJldHVybiB0fWlmKDM9PT10aGlzLm51bUNvbXBvbmVudHMmJnRoaXMuX2lzQ29sb3JDb252ZXJzaW9uTmVlZGVkKXtpZihhKXtjb25zdCBlPW5ldyBVaW50OENsYW1wZWRBcnJheShuLmxlbmd0aC8zKjQpO3JldHVybiB0aGlzLl9jb252ZXJ0WWNjVG9SZ2JhKG4sZSl9cmV0dXJuIHRoaXMuX2NvbnZlcnRZY2NUb1JnYihuKX1pZig0PT09dGhpcy5udW1Db21wb25lbnRzKXtpZih0aGlzLl9pc0NvbG9yQ29udmVyc2lvbk5lZWRlZClyZXR1cm4gYT90aGlzLl9jb252ZXJ0WWNja1RvUmdiYShuKTpyP3RoaXMuX2NvbnZlcnRZY2NrVG9SZ2Iobik6dGhpcy5fY29udmVydFljY2tUb0NteWsobik7aWYoYSlyZXR1cm4gdGhpcy5fY29udmVydENteWtUb1JnYmEobik7aWYocilyZXR1cm4gdGhpcy5fY29udmVydENteWtUb1JnYihuKX1yZXR1cm4gbn19Y2xhc3MgSnBlZ1N0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtzdGF0aWMjTT1GZWF0dXJlVGVzdC5pc0ltYWdlRGVjb2RlclN1cHBvcnRlZDtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIodCk7dGhpcy5zdHJlYW09ZTt0aGlzLmRpY3Q9ZS5kaWN0O3RoaXMubWF5YmVMZW5ndGg9dDt0aGlzLnBhcmFtcz1hfXN0YXRpYyBnZXQgY2FuVXNlSW1hZ2VEZWNvZGVyKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJjYW5Vc2VJbWFnZURlY29kZXIiLHRoaXMuI00/SW1hZ2VEZWNvZGVyLmlzVHlwZVN1cHBvcnRlZCgiaW1hZ2UvanBlZyIpOlByb21pc2UucmVzb2x2ZSghMSkpfXN0YXRpYyBzZXRPcHRpb25zKHtpc0ltYWdlRGVjb2RlclN1cHBvcnRlZDplPSExfSl7dGhpcy4jTT1lfWdldCBieXRlcygpe3JldHVybiBzaGFkb3codGhpcywiYnl0ZXMiLHRoaXMuc3RyZWFtLmdldEJ5dGVzKHRoaXMubWF5YmVMZW5ndGgpKX1lbnN1cmVCdWZmZXIoZSl7fXJlYWRCbG9jaygpe3RoaXMuZGVjb2RlSW1hZ2UoKX1nZXQganBlZ09wdGlvbnMoKXtjb25zdCBlPXtkZWNvZGVUcmFuc2Zvcm06dm9pZCAwLGNvbG9yVHJhbnNmb3JtOnZvaWQgMH0sdD10aGlzLmRpY3QuZ2V0QXJyYXkoIkQiLCJEZWNvZGUiKTtpZigodGhpcy5mb3JjZVJHQkF8fHRoaXMuZm9yY2VSR0IpJiZBcnJheS5pc0FycmF5KHQpKXtjb25zdCBhPXRoaXMuZGljdC5nZXQoIkJQQyIsIkJpdHNQZXJDb21wb25lbnQiKXx8OCxyPXQubGVuZ3RoLGk9bmV3IEludDMyQXJyYXkocik7bGV0IG49ITE7Y29uc3Qgcz0oMTw8YSktMTtmb3IobGV0IGU9MDtlPHI7ZSs9Mil7aVtlXT0yNTYqKHRbZSsxXS10W2VdKXwwO2lbZSsxXT10W2VdKnN8MDsyNTY9PT1pW2VdJiYwPT09aVtlKzFdfHwobj0hMCl9biYmKGUuZGVjb2RlVHJhbnNmb3JtPWkpfWlmKHRoaXMucGFyYW1zIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgdD10aGlzLnBhcmFtcy5nZXQoIkNvbG9yVHJhbnNmb3JtIik7TnVtYmVyLmlzSW50ZWdlcih0KSYmKGUuY29sb3JUcmFuc2Zvcm09dCl9cmV0dXJuIHNoYWRvdyh0aGlzLCJqcGVnT3B0aW9ucyIsZSl9I04oZSl7Zm9yKGxldCB0PTAsYT1lLmxlbmd0aC0xO3Q8YTt0KyspaWYoMjU1PT09ZVt0XSYmMjE2PT09ZVt0KzFdKXt0PjAmJihlPWUuc3ViYXJyYXkodCkpO2JyZWFrfXJldHVybiBlfWRlY29kZUltYWdlKGUpe2lmKHRoaXMuZW9mKXJldHVybiB0aGlzLmJ1ZmZlcjtlPXRoaXMuI04oZXx8dGhpcy5ieXRlcyk7Y29uc3QgdD1uZXcgSnBlZ0ltYWdlKHRoaXMuanBlZ09wdGlvbnMpO3QucGFyc2UoZSk7Y29uc3QgYT10LmdldERhdGEoe3dpZHRoOnRoaXMuZHJhd1dpZHRoLGhlaWdodDp0aGlzLmRyYXdIZWlnaHQsZm9yY2VSR0JBOnRoaXMuZm9yY2VSR0JBLGZvcmNlUkdCOnRoaXMuZm9yY2VSR0IsaXNTb3VyY2VQREY6ITB9KTt0aGlzLmJ1ZmZlcj1hO3RoaXMuYnVmZmVyTGVuZ3RoPWEubGVuZ3RoO3RoaXMuZW9mPSEwO3JldHVybiB0aGlzLmJ1ZmZlcn1nZXQgY2FuQXN5bmNEZWNvZGVJbWFnZUZyb21CdWZmZXIoKXtyZXR1cm4gdGhpcy5zdHJlYW0uaXNBc3luY31hc3luYyBnZXRUcmFuc2ZlcmFibGVJbWFnZSgpe2lmKCFhd2FpdCBKcGVnU3RyZWFtLmNhblVzZUltYWdlRGVjb2RlcilyZXR1cm4gbnVsbDtjb25zdCBlPXRoaXMuanBlZ09wdGlvbnM7aWYoZS5kZWNvZGVUcmFuc2Zvcm0pcmV0dXJuIG51bGw7bGV0IHQ7dHJ5e2NvbnN0IGE9dGhpcy5jYW5Bc3luY0RlY29kZUltYWdlRnJvbUJ1ZmZlciYmYXdhaXQgdGhpcy5zdHJlYW0uYXN5bmNHZXRCeXRlcygpfHx0aGlzLmJ5dGVzO2lmKCFhKXJldHVybiBudWxsO2xldCByPXRoaXMuI04oYSk7Y29uc3QgaT1KcGVnSW1hZ2UuY2FuVXNlSW1hZ2VEZWNvZGVyKHIsZS5jb2xvclRyYW5zZm9ybSk7aWYoIWkpcmV0dXJuIG51bGw7aWYoaS5leGlmU3RhcnQpe3I9ci5zbGljZSgpO3IuZmlsbCgwLGkuZXhpZlN0YXJ0LGkuZXhpZkVuZCl9dD1uZXcgSW1hZ2VEZWNvZGVyKHtkYXRhOnIsdHlwZToiaW1hZ2UvanBlZyIscHJlZmVyQW5pbWF0aW9uOiExfSk7cmV0dXJuKGF3YWl0IHQuZGVjb2RlKCkpLmltYWdlfWNhdGNoKGUpe3dhcm4oYGdldFRyYW5zZmVyYWJsZUltYWdlIC0gZmFpbGVkOiAiJHtlfSIuYCk7cmV0dXJuIG51bGx9ZmluYWxseXt0Py5jbG9zZSgpfX19dmFyIE9wZW5KUEVHPWFzeW5jIGZ1bmN0aW9uKGU9e30pe3ZhciB0LGEscj1lLGk9bmV3IFByb21pc2UoKChlLHIpPT57dD1lO2E9cn0pKSxuPSIuL3RoaXMucHJvZ3JhbSIscXVpdF89KGUsdCk9Pnt0aHJvdyB0fSxzPWltcG9ydC5tZXRhLnVybDt0cnl7bmV3IFVSTCgiLiIscykuaHJlZn1jYXRjaHt9dmFyIG8sYyxsLGgsdSxkLGY9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxnPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxwPSExO2Z1bmN0aW9uIHVwZGF0ZU1lbW9yeVZpZXdzKCl7dmFyIGU9by5idWZmZXI7bD1uZXcgSW50OEFycmF5KGUpO25ldyBJbnQxNkFycmF5KGUpO2g9bmV3IFVpbnQ4QXJyYXkoZSk7bmV3IFVpbnQxNkFycmF5KGUpO3U9bmV3IEludDMyQXJyYXkoZSk7ZD1uZXcgVWludDMyQXJyYXkoZSk7bmV3IEZsb2F0MzJBcnJheShlKTtuZXcgRmxvYXQ2NEFycmF5KGUpO25ldyBCaWdJbnQ2NEFycmF5KGUpO25ldyBCaWdVaW50NjRBcnJheShlKX12YXIgbT0wLGI9bnVsbDtjbGFzcyBFeGl0U3RhdHVze25hbWU9IkV4aXRTdGF0dXMiO2NvbnN0cnVjdG9yKGUpe3RoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke2V9KWA7dGhpcy5zdGF0dXM9ZX19dmFyIGNhbGxSdW50aW1lQ2FsbGJhY2tzPWU9Pntmb3IoO2UubGVuZ3RoPjA7KWUuc2hpZnQoKShyKX0seT1bXSxhZGRPblBvc3RSdW49ZT0+eS5wdXNoKGUpLHc9W10sYWRkT25QcmVSdW49ZT0+dy5wdXNoKGUpLHg9ITAsUz0wLGs9e30saGFuZGxlRXhjZXB0aW9uPWU9PntpZihlIGluc3RhbmNlb2YgRXhpdFN0YXR1c3x8InVud2luZCI9PWUpcmV0dXJuIGM7cXVpdF8oMCxlKX0sa2VlcFJ1bnRpbWVBbGl2ZT0oKT0+eHx8Uz4wLF9wcm9jX2V4aXQ9ZT0+e2M9ZTtpZigha2VlcFJ1bnRpbWVBbGl2ZSgpKXtyLm9uRXhpdD8uKGUpO3A9ITB9cXVpdF8oMCxuZXcgRXhpdFN0YXR1cyhlKSl9LF9leGl0PShlLHQpPT57Yz1lO19wcm9jX2V4aXQoZSl9LGNhbGxVc2VyQ2FsbGJhY2s9ZT0+e2lmKCFwKXRyeXtlKCk7KCgpPT57aWYoIWtlZXBSdW50aW1lQWxpdmUoKSl0cnl7X2V4aXQoYyl9Y2F0Y2goZSl7aGFuZGxlRXhjZXB0aW9uKGUpfX0pKCl9Y2F0Y2goZSl7aGFuZGxlRXhjZXB0aW9uKGUpfX0sZ3Jvd01lbW9yeT1lPT57dmFyIHQ9KGUtby5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzZ8MDt0cnl7by5ncm93KHQpO3VwZGF0ZU1lbW9yeVZpZXdzKCk7cmV0dXJuIDF9Y2F0Y2goZSl7fX0sQz17fSxnZXRFbnZTdHJpbmdzPSgpPT57aWYoIWdldEVudlN0cmluZ3Muc3RyaW5ncyl7dmFyIGU9e1VTRVI6IndlYl91c2VyIixMT0dOQU1FOiJ3ZWJfdXNlciIsUEFUSDoiLyIsUFdEOiIvIixIT01FOiIvaG9tZS93ZWJfdXNlciIsTEFORzooIm9iamVjdCI9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fCJDIikucmVwbGFjZSgiLSIsIl8iKSsiLlVURi04IixfOm58fCIuL3RoaXMucHJvZ3JhbSJ9O2Zvcih2YXIgdCBpbiBDKXZvaWQgMD09PUNbdF0/ZGVsZXRlIGVbdF06ZVt0XT1DW3RdO3ZhciBhPVtdO2Zvcih2YXIgdCBpbiBlKWEucHVzaChgJHt0fT0ke2VbdF19YCk7Z2V0RW52U3RyaW5ncy5zdHJpbmdzPWF9cmV0dXJuIGdldEVudlN0cmluZ3Muc3RyaW5nc30sbGVuZ3RoQnl0ZXNVVEY4PWU9Pntmb3IodmFyIHQ9MCxhPTA7YTxlLmxlbmd0aDsrK2Epe3ZhciByPWUuY2hhckNvZGVBdChhKTtpZihyPD0xMjcpdCsrO2Vsc2UgaWYocjw9MjA0Nyl0Kz0yO2Vsc2UgaWYocj49NTUyOTYmJnI8PTU3MzQzKXt0Kz00OysrYX1lbHNlIHQrPTN9cmV0dXJuIHR9LHY9W251bGwsW10sW11dLEY9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXI6dm9pZCAwLFVURjhBcnJheVRvU3RyaW5nPShlLHQ9MCxhPU5hTik9Pntmb3IodmFyIHI9dCthLGk9dDtlW2ldJiYhKGk+PXIpOykrK2k7aWYoaS10PjE2JiZlLmJ1ZmZlciYmRilyZXR1cm4gRi5kZWNvZGUoZS5zdWJhcnJheSh0LGkpKTtmb3IodmFyIG49IiI7dDxpOyl7dmFyIHM9ZVt0KytdO2lmKDEyOCZzKXt2YXIgbz02MyZlW3QrK107aWYoMTkyIT0oMjI0JnMpKXt2YXIgYz02MyZlW3QrK107aWYoKHM9MjI0PT0oMjQwJnMpPygxNSZzKTw8MTJ8bzw8NnxjOig3JnMpPDwxOHxvPDwxMnxjPDw2fDYzJmVbdCsrXSk8NjU1MzYpbis9U3RyaW5nLmZyb21DaGFyQ29kZShzKTtlbHNle3ZhciBsPXMtNjU1MzY7bis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxsPj4xMCw1NjMyMHwxMDIzJmwpfX1lbHNlIG4rPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJnMpPDw2fG8pfWVsc2Ugbis9U3RyaW5nLmZyb21DaGFyQ29kZShzKX1yZXR1cm4gbn0scHJpbnRDaGFyPShlLHQpPT57dmFyIGE9dltlXTtpZigwPT09dHx8MTA9PT10KXsoMT09PWU/ZjpnKShVVEY4QXJyYXlUb1N0cmluZyhhKSk7YS5sZW5ndGg9MH1lbHNlIGEucHVzaCh0KX0sVVRGOFRvU3RyaW5nPShlLHQpPT5lP1VURjhBcnJheVRvU3RyaW5nKGgsZSx0KToiIjtyLm5vRXhpdFJ1bnRpbWUmJih4PXIubm9FeGl0UnVudGltZSk7ci5wcmludCYmKGY9ci5wcmludCk7ci5wcmludEVyciYmKGc9ci5wcmludEVycik7ci53YXNtQmluYXJ5JiZyLndhc21CaW5hcnk7ci5hcmd1bWVudHMmJnIuYXJndW1lbnRzO3IudGhpc1Byb2dyYW0mJihuPXIudGhpc1Byb2dyYW0pO3Iud3JpdGVBcnJheVRvTWVtb3J5PShlLHQpPT57bC5zZXQoZSx0KX07dmFyIFQ9e2w6KCk9PmZ1bmN0aW9uIGFib3J0KGUpe3Iub25BYm9ydD8uKGUpO2coZT0iQWJvcnRlZCgiK2UrIikiKTtwPSEwO2UrPSIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uIjt2YXIgdD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGUpO2EodCk7dGhyb3cgdH0oIiIpLGs6KCk9Pnt4PSExO1M9MH0sbTooZSx0KT0+e2lmKGtbZV0pe2NsZWFyVGltZW91dChrW2VdLmlkKTtkZWxldGUga1tlXX1pZighdClyZXR1cm4gMDt2YXIgYT1zZXRUaW1lb3V0KCgoKT0+e2RlbGV0ZSBrW2VdO2NhbGxVc2VyQ2FsbGJhY2soKCgpPT5NKGUscGVyZm9ybWFuY2Uubm93KCkpKSl9KSx0KTtrW2VdPXtpZDphLHRpbWVvdXRfbXM6dH07cmV0dXJuIDB9LGc6ZnVuY3Rpb24gX2NvcHlfcGl4ZWxzXzEoZSx0KXtlPj49Mjtjb25zdCBhPXIuaW1hZ2VEYXRhPW5ldyBVaW50OENsYW1wZWRBcnJheSh0KSxpPXUuc3ViYXJyYXkoZSxlK3QpO2Euc2V0KGkpfSxmOmZ1bmN0aW9uIF9jb3B5X3BpeGVsc18zKGUsdCxhLGkpe2U+Pj0yO3Q+Pj0yO2E+Pj0yO2NvbnN0IG49ci5pbWFnZURhdGE9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMqaSkscz11LnN1YmFycmF5KGUsZStpKSxvPXUuc3ViYXJyYXkodCx0K2kpLGM9dS5zdWJhcnJheShhLGEraSk7Zm9yKGxldCBlPTA7ZTxpO2UrKyl7blszKmVdPXNbZV07blszKmUrMV09b1tlXTtuWzMqZSsyXT1jW2VdfX0sZTpmdW5jdGlvbiBfY29weV9waXhlbHNfNChlLHQsYSxpLG4pe2U+Pj0yO3Q+Pj0yO2E+Pj0yO2k+Pj0yO2NvbnN0IHM9ci5pbWFnZURhdGE9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQqbiksbz11LnN1YmFycmF5KGUsZStuKSxjPXUuc3ViYXJyYXkodCx0K24pLGw9dS5zdWJhcnJheShhLGErbiksaD11LnN1YmFycmF5KGksaStuKTtmb3IobGV0IGU9MDtlPG47ZSsrKXtzWzQqZV09b1tlXTtzWzQqZSsxXT1jW2VdO3NbNCplKzJdPWxbZV07c1s0KmUrM109aFtlXX19LG46ZT0+e3ZhciB0LGEscj1oLmxlbmd0aCxpPTIxNDc0ODM2NDg7aWYoKGU+Pj49MCk+aSlyZXR1cm4hMTtmb3IodmFyIG49MTtuPD00O24qPTIpe3ZhciBzPXIqKDErLjIvbik7cz1NYXRoLm1pbihzLGUrMTAwNjYzMjk2KTt2YXIgbz1NYXRoLm1pbihpLCh0PU1hdGgubWF4KGUscyksYT02NTUzNixNYXRoLmNlaWwodC9hKSphKSk7aWYoZ3Jvd01lbW9yeShvKSlyZXR1cm4hMH1yZXR1cm4hMX0scDooZSx0KT0+e3ZhciBhPTAscj0wO2Zvcih2YXIgaSBvZiBnZXRFbnZTdHJpbmdzKCkpe3ZhciBuPXQrYTtkW2Urcj4+Ml09bjthKz0oKGUsdCxhLHIpPT57aWYoIShyPjApKXJldHVybiAwO2Zvcih2YXIgaT1hLG49YStyLTEscz0wO3M8ZS5sZW5ndGg7KytzKXt2YXIgbz1lLmNoYXJDb2RlQXQocyk7bz49NTUyOTYmJm88PTU3MzQzJiYobz02NTUzNisoKDEwMjMmbyk8PDEwKXwxMDIzJmUuY2hhckNvZGVBdCgrK3MpKTtpZihvPD0xMjcpe2lmKGE+PW4pYnJlYWs7dFthKytdPW99ZWxzZSBpZihvPD0yMDQ3KXtpZihhKzE+PW4pYnJlYWs7dFthKytdPTE5MnxvPj42O3RbYSsrXT0xMjh8NjMmb31lbHNlIGlmKG88PTY1NTM1KXtpZihhKzI+PW4pYnJlYWs7dFthKytdPTIyNHxvPj4xMjt0W2ErK109MTI4fG8+PjYmNjM7dFthKytdPTEyOHw2MyZvfWVsc2V7aWYoYSszPj1uKWJyZWFrO3RbYSsrXT0yNDB8bz4+MTg7dFthKytdPTEyOHxvPj4xMiY2Mzt0W2ErK109MTI4fG8+PjYmNjM7dFthKytdPTEyOHw2MyZvfX10W2FdPTA7cmV0dXJuIGEtaX0pKGksaCxuLDEvMCkrMTtyKz00fXJldHVybiAwfSxxOihlLHQpPT57dmFyIGE9Z2V0RW52U3RyaW5ncygpO2RbZT4+Ml09YS5sZW5ndGg7dmFyIHI9MDtmb3IodmFyIGkgb2YgYSlyKz1sZW5ndGhCeXRlc1VURjgoaSkrMTtkW3Q+PjJdPXI7cmV0dXJuIDB9LGI6ZT0+NTIsbzpmdW5jdGlvbiBfZmRfc2VlayhlLHQsYSxyKXt0PShpPXQpPC05MDA3MTk5MjU0NzQwOTkyfHxpPjkwMDcxOTkyNTQ3NDA5OTI/TmFOOk51bWJlcihpKTt2YXIgaTtyZXR1cm4gNzB9LGM6KGUsdCxhLHIpPT57Zm9yKHZhciBpPTAsbj0wO248YTtuKyspe3ZhciBzPWRbdD4+Ml0sbz1kW3QrND4+Ml07dCs9ODtmb3IodmFyIGM9MDtjPG87YysrKXByaW50Q2hhcihlLGhbcytjXSk7aSs9b31kW3I+PjJdPWk7cmV0dXJuIDB9LHI6ZnVuY3Rpb24gX2dyYXlfdG9fcmdiYShlLHQpe2U+Pj0yO2NvbnN0IGE9ci5pbWFnZURhdGE9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQqdCksaT11LnN1YmFycmF5KGUsZSt0KTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXthWzQqZV09YVs0KmUrMV09YVs0KmUrMl09aVtlXTthWzQqZSszXT0yNTV9fSxpOmZ1bmN0aW9uIF9ncmF5YV90b19yZ2JhKGUsdCxhKXtlPj49Mjt0Pj49Mjtjb25zdCBpPXIuaW1hZ2VEYXRhPW5ldyBVaW50OENsYW1wZWRBcnJheSg0KmEpLG49dS5zdWJhcnJheShlLGUrYSkscz11LnN1YmFycmF5KHQsdCthKTtmb3IobGV0IGU9MDtlPGE7ZSsrKXtpWzQqZV09aVs0KmUrMV09aVs0KmUrMl09bltlXTtpWzQqZSszXT1zW2VdfX0sZDpmdW5jdGlvbiBfanNQcmludFdhcm5pbmcoZSl7Y29uc3QgdD1VVEY4VG9TdHJpbmcoZSk7KHIud2Fybnx8Y29uc29sZS53YXJuKShgT3BlbkpQRUc6ICR7dH1gKX0sajpfcHJvY19leGl0LGg6ZnVuY3Rpb24gX3JnYl90b19yZ2JhKGUsdCxhLGkpe2U+Pj0yO3Q+Pj0yO2E+Pj0yO2NvbnN0IG49ci5pbWFnZURhdGE9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQqaSkscz11LnN1YmFycmF5KGUsZStpKSxvPXUuc3ViYXJyYXkodCx0K2kpLGM9dS5zdWJhcnJheShhLGEraSk7Zm9yKGxldCBlPTA7ZTxpO2UrKyl7bls0KmVdPXNbZV07bls0KmUrMV09b1tlXTtuWzQqZSsyXT1jW2VdO25bNCplKzNdPTI1NX19LGE6ZnVuY3Rpb24gX3N0b3JlRXJyb3JNZXNzYWdlKGUpe2NvbnN0IHQ9VVRGOFRvU3RyaW5nKGUpO3IuZXJyb3JNZXNzYWdlcz9yLmVycm9yTWVzc2FnZXMrPSJcbiIrdDpyLmVycm9yTWVzc2FnZXM9dH19LE89YXdhaXQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlV2FzbSgpe2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShlLHQpe089ZS5leHBvcnRzO289Ty5zO3VwZGF0ZU1lbW9yeVZpZXdzKCk7IWZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koZSl7bS0tO3IubW9uaXRvclJ1bkRlcGVuZGVuY2llcz8uKG0pO2lmKDA9PW0mJmIpe3ZhciB0PWI7Yj1udWxsO3QoKX19KCk7cmV0dXJuIE99IWZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koZSl7bSsrO3IubW9uaXRvclJ1bkRlcGVuZGVuY2llcz8uKG0pfSgpO3ZhciBlPWZ1bmN0aW9uIGdldFdhc21JbXBvcnRzKCl7cmV0dXJue2E6VH19KCk7cmV0dXJuIG5ldyBQcm9taXNlKCgodCxhKT0+e3IuaW5zdGFudGlhdGVXYXNtKGUsKChlLGEpPT57dChyZWNlaXZlSW5zdGFuY2UoZSkpfSkpfSkpfSgpLE09KE8udCxyLl9tYWxsb2M9Ty51LHIuX2ZyZWU9Ty52LHIuX2pwMl9kZWNvZGU9Ty53LE8ueCk7IWZ1bmN0aW9uIHByZUluaXQoKXtpZihyLnByZUluaXQpeyJmdW5jdGlvbiI9PXR5cGVvZiByLnByZUluaXQmJihyLnByZUluaXQ9W3IucHJlSW5pdF0pO2Zvcig7ci5wcmVJbml0Lmxlbmd0aD4wOylyLnByZUluaXQuc2hpZnQoKSgpfX0oKTshZnVuY3Rpb24gcnVuKCl7aWYobT4wKWI9cnVuO2Vsc2V7IWZ1bmN0aW9uIHByZVJ1bigpe2lmKHIucHJlUnVuKXsiZnVuY3Rpb24iPT10eXBlb2Ygci5wcmVSdW4mJihyLnByZVJ1bj1bci5wcmVSdW5dKTtmb3IoO3IucHJlUnVuLmxlbmd0aDspYWRkT25QcmVSdW4oci5wcmVSdW4uc2hpZnQoKSl9Y2FsbFJ1bnRpbWVDYWxsYmFja3Modyl9KCk7aWYobT4wKWI9cnVuO2Vsc2UgaWYoci5zZXRTdGF0dXMpe3Iuc2V0U3RhdHVzKCJSdW5uaW5nLi4uIik7c2V0VGltZW91dCgoKCk9PntzZXRUaW1lb3V0KCgoKT0+ci5zZXRTdGF0dXMoIiIpKSwxKTtkb1J1bigpfSksMSl9ZWxzZSBkb1J1bigpfWZ1bmN0aW9uIGRvUnVuKCl7ci5jYWxsZWRSdW49ITA7aWYoIXApeyFmdW5jdGlvbiBpbml0UnVudGltZSgpe08udCgpfSgpO3Qocik7ci5vblJ1bnRpbWVJbml0aWFsaXplZD8uKCk7IWZ1bmN0aW9uIHBvc3RSdW4oKXtpZihyLnBvc3RSdW4peyJmdW5jdGlvbiI9PXR5cGVvZiByLnBvc3RSdW4mJihyLnBvc3RSdW49W3IucG9zdFJ1bl0pO2Zvcig7ci5wb3N0UnVuLmxlbmd0aDspYWRkT25Qb3N0UnVuKHIucG9zdFJ1bi5zaGlmdCgpKX1jYWxsUnVudGltZUNhbGxiYWNrcyh5KX0oKX19fSgpO3JldHVybiBpfTtjb25zdCBNYT1PcGVuSlBFRztjbGFzcyBKcHhFcnJvciBleHRlbmRzIEp0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIkpweEVycm9yIil9fWNsYXNzIEpweEltYWdle3N0YXRpYyNFPW51bGw7c3RhdGljI1A9bnVsbDtzdGF0aWMjTD1udWxsO3N0YXRpYyN2PSEwO3N0YXRpYyNqPSEwO3N0YXRpYyNGPW51bGw7c3RhdGljIHNldE9wdGlvbnMoe2hhbmRsZXI6ZSx1c2VXYXNtOnQsdXNlV29ya2VyRmV0Y2g6YSx3YXNtVXJsOnJ9KXt0aGlzLiN2PXQ7dGhpcy4jaj1hO3RoaXMuI0Y9cjthfHwodGhpcy4jUD1lKX1zdGF0aWMgYXN5bmMjXyhlKXtjb25zdCB0PWAke3RoaXMuI0Z9b3BlbmpwZWdfbm93YXNtX2ZhbGxiYWNrLmpzYDtsZXQgYT1udWxsO3RyeXthPShhd2FpdCBpbXBvcnQoCi8qd2VicGFja0lnbm9yZTogdHJ1ZSovCi8qQHZpdGUtaWdub3JlKi8KdCkpLmRlZmF1bHQoKX1jYXRjaChlKXt3YXJuKGBKcHhJbWFnZSNnZXRKc01vZHVsZTogJHtlfWApfWUoYSl9c3RhdGljIGFzeW5jI1UoZSx0LGEpe2NvbnN0IHI9Im9wZW5qcGVnLndhc20iO3RyeXt0aGlzLiNFfHwodGhpcy4jaj90aGlzLiNFPWF3YWl0IGZldGNoQmluYXJ5RGF0YShgJHt0aGlzLiNGfSR7cn1gKTp0aGlzLiNFPWF3YWl0IHRoaXMuI1Auc2VuZFdpdGhQcm9taXNlKCJGZXRjaEJpbmFyeURhdGEiLHt0eXBlOiJ3YXNtRmFjdG9yeSIsZmlsZW5hbWU6cn0pKTtyZXR1cm4gYSgoYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodGhpcy4jRSx0KSkuaW5zdGFuY2UpfWNhdGNoKHQpe3dhcm4oYEpweEltYWdlI2luc3RhbnRpYXRlV2FzbTogJHt0fWApO3RoaXMuI18oZSk7cmV0dXJuIG51bGx9ZmluYWxseXt0aGlzLiNQPW51bGx9fXN0YXRpYyBhc3luYyBkZWNvZGUoZSx7bnVtQ29tcG9uZW50czp0PTQsaXNJbmRleGVkQ29sb3JtYXA6YT0hMSxzbWFza0luRGF0YTpyPSExLHJlZHVjZVBvd2VyOmk9MH09e30pe2lmKCF0aGlzLiNMKXtjb25zdHtwcm9taXNlOmUscmVzb2x2ZTp0fT1Qcm9taXNlLndpdGhSZXNvbHZlcnMoKSxhPVtlXTt0aGlzLiN2P2EucHVzaChNYSh7d2FybixpbnN0YW50aWF0ZVdhc206dGhpcy4jVS5iaW5kKHRoaXMsdCl9KSk6dGhpcy4jXyh0KTt0aGlzLiNMPVByb21pc2UucmFjZShhKX1jb25zdCBuPWF3YWl0IHRoaXMuI0w7aWYoIW4pdGhyb3cgbmV3IEpweEVycm9yKCJPcGVuSlBFRyBmYWlsZWQgdG8gaW5pdGlhbGl6ZSIpO2xldCBzO3RyeXtjb25zdCBvPWUubGVuZ3RoO3M9bi5fbWFsbG9jKG8pO24ud3JpdGVBcnJheVRvTWVtb3J5KGUscyk7aWYobi5fanAyX2RlY29kZShzLG8sdD4wP3Q6MCwhIWEsISFyLGkpKXtjb25zdHtlcnJvck1lc3NhZ2VzOmV9PW47aWYoZSl7ZGVsZXRlIG4uZXJyb3JNZXNzYWdlczt0aHJvdyBuZXcgSnB4RXJyb3IoZSl9dGhyb3cgbmV3IEpweEVycm9yKCJVbmtub3duIGVycm9yIil9Y29uc3R7aW1hZ2VEYXRhOmN9PW47bi5pbWFnZURhdGE9bnVsbDtyZXR1cm4gY31maW5hbGx5e3MmJm4uX2ZyZWUocyl9fXN0YXRpYyBjbGVhbnVwKCl7dGhpcy4jTD1udWxsfXN0YXRpYyBwYXJzZUltYWdlUHJvcGVydGllcyhlKXtsZXQgdD1lLmdldEJ5dGUoKTtmb3IoO3Q+PTA7KXtjb25zdCBhPXQ7dD1lLmdldEJ5dGUoKTtpZig2NTM2MT09PShhPDw4fHQpKXtlLnNraXAoNCk7Y29uc3QgdD1lLmdldEludDMyKCk+Pj4wLGE9ZS5nZXRJbnQzMigpPj4+MCxyPWUuZ2V0SW50MzIoKT4+PjAsaT1lLmdldEludDMyKCk+Pj4wO2Uuc2tpcCgxNik7cmV0dXJue3dpZHRoOnQtcixoZWlnaHQ6YS1pLGJpdHNQZXJDb21wb25lbnQ6OCxjb21wb25lbnRzQ291bnQ6ZS5nZXRVaW50MTYoKX19fXRocm93IG5ldyBKcHhFcnJvcigiTm8gc2l6ZSBtYXJrZXIgZm91bmQgaW4gSlBYIHN0cmVhbSIpfX1mdW5jdGlvbiBhZGRTdGF0ZShlLHQsYSxyLGkpe2xldCBuPWU7Zm9yKGxldCBlPTAsYT10Lmxlbmd0aC0xO2U8YTtlKyspe2NvbnN0IGE9dFtlXTtuPW5bYV18fD1bXX1uW3QuYXQoLTEpXT17Y2hlY2tGbjphLGl0ZXJhdGVGbjpyLHByb2Nlc3NGbjppfX1jb25zdCBEYT1bXTthZGRTdGF0ZShEYSxbcGUsYmUsTnQsbWVdLG51bGwsKGZ1bmN0aW9uIGl0ZXJhdGVJbmxpbmVJbWFnZUdyb3VwKGUsdCl7Y29uc3QgYT1lLmZuQXJyYXkscj0odC0oZS5pQ3Vyci0zKSklNDtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiBhW3RdPT09cGU7Y2FzZSAxOnJldHVybiBhW3RdPT09YmU7Y2FzZSAyOnJldHVybiBhW3RdPT09TnQ7Y2FzZSAzOnJldHVybiBhW3RdPT09bWV9dGhyb3cgbmV3IEVycm9yKGBpdGVyYXRlSW5saW5lSW1hZ2VHcm91cCAtIGludmFsaWQgcG9zOiAke3J9YCl9KSwoZnVuY3Rpb24gZm91bmRJbmxpbmVJbWFnZUdyb3VwKGUsdCl7Y29uc3QgYT1lLmZuQXJyYXkscj1lLmFyZ3NBcnJheSxpPWUuaUN1cnIsbj1pLTMscz1pLTIsbz1pLTEsYz1NYXRoLm1pbihNYXRoLmZsb29yKCh0LW4pLzQpLDIwMCk7aWYoYzwxMClyZXR1cm4gdC0odC1uKSU0O2xldCBsPTA7Y29uc3QgaD1bXTtsZXQgdT0wLGQ9MSxmPTE7Zm9yKGxldCBlPTA7ZTxjO2UrKyl7Y29uc3QgdD1yW3MrKGU8PDIpXSxhPXJbbysoZTw8MildWzBdO2lmKGQrYS53aWR0aD4xZTMpe2w9TWF0aC5tYXgobCxkKTtmKz11KzI7ZD0wO3U9MH1oLnB1c2goe3RyYW5zZm9ybTp0LHg6ZCx5OmYsdzphLndpZHRoLGg6YS5oZWlnaHR9KTtkKz1hLndpZHRoKzI7dT1NYXRoLm1heCh1LGEuaGVpZ2h0KX1jb25zdCBnPU1hdGgubWF4KGwsZCkrMSxwPWYrdSsxLG09bmV3IFVpbnQ4QXJyYXkoZypwKjQpLGI9Zzw8Mjtmb3IobGV0IGU9MDtlPGM7ZSsrKXtjb25zdCB0PXJbbysoZTw8MildWzBdLmRhdGEsYT1oW2VdLnc8PDI7bGV0IGk9MCxuPWhbZV0ueCtoW2VdLnkqZzw8MjttLnNldCh0LnN1YmFycmF5KDAsYSksbi1iKTtmb3IobGV0IHI9MCxzPWhbZV0uaDtyPHM7cisrKXttLnNldCh0LnN1YmFycmF5KGksaSthKSxuKTtpKz1hO24rPWJ9bS5zZXQodC5zdWJhcnJheShpLWEsaSksbik7Zm9yKDtuPj0wOyl7dFtuLTRdPXRbbl07dFtuLTNdPXRbbisxXTt0W24tMl09dFtuKzJdO3Rbbi0xXT10W24rM107dFtuK2FdPXRbbithLTRdO3RbbithKzFdPXRbbithLTNdO3RbbithKzJdPXRbbithLTJdO3RbbithKzNdPXRbbithLTFdO24tPWJ9fWNvbnN0IHk9e3dpZHRoOmcsaGVpZ2h0OnB9O2lmKGUuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpe2NvbnN0IGU9bmV3IE9mZnNjcmVlbkNhbnZhcyhnLHApO2UuZ2V0Q29udGV4dCgiMmQiKS5wdXRJbWFnZURhdGEobmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkobS5idWZmZXIpLGcscCksMCwwKTt5LmJpdG1hcD1lLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO3kuZGF0YT1udWxsfWVsc2V7eS5raW5kPXY7eS5kYXRhPW19YS5zcGxpY2Uobiw0KmMsRXQpO3Iuc3BsaWNlKG4sNCpjLFt5LGhdKTtyZXR1cm4gbisxfSkpO2FkZFN0YXRlKERhLFtwZSxiZSxEdCxtZV0sbnVsbCwoZnVuY3Rpb24gaXRlcmF0ZUltYWdlTWFza0dyb3VwKGUsdCl7Y29uc3QgYT1lLmZuQXJyYXkscj0odC0oZS5pQ3Vyci0zKSklNDtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiBhW3RdPT09cGU7Y2FzZSAxOnJldHVybiBhW3RdPT09YmU7Y2FzZSAyOnJldHVybiBhW3RdPT09RHQ7Y2FzZSAzOnJldHVybiBhW3RdPT09bWV9dGhyb3cgbmV3IEVycm9yKGBpdGVyYXRlSW1hZ2VNYXNrR3JvdXAgLSBpbnZhbGlkIHBvczogJHtyfWApfSksKGZ1bmN0aW9uIGZvdW5kSW1hZ2VNYXNrR3JvdXAoZSx0KXtjb25zdCBhPWUuZm5BcnJheSxyPWUuYXJnc0FycmF5LGk9ZS5pQ3VycixuPWktMyxzPWktMixvPWktMTtsZXQgYz1NYXRoLmZsb29yKCh0LW4pLzQpO2lmKGM8MTApcmV0dXJuIHQtKHQtbiklNDtsZXQgbCxoLHU9ITE7Y29uc3QgZD1yW29dWzBdLGY9cltzXVswXSxnPXJbc11bMV0scD1yW3NdWzJdLG09cltzXVszXTtpZihnPT09cCl7dT0hMDtsPXMrNDtsZXQgZT1vKzQ7Zm9yKGxldCB0PTE7dDxjO3QrKyxsKz00LGUrPTQpe2g9cltsXTtpZihyW2VdWzBdIT09ZHx8aFswXSE9PWZ8fGhbMV0hPT1nfHxoWzJdIT09cHx8aFszXSE9PW0pe3Q8MTA/dT0hMTpjPXQ7YnJlYWt9fX1pZih1KXtjPU1hdGgubWluKGMsMWUzKTtjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkoMipjKTtsPXM7Zm9yKGxldCB0PTA7dDxjO3QrKyxsKz00KXtoPXJbbF07ZVt0PDwxXT1oWzRdO2VbMSsodDw8MSldPWhbNV19YS5zcGxpY2Uobiw0KmMsTHQpO3Iuc3BsaWNlKG4sNCpjLFtkLGYsZyxwLG0sZV0pfWVsc2V7Yz1NYXRoLm1pbihjLDEwMCk7Y29uc3QgZT1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKXtoPXJbcysodDw8MildO2NvbnN0IGE9cltvKyh0PDwyKV1bMF07ZS5wdXNoKHtkYXRhOmEuZGF0YSx3aWR0aDphLndpZHRoLGhlaWdodDphLmhlaWdodCxpbnRlcnBvbGF0ZTphLmludGVycG9sYXRlLGNvdW50OmEuY291bnQsdHJhbnNmb3JtOmh9KX1hLnNwbGljZShuLDQqYyxCdCk7ci5zcGxpY2Uobiw0KmMsW2VdKX1yZXR1cm4gbisxfSkpO2FkZFN0YXRlKERhLFtwZSxiZSxSdCxtZV0sKGZ1bmN0aW9uKGUpe2NvbnN0IHQ9ZS5hcmdzQXJyYXksYT1lLmlDdXJyLTI7cmV0dXJuIDA9PT10W2FdWzFdJiYwPT09dFthXVsyXX0pLChmdW5jdGlvbiBpdGVyYXRlSW1hZ2VHcm91cChlLHQpe2NvbnN0IGE9ZS5mbkFycmF5LHI9ZS5hcmdzQXJyYXksaT0odC0oZS5pQ3Vyci0zKSklNDtzd2l0Y2goaSl7Y2FzZSAwOnJldHVybiBhW3RdPT09cGU7Y2FzZSAxOmlmKGFbdF0hPT1iZSlyZXR1cm4hMTtjb25zdCBpPWUuaUN1cnItMixuPXJbaV1bMF0scz1yW2ldWzNdO3JldHVybiByW3RdWzBdPT09biYmMD09PXJbdF1bMV0mJjA9PT1yW3RdWzJdJiZyW3RdWzNdPT09cztjYXNlIDI6aWYoYVt0XSE9PVJ0KXJldHVybiExO2NvbnN0IG89cltlLmlDdXJyLTFdWzBdO3JldHVybiByW3RdWzBdPT09bztjYXNlIDM6cmV0dXJuIGFbdF09PT1tZX10aHJvdyBuZXcgRXJyb3IoYGl0ZXJhdGVJbWFnZUdyb3VwIC0gaW52YWxpZCBwb3M6ICR7aX1gKX0pLChmdW5jdGlvbihlLHQpe2NvbnN0IGE9ZS5mbkFycmF5LHI9ZS5hcmdzQXJyYXksaT1lLmlDdXJyLG49aS0zLHM9aS0yLG89cltpLTFdWzBdLGM9cltzXVswXSxsPXJbc11bM10saD1NYXRoLm1pbihNYXRoLmZsb29yKCh0LW4pLzQpLDFlMyk7aWYoaDwzKXJldHVybiB0LSh0LW4pJTQ7Y29uc3QgdT1uZXcgRmxvYXQzMkFycmF5KDIqaCk7bGV0IGQ9cztmb3IobGV0IGU9MDtlPGg7ZSsrLGQrPTQpe2NvbnN0IHQ9cltkXTt1W2U8PDFdPXRbNF07dVsxKyhlPDwxKV09dFs1XX1jb25zdCBmPVtvLGMsbCx1XTthLnNwbGljZShuLDQqaCxQdCk7ci5zcGxpY2Uobiw0KmgsZik7cmV0dXJuIG4rMX0pKTthZGRTdGF0ZShEYSxbUGUscWUsR2UsS2UsTGVdLG51bGwsKGZ1bmN0aW9uIGl0ZXJhdGVTaG93VGV4dEdyb3VwKGUsdCl7Y29uc3QgYT1lLmZuQXJyYXkscj1lLmFyZ3NBcnJheSxpPSh0LShlLmlDdXJyLTQpKSU1O3N3aXRjaChpKXtjYXNlIDA6cmV0dXJuIGFbdF09PT1QZTtjYXNlIDE6cmV0dXJuIGFbdF09PT1xZTtjYXNlIDI6cmV0dXJuIGFbdF09PT1HZTtjYXNlIDM6aWYoYVt0XSE9PUtlKXJldHVybiExO2NvbnN0IGk9ZS5pQ3Vyci0zLG49cltpXVswXSxzPXJbaV1bMV07cmV0dXJuIHJbdF1bMF09PT1uJiZyW3RdWzFdPT09cztjYXNlIDQ6cmV0dXJuIGFbdF09PT1MZX10aHJvdyBuZXcgRXJyb3IoYGl0ZXJhdGVTaG93VGV4dEdyb3VwIC0gaW52YWxpZCBwb3M6ICR7aX1gKX0pLChmdW5jdGlvbihlLHQpe2NvbnN0IGE9ZS5mbkFycmF5LHI9ZS5hcmdzQXJyYXksaT1lLmlDdXJyLG49aS00LHM9aS0zLG89aS0yLGM9aS0xLGw9aSxoPXJbc11bMF0sdT1yW3NdWzFdO2xldCBkPU1hdGgubWluKE1hdGguZmxvb3IoKHQtbikvNSksMWUzKTtpZihkPDMpcmV0dXJuIHQtKHQtbiklNTtsZXQgZj1uO2lmKG4+PTQmJmFbbi00XT09PWFbc10mJmFbbi0zXT09PWFbb10mJmFbbi0yXT09PWFbY10mJmFbbi0xXT09PWFbbF0mJnJbbi00XVswXT09PWgmJnJbbi00XVsxXT09PXUpe2QrKztmLT01fWxldCBnPWYrNDtmb3IobGV0IGU9MTtlPGQ7ZSsrKXthLnNwbGljZShnLDMpO3Iuc3BsaWNlKGcsMyk7Zys9Mn1yZXR1cm4gZysxfSkpO2FkZFN0YXRlKERhLFtwZSxiZSxfdCxtZV0sKGU9Pntjb25zdCB0PWUuYXJnc0FycmF5LGE9dFtlLmlDdXJyLTFdWzBdO2lmKGEhPT12ZSYmYSE9PUZlJiZhIT09T2UmJmEhPT1NZSYmYSE9PURlJiZhIT09QmUpcmV0dXJuITA7Y29uc3Qgcj10W2UuaUN1cnItMl07cmV0dXJuIDE9PT1yWzBdJiYwPT09clsxXSYmMD09PXJbMl0mJjE9PT1yWzNdfSksKCgpPT4hMSksKChlLHQpPT57Y29uc3R7Zm5BcnJheTphLGFyZ3NBcnJheTpyfT1lLGk9ZS5pQ3VycixuPWktMyxzPWktMixvPXJbaS0xXSxjPXJbc10sWyxbbF0saF09bztpZihoKXtVdGlsLnNjYWxlTWluTWF4KGMsaCk7Zm9yKGxldCBlPTAsdD1sLmxlbmd0aDtlPHQ7KXN3aXRjaChsW2UrK10pe2Nhc2UgSHQ6Y2FzZSBXdDpVdGlsLmFwcGx5VHJhbnNmb3JtKGwsYyxlKTtlKz0yO2JyZWFrO2Nhc2UgenQ6VXRpbC5hcHBseVRyYW5zZm9ybVRvQmV6aWVyKGwsYyxlKTtlKz02fX1hLnNwbGljZShuLDQsX3QpO3Iuc3BsaWNlKG4sNCxvKTtyZXR1cm4gbisxfSkpO2NsYXNzIE51bGxPcHRpbWl6ZXJ7Y29uc3RydWN0b3IoZSl7dGhpcy5xdWV1ZT1lfV9vcHRpbWl6ZSgpe31wdXNoKGUsdCl7dGhpcy5xdWV1ZS5mbkFycmF5LnB1c2goZSk7dGhpcy5xdWV1ZS5hcmdzQXJyYXkucHVzaCh0KTt0aGlzLl9vcHRpbWl6ZSgpfWZsdXNoKCl7fXJlc2V0KCl7fX1jbGFzcyBRdWV1ZU9wdGltaXplciBleHRlbmRzIE51bGxPcHRpbWl6ZXJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5zdGF0ZT1udWxsO3RoaXMuY29udGV4dD17aUN1cnI6MCxmbkFycmF5OmUuZm5BcnJheSxhcmdzQXJyYXk6ZS5hcmdzQXJyYXksaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ6T3BlcmF0b3JMaXN0LmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkfTt0aGlzLm1hdGNoPW51bGw7dGhpcy5sYXN0UHJvY2Vzc2VkPTB9X29wdGltaXplKCl7Y29uc3QgZT10aGlzLnF1ZXVlLmZuQXJyYXk7bGV0IHQ9dGhpcy5sYXN0UHJvY2Vzc2VkLGE9ZS5sZW5ndGgscj10aGlzLnN0YXRlLGk9dGhpcy5tYXRjaDtpZighciYmIWkmJnQrMT09PWEmJiFEYVtlW3RdXSl7dGhpcy5sYXN0UHJvY2Vzc2VkPWE7cmV0dXJufWNvbnN0IG49dGhpcy5jb250ZXh0O2Zvcig7dDxhOyl7aWYoaSl7aWYoKDAsaS5pdGVyYXRlRm4pKG4sdCkpe3QrKztjb250aW51ZX10PSgwLGkucHJvY2Vzc0ZuKShuLHQrMSk7YT1lLmxlbmd0aDtpPW51bGw7cj1udWxsO2lmKHQ+PWEpYnJlYWt9cj0ocnx8RGEpW2VbdF1dO2lmKHImJiFBcnJheS5pc0FycmF5KHIpKXtuLmlDdXJyPXQ7dCsrO2lmKCFyLmNoZWNrRm58fCgwLHIuY2hlY2tGbikobikpe2k9cjtyPW51bGx9ZWxzZSByPW51bGx9ZWxzZSB0Kyt9dGhpcy5zdGF0ZT1yO3RoaXMubWF0Y2g9aTt0aGlzLmxhc3RQcm9jZXNzZWQ9dH1mbHVzaCgpe2Zvcig7dGhpcy5tYXRjaDspe2NvbnN0IGU9dGhpcy5xdWV1ZS5mbkFycmF5Lmxlbmd0aDt0aGlzLmxhc3RQcm9jZXNzZWQ9KDAsdGhpcy5tYXRjaC5wcm9jZXNzRm4pKHRoaXMuY29udGV4dCxlKTt0aGlzLm1hdGNoPW51bGw7dGhpcy5zdGF0ZT1udWxsO3RoaXMuX29wdGltaXplKCl9fXJlc2V0KCl7dGhpcy5zdGF0ZT1udWxsO3RoaXMubWF0Y2g9bnVsbDt0aGlzLmxhc3RQcm9jZXNzZWQ9MH19Y2xhc3MgT3BlcmF0b3JMaXN0e3N0YXRpYyBDSFVOS19TSVpFPTFlMztzdGF0aWMgQ0hVTktfU0laRV9BQk9VVD10aGlzLkNIVU5LX1NJWkUtNTtzdGF0aWMgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ9ITE7Y29uc3RydWN0b3IoZT0wLHQpe3RoaXMuX3N0cmVhbVNpbms9dDt0aGlzLmZuQXJyYXk9W107dGhpcy5hcmdzQXJyYXk9W107dGhpcy5vcHRpbWl6ZXI9IXR8fGUmZD9uZXcgTnVsbE9wdGltaXplcih0aGlzKTpuZXcgUXVldWVPcHRpbWl6ZXIodGhpcyk7dGhpcy5kZXBlbmRlbmNpZXM9bmV3IFNldDt0aGlzLl90b3RhbExlbmd0aD0wO3RoaXMud2VpZ2h0PTA7dGhpcy5fcmVzb2x2ZWQ9dD9udWxsOlByb21pc2UucmVzb2x2ZSgpfXN0YXRpYyBzZXRPcHRpb25zKHtpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDplfSl7dGhpcy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZD1lfWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5hcmdzQXJyYXkubGVuZ3RofWdldCByZWFkeSgpe3JldHVybiB0aGlzLl9yZXNvbHZlZHx8dGhpcy5fc3RyZWFtU2luay5yZWFkeX1nZXQgdG90YWxMZW5ndGgoKXtyZXR1cm4gdGhpcy5fdG90YWxMZW5ndGgrdGhpcy5sZW5ndGh9YWRkT3AoZSx0KXt0aGlzLm9wdGltaXplci5wdXNoKGUsdCk7dGhpcy53ZWlnaHQrKzt0aGlzLl9zdHJlYW1TaW5rJiYodGhpcy53ZWlnaHQ+PU9wZXJhdG9yTGlzdC5DSFVOS19TSVpFfHx0aGlzLndlaWdodD49T3BlcmF0b3JMaXN0LkNIVU5LX1NJWkVfQUJPVVQmJihlPT09bWV8fGU9PT1MZSkpJiZ0aGlzLmZsdXNoKCl9YWRkSW1hZ2VPcHMoZSx0LGEscj0hMSl7aWYocil7dGhpcy5hZGRPcChwZSk7dGhpcy5hZGRPcChnZSxbW1siU01hc2siLCExXV1dKX12b2lkIDAhPT1hJiZ0aGlzLmFkZE9wKFN0LFsiT0MiLGFdKTt0aGlzLmFkZE9wKGUsdCk7dm9pZCAwIT09YSYmdGhpcy5hZGRPcChBdCxbXSk7ciYmdGhpcy5hZGRPcChtZSl9YWRkRGVwZW5kZW5jeShlKXtpZighdGhpcy5kZXBlbmRlbmNpZXMuaGFzKGUpKXt0aGlzLmRlcGVuZGVuY2llcy5hZGQoZSk7dGhpcy5hZGRPcChzZSxbZV0pfX1hZGREZXBlbmRlbmNpZXMoZSl7Zm9yKGNvbnN0IHQgb2YgZSl0aGlzLmFkZERlcGVuZGVuY3kodCl9YWRkT3BMaXN0KGUpe2lmKGUgaW5zdGFuY2VvZiBPcGVyYXRvckxpc3Qpe2Zvcihjb25zdCB0IG9mIGUuZGVwZW5kZW5jaWVzKXRoaXMuZGVwZW5kZW5jaWVzLmFkZCh0KTtmb3IobGV0IHQ9MCxhPWUubGVuZ3RoO3Q8YTt0KyspdGhpcy5hZGRPcChlLmZuQXJyYXlbdF0sZS5hcmdzQXJyYXlbdF0pfWVsc2Ugd2FybignYWRkT3BMaXN0IC0gaWdub3JpbmcgaW52YWxpZCAib3BMaXN0IiBwYXJhbWV0ZXIuJyl9Z2V0SVIoKXtyZXR1cm57Zm5BcnJheTp0aGlzLmZuQXJyYXksYXJnc0FycmF5OnRoaXMuYXJnc0FycmF5LGxlbmd0aDp0aGlzLmxlbmd0aH19Z2V0IF90cmFuc2ZlcnMoKXtjb25zdCBlPVtdLHtmbkFycmF5OnQsYXJnc0FycmF5OmEsbGVuZ3RoOnJ9PXRoaXM7Zm9yKGxldCBpPTA7aTxyO2krKylzd2l0Y2godFtpXSl7Y2FzZSBOdDpjYXNlIEV0OmNhc2UgRHQ6e2NvbnN0e2JpdG1hcDp0LGRhdGE6cn09YVtpXVswXTsodHx8cj8uYnVmZmVyKSYmZS5wdXNoKHR8fHIuYnVmZmVyKTticmVha31jYXNlIF90Ontjb25zdFssW3RdLHJdPWFbaV07dCYmZS5wdXNoKHQuYnVmZmVyLHIuYnVmZmVyKTticmVha31jYXNlIHZ0OmNvbnN0W3Qscl09YVtpXTt0JiZlLnB1c2godC5idWZmZXIpO3ImJmUucHVzaChyLmJ1ZmZlcik7YnJlYWs7Y2FzZSBHZTplLnB1c2goYVtpXVswXS5idWZmZXIpfXJldHVybiBlfWZsdXNoKGU9ITEsdD1udWxsKXt0aGlzLm9wdGltaXplci5mbHVzaCgpO2NvbnN0IGE9dGhpcy5sZW5ndGg7dGhpcy5fdG90YWxMZW5ndGgrPWE7dGhpcy5fc3RyZWFtU2luay5lbnF1ZXVlKHtmbkFycmF5OnRoaXMuZm5BcnJheSxhcmdzQXJyYXk6dGhpcy5hcmdzQXJyYXksbGFzdENodW5rOmUsc2VwYXJhdGVBbm5vdHM6dCxsZW5ndGg6YX0sMSx0aGlzLl90cmFuc2ZlcnMpO3RoaXMuZGVwZW5kZW5jaWVzLmNsZWFyKCk7dGhpcy5mbkFycmF5Lmxlbmd0aD0wO3RoaXMuYXJnc0FycmF5Lmxlbmd0aD0wO3RoaXMud2VpZ2h0PTA7dGhpcy5vcHRpbWl6ZXIucmVzZXQoKX19ZnVuY3Rpb24gaGV4VG9JbnQoZSx0KXtsZXQgYT0wO2ZvcihsZXQgcj0wO3I8PXQ7cisrKWE9YTw8OHxlW3JdO3JldHVybiBhPj4+MH1mdW5jdGlvbiBoZXhUb1N0cihlLHQpe3JldHVybiAxPT09dD9TdHJpbmcuZnJvbUNoYXJDb2RlKGVbMF0sZVsxXSk6Mz09PXQ/U3RyaW5nLmZyb21DaGFyQ29kZShlWzBdLGVbMV0sZVsyXSxlWzNdKTpTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmUuc3ViYXJyYXkoMCx0KzEpKX1mdW5jdGlvbiBhZGRIZXgoZSx0LGEpe2xldCByPTA7Zm9yKGxldCBpPWE7aT49MDtpLS0pe3IrPWVbaV0rdFtpXTtlW2ldPTI1NSZyO3I+Pj04fX1mdW5jdGlvbiBpbmNIZXgoZSx0KXtsZXQgYT0xO2ZvcihsZXQgcj10O3I+PTAmJmE+MDtyLS0pe2ErPWVbcl07ZVtyXT0yNTUmYTthPj49OH19Y29uc3QgQmE9MTY7Y2xhc3MgQmluYXJ5Q01hcFN0cmVhbXtjb25zdHJ1Y3RvcihlKXt0aGlzLmJ1ZmZlcj1lO3RoaXMucG9zPTA7dGhpcy5lbmQ9ZS5sZW5ndGg7dGhpcy50bXBCdWY9bmV3IFVpbnQ4QXJyYXkoMTkpfXJlYWRCeXRlKCl7cmV0dXJuIHRoaXMucG9zPj10aGlzLmVuZD8tMTp0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXX1yZWFkTnVtYmVyKCl7bGV0IGUsdD0wO2Rve2NvbnN0IGE9dGhpcy5yZWFkQnl0ZSgpO2lmKGE8MCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoInVuZXhwZWN0ZWQgRU9GIGluIGJjbWFwIik7ZT0hKDEyOCZhKTt0PXQ8PDd8MTI3JmF9d2hpbGUoIWUpO3JldHVybiB0fXJlYWRTaWduZWQoKXtjb25zdCBlPXRoaXMucmVhZE51bWJlcigpO3JldHVybiAxJmU/fihlPj4+MSk6ZT4+PjF9cmVhZEhleChlLHQpe2Uuc2V0KHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zLHRoaXMucG9zK3QrMSkpO3RoaXMucG9zKz10KzF9cmVhZEhleE51bWJlcihlLHQpe2xldCBhO2NvbnN0IHI9dGhpcy50bXBCdWY7bGV0IGk9MDtkb3tjb25zdCBlPXRoaXMucmVhZEJ5dGUoKTtpZihlPDApdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJ1bmV4cGVjdGVkIEVPRiBpbiBiY21hcCIpO2E9ISgxMjgmZSk7cltpKytdPTEyNyZlfXdoaWxlKCFhKTtsZXQgbj10LHM9MCxvPTA7Zm9yKDtuPj0wOyl7Zm9yKDtvPDgmJnIubGVuZ3RoPjA7KXtzfD1yWy0taV08PG87bys9N31lW25dPTI1NSZzO24tLTtzPj49ODtvLT04fX1yZWFkSGV4U2lnbmVkKGUsdCl7dGhpcy5yZWFkSGV4TnVtYmVyKGUsdCk7Y29uc3QgYT0xJmVbdF0/MjU1OjA7bGV0IHI9MDtmb3IobGV0IGk9MDtpPD10O2krKyl7cj0oMSZyKTw8OHxlW2ldO2VbaV09cj4+MV5hfX1yZWFkU3RyaW5nKCl7Y29uc3QgZT10aGlzLnJlYWROdW1iZXIoKSx0PW5ldyBBcnJheShlKTtmb3IobGV0IGE9MDthPGU7YSsrKXRbYV09dGhpcy5yZWFkTnVtYmVyKCk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4udCl9fWNsYXNzIEJpbmFyeUNNYXBSZWFkZXJ7YXN5bmMgcHJvY2VzcyhlLHQsYSl7Y29uc3Qgcj1uZXcgQmluYXJ5Q01hcFN0cmVhbShlKSxpPXIucmVhZEJ5dGUoKTt0LnZlcnRpY2FsPSEhKDEmaSk7bGV0IG49bnVsbDtjb25zdCBzPW5ldyBVaW50OEFycmF5KEJhKSxvPW5ldyBVaW50OEFycmF5KEJhKSxjPW5ldyBVaW50OEFycmF5KEJhKSxsPW5ldyBVaW50OEFycmF5KEJhKSxoPW5ldyBVaW50OEFycmF5KEJhKTtsZXQgdSxkO2Zvcig7KGQ9ci5yZWFkQnl0ZSgpKT49MDspe2NvbnN0IGU9ZD4+NTtpZig3PT09ZSl7c3dpdGNoKDMxJmQpe2Nhc2UgMDpyLnJlYWRTdHJpbmcoKTticmVhaztjYXNlIDE6bj1yLnJlYWRTdHJpbmcoKX1jb250aW51ZX1jb25zdCBhPSEhKDE2JmQpLGk9MTUmZDtpZihpKzE+QmEpdGhyb3cgbmV3IEVycm9yKCJCaW5hcnlDTWFwUmVhZGVyLnByb2Nlc3M6IEludmFsaWQgZGF0YVNpemUuIik7Y29uc3QgZj0xLGc9ci5yZWFkTnVtYmVyKCk7c3dpdGNoKGUpe2Nhc2UgMDpyLnJlYWRIZXgocyxpKTtyLnJlYWRIZXhOdW1iZXIobyxpKTthZGRIZXgobyxzLGkpO3QuYWRkQ29kZXNwYWNlUmFuZ2UoaSsxLGhleFRvSW50KHMsaSksaGV4VG9JbnQobyxpKSk7Zm9yKGxldCBlPTE7ZTxnO2UrKyl7aW5jSGV4KG8saSk7ci5yZWFkSGV4TnVtYmVyKHMsaSk7YWRkSGV4KHMsbyxpKTtyLnJlYWRIZXhOdW1iZXIobyxpKTthZGRIZXgobyxzLGkpO3QuYWRkQ29kZXNwYWNlUmFuZ2UoaSsxLGhleFRvSW50KHMsaSksaGV4VG9JbnQobyxpKSl9YnJlYWs7Y2FzZSAxOnIucmVhZEhleChzLGkpO3IucmVhZEhleE51bWJlcihvLGkpO2FkZEhleChvLHMsaSk7ci5yZWFkTnVtYmVyKCk7Zm9yKGxldCBlPTE7ZTxnO2UrKyl7aW5jSGV4KG8saSk7ci5yZWFkSGV4TnVtYmVyKHMsaSk7YWRkSGV4KHMsbyxpKTtyLnJlYWRIZXhOdW1iZXIobyxpKTthZGRIZXgobyxzLGkpO3IucmVhZE51bWJlcigpfWJyZWFrO2Nhc2UgMjpyLnJlYWRIZXgoYyxpKTt1PXIucmVhZE51bWJlcigpO3QubWFwT25lKGhleFRvSW50KGMsaSksdSk7Zm9yKGxldCBlPTE7ZTxnO2UrKyl7aW5jSGV4KGMsaSk7aWYoIWEpe3IucmVhZEhleE51bWJlcihoLGkpO2FkZEhleChjLGgsaSl9dT1yLnJlYWRTaWduZWQoKSsodSsxKTt0Lm1hcE9uZShoZXhUb0ludChjLGkpLHUpfWJyZWFrO2Nhc2UgMzpyLnJlYWRIZXgocyxpKTtyLnJlYWRIZXhOdW1iZXIobyxpKTthZGRIZXgobyxzLGkpO3U9ci5yZWFkTnVtYmVyKCk7dC5tYXBDaWRSYW5nZShoZXhUb0ludChzLGkpLGhleFRvSW50KG8saSksdSk7Zm9yKGxldCBlPTE7ZTxnO2UrKyl7aW5jSGV4KG8saSk7aWYoYSlzLnNldChvKTtlbHNle3IucmVhZEhleE51bWJlcihzLGkpO2FkZEhleChzLG8saSl9ci5yZWFkSGV4TnVtYmVyKG8saSk7YWRkSGV4KG8scyxpKTt1PXIucmVhZE51bWJlcigpO3QubWFwQ2lkUmFuZ2UoaGV4VG9JbnQocyxpKSxoZXhUb0ludChvLGkpLHUpfWJyZWFrO2Nhc2UgNDpyLnJlYWRIZXgoYyxmKTtyLnJlYWRIZXgobCxpKTt0Lm1hcE9uZShoZXhUb0ludChjLGYpLGhleFRvU3RyKGwsaSkpO2ZvcihsZXQgZT0xO2U8ZztlKyspe2luY0hleChjLGYpO2lmKCFhKXtyLnJlYWRIZXhOdW1iZXIoaCxmKTthZGRIZXgoYyxoLGYpfWluY0hleChsLGkpO3IucmVhZEhleFNpZ25lZChoLGkpO2FkZEhleChsLGgsaSk7dC5tYXBPbmUoaGV4VG9JbnQoYyxmKSxoZXhUb1N0cihsLGkpKX1icmVhaztjYXNlIDU6ci5yZWFkSGV4KHMsZik7ci5yZWFkSGV4TnVtYmVyKG8sZik7YWRkSGV4KG8scyxmKTtyLnJlYWRIZXgobCxpKTt0Lm1hcEJmUmFuZ2UoaGV4VG9JbnQocyxmKSxoZXhUb0ludChvLGYpLGhleFRvU3RyKGwsaSkpO2ZvcihsZXQgZT0xO2U8ZztlKyspe2luY0hleChvLGYpO2lmKGEpcy5zZXQobyk7ZWxzZXtyLnJlYWRIZXhOdW1iZXIocyxmKTthZGRIZXgocyxvLGYpfXIucmVhZEhleE51bWJlcihvLGYpO2FkZEhleChvLHMsZik7ci5yZWFkSGV4KGwsaSk7dC5tYXBCZlJhbmdlKGhleFRvSW50KHMsZiksaGV4VG9JbnQobyxmKSxoZXhUb1N0cihsLGkpKX1icmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQmluYXJ5Q01hcFJlYWRlci5wcm9jZXNzIC0gdW5rbm93biB0eXBlOiAke2V9YCl9fXJldHVybiBuP2Eobik6dH19Y2xhc3MgQXNjaWk4NVN0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQpe3QmJih0Kj0uOCk7c3VwZXIodCk7dGhpcy5zdHI9ZTt0aGlzLmRpY3Q9ZS5kaWN0O3RoaXMuaW5wdXQ9bmV3IFVpbnQ4QXJyYXkoNSl9cmVhZEJsb2NrKCl7Y29uc3QgZT10aGlzLnN0cjtsZXQgdD1lLmdldEJ5dGUoKTtmb3IoO2lzV2hpdGVTcGFjZSh0KTspdD1lLmdldEJ5dGUoKTtpZigtMT09PXR8fDEyNj09PXQpe3RoaXMuZW9mPSEwO3JldHVybn1jb25zdCBhPXRoaXMuYnVmZmVyTGVuZ3RoO2xldCByLGk7aWYoMTIyPT09dCl7cj10aGlzLmVuc3VyZUJ1ZmZlcihhKzQpO2ZvcihpPTA7aTw0OysraSlyW2EraV09MDt0aGlzLmJ1ZmZlckxlbmd0aCs9NH1lbHNle2NvbnN0IG49dGhpcy5pbnB1dDtuWzBdPXQ7Zm9yKGk9MTtpPDU7KytpKXt0PWUuZ2V0Qnl0ZSgpO2Zvcig7aXNXaGl0ZVNwYWNlKHQpOyl0PWUuZ2V0Qnl0ZSgpO25baV09dDtpZigtMT09PXR8fDEyNj09PXQpYnJlYWt9cj10aGlzLmVuc3VyZUJ1ZmZlcihhK2ktMSk7dGhpcy5idWZmZXJMZW5ndGgrPWktMTtpZihpPDUpe2Zvcig7aTw1OysraSluW2ldPTExNzt0aGlzLmVvZj0hMH1sZXQgcz0wO2ZvcihpPTA7aTw1OysraSlzPTg1KnMrKG5baV0tMzMpO2ZvcihpPTM7aT49MDstLWkpe3JbYStpXT0yNTUmcztzPj49OH19fX1jbGFzcyBBc2NpaUhleFN0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQpe3QmJih0Kj0uNSk7c3VwZXIodCk7dGhpcy5zdHI9ZTt0aGlzLmRpY3Q9ZS5kaWN0O3RoaXMuZmlyc3REaWdpdD0tMX1yZWFkQmxvY2soKXtjb25zdCBlPXRoaXMuc3RyLmdldEJ5dGVzKDhlMyk7aWYoIWUubGVuZ3RoKXt0aGlzLmVvZj0hMDtyZXR1cm59Y29uc3QgdD1lLmxlbmd0aCsxPj4xLGE9dGhpcy5lbnN1cmVCdWZmZXIodGhpcy5idWZmZXJMZW5ndGgrdCk7bGV0IHI9dGhpcy5idWZmZXJMZW5ndGgsaT10aGlzLmZpcnN0RGlnaXQ7Zm9yKGNvbnN0IHQgb2YgZSl7bGV0IGU7aWYodD49NDgmJnQ8PTU3KWU9MTUmdDtlbHNle2lmKCEodD49NjUmJnQ8PTcwfHx0Pj05NyYmdDw9MTAyKSl7aWYoNjI9PT10KXt0aGlzLmVvZj0hMDticmVha31jb250aW51ZX1lPTkrKDE1JnQpfWlmKGk8MClpPWU7ZWxzZXthW3IrK109aTw8NHxlO2k9LTF9fWlmKGk+PTAmJnRoaXMuZW9mKXthW3IrK109aTw8NDtpPS0xfXRoaXMuZmlyc3REaWdpdD1pO3RoaXMuYnVmZmVyTGVuZ3RoPXJ9fWNvbnN0IFJhPS0xLE5hPVtbLTEsLTFdLFstMSwtMV0sWzcsOF0sWzcsN10sWzYsNl0sWzYsNl0sWzYsNV0sWzYsNV0sWzQsMF0sWzQsMF0sWzQsMF0sWzQsMF0sWzQsMF0sWzQsMF0sWzQsMF0sWzQsMF0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzMsM10sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl0sWzEsMl1dLEVhPVtbLTEsLTFdLFsxMiwtMl0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFsxMSwxNzkyXSxbMTEsMTc5Ml0sWzEyLDE5ODRdLFsxMiwyMDQ4XSxbMTIsMjExMl0sWzEyLDIxNzZdLFsxMiwyMjQwXSxbMTIsMjMwNF0sWzExLDE4NTZdLFsxMSwxODU2XSxbMTEsMTkyMF0sWzExLDE5MjBdLFsxMiwyMzY4XSxbMTIsMjQzMl0sWzEyLDI0OTZdLFsxMiwyNTYwXV0sUGE9W1stMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWzgsMjldLFs4LDI5XSxbOCwzMF0sWzgsMzBdLFs4LDQ1XSxbOCw0NV0sWzgsNDZdLFs4LDQ2XSxbNywyMl0sWzcsMjJdLFs3LDIyXSxbNywyMl0sWzcsMjNdLFs3LDIzXSxbNywyM10sWzcsMjNdLFs4LDQ3XSxbOCw0N10sWzgsNDhdLFs4LDQ4XSxbNiwxM10sWzYsMTNdLFs2LDEzXSxbNiwxM10sWzYsMTNdLFs2LDEzXSxbNiwxM10sWzYsMTNdLFs3LDIwXSxbNywyMF0sWzcsMjBdLFs3LDIwXSxbOCwzM10sWzgsMzNdLFs4LDM0XSxbOCwzNF0sWzgsMzVdLFs4LDM1XSxbOCwzNl0sWzgsMzZdLFs4LDM3XSxbOCwzN10sWzgsMzhdLFs4LDM4XSxbNywxOV0sWzcsMTldLFs3LDE5XSxbNywxOV0sWzgsMzFdLFs4LDMxXSxbOCwzMl0sWzgsMzJdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDFdLFs2LDEyXSxbNiwxMl0sWzYsMTJdLFs2LDEyXSxbNiwxMl0sWzYsMTJdLFs2LDEyXSxbNiwxMl0sWzgsNTNdLFs4LDUzXSxbOCw1NF0sWzgsNTRdLFs3LDI2XSxbNywyNl0sWzcsMjZdLFs3LDI2XSxbOCwzOV0sWzgsMzldLFs4LDQwXSxbOCw0MF0sWzgsNDFdLFs4LDQxXSxbOCw0Ml0sWzgsNDJdLFs4LDQzXSxbOCw0M10sWzgsNDRdLFs4LDQ0XSxbNywyMV0sWzcsMjFdLFs3LDIxXSxbNywyMV0sWzcsMjhdLFs3LDI4XSxbNywyOF0sWzcsMjhdLFs4LDYxXSxbOCw2MV0sWzgsNjJdLFs4LDYyXSxbOCw2M10sWzgsNjNdLFs4LDBdLFs4LDBdLFs4LDMyMF0sWzgsMzIwXSxbOCwzODRdLFs4LDM4NF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNywyN10sWzcsMjddLFs3LDI3XSxbNywyN10sWzgsNTldLFs4LDU5XSxbOCw2MF0sWzgsNjBdLFs5LDE0NzJdLFs5LDE1MzZdLFs5LDE2MDBdLFs5LDE3MjhdLFs3LDE4XSxbNywxOF0sWzcsMThdLFs3LDE4XSxbNywyNF0sWzcsMjRdLFs3LDI0XSxbNywyNF0sWzgsNDldLFs4LDQ5XSxbOCw1MF0sWzgsNTBdLFs4LDUxXSxbOCw1MV0sWzgsNTJdLFs4LDUyXSxbNywyNV0sWzcsMjVdLFs3LDI1XSxbNywyNV0sWzgsNTVdLFs4LDU1XSxbOCw1Nl0sWzgsNTZdLFs4LDU3XSxbOCw1N10sWzgsNThdLFs4LDU4XSxbNiwxOTJdLFs2LDE5Ml0sWzYsMTkyXSxbNiwxOTJdLFs2LDE5Ml0sWzYsMTkyXSxbNiwxOTJdLFs2LDE5Ml0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzYsMTY2NF0sWzgsNDQ4XSxbOCw0NDhdLFs4LDUxMl0sWzgsNTEyXSxbOSw3MDRdLFs5LDc2OF0sWzgsNjQwXSxbOCw2NDBdLFs4LDU3Nl0sWzgsNTc2XSxbOSw4MzJdLFs5LDg5Nl0sWzksOTYwXSxbOSwxMDI0XSxbOSwxMDg4XSxbOSwxMTUyXSxbOSwxMjE2XSxbOSwxMjgwXSxbOSwxMzQ0XSxbOSwxNDA4XSxbNywyNTZdLFs3LDI1Nl0sWzcsMjU2XSxbNywyNTZdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDJdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOF0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzUsOV0sWzYsMTZdLFs2LDE2XSxbNiwxNl0sWzYsMTZdLFs2LDE2XSxbNiwxNl0sWzYsMTZdLFs2LDE2XSxbNiwxN10sWzYsMTddLFs2LDE3XSxbNiwxN10sWzYsMTddLFs2LDE3XSxbNiwxN10sWzYsMTddLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDRdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFs2LDE0XSxbNiwxNF0sWzYsMTRdLFs2LDE0XSxbNiwxNF0sWzYsMTRdLFs2LDE0XSxbNiwxNF0sWzYsMTVdLFs2LDE1XSxbNiwxNV0sWzYsMTVdLFs2LDE1XSxbNiwxNV0sWzYsMTVdLFs2LDE1XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN10sWzQsN11dLExhPVtbLTEsLTFdLFstMSwtMV0sWzEyLC0yXSxbMTIsLTJdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWzExLDE3OTJdLFsxMSwxNzkyXSxbMTEsMTc5Ml0sWzExLDE3OTJdLFsxMiwxOTg0XSxbMTIsMTk4NF0sWzEyLDIwNDhdLFsxMiwyMDQ4XSxbMTIsMjExMl0sWzEyLDIxMTJdLFsxMiwyMTc2XSxbMTIsMjE3Nl0sWzEyLDIyNDBdLFsxMiwyMjQwXSxbMTIsMjMwNF0sWzEyLDIzMDRdLFsxMSwxODU2XSxbMTEsMTg1Nl0sWzExLDE4NTZdLFsxMSwxODU2XSxbMTEsMTkyMF0sWzExLDE5MjBdLFsxMSwxOTIwXSxbMTEsMTkyMF0sWzEyLDIzNjhdLFsxMiwyMzY4XSxbMTIsMjQzMl0sWzEyLDI0MzJdLFsxMiwyNDk2XSxbMTIsMjQ5Nl0sWzEyLDI1NjBdLFsxMiwyNTYwXSxbMTAsMThdLFsxMCwxOF0sWzEwLDE4XSxbMTAsMThdLFsxMCwxOF0sWzEwLDE4XSxbMTAsMThdLFsxMCwxOF0sWzEyLDUyXSxbMTIsNTJdLFsxMyw2NDBdLFsxMyw3MDRdLFsxMyw3NjhdLFsxMyw4MzJdLFsxMiw1NV0sWzEyLDU1XSxbMTIsNTZdLFsxMiw1Nl0sWzEzLDEyODBdLFsxMywxMzQ0XSxbMTMsMTQwOF0sWzEzLDE0NzJdLFsxMiw1OV0sWzEyLDU5XSxbMTIsNjBdLFsxMiw2MF0sWzEzLDE1MzZdLFsxMywxNjAwXSxbMTEsMjRdLFsxMSwyNF0sWzExLDI0XSxbMTEsMjRdLFsxMSwyNV0sWzExLDI1XSxbMTEsMjVdLFsxMSwyNV0sWzEzLDE2NjRdLFsxMywxNzI4XSxbMTIsMzIwXSxbMTIsMzIwXSxbMTIsMzg0XSxbMTIsMzg0XSxbMTIsNDQ4XSxbMTIsNDQ4XSxbMTMsNTEyXSxbMTMsNTc2XSxbMTIsNTNdLFsxMiw1M10sWzEyLDU0XSxbMTIsNTRdLFsxMyw4OTZdLFsxMyw5NjBdLFsxMywxMDI0XSxbMTMsMTA4OF0sWzEzLDExNTJdLFsxMywxMjE2XSxbMTAsNjRdLFsxMCw2NF0sWzEwLDY0XSxbMTAsNjRdLFsxMCw2NF0sWzEwLDY0XSxbMTAsNjRdLFsxMCw2NF1dLGphPVtbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzExLDIzXSxbMTEsMjNdLFsxMiw1MF0sWzEyLDUxXSxbMTIsNDRdLFsxMiw0NV0sWzEyLDQ2XSxbMTIsNDddLFsxMiw1N10sWzEyLDU4XSxbMTIsNjFdLFsxMiwyNTZdLFsxMCwxNl0sWzEwLDE2XSxbMTAsMTZdLFsxMCwxNl0sWzEwLDE3XSxbMTAsMTddLFsxMCwxN10sWzEwLDE3XSxbMTIsNDhdLFsxMiw0OV0sWzEyLDYyXSxbMTIsNjNdLFsxMiwzMF0sWzEyLDMxXSxbMTIsMzJdLFsxMiwzM10sWzEyLDQwXSxbMTIsNDFdLFsxMSwyMl0sWzExLDIyXSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs5LDE1XSxbOSwxNV0sWzksMTVdLFs5LDE1XSxbOSwxNV0sWzksMTVdLFs5LDE1XSxbOSwxNV0sWzEyLDEyOF0sWzEyLDE5Ml0sWzEyLDI2XSxbMTIsMjddLFsxMiwyOF0sWzEyLDI5XSxbMTEsMTldLFsxMSwxOV0sWzExLDIwXSxbMTEsMjBdLFsxMiwzNF0sWzEyLDM1XSxbMTIsMzZdLFsxMiwzN10sWzEyLDM4XSxbMTIsMzldLFsxMSwyMV0sWzExLDIxXSxbMTIsNDJdLFsxMiw0M10sWzEwLDBdLFsxMCwwXSxbMTAsMF0sWzEwLDBdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl1dLF9hPVtbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFs2LDldLFs2LDhdLFs1LDddLFs1LDddLFs0LDZdLFs0LDZdLFs0LDZdLFs0LDZdLFs0LDVdLFs0LDVdLFs0LDVdLFs0LDVdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDFdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFszLDRdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDNdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdLFsyLDJdXTtjbGFzcyBDQ0lUVEZheERlY29kZXJ7Y29uc3RydWN0b3IoZSx0PXt9KXtpZigiZnVuY3Rpb24iIT10eXBlb2YgZT8ubmV4dCl0aHJvdyBuZXcgRXJyb3IoJ0NDSVRURmF4RGVjb2RlciAtIGludmFsaWQgInNvdXJjZSIgcGFyYW1ldGVyLicpO3RoaXMuc291cmNlPWU7dGhpcy5lb2Y9ITE7dGhpcy5lbmNvZGluZz10Lkt8fDA7dGhpcy5lb2xpbmU9dC5FbmRPZkxpbmV8fCExO3RoaXMuYnl0ZUFsaWduPXQuRW5jb2RlZEJ5dGVBbGlnbnx8ITE7dGhpcy5jb2x1bW5zPXQuQ29sdW1uc3x8MTcyODt0aGlzLnJvd3M9dC5Sb3dzfHwwO3RoaXMuZW9ibG9jaz10LkVuZE9mQmxvY2s/PyEwO3RoaXMuYmxhY2s9dC5CbGFja0lzMXx8ITE7dGhpcy5jb2RpbmdMaW5lPW5ldyBVaW50MzJBcnJheSh0aGlzLmNvbHVtbnMrMSk7dGhpcy5yZWZMaW5lPW5ldyBVaW50MzJBcnJheSh0aGlzLmNvbHVtbnMrMik7dGhpcy5jb2RpbmdMaW5lWzBdPXRoaXMuY29sdW1uczt0aGlzLmNvZGluZ1Bvcz0wO3RoaXMucm93PTA7dGhpcy5uZXh0TGluZTJEPXRoaXMuZW5jb2Rpbmc8MDt0aGlzLmlucHV0Qml0cz0wO3RoaXMuaW5wdXRCdWY9MDt0aGlzLm91dHB1dEJpdHM9MDt0aGlzLnJvd3NEb25lPSExO2xldCBhO2Zvcig7MD09PShhPXRoaXMuX2xvb2tCaXRzKDEyKSk7KXRoaXMuX2VhdEJpdHMoMSk7MT09PWEmJnRoaXMuX2VhdEJpdHMoMTIpO2lmKHRoaXMuZW5jb2Rpbmc+MCl7dGhpcy5uZXh0TGluZTJEPSF0aGlzLl9sb29rQml0cygxKTt0aGlzLl9lYXRCaXRzKDEpfX1yZWFkTmV4dENoYXIoKXtpZih0aGlzLmVvZilyZXR1cm4tMTtjb25zdCBlPXRoaXMucmVmTGluZSx0PXRoaXMuY29kaW5nTGluZSxhPXRoaXMuY29sdW1ucztsZXQgcixpLG4scyxvO2lmKDA9PT10aGlzLm91dHB1dEJpdHMpe3RoaXMucm93c0RvbmUmJih0aGlzLmVvZj0hMCk7aWYodGhpcy5lb2YpcmV0dXJuLTE7dGhpcy5lcnI9ITE7bGV0IG4sbyxjO2lmKHRoaXMubmV4dExpbmUyRCl7Zm9yKHM9MDt0W3NdPGE7KytzKWVbc109dFtzXTtlW3MrK109YTtlW3NdPWE7dFswXT0wO3RoaXMuY29kaW5nUG9zPTA7cj0wO2k9MDtmb3IoO3RbdGhpcy5jb2RpbmdQb3NdPGE7KXtuPXRoaXMuX2dldFR3b0RpbUNvZGUoKTtzd2l0Y2gobil7Y2FzZSAwOnRoaXMuX2FkZFBpeGVscyhlW3IrMV0saSk7ZVtyKzFdPGEmJihyKz0yKTticmVhaztjYXNlIDE6bj1vPTA7aWYoaSl7ZG97bis9Yz10aGlzLl9nZXRCbGFja0NvZGUoKX13aGlsZShjPj02NCk7ZG97bys9Yz10aGlzLl9nZXRXaGl0ZUNvZGUoKX13aGlsZShjPj02NCl9ZWxzZXtkb3tuKz1jPXRoaXMuX2dldFdoaXRlQ29kZSgpfXdoaWxlKGM+PTY0KTtkb3tvKz1jPXRoaXMuX2dldEJsYWNrQ29kZSgpfXdoaWxlKGM+PTY0KX10aGlzLl9hZGRQaXhlbHModFt0aGlzLmNvZGluZ1Bvc10rbixpKTt0W3RoaXMuY29kaW5nUG9zXTxhJiZ0aGlzLl9hZGRQaXhlbHModFt0aGlzLmNvZGluZ1Bvc10rbywxXmkpO2Zvcig7ZVtyXTw9dFt0aGlzLmNvZGluZ1Bvc10mJmVbcl08YTspcis9MjticmVhaztjYXNlIDc6dGhpcy5fYWRkUGl4ZWxzKGVbcl0rMyxpKTtpXj0xO2lmKHRbdGhpcy5jb2RpbmdQb3NdPGEpeysrcjtmb3IoO2Vbcl08PXRbdGhpcy5jb2RpbmdQb3NdJiZlW3JdPGE7KXIrPTJ9YnJlYWs7Y2FzZSA1OnRoaXMuX2FkZFBpeGVscyhlW3JdKzIsaSk7aV49MTtpZih0W3RoaXMuY29kaW5nUG9zXTxhKXsrK3I7Zm9yKDtlW3JdPD10W3RoaXMuY29kaW5nUG9zXSYmZVtyXTxhOylyKz0yfWJyZWFrO2Nhc2UgMzp0aGlzLl9hZGRQaXhlbHMoZVtyXSsxLGkpO2lePTE7aWYodFt0aGlzLmNvZGluZ1Bvc108YSl7KytyO2Zvcig7ZVtyXTw9dFt0aGlzLmNvZGluZ1Bvc10mJmVbcl08YTspcis9Mn1icmVhaztjYXNlIDI6dGhpcy5fYWRkUGl4ZWxzKGVbcl0saSk7aV49MTtpZih0W3RoaXMuY29kaW5nUG9zXTxhKXsrK3I7Zm9yKDtlW3JdPD10W3RoaXMuY29kaW5nUG9zXSYmZVtyXTxhOylyKz0yfWJyZWFrO2Nhc2UgODp0aGlzLl9hZGRQaXhlbHNOZWcoZVtyXS0zLGkpO2lePTE7aWYodFt0aGlzLmNvZGluZ1Bvc108YSl7cj4wPy0tcjorK3I7Zm9yKDtlW3JdPD10W3RoaXMuY29kaW5nUG9zXSYmZVtyXTxhOylyKz0yfWJyZWFrO2Nhc2UgNjp0aGlzLl9hZGRQaXhlbHNOZWcoZVtyXS0yLGkpO2lePTE7aWYodFt0aGlzLmNvZGluZ1Bvc108YSl7cj4wPy0tcjorK3I7Zm9yKDtlW3JdPD10W3RoaXMuY29kaW5nUG9zXSYmZVtyXTxhOylyKz0yfWJyZWFrO2Nhc2UgNDp0aGlzLl9hZGRQaXhlbHNOZWcoZVtyXS0xLGkpO2lePTE7aWYodFt0aGlzLmNvZGluZ1Bvc108YSl7cj4wPy0tcjorK3I7Zm9yKDtlW3JdPD10W3RoaXMuY29kaW5nUG9zXSYmZVtyXTxhOylyKz0yfWJyZWFrO2Nhc2UgUmE6dGhpcy5fYWRkUGl4ZWxzKGEsMCk7dGhpcy5lb2Y9ITA7YnJlYWs7ZGVmYXVsdDppbmZvKCJiYWQgMmQgY29kZSIpO3RoaXMuX2FkZFBpeGVscyhhLDApO3RoaXMuZXJyPSEwfX19ZWxzZXt0WzBdPTA7dGhpcy5jb2RpbmdQb3M9MDtpPTA7Zm9yKDt0W3RoaXMuY29kaW5nUG9zXTxhOyl7bj0wO2lmKGkpZG97bis9Yz10aGlzLl9nZXRCbGFja0NvZGUoKX13aGlsZShjPj02NCk7ZWxzZSBkb3tuKz1jPXRoaXMuX2dldFdoaXRlQ29kZSgpfXdoaWxlKGM+PTY0KTt0aGlzLl9hZGRQaXhlbHModFt0aGlzLmNvZGluZ1Bvc10rbixpKTtpXj0xfX1sZXQgbD0hMTt0aGlzLmJ5dGVBbGlnbiYmKHRoaXMuaW5wdXRCaXRzJj0tOCk7aWYodGhpcy5lb2Jsb2NrfHx0aGlzLnJvdyE9PXRoaXMucm93cy0xKXtuPXRoaXMuX2xvb2tCaXRzKDEyKTtpZih0aGlzLmVvbGluZSlmb3IoO24hPT1SYSYmMSE9PW47KXt0aGlzLl9lYXRCaXRzKDEpO249dGhpcy5fbG9va0JpdHMoMTIpfWVsc2UgZm9yKDswPT09bjspe3RoaXMuX2VhdEJpdHMoMSk7bj10aGlzLl9sb29rQml0cygxMil9aWYoMT09PW4pe3RoaXMuX2VhdEJpdHMoMTIpO2w9ITB9ZWxzZSBuPT09UmEmJih0aGlzLmVvZj0hMCl9ZWxzZSB0aGlzLnJvd3NEb25lPSEwO2lmKCF0aGlzLmVvZiYmdGhpcy5lbmNvZGluZz4wJiYhdGhpcy5yb3dzRG9uZSl7dGhpcy5uZXh0TGluZTJEPSF0aGlzLl9sb29rQml0cygxKTt0aGlzLl9lYXRCaXRzKDEpfWlmKHRoaXMuZW9ibG9jayYmbCYmdGhpcy5ieXRlQWxpZ24pe249dGhpcy5fbG9va0JpdHMoMTIpO2lmKDE9PT1uKXt0aGlzLl9lYXRCaXRzKDEyKTtpZih0aGlzLmVuY29kaW5nPjApe3RoaXMuX2xvb2tCaXRzKDEpO3RoaXMuX2VhdEJpdHMoMSl9aWYodGhpcy5lbmNvZGluZz49MClmb3Iocz0wO3M8NDsrK3Mpe249dGhpcy5fbG9va0JpdHMoMTIpOzEhPT1uJiZpbmZvKCJiYWQgcnRjIGNvZGU6ICIrbik7dGhpcy5fZWF0Qml0cygxMik7aWYodGhpcy5lbmNvZGluZz4wKXt0aGlzLl9sb29rQml0cygxKTt0aGlzLl9lYXRCaXRzKDEpfX10aGlzLmVvZj0hMH19ZWxzZSBpZih0aGlzLmVyciYmdGhpcy5lb2xpbmUpe2Zvcig7Oyl7bj10aGlzLl9sb29rQml0cygxMyk7aWYobj09PVJhKXt0aGlzLmVvZj0hMDtyZXR1cm4tMX1pZihuPj4xPT0xKWJyZWFrO3RoaXMuX2VhdEJpdHMoMSl9dGhpcy5fZWF0Qml0cygxMik7aWYodGhpcy5lbmNvZGluZz4wKXt0aGlzLl9lYXRCaXRzKDEpO3RoaXMubmV4dExpbmUyRD0hKDEmbil9fXRoaXMub3V0cHV0Qml0cz10WzBdPjA/dFt0aGlzLmNvZGluZ1Bvcz0wXTp0W3RoaXMuY29kaW5nUG9zPTFdO3RoaXMucm93Kyt9aWYodGhpcy5vdXRwdXRCaXRzPj04KXtvPTEmdGhpcy5jb2RpbmdQb3M/MDoyNTU7dGhpcy5vdXRwdXRCaXRzLT04O2lmKDA9PT10aGlzLm91dHB1dEJpdHMmJnRbdGhpcy5jb2RpbmdQb3NdPGEpe3RoaXMuY29kaW5nUG9zKys7dGhpcy5vdXRwdXRCaXRzPXRbdGhpcy5jb2RpbmdQb3NdLXRbdGhpcy5jb2RpbmdQb3MtMV19fWVsc2V7bj04O289MDtkb3tpZigibnVtYmVyIiE9dHlwZW9mIHRoaXMub3V0cHV0Qml0cyl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoJ0ludmFsaWQgL0NDSVRURmF4RGVjb2RlIGRhdGEsICJvdXRwdXRCaXRzIiBtdXN0IGJlIGEgbnVtYmVyLicpO2lmKHRoaXMub3V0cHV0Qml0cz5uKXtvPDw9bjsxJnRoaXMuY29kaW5nUG9zfHwob3w9MjU1Pj44LW4pO3RoaXMub3V0cHV0Qml0cy09bjtuPTB9ZWxzZXtvPDw9dGhpcy5vdXRwdXRCaXRzOzEmdGhpcy5jb2RpbmdQb3N8fChvfD0yNTU+PjgtdGhpcy5vdXRwdXRCaXRzKTtuLT10aGlzLm91dHB1dEJpdHM7dGhpcy5vdXRwdXRCaXRzPTA7aWYodFt0aGlzLmNvZGluZ1Bvc108YSl7dGhpcy5jb2RpbmdQb3MrKzt0aGlzLm91dHB1dEJpdHM9dFt0aGlzLmNvZGluZ1Bvc10tdFt0aGlzLmNvZGluZ1Bvcy0xXX1lbHNlIGlmKG4+MCl7bzw8PW47bj0wfX19d2hpbGUobil9dGhpcy5ibGFjayYmKG9ePTI1NSk7cmV0dXJuIG99X2FkZFBpeGVscyhlLHQpe2NvbnN0IGE9dGhpcy5jb2RpbmdMaW5lO2xldCByPXRoaXMuY29kaW5nUG9zO2lmKGU+YVtyXSl7aWYoZT50aGlzLmNvbHVtbnMpe2luZm8oInJvdyBpcyB3cm9uZyBsZW5ndGgiKTt0aGlzLmVycj0hMDtlPXRoaXMuY29sdW1uc30xJnJedCYmKytyO2Fbcl09ZX10aGlzLmNvZGluZ1Bvcz1yfV9hZGRQaXhlbHNOZWcoZSx0KXtjb25zdCBhPXRoaXMuY29kaW5nTGluZTtsZXQgcj10aGlzLmNvZGluZ1BvcztpZihlPmFbcl0pe2lmKGU+dGhpcy5jb2x1bW5zKXtpbmZvKCJyb3cgaXMgd3JvbmcgbGVuZ3RoIik7dGhpcy5lcnI9ITA7ZT10aGlzLmNvbHVtbnN9MSZyXnQmJisrcjthW3JdPWV9ZWxzZSBpZihlPGFbcl0pe2lmKGU8MCl7aW5mbygiaW52YWxpZCBjb2RlIik7dGhpcy5lcnI9ITA7ZT0wfWZvcig7cj4wJiZlPGFbci0xXTspLS1yO2Fbcl09ZX10aGlzLmNvZGluZ1Bvcz1yfV9maW5kVGFibGVDb2RlKGUsdCxhLHIpe2NvbnN0IGk9cnx8MDtmb3IobGV0IHI9ZTtyPD10Oysrcil7bGV0IGU9dGhpcy5fbG9va0JpdHMocik7aWYoZT09PVJhKXJldHVyblshMCwxLCExXTtyPHQmJihlPDw9dC1yKTtpZighaXx8ZT49aSl7Y29uc3QgdD1hW2UtaV07aWYodFswXT09PXIpe3RoaXMuX2VhdEJpdHMocik7cmV0dXJuWyEwLHRbMV0sITBdfX19cmV0dXJuWyExLDAsITFdfV9nZXRUd29EaW1Db2RlKCl7bGV0IGUsdD0wO2lmKHRoaXMuZW9ibG9jayl7dD10aGlzLl9sb29rQml0cyg3KTtlPU5hW3RdO2lmKGU/LlswXT4wKXt0aGlzLl9lYXRCaXRzKGVbMF0pO3JldHVybiBlWzFdfX1lbHNle2NvbnN0IGU9dGhpcy5fZmluZFRhYmxlQ29kZSgxLDcsTmEpO2lmKGVbMF0mJmVbMl0pcmV0dXJuIGVbMV19aW5mbygiQmFkIHR3byBkaW0gY29kZSIpO3JldHVybiBSYX1fZ2V0V2hpdGVDb2RlKCl7bGV0IGUsdD0wO2lmKHRoaXMuZW9ibG9jayl7dD10aGlzLl9sb29rQml0cygxMik7aWYodD09PVJhKXJldHVybiAxO2U9dD4+NT9QYVt0Pj4zXTpFYVt0XTtpZihlWzBdPjApe3RoaXMuX2VhdEJpdHMoZVswXSk7cmV0dXJuIGVbMV19fWVsc2V7bGV0IGU9dGhpcy5fZmluZFRhYmxlQ29kZSgxLDksUGEpO2lmKGVbMF0pcmV0dXJuIGVbMV07ZT10aGlzLl9maW5kVGFibGVDb2RlKDExLDEyLEVhKTtpZihlWzBdKXJldHVybiBlWzFdfWluZm8oImJhZCB3aGl0ZSBjb2RlIik7dGhpcy5fZWF0Qml0cygxKTtyZXR1cm4gMX1fZ2V0QmxhY2tDb2RlKCl7bGV0IGUsdDtpZih0aGlzLmVvYmxvY2spe2U9dGhpcy5fbG9va0JpdHMoMTMpO2lmKGU9PT1SYSlyZXR1cm4gMTt0PWU+Pjc/IShlPj45KSYmZT4+Nz9qYVsoZT4+MSktNjRdOl9hW2U+PjddOkxhW2VdO2lmKHRbMF0+MCl7dGhpcy5fZWF0Qml0cyh0WzBdKTtyZXR1cm4gdFsxXX19ZWxzZXtsZXQgZT10aGlzLl9maW5kVGFibGVDb2RlKDIsNixfYSk7aWYoZVswXSlyZXR1cm4gZVsxXTtlPXRoaXMuX2ZpbmRUYWJsZUNvZGUoNywxMixqYSw2NCk7aWYoZVswXSlyZXR1cm4gZVsxXTtlPXRoaXMuX2ZpbmRUYWJsZUNvZGUoMTAsMTMsTGEpO2lmKGVbMF0pcmV0dXJuIGVbMV19aW5mbygiYmFkIGJsYWNrIGNvZGUiKTt0aGlzLl9lYXRCaXRzKDEpO3JldHVybiAxfV9sb29rQml0cyhlKXtsZXQgdDtmb3IoO3RoaXMuaW5wdXRCaXRzPGU7KXtpZigtMT09PSh0PXRoaXMuc291cmNlLm5leHQoKSkpcmV0dXJuIDA9PT10aGlzLmlucHV0Qml0cz9SYTp0aGlzLmlucHV0QnVmPDxlLXRoaXMuaW5wdXRCaXRzJjY1NTM1Pj4xNi1lO3RoaXMuaW5wdXRCdWY9dGhpcy5pbnB1dEJ1Zjw8OHx0O3RoaXMuaW5wdXRCaXRzKz04fXJldHVybiB0aGlzLmlucHV0QnVmPj50aGlzLmlucHV0Qml0cy1lJjY1NTM1Pj4xNi1lfV9lYXRCaXRzKGUpeyh0aGlzLmlucHV0Qml0cy09ZSk8MCYmKHRoaXMuaW5wdXRCaXRzPTApfX1jbGFzcyBDQ0lUVEZheFN0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIodCk7dGhpcy5zdHI9ZTt0aGlzLmRpY3Q9ZS5kaWN0O2EgaW5zdGFuY2VvZiBEaWN0fHwoYT1EaWN0LmVtcHR5KTtjb25zdCByPXtuZXh0OigpPT5lLmdldEJ5dGUoKX07dGhpcy5jY2l0dEZheERlY29kZXI9bmV3IENDSVRURmF4RGVjb2RlcihyLHtLOmEuZ2V0KCJLIiksRW5kT2ZMaW5lOmEuZ2V0KCJFbmRPZkxpbmUiKSxFbmNvZGVkQnl0ZUFsaWduOmEuZ2V0KCJFbmNvZGVkQnl0ZUFsaWduIiksQ29sdW1uczphLmdldCgiQ29sdW1ucyIpLFJvd3M6YS5nZXQoIlJvd3MiKSxFbmRPZkJsb2NrOmEuZ2V0KCJFbmRPZkJsb2NrIiksQmxhY2tJczE6YS5nZXQoIkJsYWNrSXMxIil9KX1yZWFkQmxvY2soKXtmb3IoOyF0aGlzLmVvZjspe2NvbnN0IGU9dGhpcy5jY2l0dEZheERlY29kZXIucmVhZE5leHRDaGFyKCk7aWYoLTE9PT1lKXt0aGlzLmVvZj0hMDtyZXR1cm59dGhpcy5lbnN1cmVCdWZmZXIodGhpcy5idWZmZXJMZW5ndGgrMSk7dGhpcy5idWZmZXJbdGhpcy5idWZmZXJMZW5ndGgrK109ZX19fWNvbnN0IFVhPW5ldyBJbnQzMkFycmF5KFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksWGE9bmV3IEludDMyQXJyYXkoWzMsNCw1LDYsNyw4LDksMTAsNjU1NDcsNjU1NDksNjU1NTEsNjU1NTMsMTMxMDkxLDEzMTA5NSwxMzEwOTksMTMxMTAzLDE5NjY0MywxOTY2NTEsMTk2NjU5LDE5NjY2NywyNjIyMTEsMjYyMjI3LDI2MjI0MywyNjIyNTksMzI3ODExLDMyNzg0MywzMjc4NzUsMzI3OTA3LDI1OCwyNTgsMjU4XSkscWE9bmV3IEludDMyQXJyYXkoWzEsMiwzLDQsNjU1NDEsNjU1NDMsMTMxMDgxLDEzMTA4NSwxOTY2MjUsMTk2NjMzLDI2MjE3NywyNjIxOTMsMzI3NzQ1LDMyNzc3NywzOTMzNDUsMzkzNDA5LDQ1OTAwOSw0NTkxMzcsNTI0ODAxLDUyNTA1Nyw1OTA4NDksNTkxMzYxLDY1NzQwOSw2NTg0MzMsNzI0OTkzLDcyNzA0MSw3OTQ2MjUsNzk4NzIxLDg2ODM1Myw4NzY1NDVdKSxIYT1bbmV3IEludDMyQXJyYXkoWzQ1OTAwOCw1MjQzNjgsNTI0MzA0LDUyNDU2OCw0NTkwMjQsNTI0NDAwLDUyNDMzNiw1OTAwMTYsNDU5MDE2LDUyNDM4NCw1MjQzMjAsNTg5OTg0LDUyNDI4OCw1MjQ0MTYsNTI0MzUyLDU5MDA0OCw0NTkwMTIsNTI0Mzc2LDUyNDMxMiw1ODk5NjgsNDU5MDI4LDUyNDQwOCw1MjQzNDQsNTkwMDMyLDQ1OTAyMCw1MjQzOTIsNTI0MzI4LDU5ZTQsNTI0Mjk2LDUyNDQyNCw1MjQzNjAsNTkwMDY0LDQ1OTAxMCw1MjQzNzIsNTI0MzA4LDUyNDU3Miw0NTkwMjYsNTI0NDA0LDUyNDM0MCw1OTAwMjQsNDU5MDE4LDUyNDM4OCw1MjQzMjQsNTg5OTkyLDUyNDI5Miw1MjQ0MjAsNTI0MzU2LDU5MDA1Niw0NTkwMTQsNTI0MzgwLDUyNDMxNiw1ODk5NzYsNDU5MDMwLDUyNDQxMiw1MjQzNDgsNTkwMDQwLDQ1OTAyMiw1MjQzOTYsNTI0MzMyLDU5MDAwOCw1MjQzMDAsNTI0NDI4LDUyNDM2NCw1OTAwNzIsNDU5MDA5LDUyNDM3MCw1MjQzMDYsNTI0NTcwLDQ1OTAyNSw1MjQ0MDIsNTI0MzM4LDU5MDAyMCw0NTkwMTcsNTI0Mzg2LDUyNDMyMiw1ODk5ODgsNTI0MjkwLDUyNDQxOCw1MjQzNTQsNTkwMDUyLDQ1OTAxMyw1MjQzNzgsNTI0MzE0LDU4OTk3Miw0NTkwMjksNTI0NDEwLDUyNDM0Niw1OTAwMzYsNDU5MDIxLDUyNDM5NCw1MjQzMzAsNTkwMDA0LDUyNDI5OCw1MjQ0MjYsNTI0MzYyLDU5MDA2OCw0NTkwMTEsNTI0Mzc0LDUyNDMxMCw1MjQ1NzQsNDU5MDI3LDUyNDQwNiw1MjQzNDIsNTkwMDI4LDQ1OTAxOSw1MjQzOTAsNTI0MzI2LDU4OTk5Niw1MjQyOTQsNTI0NDIyLDUyNDM1OCw1OTAwNjAsNDU5MDE1LDUyNDM4Miw1MjQzMTgsNTg5OTgwLDQ1OTAzMSw1MjQ0MTQsNTI0MzUwLDU5MDA0NCw0NTkwMjMsNTI0Mzk4LDUyNDMzNCw1OTAwMTIsNTI0MzAyLDUyNDQzMCw1MjQzNjYsNTkwMDc2LDQ1OTAwOCw1MjQzNjksNTI0MzA1LDUyNDU2OSw0NTkwMjQsNTI0NDAxLDUyNDMzNyw1OTAwMTgsNDU5MDE2LDUyNDM4NSw1MjQzMjEsNTg5OTg2LDUyNDI4OSw1MjQ0MTcsNTI0MzUzLDU5MDA1MCw0NTkwMTIsNTI0Mzc3LDUyNDMxMyw1ODk5NzAsNDU5MDI4LDUyNDQwOSw1MjQzNDUsNTkwMDM0LDQ1OTAyMCw1MjQzOTMsNTI0MzI5LDU5MDAwMiw1MjQyOTcsNTI0NDI1LDUyNDM2MSw1OTAwNjYsNDU5MDEwLDUyNDM3Myw1MjQzMDksNTI0NTczLDQ1OTAyNiw1MjQ0MDUsNTI0MzQxLDU5MDAyNiw0NTkwMTgsNTI0Mzg5LDUyNDMyNSw1ODk5OTQsNTI0MjkzLDUyNDQyMSw1MjQzNTcsNTkwMDU4LDQ1OTAxNCw1MjQzODEsNTI0MzE3LDU4OTk3OCw0NTkwMzAsNTI0NDEzLDUyNDM0OSw1OTAwNDIsNDU5MDIyLDUyNDM5Nyw1MjQzMzMsNTkwMDEwLDUyNDMwMSw1MjQ0MjksNTI0MzY1LDU5MDA3NCw0NTkwMDksNTI0MzcxLDUyNDMwNyw1MjQ1NzEsNDU5MDI1LDUyNDQwMyw1MjQzMzksNTkwMDIyLDQ1OTAxNyw1MjQzODcsNTI0MzIzLDU4OTk5MCw1MjQyOTEsNTI0NDE5LDUyNDM1NSw1OTAwNTQsNDU5MDEzLDUyNDM3OSw1MjQzMTUsNTg5OTc0LDQ1OTAyOSw1MjQ0MTEsNTI0MzQ3LDU5MDAzOCw0NTkwMjEsNTI0Mzk1LDUyNDMzMSw1OTAwMDYsNTI0Mjk5LDUyNDQyNyw1MjQzNjMsNTkwMDcwLDQ1OTAxMSw1MjQzNzUsNTI0MzExLDUyNDU3NSw0NTkwMjcsNTI0NDA3LDUyNDM0Myw1OTAwMzAsNDU5MDE5LDUyNDM5MSw1MjQzMjcsNTg5OTk4LDUyNDI5NSw1MjQ0MjMsNTI0MzU5LDU5MDA2Miw0NTkwMTUsNTI0MzgzLDUyNDMxOSw1ODk5ODIsNDU5MDMxLDUyNDQxNSw1MjQzNTEsNTkwMDQ2LDQ1OTAyMyw1MjQzOTksNTI0MzM1LDU5MDAxNCw1MjQzMDMsNTI0NDMxLDUyNDM2Nyw1OTAwNzgsNDU5MDA4LDUyNDM2OCw1MjQzMDQsNTI0NTY4LDQ1OTAyNCw1MjQ0MDAsNTI0MzM2LDU5MDAxNyw0NTkwMTYsNTI0Mzg0LDUyNDMyMCw1ODk5ODUsNTI0Mjg4LDUyNDQxNiw1MjQzNTIsNTkwMDQ5LDQ1OTAxMiw1MjQzNzYsNTI0MzEyLDU4OTk2OSw0NTkwMjgsNTI0NDA4LDUyNDM0NCw1OTAwMzMsNDU5MDIwLDUyNDM5Miw1MjQzMjgsNTkwMDAxLDUyNDI5Niw1MjQ0MjQsNTI0MzYwLDU5MDA2NSw0NTkwMTAsNTI0MzcyLDUyNDMwOCw1MjQ1NzIsNDU5MDI2LDUyNDQwNCw1MjQzNDAsNTkwMDI1LDQ1OTAxOCw1MjQzODgsNTI0MzI0LDU4OTk5Myw1MjQyOTIsNTI0NDIwLDUyNDM1Niw1OTAwNTcsNDU5MDE0LDUyNDM4MCw1MjQzMTYsNTg5OTc3LDQ1OTAzMCw1MjQ0MTIsNTI0MzQ4LDU5MDA0MSw0NTkwMjIsNTI0Mzk2LDUyNDMzMiw1OTAwMDksNTI0MzAwLDUyNDQyOCw1MjQzNjQsNTkwMDczLDQ1OTAwOSw1MjQzNzAsNTI0MzA2LDUyNDU3MCw0NTkwMjUsNTI0NDAyLDUyNDMzOCw1OTAwMjEsNDU5MDE3LDUyNDM4Niw1MjQzMjIsNTg5OTg5LDUyNDI5MCw1MjQ0MTgsNTI0MzU0LDU5MDA1Myw0NTkwMTMsNTI0Mzc4LDUyNDMxNCw1ODk5NzMsNDU5MDI5LDUyNDQxMCw1MjQzNDYsNTkwMDM3LDQ1OTAyMSw1MjQzOTQsNTI0MzMwLDU5MDAwNSw1MjQyOTgsNTI0NDI2LDUyNDM2Miw1OTAwNjksNDU5MDExLDUyNDM3NCw1MjQzMTAsNTI0NTc0LDQ1OTAyNyw1MjQ0MDYsNTI0MzQyLDU5MDAyOSw0NTkwMTksNTI0MzkwLDUyNDMyNiw1ODk5OTcsNTI0Mjk0LDUyNDQyMiw1MjQzNTgsNTkwMDYxLDQ1OTAxNSw1MjQzODIsNTI0MzE4LDU4OTk4MSw0NTkwMzEsNTI0NDE0LDUyNDM1MCw1OTAwNDUsNDU5MDIzLDUyNDM5OCw1MjQzMzQsNTkwMDEzLDUyNDMwMiw1MjQ0MzAsNTI0MzY2LDU5MDA3Nyw0NTkwMDgsNTI0MzY5LDUyNDMwNSw1MjQ1NjksNDU5MDI0LDUyNDQwMSw1MjQzMzcsNTkwMDE5LDQ1OTAxNiw1MjQzODUsNTI0MzIxLDU4OTk4Nyw1MjQyODksNTI0NDE3LDUyNDM1Myw1OTAwNTEsNDU5MDEyLDUyNDM3Nyw1MjQzMTMsNTg5OTcxLDQ1OTAyOCw1MjQ0MDksNTI0MzQ1LDU5MDAzNSw0NTkwMjAsNTI0MzkzLDUyNDMyOSw1OTAwMDMsNTI0Mjk3LDUyNDQyNSw1MjQzNjEsNTkwMDY3LDQ1OTAxMCw1MjQzNzMsNTI0MzA5LDUyNDU3Myw0NTkwMjYsNTI0NDA1LDUyNDM0MSw1OTAwMjcsNDU5MDE4LDUyNDM4OSw1MjQzMjUsNTg5OTk1LDUyNDI5Myw1MjQ0MjEsNTI0MzU3LDU5MDA1OSw0NTkwMTQsNTI0MzgxLDUyNDMxNyw1ODk5NzksNDU5MDMwLDUyNDQxMyw1MjQzNDksNTkwMDQzLDQ1OTAyMiw1MjQzOTcsNTI0MzMzLDU5MDAxMSw1MjQzMDEsNTI0NDI5LDUyNDM2NSw1OTAwNzUsNDU5MDA5LDUyNDM3MSw1MjQzMDcsNTI0NTcxLDQ1OTAyNSw1MjQ0MDMsNTI0MzM5LDU5MDAyMyw0NTkwMTcsNTI0Mzg3LDUyNDMyMyw1ODk5OTEsNTI0MjkxLDUyNDQxOSw1MjQzNTUsNTkwMDU1LDQ1OTAxMyw1MjQzNzksNTI0MzE1LDU4OTk3NSw0NTkwMjksNTI0NDExLDUyNDM0Nyw1OTAwMzksNDU5MDIxLDUyNDM5NSw1MjQzMzEsNTkwMDA3LDUyNDI5OSw1MjQ0MjcsNTI0MzYzLDU5MDA3MSw0NTkwMTEsNTI0Mzc1LDUyNDMxMSw1MjQ1NzUsNDU5MDI3LDUyNDQwNyw1MjQzNDMsNTkwMDMxLDQ1OTAxOSw1MjQzOTEsNTI0MzI3LDU4OTk5OSw1MjQyOTUsNTI0NDIzLDUyNDM1OSw1OTAwNjMsNDU5MDE1LDUyNDM4Myw1MjQzMTksNTg5OTgzLDQ1OTAzMSw1MjQ0MTUsNTI0MzUxLDU5MDA0Nyw0NTkwMjMsNTI0Mzk5LDUyNDMzNSw1OTAwMTUsNTI0MzAzLDUyNDQzMSw1MjQzNjcsNTkwMDc5XSksOV0sV2E9W25ldyBJbnQzMkFycmF5KFszMjc2ODAsMzI3Njk2LDMyNzY4OCwzMjc3MDQsMzI3Njg0LDMyNzcwMCwzMjc2OTIsMzI3NzA4LDMyNzY4MiwzMjc2OTgsMzI3NjkwLDMyNzcwNiwzMjc2ODYsMzI3NzAyLDMyNzY5NCwwLDMyNzY4MSwzMjc2OTcsMzI3Njg5LDMyNzcwNSwzMjc2ODUsMzI3NzAxLDMyNzY5MywzMjc3MDksMzI3NjgzLDMyNzY5OSwzMjc2OTEsMzI3NzA3LDMyNzY4NywzMjc3MDMsMzI3Njk1LDBdKSw1XTtjbGFzcyBGbGF0ZVN0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKHQpO3RoaXMuc3RyPWU7dGhpcy5kaWN0PWUuZGljdDtjb25zdCBhPWUuZ2V0Qnl0ZSgpLHI9ZS5nZXRCeXRlKCk7aWYoLTE9PT1hfHwtMT09PXIpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIGhlYWRlciBpbiBmbGF0ZSBzdHJlYW06ICR7YX0sICR7cn1gKTtpZig4IT0oMTUmYSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCBpbiBmbGF0ZSBzdHJlYW06ICR7YX0sICR7cn1gKTtpZigoKGE8PDgpK3IpJTMxIT0wKXRocm93IG5ldyBGb3JtYXRFcnJvcihgQmFkIEZDSEVDSyBpbiBmbGF0ZSBzdHJlYW06ICR7YX0sICR7cn1gKTtpZigzMiZyKXRocm93IG5ldyBGb3JtYXRFcnJvcihgRkRJQ1QgYml0IHNldCBpbiBmbGF0ZSBzdHJlYW06ICR7YX0sICR7cn1gKTt0aGlzLmNvZGVTaXplPTA7dGhpcy5jb2RlQnVmPTB9YXN5bmMgZ2V0SW1hZ2VEYXRhKGUsdCl7Y29uc3QgYT1hd2FpdCB0aGlzLmFzeW5jR2V0Qnl0ZXMoKTtyZXR1cm4gYT9hLmxlbmd0aDw9ZT9hOmEuc3ViYXJyYXkoMCxlKTp0aGlzLmdldEJ5dGVzKGUpfWFzeW5jIGFzeW5jR2V0Qnl0ZXMoKXt0aGlzLnN0ci5yZXNldCgpO2NvbnN0IGU9dGhpcy5zdHIuZ2V0Qnl0ZXMoKTt0cnl7Y29uc3R7cmVhZGFibGU6dCx3cml0YWJsZTphfT1uZXcgRGVjb21wcmVzc2lvblN0cmVhbSgiZGVmbGF0ZSIpLHI9YS5nZXRXcml0ZXIoKTthd2FpdCByLnJlYWR5O3Iud3JpdGUoZSkudGhlbigoYXN5bmMoKT0+e2F3YWl0IHIucmVhZHk7YXdhaXQgci5jbG9zZSgpfSkpLmNhdGNoKCgoKT0+e30pKTtjb25zdCBpPVtdO2xldCBuPTA7Zm9yIGF3YWl0KGNvbnN0IGUgb2YgdCl7aS5wdXNoKGUpO24rPWUuYnl0ZUxlbmd0aH1jb25zdCBzPW5ldyBVaW50OEFycmF5KG4pO2xldCBvPTA7Zm9yKGNvbnN0IGUgb2YgaSl7cy5zZXQoZSxvKTtvKz1lLmJ5dGVMZW5ndGh9cmV0dXJuIHN9Y2F0Y2h7dGhpcy5zdHI9bmV3IFN0cmVhbShlLDIsZS5sZW5ndGgsdGhpcy5zdHIuZGljdCk7dGhpcy5yZXNldCgpO3JldHVybiBudWxsfX1nZXQgaXNBc3luYygpe3JldHVybiEwfWdldEJpdHMoZSl7Y29uc3QgdD10aGlzLnN0cjtsZXQgYSxyPXRoaXMuY29kZVNpemUsaT10aGlzLmNvZGVCdWY7Zm9yKDtyPGU7KXtpZigtMT09PShhPXQuZ2V0Qnl0ZSgpKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkJhZCBlbmNvZGluZyBpbiBmbGF0ZSBzdHJlYW0iKTtpfD1hPDxyO3IrPTh9YT1pJigxPDxlKS0xO3RoaXMuY29kZUJ1Zj1pPj5lO3RoaXMuY29kZVNpemU9ci09ZTtyZXR1cm4gYX1nZXRDb2RlKGUpe2NvbnN0IHQ9dGhpcy5zdHIsYT1lWzBdLHI9ZVsxXTtsZXQgaSxuPXRoaXMuY29kZVNpemUscz10aGlzLmNvZGVCdWY7Zm9yKDtuPHImJi0xIT09KGk9dC5nZXRCeXRlKCkpOyl7c3w9aTw8bjtuKz04fWNvbnN0IG89YVtzJigxPDxyKS0xXSxjPW8+PjE2LGw9NjU1MzUmbztpZihjPDF8fG48Yyl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkJhZCBlbmNvZGluZyBpbiBmbGF0ZSBzdHJlYW0iKTt0aGlzLmNvZGVCdWY9cz4+Yzt0aGlzLmNvZGVTaXplPW4tYztyZXR1cm4gbH1nZW5lcmF0ZUh1ZmZtYW5UYWJsZShlKXtjb25zdCB0PWUubGVuZ3RoO2xldCBhLHI9MDtmb3IoYT0wO2E8dDsrK2EpZVthXT5yJiYocj1lW2FdKTtjb25zdCBpPTE8PHIsbj1uZXcgSW50MzJBcnJheShpKTtmb3IobGV0IHM9MSxvPTAsYz0yO3M8PXI7KytzLG88PD0xLGM8PD0xKWZvcihsZXQgcj0wO3I8dDsrK3IpaWYoZVtyXT09PXMpe2xldCBlPTAsdD1vO2ZvcihhPTA7YTxzOysrYSl7ZT1lPDwxfDEmdDt0Pj49MX1mb3IoYT1lO2E8aTthKz1jKW5bYV09czw8MTZ8cjsrK299cmV0dXJuW24scl19I1goZSl7aW5mbyhlKTt0aGlzLmVvZj0hMH1yZWFkQmxvY2soKXtsZXQgZSx0LGE7Y29uc3Qgcj10aGlzLnN0cjt0cnl7dD10aGlzLmdldEJpdHMoMyl9Y2F0Y2goZSl7dGhpcy4jWChlLm1lc3NhZ2UpO3JldHVybn0xJnQmJih0aGlzLmVvZj0hMCk7dD4+PTE7aWYoMD09PXQpe2xldCB0O2lmKC0xPT09KHQ9ci5nZXRCeXRlKCkpKXt0aGlzLiNYKCJCYWQgYmxvY2sgaGVhZGVyIGluIGZsYXRlIHN0cmVhbSIpO3JldHVybn1sZXQgYT10O2lmKC0xPT09KHQ9ci5nZXRCeXRlKCkpKXt0aGlzLiNYKCJCYWQgYmxvY2sgaGVhZGVyIGluIGZsYXRlIHN0cmVhbSIpO3JldHVybn1hfD10PDw4O2lmKC0xPT09KHQ9ci5nZXRCeXRlKCkpKXt0aGlzLiNYKCJCYWQgYmxvY2sgaGVhZGVyIGluIGZsYXRlIHN0cmVhbSIpO3JldHVybn1sZXQgaT10O2lmKC0xPT09KHQ9ci5nZXRCeXRlKCkpKXt0aGlzLiNYKCJCYWQgYmxvY2sgaGVhZGVyIGluIGZsYXRlIHN0cmVhbSIpO3JldHVybn1pfD10PDw4O2lmKGkhPT0oNjU1MzUmfmEpJiYoMCE9PWF8fDAhPT1pKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkJhZCB1bmNvbXByZXNzZWQgYmxvY2sgbGVuZ3RoIGluIGZsYXRlIHN0cmVhbSIpO3RoaXMuY29kZUJ1Zj0wO3RoaXMuY29kZVNpemU9MDtjb25zdCBuPXRoaXMuYnVmZmVyTGVuZ3RoLHM9bithO2U9dGhpcy5lbnN1cmVCdWZmZXIocyk7dGhpcy5idWZmZXJMZW5ndGg9cztpZigwPT09YSktMT09PXIucGVla0J5dGUoKSYmKHRoaXMuZW9mPSEwKTtlbHNle2NvbnN0IHQ9ci5nZXRCeXRlcyhhKTtlLnNldCh0LG4pO3QubGVuZ3RoPGEmJih0aGlzLmVvZj0hMCl9cmV0dXJufWxldCBpLG47aWYoMT09PXQpe2k9SGE7bj1XYX1lbHNle2lmKDIhPT10KXRocm93IG5ldyBGb3JtYXRFcnJvcigiVW5rbm93biBibG9jayB0eXBlIGluIGZsYXRlIHN0cmVhbSIpO3tjb25zdCBlPXRoaXMuZ2V0Qml0cyg1KSsyNTcsdD10aGlzLmdldEJpdHMoNSkrMSxyPXRoaXMuZ2V0Qml0cyg0KSs0LHM9bmV3IFVpbnQ4QXJyYXkoVWEubGVuZ3RoKTtsZXQgbztmb3Iobz0wO288cjsrK28pc1tVYVtvXV09dGhpcy5nZXRCaXRzKDMpO2NvbnN0IGM9dGhpcy5nZW5lcmF0ZUh1ZmZtYW5UYWJsZShzKTthPTA7bz0wO2NvbnN0IGw9ZSt0LGg9bmV3IFVpbnQ4QXJyYXkobCk7bGV0IHUsZCxmO2Zvcig7bzxsOyl7Y29uc3QgZT10aGlzLmdldENvZGUoYyk7aWYoMTY9PT1lKXt1PTI7ZD0zO2Y9YX1lbHNlIGlmKDE3PT09ZSl7dT0zO2Q9MztmPWE9MH1lbHNle2lmKDE4IT09ZSl7aFtvKytdPWE9ZTtjb250aW51ZX11PTc7ZD0xMTtmPWE9MH1sZXQgdD10aGlzLmdldEJpdHModSkrZDtmb3IoO3QtLSA+MDspaFtvKytdPWZ9aT10aGlzLmdlbmVyYXRlSHVmZm1hblRhYmxlKGguc3ViYXJyYXkoMCxlKSk7bj10aGlzLmdlbmVyYXRlSHVmZm1hblRhYmxlKGguc3ViYXJyYXkoZSxsKSl9fWU9dGhpcy5idWZmZXI7bGV0IHM9ZT9lLmxlbmd0aDowLG89dGhpcy5idWZmZXJMZW5ndGg7Zm9yKDs7KXtsZXQgdD10aGlzLmdldENvZGUoaSk7aWYodDwyNTYpe2lmKG8rMT49cyl7ZT10aGlzLmVuc3VyZUJ1ZmZlcihvKzEpO3M9ZS5sZW5ndGh9ZVtvKytdPXQ7Y29udGludWV9aWYoMjU2PT09dCl7dGhpcy5idWZmZXJMZW5ndGg9bztyZXR1cm59dC09MjU3O3Q9WGFbdF07bGV0IHI9dD4+MTY7cj4wJiYocj10aGlzLmdldEJpdHMocikpO2E9KDY1NTM1JnQpK3I7dD10aGlzLmdldENvZGUobik7dD1xYVt0XTtyPXQ+PjE2O3I+MCYmKHI9dGhpcy5nZXRCaXRzKHIpKTtjb25zdCBjPSg2NTUzNSZ0KStyO2lmKG8rYT49cyl7ZT10aGlzLmVuc3VyZUJ1ZmZlcihvK2EpO3M9ZS5sZW5ndGh9Zm9yKGxldCB0PTA7dDxhOysrdCwrK28pZVtvXT1lW28tY119fX1jb25zdCB6YT1be3FlOjIyMDE3LG5tcHM6MSxubHBzOjEsc3dpdGNoRmxhZzoxfSx7cWU6MTMzMTMsbm1wczoyLG5scHM6Nixzd2l0Y2hGbGFnOjB9LHtxZTo2MTQ1LG5tcHM6MyxubHBzOjksc3dpdGNoRmxhZzowfSx7cWU6Mjc1MyxubXBzOjQsbmxwczoxMixzd2l0Y2hGbGFnOjB9LHtxZToxMzEzLG5tcHM6NSxubHBzOjI5LHN3aXRjaEZsYWc6MH0se3FlOjU0NSxubXBzOjM4LG5scHM6MzMsc3dpdGNoRmxhZzowfSx7cWU6MjIwMTcsbm1wczo3LG5scHM6Nixzd2l0Y2hGbGFnOjF9LHtxZToyMTUwNSxubXBzOjgsbmxwczoxNCxzd2l0Y2hGbGFnOjB9LHtxZToxODQzMyxubXBzOjksbmxwczoxNCxzd2l0Y2hGbGFnOjB9LHtxZToxNDMzNyxubXBzOjEwLG5scHM6MTQsc3dpdGNoRmxhZzowfSx7cWU6MTIyODksbm1wczoxMSxubHBzOjE3LHN3aXRjaEZsYWc6MH0se3FlOjkyMTcsbm1wczoxMixubHBzOjE4LHN3aXRjaEZsYWc6MH0se3FlOjcxNjksbm1wczoxMyxubHBzOjIwLHN3aXRjaEZsYWc6MH0se3FlOjU2MzMsbm1wczoyOSxubHBzOjIxLHN3aXRjaEZsYWc6MH0se3FlOjIyMDE3LG5tcHM6MTUsbmxwczoxNCxzd2l0Y2hGbGFnOjF9LHtxZToyMTUwNSxubXBzOjE2LG5scHM6MTQsc3dpdGNoRmxhZzowfSx7cWU6MjA3Mzcsbm1wczoxNyxubHBzOjE1LHN3aXRjaEZsYWc6MH0se3FlOjE4NDMzLG5tcHM6MTgsbmxwczoxNixzd2l0Y2hGbGFnOjB9LHtxZToxNDMzNyxubXBzOjE5LG5scHM6MTcsc3dpdGNoRmxhZzowfSx7cWU6MTMzMTMsbm1wczoyMCxubHBzOjE4LHN3aXRjaEZsYWc6MH0se3FlOjEyMjg5LG5tcHM6MjEsbmxwczoxOSxzd2l0Y2hGbGFnOjB9LHtxZToxMDI0MSxubXBzOjIyLG5scHM6MTksc3dpdGNoRmxhZzowfSx7cWU6OTIxNyxubXBzOjIzLG5scHM6MjAsc3dpdGNoRmxhZzowfSx7cWU6ODcwNSxubXBzOjI0LG5scHM6MjEsc3dpdGNoRmxhZzowfSx7cWU6NzE2OSxubXBzOjI1LG5scHM6MjIsc3dpdGNoRmxhZzowfSx7cWU6NjE0NSxubXBzOjI2LG5scHM6MjMsc3dpdGNoRmxhZzowfSx7cWU6NTYzMyxubXBzOjI3LG5scHM6MjQsc3dpdGNoRmxhZzowfSx7cWU6NTEyMSxubXBzOjI4LG5scHM6MjUsc3dpdGNoRmxhZzowfSx7cWU6NDYwOSxubXBzOjI5LG5scHM6MjYsc3dpdGNoRmxhZzowfSx7cWU6NDM1MyxubXBzOjMwLG5scHM6Mjcsc3dpdGNoRmxhZzowfSx7cWU6Mjc1MyxubXBzOjMxLG5scHM6Mjgsc3dpdGNoRmxhZzowfSx7cWU6MjQ5NyxubXBzOjMyLG5scHM6Mjksc3dpdGNoRmxhZzowfSx7cWU6MjIwOSxubXBzOjMzLG5scHM6MzAsc3dpdGNoRmxhZzowfSx7cWU6MTMxMyxubXBzOjM0LG5scHM6MzEsc3dpdGNoRmxhZzowfSx7cWU6MTA4OSxubXBzOjM1LG5scHM6MzIsc3dpdGNoRmxhZzowfSx7cWU6NjczLG5tcHM6MzYsbmxwczozMyxzd2l0Y2hGbGFnOjB9LHtxZTo1NDUsbm1wczozNyxubHBzOjM0LHN3aXRjaEZsYWc6MH0se3FlOjMyMSxubXBzOjM4LG5scHM6MzUsc3dpdGNoRmxhZzowfSx7cWU6MjczLG5tcHM6MzksbmxwczozNixzd2l0Y2hGbGFnOjB9LHtxZToxMzMsbm1wczo0MCxubHBzOjM3LHN3aXRjaEZsYWc6MH0se3FlOjczLG5tcHM6NDEsbmxwczozOCxzd2l0Y2hGbGFnOjB9LHtxZTozNyxubXBzOjQyLG5scHM6Mzksc3dpdGNoRmxhZzowfSx7cWU6MjEsbm1wczo0MyxubHBzOjQwLHN3aXRjaEZsYWc6MH0se3FlOjksbm1wczo0NCxubHBzOjQxLHN3aXRjaEZsYWc6MH0se3FlOjUsbm1wczo0NSxubHBzOjQyLHN3aXRjaEZsYWc6MH0se3FlOjEsbm1wczo0NSxubHBzOjQzLHN3aXRjaEZsYWc6MH0se3FlOjIyMDE3LG5tcHM6NDYsbmxwczo0Nixzd2l0Y2hGbGFnOjB9XTtjbGFzcyBBcml0aG1ldGljRGVjb2Rlcntjb25zdHJ1Y3RvcihlLHQsYSl7dGhpcy5kYXRhPWU7dGhpcy5icD10O3RoaXMuZGF0YUVuZD1hO3RoaXMuY2hpZ2g9ZVt0XTt0aGlzLmNsb3c9MDt0aGlzLmJ5dGVJbigpO3RoaXMuY2hpZ2g9dGhpcy5jaGlnaDw8NyY2NTUzNXx0aGlzLmNsb3c+PjkmMTI3O3RoaXMuY2xvdz10aGlzLmNsb3c8PDcmNjU1MzU7dGhpcy5jdC09Nzt0aGlzLmE9MzI3Njh9Ynl0ZUluKCl7Y29uc3QgZT10aGlzLmRhdGE7bGV0IHQ9dGhpcy5icDtpZigyNTU9PT1lW3RdKWlmKGVbdCsxXT4xNDMpe3RoaXMuY2xvdys9NjUyODA7dGhpcy5jdD04fWVsc2V7dCsrO3RoaXMuY2xvdys9ZVt0XTw8OTt0aGlzLmN0PTc7dGhpcy5icD10fWVsc2V7dCsrO3RoaXMuY2xvdys9dDx0aGlzLmRhdGFFbmQ/ZVt0XTw8ODo2NTI4MDt0aGlzLmN0PTg7dGhpcy5icD10fWlmKHRoaXMuY2xvdz42NTUzNSl7dGhpcy5jaGlnaCs9dGhpcy5jbG93Pj4xNjt0aGlzLmNsb3cmPTY1NTM1fX1yZWFkQml0KGUsdCl7bGV0IGE9ZVt0XT4+MSxyPTEmZVt0XTtjb25zdCBpPXphW2FdLG49aS5xZTtsZXQgcyxvPXRoaXMuYS1uO2lmKHRoaXMuY2hpZ2g8bilpZihvPG4pe289bjtzPXI7YT1pLm5tcHN9ZWxzZXtvPW47cz0xXnI7MT09PWkuc3dpdGNoRmxhZyYmKHI9cyk7YT1pLm5scHN9ZWxzZXt0aGlzLmNoaWdoLT1uO2lmKDMyNzY4Jm8pe3RoaXMuYT1vO3JldHVybiByfWlmKG88bil7cz0xXnI7MT09PWkuc3dpdGNoRmxhZyYmKHI9cyk7YT1pLm5scHN9ZWxzZXtzPXI7YT1pLm5tcHN9fWRvezA9PT10aGlzLmN0JiZ0aGlzLmJ5dGVJbigpO288PD0xO3RoaXMuY2hpZ2g9dGhpcy5jaGlnaDw8MSY2NTUzNXx0aGlzLmNsb3c+PjE1JjE7dGhpcy5jbG93PXRoaXMuY2xvdzw8MSY2NTUzNTt0aGlzLmN0LS19d2hpbGUoISgzMjc2OCZvKSk7dGhpcy5hPW87ZVt0XT1hPDwxfHI7cmV0dXJuIHN9fWNsYXNzIEpiaWcyRXJyb3IgZXh0ZW5kcyBKdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJKYmlnMkVycm9yIil9fWNsYXNzIENvbnRleHRDYWNoZXtnZXRDb250ZXh0cyhlKXtyZXR1cm4gZSBpbiB0aGlzP3RoaXNbZV06dGhpc1tlXT1uZXcgSW50OEFycmF5KDY1NTM2KX19Y2xhc3MgRGVjb2RpbmdDb250ZXh0e2NvbnN0cnVjdG9yKGUsdCxhKXt0aGlzLmRhdGE9ZTt0aGlzLnN0YXJ0PXQ7dGhpcy5lbmQ9YX1nZXQgZGVjb2Rlcigpe3JldHVybiBzaGFkb3codGhpcywiZGVjb2RlciIsbmV3IEFyaXRobWV0aWNEZWNvZGVyKHRoaXMuZGF0YSx0aGlzLnN0YXJ0LHRoaXMuZW5kKSl9Z2V0IGNvbnRleHRDYWNoZSgpe3JldHVybiBzaGFkb3codGhpcywiY29udGV4dENhY2hlIixuZXcgQ29udGV4dENhY2hlKX19ZnVuY3Rpb24gZGVjb2RlSW50ZWdlcihlLHQsYSl7Y29uc3Qgcj1lLmdldENvbnRleHRzKHQpO2xldCBpPTE7ZnVuY3Rpb24gcmVhZEJpdHMoZSl7bGV0IHQ9MDtmb3IobGV0IG49MDtuPGU7bisrKXtjb25zdCBlPWEucmVhZEJpdChyLGkpO2k9aTwyNTY/aTw8MXxlOjUxMSYoaTw8MXxlKXwyNTY7dD10PDwxfGV9cmV0dXJuIHQ+Pj4wfWNvbnN0IG49cmVhZEJpdHMoMSkscz1yZWFkQml0cygxKT9yZWFkQml0cygxKT9yZWFkQml0cygxKT9yZWFkQml0cygxKT9yZWFkQml0cygxKT9yZWFkQml0cygzMikrNDQzNjpyZWFkQml0cygxMikrMzQwOnJlYWRCaXRzKDgpKzg0OnJlYWRCaXRzKDYpKzIwOnJlYWRCaXRzKDQpKzQ6cmVhZEJpdHMoMik7bGV0IG87MD09PW4/bz1zOnM+MCYmKG89LXMpO3JldHVybiBvPj0tMjE0NzQ4MzY0OCYmbzw9Y2E/bzpudWxsfWZ1bmN0aW9uIGRlY29kZUlBSUQoZSx0LGEpe2NvbnN0IHI9ZS5nZXRDb250ZXh0cygiSUFJRCIpO2xldCBpPTE7Zm9yKGxldCBlPTA7ZTxhO2UrKyl7aT1pPDwxfHQucmVhZEJpdChyLGkpfXJldHVybiBhPDMxP2kmKDE8PGEpLTE6MjE0NzQ4MzY0NyZpfWNvbnN0ICRhPVsiU3ltYm9sRGljdGlvbmFyeSIsbnVsbCxudWxsLG51bGwsIkludGVybWVkaWF0ZVRleHRSZWdpb24iLG51bGwsIkltbWVkaWF0ZVRleHRSZWdpb24iLCJJbW1lZGlhdGVMb3NzbGVzc1RleHRSZWdpb24iLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCwiUGF0dGVybkRpY3Rpb25hcnkiLG51bGwsbnVsbCxudWxsLCJJbnRlcm1lZGlhdGVIYWxmdG9uZVJlZ2lvbiIsbnVsbCwiSW1tZWRpYXRlSGFsZnRvbmVSZWdpb24iLCJJbW1lZGlhdGVMb3NzbGVzc0hhbGZ0b25lUmVnaW9uIixudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCwiSW50ZXJtZWRpYXRlR2VuZXJpY1JlZ2lvbiIsbnVsbCwiSW1tZWRpYXRlR2VuZXJpY1JlZ2lvbiIsIkltbWVkaWF0ZUxvc3NsZXNzR2VuZXJpY1JlZ2lvbiIsIkludGVybWVkaWF0ZUdlbmVyaWNSZWZpbmVtZW50UmVnaW9uIixudWxsLCJJbW1lZGlhdGVHZW5lcmljUmVmaW5lbWVudFJlZ2lvbiIsIkltbWVkaWF0ZUxvc3NsZXNzR2VuZXJpY1JlZmluZW1lbnRSZWdpb24iLG51bGwsbnVsbCxudWxsLG51bGwsIlBhZ2VJbmZvcm1hdGlvbiIsIkVuZE9mUGFnZSIsIkVuZE9mU3RyaXBlIiwiRW5kT2ZGaWxlIiwiUHJvZmlsZXMiLCJUYWJsZXMiLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCwiRXh0ZW5zaW9uIl0sR2E9W1t7eDotMSx5Oi0yfSx7eDowLHk6LTJ9LHt4OjEseTotMn0se3g6LTIseTotMX0se3g6LTEseTotMX0se3g6MCx5Oi0xfSx7eDoxLHk6LTF9LHt4OjIseTotMX0se3g6LTQseTowfSx7eDotMyx5OjB9LHt4Oi0yLHk6MH0se3g6LTEseTowfV0sW3t4Oi0xLHk6LTJ9LHt4OjAseTotMn0se3g6MSx5Oi0yfSx7eDoyLHk6LTJ9LHt4Oi0yLHk6LTF9LHt4Oi0xLHk6LTF9LHt4OjAseTotMX0se3g6MSx5Oi0xfSx7eDoyLHk6LTF9LHt4Oi0zLHk6MH0se3g6LTIseTowfSx7eDotMSx5OjB9XSxbe3g6LTEseTotMn0se3g6MCx5Oi0yfSx7eDoxLHk6LTJ9LHt4Oi0yLHk6LTF9LHt4Oi0xLHk6LTF9LHt4OjAseTotMX0se3g6MSx5Oi0xfSx7eDotMix5OjB9LHt4Oi0xLHk6MH1dLFt7eDotMyx5Oi0xfSx7eDotMix5Oi0xfSx7eDotMSx5Oi0xfSx7eDowLHk6LTF9LHt4OjEseTotMX0se3g6LTQseTowfSx7eDotMyx5OjB9LHt4Oi0yLHk6MH0se3g6LTEseTowfV1dLFZhPVt7Y29kaW5nOlt7eDowLHk6LTF9LHt4OjEseTotMX0se3g6LTEseTowfV0scmVmZXJlbmNlOlt7eDowLHk6LTF9LHt4OjEseTotMX0se3g6LTEseTowfSx7eDowLHk6MH0se3g6MSx5OjB9LHt4Oi0xLHk6MX0se3g6MCx5OjF9LHt4OjEseToxfV19LHtjb2Rpbmc6W3t4Oi0xLHk6LTF9LHt4OjAseTotMX0se3g6MSx5Oi0xfSx7eDotMSx5OjB9XSxyZWZlcmVuY2U6W3t4OjAseTotMX0se3g6LTEseTowfSx7eDowLHk6MH0se3g6MSx5OjB9LHt4OjAseToxfSx7eDoxLHk6MX1dfV0sS2E9WzM5NzE3LDE5NDEsMjI5LDQwNV0sSmE9WzMyLDhdO2Z1bmN0aW9uIGRlY29kZUJpdG1hcChlLHQsYSxyLGksbixzLG8pe2lmKGUpe3JldHVybiBkZWNvZGVNTVJCaXRtYXAobmV3IFJlYWRlcihvLmRhdGEsby5zdGFydCxvLmVuZCksdCxhLCExKX1pZigwPT09ciYmIW4mJiFpJiY0PT09cy5sZW5ndGgmJjM9PT1zWzBdLngmJi0xPT09c1swXS55JiYtMz09PXNbMV0ueCYmLTE9PT1zWzFdLnkmJjI9PT1zWzJdLngmJi0yPT09c1syXS55JiYtMj09PXNbM10ueCYmLTI9PT1zWzNdLnkpcmV0dXJuIGZ1bmN0aW9uIGRlY29kZUJpdG1hcFRlbXBsYXRlMChlLHQsYSl7Y29uc3Qgcj1hLmRlY29kZXIsaT1hLmNvbnRleHRDYWNoZS5nZXRDb250ZXh0cygiR0IiKSxuPVtdO2xldCBzLG8sYyxsLGgsdSxkO2ZvcihvPTA7bzx0O28rKyl7aD1uW29dPW5ldyBVaW50OEFycmF5KGUpO3U9bzwxP2g6bltvLTFdO2Q9bzwyP2g6bltvLTJdO3M9ZFswXTw8MTN8ZFsxXTw8MTJ8ZFsyXTw8MTF8dVswXTw8N3x1WzFdPDw2fHVbMl08PDV8dVszXTw8NDtmb3IoYz0wO2M8ZTtjKyspe2hbY109bD1yLnJlYWRCaXQoaSxzKTtzPSgzMTczNSZzKTw8MXwoYyszPGU/ZFtjKzNdPDwxMTowKXwoYys0PGU/dVtjKzRdPDw0OjApfGx9fXJldHVybiBufSh0LGEsbyk7Y29uc3QgYz0hIW4sbD1HYVtyXS5jb25jYXQocyk7bC5zb3J0KCgoZSx0KT0+ZS55LXQueXx8ZS54LXQueCkpO2NvbnN0IGg9bC5sZW5ndGgsdT1uZXcgSW50OEFycmF5KGgpLGQ9bmV3IEludDhBcnJheShoKSxmPVtdO2xldCBnLHAsbT0wLGI9MCx5PTAsdz0wO2ZvcihwPTA7cDxoO3ArKyl7dVtwXT1sW3BdLng7ZFtwXT1sW3BdLnk7Yj1NYXRoLm1pbihiLGxbcF0ueCk7eT1NYXRoLm1heCh5LGxbcF0ueCk7dz1NYXRoLm1pbih3LGxbcF0ueSk7cDxoLTEmJmxbcF0ueT09PWxbcCsxXS55JiZsW3BdLng9PT1sW3ArMV0ueC0xP218PTE8PGgtMS1wOmYucHVzaChwKX1jb25zdCB4PWYubGVuZ3RoLFM9bmV3IEludDhBcnJheSh4KSxrPW5ldyBJbnQ4QXJyYXkoeCksQz1uZXcgVWludDE2QXJyYXkoeCk7Zm9yKGc9MDtnPHg7ZysrKXtwPWZbZ107U1tnXT1sW3BdLng7a1tnXT1sW3BdLnk7Q1tnXT0xPDxoLTEtcH1jb25zdCB2PS1iLEY9LXcsVD10LXksTz1LYVtyXTtsZXQgTT1uZXcgVWludDhBcnJheSh0KTtjb25zdCBEPVtdLFI9by5kZWNvZGVyLE49by5jb250ZXh0Q2FjaGUuZ2V0Q29udGV4dHMoIkdCIik7bGV0IEUsTCxqLF8sVSxYPTAscT0wO2ZvcihsZXQgZT0wO2U8YTtlKyspe2lmKGkpe1hePVIucmVhZEJpdChOLE8pO2lmKFgpe0QucHVzaChNKTtjb250aW51ZX19TT1uZXcgVWludDhBcnJheShNKTtELnB1c2goTSk7Zm9yKEU9MDtFPHQ7RSsrKXtpZihjJiZuW2VdW0VdKXtNW0VdPTA7Y29udGludWV9aWYoRT49diYmRTxUJiZlPj1GKXtxPXE8PDEmbTtmb3IocD0wO3A8eDtwKyspe0w9ZStrW3BdO2o9RStTW3BdO189RFtMXVtqXTtpZihfKXtfPUNbcF07cXw9X319fWVsc2V7cT0wO1U9aC0xO2ZvcihwPTA7cDxoO3ArKyxVLS0pe2o9RSt1W3BdO2lmKGo+PTAmJmo8dCl7TD1lK2RbcF07aWYoTD49MCl7Xz1EW0xdW2pdO18mJihxfD1fPDxVKX19fX1jb25zdCBhPVIucmVhZEJpdChOLHEpO01bRV09YX19cmV0dXJuIER9ZnVuY3Rpb24gZGVjb2RlUmVmaW5lbWVudChlLHQsYSxyLGksbixzLG8sYyl7bGV0IGw9VmFbYV0uY29kaW5nOzA9PT1hJiYobD1sLmNvbmNhdChbb1swXV0pKTtjb25zdCBoPWwubGVuZ3RoLHU9bmV3IEludDMyQXJyYXkoaCksZD1uZXcgSW50MzJBcnJheShoKTtsZXQgZjtmb3IoZj0wO2Y8aDtmKyspe3VbZl09bFtmXS54O2RbZl09bFtmXS55fWxldCBnPVZhW2FdLnJlZmVyZW5jZTswPT09YSYmKGc9Zy5jb25jYXQoW29bMV1dKSk7Y29uc3QgcD1nLmxlbmd0aCxtPW5ldyBJbnQzMkFycmF5KHApLGI9bmV3IEludDMyQXJyYXkocCk7Zm9yKGY9MDtmPHA7ZisrKXttW2ZdPWdbZl0ueDtiW2ZdPWdbZl0ueX1jb25zdCB5PXJbMF0ubGVuZ3RoLHc9ci5sZW5ndGgseD1KYVthXSxTPVtdLGs9Yy5kZWNvZGVyLEM9Yy5jb250ZXh0Q2FjaGUuZ2V0Q29udGV4dHMoIkdSIik7bGV0IHY9MDtmb3IobGV0IGE9MDthPHQ7YSsrKXtpZihzKXt2Xj1rLnJlYWRCaXQoQyx4KTtpZih2KXRocm93IG5ldyBKYmlnMkVycm9yKCJwcmVkaWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQiKX1jb25zdCB0PW5ldyBVaW50OEFycmF5KGUpO1MucHVzaCh0KTtmb3IobGV0IHM9MDtzPGU7cysrKXtsZXQgbyxjLGw9MDtmb3IoZj0wO2Y8aDtmKyspe289YStkW2ZdO2M9cyt1W2ZdO288MHx8YzwwfHxjPj1lP2w8PD0xOmw9bDw8MXxTW29dW2NdfWZvcihmPTA7ZjxwO2YrKyl7bz1hK2JbZl0tbjtjPXMrbVtmXS1pO288MHx8bz49d3x8YzwwfHxjPj15P2w8PD0xOmw9bDw8MXxyW29dW2NdfWNvbnN0IGc9ay5yZWFkQml0KEMsbCk7dFtzXT1nfX1yZXR1cm4gU31mdW5jdGlvbiBkZWNvZGVUZXh0UmVnaW9uKGUsdCxhLHIsaSxuLHMsbyxjLGwsaCx1LGQsZixnLHAsbSxiLHkpe2lmKGUmJnQpdGhyb3cgbmV3IEpiaWcyRXJyb3IoInJlZmluZW1lbnQgd2l0aCBIdWZmbWFuIGlzIG5vdCBzdXBwb3J0ZWQiKTtjb25zdCB3PVtdO2xldCB4LFM7Zm9yKHg9MDt4PHI7eCsrKXtTPW5ldyBVaW50OEFycmF5KGEpO2kmJlMuZmlsbChpKTt3LnB1c2goUyl9Y29uc3Qgaz1tLmRlY29kZXIsQz1tLmNvbnRleHRDYWNoZTtsZXQgdj1lPy1mLnRhYmxlRGVsdGFULmRlY29kZSh5KTotZGVjb2RlSW50ZWdlcihDLCJJQURUIixrKSxGPTA7eD0wO2Zvcig7eDxuOyl7dis9ZT9mLnRhYmxlRGVsdGFULmRlY29kZSh5KTpkZWNvZGVJbnRlZ2VyKEMsIklBRFQiLGspO0YrPWU/Zi50YWJsZUZpcnN0Uy5kZWNvZGUoeSk6ZGVjb2RlSW50ZWdlcihDLCJJQUZTIixrKTtsZXQgcj1GO2Zvcig7Oyl7bGV0IGk9MDtzPjEmJihpPWU/eS5yZWFkQml0cyhiKTpkZWNvZGVJbnRlZ2VyKEMsIklBSVQiLGspKTtjb25zdCBuPXMqditpLEY9ZT9mLnN5bWJvbElEVGFibGUuZGVjb2RlKHkpOmRlY29kZUlBSUQoQyxrLGMpLFQ9dCYmKGU/eS5yZWFkQml0KCk6ZGVjb2RlSW50ZWdlcihDLCJJQVJJIixrKSk7bGV0IE89b1tGXSxNPU9bMF0ubGVuZ3RoLEQ9Ty5sZW5ndGg7aWYoVCl7Y29uc3QgZT1kZWNvZGVJbnRlZ2VyKEMsIklBUkRXIixrKSx0PWRlY29kZUludGVnZXIoQywiSUFSREgiLGspO00rPWU7RCs9dDtPPWRlY29kZVJlZmluZW1lbnQoTSxELGcsTywoZT4+MSkrZGVjb2RlSW50ZWdlcihDLCJJQVJEWCIsayksKHQ+PjEpK2RlY29kZUludGVnZXIoQywiSUFSRFkiLGspLCExLHAsbSl9bGV0IFI9MDtsPzEmdT9SPUQtMTpyKz1ELTE6dT4xP3IrPU0tMTpSPU0tMTtjb25zdCBOPW4tKDEmdT8wOkQtMSksRT1yLSgyJnU/TS0xOjApO2xldCBMLGosXztpZihsKWZvcihMPTA7TDxEO0wrKyl7Uz13W0UrTF07aWYoIVMpY29udGludWU7Xz1PW0xdO2NvbnN0IGU9TWF0aC5taW4oYS1OLE0pO3N3aXRjaChkKXtjYXNlIDA6Zm9yKGo9MDtqPGU7aisrKVNbTitqXXw9X1tqXTticmVhaztjYXNlIDI6Zm9yKGo9MDtqPGU7aisrKVNbTitqXV49X1tqXTticmVhaztkZWZhdWx0OnRocm93IG5ldyBKYmlnMkVycm9yKGBvcGVyYXRvciAke2R9IGlzIG5vdCBzdXBwb3J0ZWRgKX19ZWxzZSBmb3Ioaj0wO2o8RDtqKyspe1M9d1tOK2pdO2lmKFMpe189T1tqXTtzd2l0Y2goZCl7Y2FzZSAwOmZvcihMPTA7TDxNO0wrKylTW0UrTF18PV9bTF07YnJlYWs7Y2FzZSAyOmZvcihMPTA7TDxNO0wrKylTW0UrTF1ePV9bTF07YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcihgb3BlcmF0b3IgJHtkfSBpcyBub3Qgc3VwcG9ydGVkYCl9fX14Kys7Y29uc3QgVT1lP2YudGFibGVEZWx0YVMuZGVjb2RlKHkpOmRlY29kZUludGVnZXIoQywiSUFEUyIsayk7aWYobnVsbD09PVUpYnJlYWs7cis9UitVK2h9fXJldHVybiB3fWZ1bmN0aW9uIHJlYWRTZWdtZW50SGVhZGVyKGUsdCl7Y29uc3QgYT17fTthLm51bWJlcj1yZWFkVWludDMyKGUsdCk7Y29uc3Qgcj1lW3QrNF0saT02MyZyO2lmKCEkYVtpXSl0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBzZWdtZW50IHR5cGU6ICIraSk7YS50eXBlPWk7YS50eXBlTmFtZT0kYVtpXTthLmRlZmVycmVkTm9uUmV0YWluPSEhKDEyOCZyKTtjb25zdCBuPSEhKDY0JnIpLHM9ZVt0KzVdO2xldCBvPXM+PjUmNztjb25zdCBjPVszMSZzXTtsZXQgbD10KzY7aWYoNz09PXMpe289NTM2ODcwOTExJnJlYWRVaW50MzIoZSxsLTEpO2wrPTM7bGV0IHQ9bys3Pj4zO2NbMF09ZVtsKytdO2Zvcig7LS10PjA7KWMucHVzaChlW2wrK10pfWVsc2UgaWYoNT09PXN8fDY9PT1zKXRocm93IG5ldyBKYmlnMkVycm9yKCJpbnZhbGlkIHJlZmVycmVkLXRvIGZsYWdzIik7YS5yZXRhaW5CaXRzPWM7bGV0IGg9NDthLm51bWJlcjw9MjU2P2g9MTphLm51bWJlcjw9NjU1MzYmJihoPTIpO2NvbnN0IHU9W107bGV0IGQsZjtmb3IoZD0wO2Q8bztkKyspe2xldCB0O3Q9MT09PWg/ZVtsXToyPT09aD9yZWFkVWludDE2KGUsbCk6cmVhZFVpbnQzMihlLGwpO3UucHVzaCh0KTtsKz1ofWEucmVmZXJyZWRUbz11O2lmKG4pe2EucGFnZUFzc29jaWF0aW9uPXJlYWRVaW50MzIoZSxsKTtsKz00fWVsc2UgYS5wYWdlQXNzb2NpYXRpb249ZVtsKytdO2EubGVuZ3RoPXJlYWRVaW50MzIoZSxsKTtsKz00O2lmKDQyOTQ5NjcyOTU9PT1hLmxlbmd0aCl7aWYoMzghPT1pKXRocm93IG5ldyBKYmlnMkVycm9yKCJpbnZhbGlkIHVua25vd24gc2VnbWVudCBsZW5ndGgiKTt7Y29uc3QgdD1yZWFkUmVnaW9uU2VnbWVudEluZm9ybWF0aW9uKGUsbCkscj0hISgxJmVbbCtZYV0pLGk9NixuPW5ldyBVaW50OEFycmF5KGkpO2lmKCFyKXtuWzBdPTI1NTtuWzFdPTE3Mn1uWzJdPXQuaGVpZ2h0Pj4+MjQmMjU1O25bM109dC5oZWlnaHQ+PjE2JjI1NTtuWzRdPXQuaGVpZ2h0Pj44JjI1NTtuWzVdPTI1NSZ0LmhlaWdodDtmb3IoZD1sLGY9ZS5sZW5ndGg7ZDxmO2QrKyl7bGV0IHQ9MDtmb3IoO3Q8aSYmblt0XT09PWVbZCt0XTspdCsrO2lmKHQ9PT1pKXthLmxlbmd0aD1kK2k7YnJlYWt9fWlmKDQyOTQ5NjcyOTU9PT1hLmxlbmd0aCl0aHJvdyBuZXcgSmJpZzJFcnJvcigic2VnbWVudCBlbmQgd2FzIG5vdCBmb3VuZCIpfX1hLmhlYWRlckVuZD1sO3JldHVybiBhfWZ1bmN0aW9uIHJlYWRTZWdtZW50cyhlLHQsYSxyKXtjb25zdCBpPVtdO2xldCBuPWE7Zm9yKDtuPHI7KXtjb25zdCBhPXJlYWRTZWdtZW50SGVhZGVyKHQsbik7bj1hLmhlYWRlckVuZDtjb25zdCByPXtoZWFkZXI6YSxkYXRhOnR9O2lmKCFlLnJhbmRvbUFjY2Vzcyl7ci5zdGFydD1uO24rPWEubGVuZ3RoO3IuZW5kPW59aS5wdXNoKHIpO2lmKDUxPT09YS50eXBlKWJyZWFrfWlmKGUucmFuZG9tQWNjZXNzKWZvcihsZXQgZT0wLHQ9aS5sZW5ndGg7ZTx0O2UrKyl7aVtlXS5zdGFydD1uO24rPWlbZV0uaGVhZGVyLmxlbmd0aDtpW2VdLmVuZD1ufXJldHVybiBpfWZ1bmN0aW9uIHJlYWRSZWdpb25TZWdtZW50SW5mb3JtYXRpb24oZSx0KXtyZXR1cm57d2lkdGg6cmVhZFVpbnQzMihlLHQpLGhlaWdodDpyZWFkVWludDMyKGUsdCs0KSx4OnJlYWRVaW50MzIoZSx0KzgpLHk6cmVhZFVpbnQzMihlLHQrMTIpLGNvbWJpbmF0aW9uT3BlcmF0b3I6NyZlW3QrMTZdfX1jb25zdCBZYT0xNztmdW5jdGlvbiBwcm9jZXNzU2VnbWVudChlLHQpe2NvbnN0IGE9ZS5oZWFkZXIscj1lLmRhdGEsaT1lLmVuZDtsZXQgbixzLG8sYyxsPWUuc3RhcnQ7c3dpdGNoKGEudHlwZSl7Y2FzZSAwOmNvbnN0IGU9e30sdD1yZWFkVWludDE2KHIsbCk7ZS5odWZmbWFuPSEhKDEmdCk7ZS5yZWZpbmVtZW50PSEhKDImdCk7ZS5odWZmbWFuREhTZWxlY3Rvcj10Pj4yJjM7ZS5odWZmbWFuRFdTZWxlY3Rvcj10Pj40JjM7ZS5iaXRtYXBTaXplU2VsZWN0b3I9dD4+NiYxO2UuYWdncmVnYXRpb25JbnN0YW5jZXNTZWxlY3Rvcj10Pj43JjE7ZS5iaXRtYXBDb2RpbmdDb250ZXh0VXNlZD0hISgyNTYmdCk7ZS5iaXRtYXBDb2RpbmdDb250ZXh0UmV0YWluZWQ9ISEoNTEyJnQpO2UudGVtcGxhdGU9dD4+MTAmMztlLnJlZmluZW1lbnRUZW1wbGF0ZT10Pj4xMiYxO2wrPTI7aWYoIWUuaHVmZm1hbil7Yz0wPT09ZS50ZW1wbGF0ZT80OjE7cz1bXTtmb3Iobz0wO288YztvKyspe3MucHVzaCh7eDpyZWFkSW50OChyLGwpLHk6cmVhZEludDgocixsKzEpfSk7bCs9Mn1lLmF0PXN9aWYoZS5yZWZpbmVtZW50JiYhZS5yZWZpbmVtZW50VGVtcGxhdGUpe3M9W107Zm9yKG89MDtvPDI7bysrKXtzLnB1c2goe3g6cmVhZEludDgocixsKSx5OnJlYWRJbnQ4KHIsbCsxKX0pO2wrPTJ9ZS5yZWZpbmVtZW50QXQ9c31lLm51bWJlck9mRXhwb3J0ZWRTeW1ib2xzPXJlYWRVaW50MzIocixsKTtsKz00O2UubnVtYmVyT2ZOZXdTeW1ib2xzPXJlYWRVaW50MzIocixsKTtsKz00O249W2UsYS5udW1iZXIsYS5yZWZlcnJlZFRvLHIsbCxpXTticmVhaztjYXNlIDY6Y2FzZSA3OmNvbnN0IGg9e307aC5pbmZvPXJlYWRSZWdpb25TZWdtZW50SW5mb3JtYXRpb24ocixsKTtsKz1ZYTtjb25zdCB1PXJlYWRVaW50MTYocixsKTtsKz0yO2guaHVmZm1hbj0hISgxJnUpO2gucmVmaW5lbWVudD0hISgyJnUpO2gubG9nU3RyaXBTaXplPXU+PjImMztoLnN0cmlwU2l6ZT0xPDxoLmxvZ1N0cmlwU2l6ZTtoLnJlZmVyZW5jZUNvcm5lcj11Pj40JjM7aC50cmFuc3Bvc2VkPSEhKDY0JnUpO2guY29tYmluYXRpb25PcGVyYXRvcj11Pj43JjM7aC5kZWZhdWx0UGl4ZWxWYWx1ZT11Pj45JjE7aC5kc09mZnNldD11PDwxNz4+Mjc7aC5yZWZpbmVtZW50VGVtcGxhdGU9dT4+MTUmMTtpZihoLmh1ZmZtYW4pe2NvbnN0IGU9cmVhZFVpbnQxNihyLGwpO2wrPTI7aC5odWZmbWFuRlM9MyZlO2guaHVmZm1hbkRTPWU+PjImMztoLmh1ZmZtYW5EVD1lPj40JjM7aC5odWZmbWFuUmVmaW5lbWVudERXPWU+PjYmMztoLmh1ZmZtYW5SZWZpbmVtZW50REg9ZT4+OCYzO2guaHVmZm1hblJlZmluZW1lbnREWD1lPj4xMCYzO2guaHVmZm1hblJlZmluZW1lbnREWT1lPj4xMiYzO2guaHVmZm1hblJlZmluZW1lbnRTaXplU2VsZWN0b3I9ISEoMTYzODQmZSl9aWYoaC5yZWZpbmVtZW50JiYhaC5yZWZpbmVtZW50VGVtcGxhdGUpe3M9W107Zm9yKG89MDtvPDI7bysrKXtzLnB1c2goe3g6cmVhZEludDgocixsKSx5OnJlYWRJbnQ4KHIsbCsxKX0pO2wrPTJ9aC5yZWZpbmVtZW50QXQ9c31oLm51bWJlck9mU3ltYm9sSW5zdGFuY2VzPXJlYWRVaW50MzIocixsKTtsKz00O249W2gsYS5yZWZlcnJlZFRvLHIsbCxpXTticmVhaztjYXNlIDE2OmNvbnN0IGQ9e30sZj1yW2wrK107ZC5tbXI9ISEoMSZmKTtkLnRlbXBsYXRlPWY+PjEmMztkLnBhdHRlcm5XaWR0aD1yW2wrK107ZC5wYXR0ZXJuSGVpZ2h0PXJbbCsrXTtkLm1heFBhdHRlcm5JbmRleD1yZWFkVWludDMyKHIsbCk7bCs9NDtuPVtkLGEubnVtYmVyLHIsbCxpXTticmVhaztjYXNlIDIyOmNhc2UgMjM6Y29uc3QgZz17fTtnLmluZm89cmVhZFJlZ2lvblNlZ21lbnRJbmZvcm1hdGlvbihyLGwpO2wrPVlhO2NvbnN0IHA9cltsKytdO2cubW1yPSEhKDEmcCk7Zy50ZW1wbGF0ZT1wPj4xJjM7Zy5lbmFibGVTa2lwPSEhKDgmcCk7Zy5jb21iaW5hdGlvbk9wZXJhdG9yPXA+PjQmNztnLmRlZmF1bHRQaXhlbFZhbHVlPXA+PjcmMTtnLmdyaWRXaWR0aD1yZWFkVWludDMyKHIsbCk7bCs9NDtnLmdyaWRIZWlnaHQ9cmVhZFVpbnQzMihyLGwpO2wrPTQ7Zy5ncmlkT2Zmc2V0WD00Mjk0OTY3Mjk1JnJlYWRVaW50MzIocixsKTtsKz00O2cuZ3JpZE9mZnNldFk9NDI5NDk2NzI5NSZyZWFkVWludDMyKHIsbCk7bCs9NDtnLmdyaWRWZWN0b3JYPXJlYWRVaW50MTYocixsKTtsKz0yO2cuZ3JpZFZlY3Rvclk9cmVhZFVpbnQxNihyLGwpO2wrPTI7bj1bZyxhLnJlZmVycmVkVG8scixsLGldO2JyZWFrO2Nhc2UgMzg6Y2FzZSAzOTpjb25zdCBtPXt9O20uaW5mbz1yZWFkUmVnaW9uU2VnbWVudEluZm9ybWF0aW9uKHIsbCk7bCs9WWE7Y29uc3QgYj1yW2wrK107bS5tbXI9ISEoMSZiKTttLnRlbXBsYXRlPWI+PjEmMzttLnByZWRpY3Rpb249ISEoOCZiKTtpZighbS5tbXIpe2M9MD09PW0udGVtcGxhdGU/NDoxO3M9W107Zm9yKG89MDtvPGM7bysrKXtzLnB1c2goe3g6cmVhZEludDgocixsKSx5OnJlYWRJbnQ4KHIsbCsxKX0pO2wrPTJ9bS5hdD1zfW49W20scixsLGldO2JyZWFrO2Nhc2UgNDg6Y29uc3QgeT17d2lkdGg6cmVhZFVpbnQzMihyLGwpLGhlaWdodDpyZWFkVWludDMyKHIsbCs0KSxyZXNvbHV0aW9uWDpyZWFkVWludDMyKHIsbCs4KSxyZXNvbHV0aW9uWTpyZWFkVWludDMyKHIsbCsxMil9OzQyOTQ5NjcyOTU9PT15LmhlaWdodCYmZGVsZXRlIHkuaGVpZ2h0O2NvbnN0IHc9cltsKzE2XTtyZWFkVWludDE2KHIsbCsxNyk7eS5sb3NzbGVzcz0hISgxJncpO3kucmVmaW5lbWVudD0hISgyJncpO3kuZGVmYXVsdFBpeGVsVmFsdWU9dz4+MiYxO3kuY29tYmluYXRpb25PcGVyYXRvcj13Pj4zJjM7eS5yZXF1aXJlc0J1ZmZlcj0hISgzMiZ3KTt5LmNvbWJpbmF0aW9uT3BlcmF0b3JPdmVycmlkZT0hISg2NCZ3KTtuPVt5XTticmVhaztjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDYyOmJyZWFrO2Nhc2UgNTM6bj1bYS5udW1iZXIscixsLGldO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoYHNlZ21lbnQgdHlwZSAke2EudHlwZU5hbWV9KCR7YS50eXBlfSkgaXMgbm90IGltcGxlbWVudGVkYCl9Y29uc3QgaD0ib24iK2EudHlwZU5hbWU7aCBpbiB0JiZ0W2hdLmFwcGx5KHQsbil9ZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnRzKGUsdCl7Zm9yKGxldCBhPTAscj1lLmxlbmd0aDthPHI7YSsrKXByb2Nlc3NTZWdtZW50KGVbYV0sdCl9Y2xhc3MgU2ltcGxlU2VnbWVudFZpc2l0b3J7b25QYWdlSW5mb3JtYXRpb24oZSl7dGhpcy5jdXJyZW50UGFnZUluZm89ZTtjb25zdCB0PWUud2lkdGgrNz4+MyxhPW5ldyBVaW50OENsYW1wZWRBcnJheSh0KmUuaGVpZ2h0KTtlLmRlZmF1bHRQaXhlbFZhbHVlJiZhLmZpbGwoMjU1KTt0aGlzLmJ1ZmZlcj1hfWRyYXdCaXRtYXAoZSx0KXtjb25zdCBhPXRoaXMuY3VycmVudFBhZ2VJbmZvLHI9ZS53aWR0aCxpPWUuaGVpZ2h0LG49YS53aWR0aCs3Pj4zLHM9YS5jb21iaW5hdGlvbk9wZXJhdG9yT3ZlcnJpZGU/ZS5jb21iaW5hdGlvbk9wZXJhdG9yOmEuY29tYmluYXRpb25PcGVyYXRvcixvPXRoaXMuYnVmZmVyLGM9MTI4Pj4oNyZlLngpO2xldCBsLGgsdSxkLGY9ZS55Km4rKGUueD4+Myk7c3dpdGNoKHMpe2Nhc2UgMDpmb3IobD0wO2w8aTtsKyspe3U9YztkPWY7Zm9yKGg9MDtoPHI7aCsrKXt0W2xdW2hdJiYob1tkXXw9dSk7dT4+PTE7aWYoIXUpe3U9MTI4O2QrK319Zis9bn1icmVhaztjYXNlIDI6Zm9yKGw9MDtsPGk7bCsrKXt1PWM7ZD1mO2ZvcihoPTA7aDxyO2grKyl7dFtsXVtoXSYmKG9bZF1ePXUpO3U+Pj0xO2lmKCF1KXt1PTEyODtkKyt9fWYrPW59YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcihgb3BlcmF0b3IgJHtzfSBpcyBub3Qgc3VwcG9ydGVkYCl9fW9uSW1tZWRpYXRlR2VuZXJpY1JlZ2lvbihlLHQsYSxyKXtjb25zdCBpPWUuaW5mbyxuPW5ldyBEZWNvZGluZ0NvbnRleHQodCxhLHIpLHM9ZGVjb2RlQml0bWFwKGUubW1yLGkud2lkdGgsaS5oZWlnaHQsZS50ZW1wbGF0ZSxlLnByZWRpY3Rpb24sbnVsbCxlLmF0LG4pO3RoaXMuZHJhd0JpdG1hcChpLHMpfW9uSW1tZWRpYXRlTG9zc2xlc3NHZW5lcmljUmVnaW9uKCl7dGhpcy5vbkltbWVkaWF0ZUdlbmVyaWNSZWdpb24oLi4uYXJndW1lbnRzKX1vblN5bWJvbERpY3Rpb25hcnkoZSx0LGEscixpLG4pe2xldCBzLG87aWYoZS5odWZmbWFuKXtzPWZ1bmN0aW9uIGdldFN5bWJvbERpY3Rpb25hcnlIdWZmbWFuVGFibGVzKGUsdCxhKXtsZXQgcixpLG4scyxvPTA7c3dpdGNoKGUuaHVmZm1hbkRIU2VsZWN0b3Ipe2Nhc2UgMDpjYXNlIDE6cj1nZXRTdGFuZGFyZFRhYmxlKGUuaHVmZm1hbkRIU2VsZWN0b3IrNCk7YnJlYWs7Y2FzZSAzOnI9Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKG8sdCxhKTtvKys7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBIdWZmbWFuIERIIHNlbGVjdG9yIil9c3dpdGNoKGUuaHVmZm1hbkRXU2VsZWN0b3Ipe2Nhc2UgMDpjYXNlIDE6aT1nZXRTdGFuZGFyZFRhYmxlKGUuaHVmZm1hbkRXU2VsZWN0b3IrMik7YnJlYWs7Y2FzZSAzOmk9Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKG8sdCxhKTtvKys7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBIdWZmbWFuIERXIHNlbGVjdG9yIil9aWYoZS5iaXRtYXBTaXplU2VsZWN0b3Ipe249Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKG8sdCxhKTtvKyt9ZWxzZSBuPWdldFN0YW5kYXJkVGFibGUoMSk7cz1lLmFnZ3JlZ2F0aW9uSW5zdGFuY2VzU2VsZWN0b3I/Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKG8sdCxhKTpnZXRTdGFuZGFyZFRhYmxlKDEpO3JldHVybnt0YWJsZURlbHRhSGVpZ2h0OnIsdGFibGVEZWx0YVdpZHRoOmksdGFibGVCaXRtYXBTaXplOm4sdGFibGVBZ2dyZWdhdGVJbnN0YW5jZXM6c319KGUsYSx0aGlzLmN1c3RvbVRhYmxlcyk7bz1uZXcgUmVhZGVyKHIsaSxuKX1sZXQgYz10aGlzLnN5bWJvbHM7Y3x8KHRoaXMuc3ltYm9scz1jPXt9KTtjb25zdCBsPVtdO2Zvcihjb25zdCBlIG9mIGEpe2NvbnN0IHQ9Y1tlXTt0JiZsLnB1c2goLi4udCl9Y29uc3QgaD1uZXcgRGVjb2RpbmdDb250ZXh0KHIsaSxuKTtjW3RdPWZ1bmN0aW9uIGRlY29kZVN5bWJvbERpY3Rpb25hcnkoZSx0LGEscixpLG4scyxvLGMsbCxoLHUpe2lmKGUmJnQpdGhyb3cgbmV3IEpiaWcyRXJyb3IoInN5bWJvbCByZWZpbmVtZW50IHdpdGggSHVmZm1hbiBpcyBub3Qgc3VwcG9ydGVkIik7Y29uc3QgZD1bXTtsZXQgZj0wLGc9bG9nMihhLmxlbmd0aCtyKTtjb25zdCBwPWguZGVjb2RlcixtPWguY29udGV4dENhY2hlO2xldCBiLHk7aWYoZSl7Yj1nZXRTdGFuZGFyZFRhYmxlKDEpO3k9W107Zz1NYXRoLm1heChnLDEpfWZvcig7ZC5sZW5ndGg8cjspe2YrPWU/bi50YWJsZURlbHRhSGVpZ2h0LmRlY29kZSh1KTpkZWNvZGVJbnRlZ2VyKG0sIklBREgiLHApO2xldCByPTAsaT0wO2NvbnN0IGI9ZT95Lmxlbmd0aDowO2Zvcig7Oyl7Y29uc3QgYj1lP24udGFibGVEZWx0YVdpZHRoLmRlY29kZSh1KTpkZWNvZGVJbnRlZ2VyKG0sIklBRFciLHApO2lmKG51bGw9PT1iKWJyZWFrO3IrPWI7aSs9cjtsZXQgdztpZih0KXtjb25zdCBpPWRlY29kZUludGVnZXIobSwiSUFBSSIscCk7aWYoaT4xKXc9ZGVjb2RlVGV4dFJlZ2lvbihlLHQscixmLDAsaSwxLGEuY29uY2F0KGQpLGcsMCwwLDEsMCxuLGMsbCxoLDAsdSk7ZWxzZXtjb25zdCBlPWRlY29kZUlBSUQobSxwLGcpLHQ9ZGVjb2RlSW50ZWdlcihtLCJJQVJEWCIscCksaT1kZWNvZGVJbnRlZ2VyKG0sIklBUkRZIixwKTt3PWRlY29kZVJlZmluZW1lbnQocixmLGMsZTxhLmxlbmd0aD9hW2VdOmRbZS1hLmxlbmd0aF0sdCxpLCExLGwsaCl9ZC5wdXNoKHcpfWVsc2UgaWYoZSl5LnB1c2gocik7ZWxzZXt3PWRlY29kZUJpdG1hcCghMSxyLGYscywhMSxudWxsLG8saCk7ZC5wdXNoKHcpfX1pZihlJiYhdCl7Y29uc3QgZT1uLnRhYmxlQml0bWFwU2l6ZS5kZWNvZGUodSk7dS5ieXRlQWxpZ24oKTtsZXQgdDtpZigwPT09ZSl0PXJlYWRVbmNvbXByZXNzZWRCaXRtYXAodSxpLGYpO2Vsc2V7Y29uc3QgYT11LmVuZCxyPXUucG9zaXRpb24rZTt1LmVuZD1yO3Q9ZGVjb2RlTU1SQml0bWFwKHUsaSxmLCExKTt1LmVuZD1hO3UucG9zaXRpb249cn1jb25zdCBhPXkubGVuZ3RoO2lmKGI9PT1hLTEpZC5wdXNoKHQpO2Vsc2V7bGV0IGUscixpLG4scyxvPTA7Zm9yKGU9YjtlPGE7ZSsrKXtuPXlbZV07aT1vK247cz1bXTtmb3Iocj0wO3I8ZjtyKyspcy5wdXNoKHRbcl0uc3ViYXJyYXkobyxpKSk7ZC5wdXNoKHMpO289aX19fX1jb25zdCB3PVtdLHg9W107bGV0IFMsayxDPSExO2NvbnN0IHY9YS5sZW5ndGgrcjtmb3IoO3gubGVuZ3RoPHY7KXtsZXQgdD1lP2IuZGVjb2RlKHUpOmRlY29kZUludGVnZXIobSwiSUFFWCIscCk7Zm9yKDt0LS07KXgucHVzaChDKTtDPSFDfWZvcihTPTAsaz1hLmxlbmd0aDtTPGs7UysrKXhbU10mJncucHVzaChhW1NdKTtmb3IobGV0IGU9MDtlPHI7UysrLGUrKyl4W1NdJiZ3LnB1c2goZFtlXSk7cmV0dXJuIHd9KGUuaHVmZm1hbixlLnJlZmluZW1lbnQsbCxlLm51bWJlck9mTmV3U3ltYm9scyxlLm51bWJlck9mRXhwb3J0ZWRTeW1ib2xzLHMsZS50ZW1wbGF0ZSxlLmF0LGUucmVmaW5lbWVudFRlbXBsYXRlLGUucmVmaW5lbWVudEF0LGgsbyl9b25JbW1lZGlhdGVUZXh0UmVnaW9uKGUsdCxhLHIsaSl7Y29uc3Qgbj1lLmluZm87bGV0IHMsbztjb25zdCBjPXRoaXMuc3ltYm9scyxsPVtdO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9Y1tlXTt0JiZsLnB1c2goLi4udCl9Y29uc3QgaD1sb2cyKGwubGVuZ3RoKTtpZihlLmh1ZmZtYW4pe289bmV3IFJlYWRlcihhLHIsaSk7cz1mdW5jdGlvbiBnZXRUZXh0UmVnaW9uSHVmZm1hblRhYmxlcyhlLHQsYSxyLGkpe2NvbnN0IG49W107Zm9yKGxldCBlPTA7ZTw9MzQ7ZSsrKXtjb25zdCB0PWkucmVhZEJpdHMoNCk7bi5wdXNoKG5ldyBIdWZmbWFuTGluZShbZSx0LDAsMF0pKX1jb25zdCBzPW5ldyBIdWZmbWFuVGFibGUobiwhMSk7bi5sZW5ndGg9MDtmb3IobGV0IGU9MDtlPHI7KXtjb25zdCB0PXMuZGVjb2RlKGkpO2lmKHQ+PTMyKXtsZXQgYSxyLHM7c3dpdGNoKHQpe2Nhc2UgMzI6aWYoMD09PWUpdGhyb3cgbmV3IEpiaWcyRXJyb3IoIm5vIHByZXZpb3VzIHZhbHVlIGluIHN5bWJvbCBJRCB0YWJsZSIpO3I9aS5yZWFkQml0cygyKSszO2E9bltlLTFdLnByZWZpeExlbmd0aDticmVhaztjYXNlIDMzOnI9aS5yZWFkQml0cygzKSszO2E9MDticmVhaztjYXNlIDM0OnI9aS5yZWFkQml0cyg3KSsxMTthPTA7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBjb2RlIGxlbmd0aCBpbiBzeW1ib2wgSUQgdGFibGUiKX1mb3Iocz0wO3M8cjtzKyspe24ucHVzaChuZXcgSHVmZm1hbkxpbmUoW2UsYSwwLDBdKSk7ZSsrfX1lbHNle24ucHVzaChuZXcgSHVmZm1hbkxpbmUoW2UsdCwwLDBdKSk7ZSsrfX1pLmJ5dGVBbGlnbigpO2NvbnN0IG89bmV3IEh1ZmZtYW5UYWJsZShuLCExKTtsZXQgYyxsLGgsdT0wO3N3aXRjaChlLmh1ZmZtYW5GUyl7Y2FzZSAwOmNhc2UgMTpjPWdldFN0YW5kYXJkVGFibGUoZS5odWZmbWFuRlMrNik7YnJlYWs7Y2FzZSAzOmM9Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKHUsdCxhKTt1Kys7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBIdWZmbWFuIEZTIHNlbGVjdG9yIil9c3dpdGNoKGUuaHVmZm1hbkRTKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpsPWdldFN0YW5kYXJkVGFibGUoZS5odWZmbWFuRFMrOCk7YnJlYWs7Y2FzZSAzOmw9Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKHUsdCxhKTt1Kys7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBIdWZmbWFuIERTIHNlbGVjdG9yIil9c3dpdGNoKGUuaHVmZm1hbkRUKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpoPWdldFN0YW5kYXJkVGFibGUoZS5odWZmbWFuRFQrMTEpO2JyZWFrO2Nhc2UgMzpoPWdldEN1c3RvbUh1ZmZtYW5UYWJsZSh1LHQsYSk7dSsrO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgSHVmZm1hbiBEVCBzZWxlY3RvciIpfWlmKGUucmVmaW5lbWVudCl0aHJvdyBuZXcgSmJpZzJFcnJvcigicmVmaW5lbWVudCB3aXRoIEh1ZmZtYW4gaXMgbm90IHN1cHBvcnRlZCIpO3JldHVybntzeW1ib2xJRFRhYmxlOm8sdGFibGVGaXJzdFM6Yyx0YWJsZURlbHRhUzpsLHRhYmxlRGVsdGFUOmh9fShlLHQsdGhpcy5jdXN0b21UYWJsZXMsbC5sZW5ndGgsbyl9Y29uc3QgdT1uZXcgRGVjb2RpbmdDb250ZXh0KGEscixpKSxkPWRlY29kZVRleHRSZWdpb24oZS5odWZmbWFuLGUucmVmaW5lbWVudCxuLndpZHRoLG4uaGVpZ2h0LGUuZGVmYXVsdFBpeGVsVmFsdWUsZS5udW1iZXJPZlN5bWJvbEluc3RhbmNlcyxlLnN0cmlwU2l6ZSxsLGgsZS50cmFuc3Bvc2VkLGUuZHNPZmZzZXQsZS5yZWZlcmVuY2VDb3JuZXIsZS5jb21iaW5hdGlvbk9wZXJhdG9yLHMsZS5yZWZpbmVtZW50VGVtcGxhdGUsZS5yZWZpbmVtZW50QXQsdSxlLmxvZ1N0cmlwU2l6ZSxvKTt0aGlzLmRyYXdCaXRtYXAobixkKX1vbkltbWVkaWF0ZUxvc3NsZXNzVGV4dFJlZ2lvbigpe3RoaXMub25JbW1lZGlhdGVUZXh0UmVnaW9uKC4uLmFyZ3VtZW50cyl9b25QYXR0ZXJuRGljdGlvbmFyeShlLHQsYSxyLGkpe2xldCBuPXRoaXMucGF0dGVybnM7bnx8KHRoaXMucGF0dGVybnM9bj17fSk7Y29uc3Qgcz1uZXcgRGVjb2RpbmdDb250ZXh0KGEscixpKTtuW3RdPWZ1bmN0aW9uIGRlY29kZVBhdHRlcm5EaWN0aW9uYXJ5KGUsdCxhLHIsaSxuKXtjb25zdCBzPVtdO2lmKCFlKXtzLnB1c2goe3g6LXQseTowfSk7MD09PWkmJnMucHVzaCh7eDotMyx5Oi0xfSx7eDoyLHk6LTJ9LHt4Oi0yLHk6LTJ9KX1jb25zdCBvPWRlY29kZUJpdG1hcChlLChyKzEpKnQsYSxpLCExLG51bGwscyxuKSxjPVtdO2ZvcihsZXQgZT0wO2U8PXI7ZSsrKXtjb25zdCByPVtdLGk9dCplLG49aSt0O2ZvcihsZXQgZT0wO2U8YTtlKyspci5wdXNoKG9bZV0uc3ViYXJyYXkoaSxuKSk7Yy5wdXNoKHIpfXJldHVybiBjfShlLm1tcixlLnBhdHRlcm5XaWR0aCxlLnBhdHRlcm5IZWlnaHQsZS5tYXhQYXR0ZXJuSW5kZXgsZS50ZW1wbGF0ZSxzKX1vbkltbWVkaWF0ZUhhbGZ0b25lUmVnaW9uKGUsdCxhLHIsaSl7Y29uc3Qgbj10aGlzLnBhdHRlcm5zW3RbMF1dLHM9ZS5pbmZvLG89bmV3IERlY29kaW5nQ29udGV4dChhLHIsaSksYz1mdW5jdGlvbiBkZWNvZGVIYWxmdG9uZVJlZ2lvbihlLHQsYSxyLGksbixzLG8sYyxsLGgsdSxkLGYsZyl7aWYocyl0aHJvdyBuZXcgSmJpZzJFcnJvcigic2tpcCBpcyBub3Qgc3VwcG9ydGVkIik7aWYoMCE9PW8pdGhyb3cgbmV3IEpiaWcyRXJyb3IoYG9wZXJhdG9yICIke299IiBpcyBub3Qgc3VwcG9ydGVkIGluIGhhbGZ0b25lIHJlZ2lvbmApO2NvbnN0IHA9W107bGV0IG0sYix5O2ZvcihtPTA7bTxpO20rKyl7eT1uZXcgVWludDhBcnJheShyKTtuJiZ5LmZpbGwobik7cC5wdXNoKHkpfWNvbnN0IHc9dC5sZW5ndGgseD10WzBdLFM9eFswXS5sZW5ndGgsaz14Lmxlbmd0aCxDPWxvZzIodyksdj1bXTtpZighZSl7di5wdXNoKHt4OmE8PTE/MzoyLHk6LTF9KTswPT09YSYmdi5wdXNoKHt4Oi0zLHk6LTF9LHt4OjIseTotMn0se3g6LTIseTotMn0pfWNvbnN0IEY9W107bGV0IFQsTyxNLEQsUixOLEUsTCxqLF8sVTtlJiYoVD1uZXcgUmVhZGVyKGcuZGF0YSxnLnN0YXJ0LGcuZW5kKSk7Zm9yKG09Qy0xO20+PTA7bS0tKXtPPWU/ZGVjb2RlTU1SQml0bWFwKFQsYyxsLCEwKTpkZWNvZGVCaXRtYXAoITEsYyxsLGEsITEsbnVsbCx2LGcpO0ZbbV09T31mb3IoTT0wO008bDtNKyspZm9yKEQ9MDtEPGM7RCsrKXtSPTA7Tj0wO2ZvcihiPUMtMTtiPj0wO2ItLSl7Ul49RltiXVtNXVtEXTtOfD1SPDxifUU9dFtOXTtMPWgrTSpmK0QqZD4+ODtqPXUrTSpkLUQqZj4+ODtpZihMPj0wJiZMK1M8PXImJmo+PTAmJmorazw9aSlmb3IobT0wO208azttKyspe1U9cFtqK21dO189RVttXTtmb3IoYj0wO2I8UztiKyspVVtMK2JdfD1fW2JdfWVsc2V7bGV0IGUsdDtmb3IobT0wO208azttKyspe3Q9aittO2lmKCEodDwwfHx0Pj1pKSl7VT1wW3RdO189RVttXTtmb3IoYj0wO2I8UztiKyspe2U9TCtiO2U+PTAmJmU8ciYmKFVbZV18PV9bYl0pfX19fX1yZXR1cm4gcH0oZS5tbXIsbixlLnRlbXBsYXRlLHMud2lkdGgscy5oZWlnaHQsZS5kZWZhdWx0UGl4ZWxWYWx1ZSxlLmVuYWJsZVNraXAsZS5jb21iaW5hdGlvbk9wZXJhdG9yLGUuZ3JpZFdpZHRoLGUuZ3JpZEhlaWdodCxlLmdyaWRPZmZzZXRYLGUuZ3JpZE9mZnNldFksZS5ncmlkVmVjdG9yWCxlLmdyaWRWZWN0b3JZLG8pO3RoaXMuZHJhd0JpdG1hcChzLGMpfW9uSW1tZWRpYXRlTG9zc2xlc3NIYWxmdG9uZVJlZ2lvbigpe3RoaXMub25JbW1lZGlhdGVIYWxmdG9uZVJlZ2lvbiguLi5hcmd1bWVudHMpfW9uVGFibGVzKGUsdCxhLHIpe2xldCBpPXRoaXMuY3VzdG9tVGFibGVzO2l8fCh0aGlzLmN1c3RvbVRhYmxlcz1pPXt9KTtpW2VdPWZ1bmN0aW9uIGRlY29kZVRhYmxlc1NlZ21lbnQoZSx0LGEpe2NvbnN0IHI9ZVt0XSxpPTQyOTQ5NjcyOTUmcmVhZFVpbnQzMihlLHQrMSksbj00Mjk0OTY3Mjk1JnJlYWRVaW50MzIoZSx0KzUpLHM9bmV3IFJlYWRlcihlLHQrOSxhKSxvPTErKHI+PjEmNyksYz0xKyhyPj40JjcpLGw9W107bGV0IGgsdSxkPWk7ZG97aD1zLnJlYWRCaXRzKG8pO3U9cy5yZWFkQml0cyhjKTtsLnB1c2gobmV3IEh1ZmZtYW5MaW5lKFtkLGgsdSwwXSkpO2QrPTE8PHV9d2hpbGUoZDxuKTtoPXMucmVhZEJpdHMobyk7bC5wdXNoKG5ldyBIdWZmbWFuTGluZShbaS0xLGgsMzIsMCwibG93ZXIiXSkpO2g9cy5yZWFkQml0cyhvKTtsLnB1c2gobmV3IEh1ZmZtYW5MaW5lKFtuLGgsMzIsMF0pKTtpZigxJnIpe2g9cy5yZWFkQml0cyhvKTtsLnB1c2gobmV3IEh1ZmZtYW5MaW5lKFtoLDBdKSl9cmV0dXJuIG5ldyBIdWZmbWFuVGFibGUobCwhMSl9KHQsYSxyKX19Y2xhc3MgSHVmZm1hbkxpbmV7Y29uc3RydWN0b3IoZSl7aWYoMj09PWUubGVuZ3RoKXt0aGlzLmlzT09CPSEwO3RoaXMucmFuZ2VMb3c9MDt0aGlzLnByZWZpeExlbmd0aD1lWzBdO3RoaXMucmFuZ2VMZW5ndGg9MDt0aGlzLnByZWZpeENvZGU9ZVsxXTt0aGlzLmlzTG93ZXJSYW5nZT0hMX1lbHNle3RoaXMuaXNPT0I9ITE7dGhpcy5yYW5nZUxvdz1lWzBdO3RoaXMucHJlZml4TGVuZ3RoPWVbMV07dGhpcy5yYW5nZUxlbmd0aD1lWzJdO3RoaXMucHJlZml4Q29kZT1lWzNdO3RoaXMuaXNMb3dlclJhbmdlPSJsb3dlciI9PT1lWzRdfX19Y2xhc3MgSHVmZm1hblRyZWVOb2Rle2NvbnN0cnVjdG9yKGUpe3RoaXMuY2hpbGRyZW49W107aWYoZSl7dGhpcy5pc0xlYWY9ITA7dGhpcy5yYW5nZUxlbmd0aD1lLnJhbmdlTGVuZ3RoO3RoaXMucmFuZ2VMb3c9ZS5yYW5nZUxvdzt0aGlzLmlzTG93ZXJSYW5nZT1lLmlzTG93ZXJSYW5nZTt0aGlzLmlzT09CPWUuaXNPT0J9ZWxzZSB0aGlzLmlzTGVhZj0hMX1idWlsZFRyZWUoZSx0KXtjb25zdCBhPWUucHJlZml4Q29kZT4+dCYxO2lmKHQ8PTApdGhpcy5jaGlsZHJlblthXT1uZXcgSHVmZm1hblRyZWVOb2RlKGUpO2Vsc2V7bGV0IHI9dGhpcy5jaGlsZHJlblthXTtyfHwodGhpcy5jaGlsZHJlblthXT1yPW5ldyBIdWZmbWFuVHJlZU5vZGUobnVsbCkpO3IuYnVpbGRUcmVlKGUsdC0xKX19ZGVjb2RlTm9kZShlKXtpZih0aGlzLmlzTGVhZil7aWYodGhpcy5pc09PQilyZXR1cm4gbnVsbDtjb25zdCB0PWUucmVhZEJpdHModGhpcy5yYW5nZUxlbmd0aCk7cmV0dXJuIHRoaXMucmFuZ2VMb3crKHRoaXMuaXNMb3dlclJhbmdlPy10OnQpfWNvbnN0IHQ9dGhpcy5jaGlsZHJlbltlLnJlYWRCaXQoKV07aWYoIXQpdGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgSHVmZm1hbiBkYXRhIik7cmV0dXJuIHQuZGVjb2RlTm9kZShlKX19Y2xhc3MgSHVmZm1hblRhYmxle2NvbnN0cnVjdG9yKGUsdCl7dHx8dGhpcy5hc3NpZ25QcmVmaXhDb2RlcyhlKTt0aGlzLnJvb3ROb2RlPW5ldyBIdWZmbWFuVHJlZU5vZGUobnVsbCk7Zm9yKGxldCB0PTAsYT1lLmxlbmd0aDt0PGE7dCsrKXtjb25zdCBhPWVbdF07YS5wcmVmaXhMZW5ndGg+MCYmdGhpcy5yb290Tm9kZS5idWlsZFRyZWUoYSxhLnByZWZpeExlbmd0aC0xKX19ZGVjb2RlKGUpe3JldHVybiB0aGlzLnJvb3ROb2RlLmRlY29kZU5vZGUoZSl9YXNzaWduUHJlZml4Q29kZXMoZSl7Y29uc3QgdD1lLmxlbmd0aDtsZXQgYT0wO2ZvcihsZXQgcj0wO3I8dDtyKyspYT1NYXRoLm1heChhLGVbcl0ucHJlZml4TGVuZ3RoKTtjb25zdCByPW5ldyBVaW50MzJBcnJheShhKzEpO2ZvcihsZXQgYT0wO2E8dDthKyspcltlW2FdLnByZWZpeExlbmd0aF0rKztsZXQgaSxuLHMsbz0xLGM9MDtyWzBdPTA7Zm9yKDtvPD1hOyl7Yz1jK3Jbby0xXTw8MTtpPWM7bj0wO2Zvcig7bjx0Oyl7cz1lW25dO2lmKHMucHJlZml4TGVuZ3RoPT09byl7cy5wcmVmaXhDb2RlPWk7aSsrfW4rK31vKyt9fX1jb25zdCBaYT17fTtmdW5jdGlvbiBnZXRTdGFuZGFyZFRhYmxlKGUpe2xldCB0LGE9WmFbZV07aWYoYSlyZXR1cm4gYTtzd2l0Y2goZSl7Y2FzZSAxOnQ9W1swLDEsNCwwXSxbMTYsMiw4LDJdLFsyNzIsMywxNiw2XSxbNjU4MDgsMywzMiw3XV07YnJlYWs7Y2FzZSAyOnQ9W1swLDEsMCwwXSxbMSwyLDAsMl0sWzIsMywwLDZdLFszLDQsMywxNF0sWzExLDUsNiwzMF0sWzc1LDYsMzIsNjJdLFs2LDYzXV07YnJlYWs7Y2FzZSAzOnQ9W1stMjU2LDgsOCwyNTRdLFswLDEsMCwwXSxbMSwyLDAsMl0sWzIsMywwLDZdLFszLDQsMywxNF0sWzExLDUsNiwzMF0sWy0yNTcsOCwzMiwyNTUsImxvd2VyIl0sWzc1LDcsMzIsMTI2XSxbNiw2Ml1dO2JyZWFrO2Nhc2UgNDp0PVtbMSwxLDAsMF0sWzIsMiwwLDJdLFszLDMsMCw2XSxbNCw0LDMsMTRdLFsxMiw1LDYsMzBdLFs3Niw1LDMyLDMxXV07YnJlYWs7Y2FzZSA1OnQ9W1stMjU1LDcsOCwxMjZdLFsxLDEsMCwwXSxbMiwyLDAsMl0sWzMsMywwLDZdLFs0LDQsMywxNF0sWzEyLDUsNiwzMF0sWy0yNTYsNywzMiwxMjcsImxvd2VyIl0sWzc2LDYsMzIsNjJdXTticmVhaztjYXNlIDY6dD1bWy0yMDQ4LDUsMTAsMjhdLFstMTAyNCw0LDksOF0sWy01MTIsNCw4LDldLFstMjU2LDQsNywxMF0sWy0xMjgsNSw2LDI5XSxbLTY0LDUsNSwzMF0sWy0zMiw0LDUsMTFdLFswLDIsNywwXSxbMTI4LDMsNywyXSxbMjU2LDMsOCwzXSxbNTEyLDQsOSwxMl0sWzEwMjQsNCwxMCwxM10sWy0yMDQ5LDYsMzIsNjIsImxvd2VyIl0sWzIwNDgsNiwzMiw2M11dO2JyZWFrO2Nhc2UgNzp0PVtbLTEwMjQsNCw5LDhdLFstNTEyLDMsOCwwXSxbLTI1Niw0LDcsOV0sWy0xMjgsNSw2LDI2XSxbLTY0LDUsNSwyN10sWy0zMiw0LDUsMTBdLFswLDQsNSwxMV0sWzMyLDUsNSwyOF0sWzY0LDUsNiwyOV0sWzEyOCw0LDcsMTJdLFsyNTYsMyw4LDFdLFs1MTIsMyw5LDJdLFsxMDI0LDMsMTAsM10sWy0xMDI1LDUsMzIsMzAsImxvd2VyIl0sWzIwNDgsNSwzMiwzMV1dO2JyZWFrO2Nhc2UgODp0PVtbLTE1LDgsMywyNTJdLFstNyw5LDEsNTA4XSxbLTUsOCwxLDI1M10sWy0zLDksMCw1MDldLFstMiw3LDAsMTI0XSxbLTEsNCwwLDEwXSxbMCwyLDEsMF0sWzIsNSwwLDI2XSxbMyw2LDAsNThdLFs0LDMsNCw0XSxbMjAsNiwxLDU5XSxbMjIsNCw0LDExXSxbMzgsNCw1LDEyXSxbNzAsNSw2LDI3XSxbMTM0LDUsNywyOF0sWzI2Miw2LDcsNjBdLFszOTAsNyw4LDEyNV0sWzY0Niw2LDEwLDYxXSxbLTE2LDksMzIsNTEwLCJsb3dlciJdLFsxNjcwLDksMzIsNTExXSxbMiwxXV07YnJlYWs7Y2FzZSA5OnQ9W1stMzEsOCw0LDI1Ml0sWy0xNSw5LDIsNTA4XSxbLTExLDgsMiwyNTNdLFstNyw5LDEsNTA5XSxbLTUsNywxLDEyNF0sWy0zLDQsMSwxMF0sWy0xLDMsMSwyXSxbMSwzLDEsM10sWzMsNSwxLDI2XSxbNSw2LDEsNThdLFs3LDMsNSw0XSxbMzksNiwyLDU5XSxbNDMsNCw1LDExXSxbNzUsNCw2LDEyXSxbMTM5LDUsNywyN10sWzI2Nyw1LDgsMjhdLFs1MjMsNiw4LDYwXSxbNzc5LDcsOSwxMjVdLFsxMjkxLDYsMTEsNjFdLFstMzIsOSwzMiw1MTAsImxvd2VyIl0sWzMzMzksOSwzMiw1MTFdLFsyLDBdXTticmVhaztjYXNlIDEwOnQ9W1stMjEsNyw0LDEyMl0sWy01LDgsMCwyNTJdLFstNCw3LDAsMTIzXSxbLTMsNSwwLDI0XSxbLTIsMiwyLDBdLFsyLDUsMCwyNV0sWzMsNiwwLDU0XSxbNCw3LDAsMTI0XSxbNSw4LDAsMjUzXSxbNiwyLDYsMV0sWzcwLDUsNSwyNl0sWzEwMiw2LDUsNTVdLFsxMzQsNiw2LDU2XSxbMTk4LDYsNyw1N10sWzMyNiw2LDgsNThdLFs1ODIsNiw5LDU5XSxbMTA5NCw2LDEwLDYwXSxbMjExOCw3LDExLDEyNV0sWy0yMiw4LDMyLDI1NCwibG93ZXIiXSxbNDE2Niw4LDMyLDI1NV0sWzIsMl1dO2JyZWFrO2Nhc2UgMTE6dD1bWzEsMSwwLDBdLFsyLDIsMSwyXSxbNCw0LDAsMTJdLFs1LDQsMSwxM10sWzcsNSwxLDI4XSxbOSw1LDIsMjldLFsxMyw2LDIsNjBdLFsxNyw3LDIsMTIyXSxbMjEsNywzLDEyM10sWzI5LDcsNCwxMjRdLFs0NSw3LDUsMTI1XSxbNzcsNyw2LDEyNl0sWzE0MSw3LDMyLDEyN11dO2JyZWFrO2Nhc2UgMTI6dD1bWzEsMSwwLDBdLFsyLDIsMCwyXSxbMywzLDEsNl0sWzUsNSwwLDI4XSxbNiw1LDEsMjldLFs4LDYsMSw2MF0sWzEwLDcsMCwxMjJdLFsxMSw3LDEsMTIzXSxbMTMsNywyLDEyNF0sWzE3LDcsMywxMjVdLFsyNSw3LDQsMTI2XSxbNDEsOCw1LDI1NF0sWzczLDgsMzIsMjU1XV07YnJlYWs7Y2FzZSAxMzp0PVtbMSwxLDAsMF0sWzIsMywwLDRdLFszLDQsMCwxMl0sWzQsNSwwLDI4XSxbNSw0LDEsMTNdLFs3LDMsMyw1XSxbMTUsNiwxLDU4XSxbMTcsNiwyLDU5XSxbMjEsNiwzLDYwXSxbMjksNiw0LDYxXSxbNDUsNiw1LDYyXSxbNzcsNyw2LDEyNl0sWzE0MSw3LDMyLDEyN11dO2JyZWFrO2Nhc2UgMTQ6dD1bWy0yLDMsMCw0XSxbLTEsMywwLDVdLFswLDEsMCwwXSxbMSwzLDAsNl0sWzIsMywwLDddXTticmVhaztjYXNlIDE1OnQ9W1stMjQsNyw0LDEyNF0sWy04LDYsMiw2MF0sWy00LDUsMSwyOF0sWy0yLDQsMCwxMl0sWy0xLDMsMCw0XSxbMCwxLDAsMF0sWzEsMywwLDVdLFsyLDQsMCwxM10sWzMsNSwxLDI5XSxbNSw2LDIsNjFdLFs5LDcsNCwxMjVdLFstMjUsNywzMiwxMjYsImxvd2VyIl0sWzI1LDcsMzIsMTI3XV07YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcihgc3RhbmRhcmQgdGFibGUgQi4ke2V9IGRvZXMgbm90IGV4aXN0YCl9Zm9yKGxldCBlPTAsYT10Lmxlbmd0aDtlPGE7ZSsrKXRbZV09bmV3IEh1ZmZtYW5MaW5lKHRbZV0pO2E9bmV3IEh1ZmZtYW5UYWJsZSh0LCEwKTtaYVtlXT1hO3JldHVybiBhfWNsYXNzIFJlYWRlcntjb25zdHJ1Y3RvcihlLHQsYSl7dGhpcy5kYXRhPWU7dGhpcy5zdGFydD10O3RoaXMuZW5kPWE7dGhpcy5wb3NpdGlvbj10O3RoaXMuc2hpZnQ9LTE7dGhpcy5jdXJyZW50Qnl0ZT0wfXJlYWRCaXQoKXtpZih0aGlzLnNoaWZ0PDApe2lmKHRoaXMucG9zaXRpb24+PXRoaXMuZW5kKXRocm93IG5ldyBKYmlnMkVycm9yKCJlbmQgb2YgZGF0YSB3aGlsZSByZWFkaW5nIGJpdCIpO3RoaXMuY3VycmVudEJ5dGU9dGhpcy5kYXRhW3RoaXMucG9zaXRpb24rK107dGhpcy5zaGlmdD03fWNvbnN0IGU9dGhpcy5jdXJyZW50Qnl0ZT4+dGhpcy5zaGlmdCYxO3RoaXMuc2hpZnQtLTtyZXR1cm4gZX1yZWFkQml0cyhlKXtsZXQgdCxhPTA7Zm9yKHQ9ZS0xO3Q+PTA7dC0tKWF8PXRoaXMucmVhZEJpdCgpPDx0O3JldHVybiBhfWJ5dGVBbGlnbigpe3RoaXMuc2hpZnQ9LTF9bmV4dCgpe3JldHVybiB0aGlzLnBvc2l0aW9uPj10aGlzLmVuZD8tMTp0aGlzLmRhdGFbdGhpcy5wb3NpdGlvbisrXX19ZnVuY3Rpb24gZ2V0Q3VzdG9tSHVmZm1hblRhYmxlKGUsdCxhKXtsZXQgcj0wO2ZvcihsZXQgaT0wLG49dC5sZW5ndGg7aTxuO2krKyl7Y29uc3Qgbj1hW3RbaV1dO2lmKG4pe2lmKGU9PT1yKXJldHVybiBuO3IrK319dGhyb3cgbmV3IEpiaWcyRXJyb3IoImNhbid0IGZpbmQgY3VzdG9tIEh1ZmZtYW4gdGFibGUiKX1mdW5jdGlvbiByZWFkVW5jb21wcmVzc2VkQml0bWFwKGUsdCxhKXtjb25zdCByPVtdO2ZvcihsZXQgaT0wO2k8YTtpKyspe2NvbnN0IGE9bmV3IFVpbnQ4QXJyYXkodCk7ci5wdXNoKGEpO2ZvcihsZXQgcj0wO3I8dDtyKyspYVtyXT1lLnJlYWRCaXQoKTtlLmJ5dGVBbGlnbigpfXJldHVybiByfWZ1bmN0aW9uIGRlY29kZU1NUkJpdG1hcChlLHQsYSxyKXtjb25zdCBpPW5ldyBDQ0lUVEZheERlY29kZXIoZSx7SzotMSxDb2x1bW5zOnQsUm93czphLEJsYWNrSXMxOiEwLEVuZE9mQmxvY2s6cn0pLG49W107bGV0IHMsbz0hMTtmb3IobGV0IGU9MDtlPGE7ZSsrKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KHQpO24ucHVzaChlKTtsZXQgYT0tMTtmb3IobGV0IHI9MDtyPHQ7cisrKXtpZihhPDApe3M9aS5yZWFkTmV4dENoYXIoKTtpZigtMT09PXMpe3M9MDtvPSEwfWE9N31lW3JdPXM+PmEmMTthLS19fWlmKHImJiFvKXtjb25zdCBlPTU7Zm9yKGxldCB0PTA7dDxlJiYtMSE9PWkucmVhZE5leHRDaGFyKCk7dCsrKTt9cmV0dXJuIG59Y2xhc3MgSmJpZzJJbWFnZXtwYXJzZUNodW5rcyhlKXtyZXR1cm4gZnVuY3Rpb24gcGFyc2VKYmlnMkNodW5rcyhlKXtjb25zdCB0PW5ldyBTaW1wbGVTZWdtZW50VmlzaXRvcjtmb3IobGV0IGE9MCxyPWUubGVuZ3RoO2E8cjthKyspe2NvbnN0IHI9ZVthXTtwcm9jZXNzU2VnbWVudHMocmVhZFNlZ21lbnRzKHt9LHIuZGF0YSxyLnN0YXJ0LHIuZW5kKSx0KX1yZXR1cm4gdC5idWZmZXJ9KGUpfXBhcnNlKGUpe3Rocm93IG5ldyBFcnJvcigiTm90IGltcGxlbWVudGVkOiBKYmlnMkltYWdlLnBhcnNlIil9fWNsYXNzIEpiaWcyU3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcih0KTt0aGlzLnN0cmVhbT1lO3RoaXMuZGljdD1lLmRpY3Q7dGhpcy5tYXliZUxlbmd0aD10O3RoaXMucGFyYW1zPWF9Z2V0IGJ5dGVzKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJieXRlcyIsdGhpcy5zdHJlYW0uZ2V0Qnl0ZXModGhpcy5tYXliZUxlbmd0aCkpfWVuc3VyZUJ1ZmZlcihlKXt9cmVhZEJsb2NrKCl7dGhpcy5kZWNvZGVJbWFnZSgpfWRlY29kZUltYWdlKGUpe2lmKHRoaXMuZW9mKXJldHVybiB0aGlzLmJ1ZmZlcjtlfHw9dGhpcy5ieXRlcztjb25zdCB0PW5ldyBKYmlnMkltYWdlLGE9W107aWYodGhpcy5wYXJhbXMgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBlPXRoaXMucGFyYW1zLmdldCgiSkJJRzJHbG9iYWxzIik7aWYoZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pe2NvbnN0IHQ9ZS5nZXRCeXRlcygpO2EucHVzaCh7ZGF0YTp0LHN0YXJ0OjAsZW5kOnQubGVuZ3RofSl9fWEucHVzaCh7ZGF0YTplLHN0YXJ0OjAsZW5kOmUubGVuZ3RofSk7Y29uc3Qgcj10LnBhcnNlQ2h1bmtzKGEpLGk9ci5sZW5ndGg7Zm9yKGxldCBlPTA7ZTxpO2UrKylyW2VdXj0yNTU7dGhpcy5idWZmZXI9cjt0aGlzLmJ1ZmZlckxlbmd0aD1pO3RoaXMuZW9mPSEwO3JldHVybiB0aGlzLmJ1ZmZlcn1nZXQgY2FuQXN5bmNEZWNvZGVJbWFnZUZyb21CdWZmZXIoKXtyZXR1cm4gdGhpcy5zdHJlYW0uaXNBc3luY319Y2xhc3MgSnB4U3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcih0KTt0aGlzLnN0cmVhbT1lO3RoaXMuZGljdD1lLmRpY3Q7dGhpcy5tYXliZUxlbmd0aD10O3RoaXMucGFyYW1zPWF9Z2V0IGJ5dGVzKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJieXRlcyIsdGhpcy5zdHJlYW0uZ2V0Qnl0ZXModGhpcy5tYXliZUxlbmd0aCkpfWVuc3VyZUJ1ZmZlcihlKXt9cmVhZEJsb2NrKGUpe3VucmVhY2hhYmxlKCJKcHhTdHJlYW0ucmVhZEJsb2NrIil9Z2V0IGlzQXN5bmNEZWNvZGVyKCl7cmV0dXJuITB9YXN5bmMgZGVjb2RlSW1hZ2UoZSx0KXtpZih0aGlzLmVvZilyZXR1cm4gdGhpcy5idWZmZXI7ZXx8PXRoaXMuYnl0ZXM7dGhpcy5idWZmZXI9YXdhaXQgSnB4SW1hZ2UuZGVjb2RlKGUsdCk7dGhpcy5idWZmZXJMZW5ndGg9dGhpcy5idWZmZXIubGVuZ3RoO3RoaXMuZW9mPSEwO3JldHVybiB0aGlzLmJ1ZmZlcn1nZXQgY2FuQXN5bmNEZWNvZGVJbWFnZUZyb21CdWZmZXIoKXtyZXR1cm4gdGhpcy5zdHJlYW0uaXNBc3luY319Y2xhc3MgTFpXU3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcih0KTt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3Q7dGhpcy5jYWNoZWREYXRhPTA7dGhpcy5iaXRzQ2FjaGVkPTA7Y29uc3Qgcj00MDk2LGk9e2Vhcmx5Q2hhbmdlOmEsY29kZUxlbmd0aDo5LG5leHRDb2RlOjI1OCxkaWN0aW9uYXJ5VmFsdWVzOm5ldyBVaW50OEFycmF5KHIpLGRpY3Rpb25hcnlMZW5ndGhzOm5ldyBVaW50MTZBcnJheShyKSxkaWN0aW9uYXJ5UHJldkNvZGVzOm5ldyBVaW50MTZBcnJheShyKSxjdXJyZW50U2VxdWVuY2U6bmV3IFVpbnQ4QXJyYXkociksY3VycmVudFNlcXVlbmNlTGVuZ3RoOjB9O2ZvcihsZXQgZT0wO2U8MjU2OysrZSl7aS5kaWN0aW9uYXJ5VmFsdWVzW2VdPWU7aS5kaWN0aW9uYXJ5TGVuZ3Roc1tlXT0xfXRoaXMubHp3U3RhdGU9aX1yZWFkQml0cyhlKXtsZXQgdD10aGlzLmJpdHNDYWNoZWQsYT10aGlzLmNhY2hlZERhdGE7Zm9yKDt0PGU7KXtjb25zdCBlPXRoaXMuc3RyLmdldEJ5dGUoKTtpZigtMT09PWUpe3RoaXMuZW9mPSEwO3JldHVybiBudWxsfWE9YTw8OHxlO3QrPTh9dGhpcy5iaXRzQ2FjaGVkPXQtPWU7dGhpcy5jYWNoZWREYXRhPWE7dGhpcy5sYXN0Q29kZT1udWxsO3JldHVybiBhPj4+dCYoMTw8ZSktMX1yZWFkQmxvY2soKXtsZXQgZSx0LGEscj0xMDI0O2NvbnN0IGk9dGhpcy5sendTdGF0ZTtpZighaSlyZXR1cm47Y29uc3Qgbj1pLmVhcmx5Q2hhbmdlO2xldCBzPWkubmV4dENvZGU7Y29uc3Qgbz1pLmRpY3Rpb25hcnlWYWx1ZXMsYz1pLmRpY3Rpb25hcnlMZW5ndGhzLGw9aS5kaWN0aW9uYXJ5UHJldkNvZGVzO2xldCBoPWkuY29kZUxlbmd0aCx1PWkucHJldkNvZGU7Y29uc3QgZD1pLmN1cnJlbnRTZXF1ZW5jZTtsZXQgZj1pLmN1cnJlbnRTZXF1ZW5jZUxlbmd0aCxnPTAscD10aGlzLmJ1ZmZlckxlbmd0aCxtPXRoaXMuZW5zdXJlQnVmZmVyKHRoaXMuYnVmZmVyTGVuZ3RoK3IpO2ZvcihlPTA7ZTw1MTI7ZSsrKXtjb25zdCBlPXRoaXMucmVhZEJpdHMoaCksaT1mPjA7aWYoZTwyNTYpe2RbMF09ZTtmPTF9ZWxzZXtpZighKGU+PTI1OCkpe2lmKDI1Nj09PWUpe2g9OTtzPTI1ODtmPTA7Y29udGludWV9dGhpcy5lb2Y9ITA7ZGVsZXRlIHRoaXMubHp3U3RhdGU7YnJlYWt9aWYoZTxzKXtmPWNbZV07Zm9yKHQ9Zi0xLGE9ZTt0Pj0wO3QtLSl7ZFt0XT1vW2FdO2E9bFthXX19ZWxzZSBkW2YrK109ZFswXX1pZihpKXtsW3NdPXU7Y1tzXT1jW3VdKzE7b1tzXT1kWzBdO3MrKztoPXMrbiZzK24tMT9oOjB8TWF0aC5taW4oTWF0aC5sb2cocytuKS8uNjkzMTQ3MTgwNTU5OTQ1MysxLDEyKX11PWU7Zys9ZjtpZihyPGcpe2Rve3IrPTUxMn13aGlsZShyPGcpO209dGhpcy5lbnN1cmVCdWZmZXIodGhpcy5idWZmZXJMZW5ndGgrcil9Zm9yKHQ9MDt0PGY7dCsrKW1bcCsrXT1kW3RdfWkubmV4dENvZGU9cztpLmNvZGVMZW5ndGg9aDtpLnByZXZDb2RlPXU7aS5jdXJyZW50U2VxdWVuY2VMZW5ndGg9Zjt0aGlzLmJ1ZmZlckxlbmd0aD1wfX1jbGFzcyBQcmVkaWN0b3JTdHJlYW0gZXh0ZW5kcyBEZWNvZGVTdHJlYW17Y29uc3RydWN0b3IoZSx0LGEpe3N1cGVyKHQpO2lmKCEoYSBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBlO2NvbnN0IHI9dGhpcy5wcmVkaWN0b3I9YS5nZXQoIlByZWRpY3RvciIpfHwxO2lmKHI8PTEpcmV0dXJuIGU7aWYoMiE9PXImJihyPDEwfHxyPjE1KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHByZWRpY3RvcjogJHtyfWApO3RoaXMucmVhZEJsb2NrPTI9PT1yP3RoaXMucmVhZEJsb2NrVGlmZjp0aGlzLnJlYWRCbG9ja1BuZzt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3Q7Y29uc3QgaT10aGlzLmNvbG9ycz1hLmdldCgiQ29sb3JzIil8fDEsbj10aGlzLmJpdHM9YS5nZXQoIkJQQyIsIkJpdHNQZXJDb21wb25lbnQiKXx8OCxzPXRoaXMuY29sdW1ucz1hLmdldCgiQ29sdW1ucyIpfHwxO3RoaXMucGl4Qnl0ZXM9aSpuKzc+PjM7dGhpcy5yb3dCeXRlcz1zKmkqbis3Pj4zO3JldHVybiB0aGlzfXJlYWRCbG9ja1RpZmYoKXtjb25zdCBlPXRoaXMucm93Qnl0ZXMsdD10aGlzLmJ1ZmZlckxlbmd0aCxhPXRoaXMuZW5zdXJlQnVmZmVyKHQrZSkscj10aGlzLmJpdHMsaT10aGlzLmNvbG9ycyxuPXRoaXMuc3RyLmdldEJ5dGVzKGUpO3RoaXMuZW9mPSFuLmxlbmd0aDtpZih0aGlzLmVvZilyZXR1cm47bGV0IHMsbz0wLGM9MCxsPTAsaD0wLHU9dDtpZigxPT09ciYmMT09PWkpZm9yKHM9MDtzPGU7KytzKXtsZXQgZT1uW3NdXm87ZV49ZT4+MTtlXj1lPj4yO2VePWU+PjQ7bz0oMSZlKTw8NzthW3UrK109ZX1lbHNlIGlmKDg9PT1yKXtmb3Iocz0wO3M8aTsrK3MpYVt1KytdPW5bc107Zm9yKDtzPGU7KytzKXthW3VdPWFbdS1pXStuW3NdO3UrK319ZWxzZSBpZigxNj09PXIpe2NvbnN0IHQ9MippO2ZvcihzPTA7czx0OysrcylhW3UrK109bltzXTtmb3IoO3M8ZTtzKz0yKXtjb25zdCBlPSgoMjU1Jm5bc10pPDw4KSsoMjU1Jm5bcysxXSkrKCgyNTUmYVt1LXRdKTw8OCkrKDI1NSZhW3UtdCsxXSk7YVt1KytdPWU+PjgmMjU1O2FbdSsrXT0yNTUmZX19ZWxzZXtjb25zdCBlPW5ldyBVaW50OEFycmF5KGkrMSksdT0oMTw8ciktMTtsZXQgZD0wLGY9dDtjb25zdCBnPXRoaXMuY29sdW1ucztmb3Iocz0wO3M8ZzsrK3MpZm9yKGxldCB0PTA7dDxpOysrdCl7aWYobDxyKXtvPW88PDh8MjU1Jm5bZCsrXTtsKz04fWVbdF09ZVt0XSsobz4+bC1yKSZ1O2wtPXI7Yz1jPDxyfGVbdF07aCs9cjtpZihoPj04KXthW2YrK109Yz4+aC04JjI1NTtoLT04fX1oPjAmJihhW2YrK109KGM8PDgtaCkrKG8mKDE8PDgtaCktMSkpfXRoaXMuYnVmZmVyTGVuZ3RoKz1lfXJlYWRCbG9ja1BuZygpe2NvbnN0IGU9dGhpcy5yb3dCeXRlcyx0PXRoaXMucGl4Qnl0ZXMsYT10aGlzLnN0ci5nZXRCeXRlKCkscj10aGlzLnN0ci5nZXRCeXRlcyhlKTt0aGlzLmVvZj0hci5sZW5ndGg7aWYodGhpcy5lb2YpcmV0dXJuO2NvbnN0IGk9dGhpcy5idWZmZXJMZW5ndGgsbj10aGlzLmVuc3VyZUJ1ZmZlcihpK2UpO2xldCBzPW4uc3ViYXJyYXkoaS1lLGkpOzA9PT1zLmxlbmd0aCYmKHM9bmV3IFVpbnQ4QXJyYXkoZSkpO2xldCBvLGMsbCxoPWk7c3dpdGNoKGEpe2Nhc2UgMDpmb3Iobz0wO288ZTsrK28pbltoKytdPXJbb107YnJlYWs7Y2FzZSAxOmZvcihvPTA7bzx0OysrbyluW2grK109cltvXTtmb3IoO288ZTsrK28pe25baF09bltoLXRdK3Jbb10mMjU1O2grK31icmVhaztjYXNlIDI6Zm9yKG89MDtvPGU7KytvKW5baCsrXT1zW29dK3Jbb10mMjU1O2JyZWFrO2Nhc2UgMzpmb3Iobz0wO288dDsrK28pbltoKytdPShzW29dPj4xKStyW29dO2Zvcig7bzxlOysrbyl7bltoXT0oc1tvXStuW2gtdF0+PjEpK3Jbb10mMjU1O2grK31icmVhaztjYXNlIDQ6Zm9yKG89MDtvPHQ7KytvKXtjPXNbb107bD1yW29dO25baCsrXT1jK2x9Zm9yKDtvPGU7KytvKXtjPXNbb107Y29uc3QgZT1zW28tdF0sYT1uW2gtdF0saT1hK2MtZTtsZXQgdT1pLWE7dTwwJiYodT0tdSk7bGV0IGQ9aS1jO2Q8MCYmKGQ9LWQpO2xldCBmPWktZTtmPDAmJihmPS1mKTtsPXJbb107bltoKytdPXU8PWQmJnU8PWY/YStsOmQ8PWY/YytsOmUrbH1icmVhaztkZWZhdWx0OnRocm93IG5ldyBGb3JtYXRFcnJvcihgVW5zdXBwb3J0ZWQgcHJlZGljdG9yOiAke2F9YCl9dGhpcy5idWZmZXJMZW5ndGgrPWV9fWNsYXNzIFJ1bkxlbmd0aFN0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKHQpO3RoaXMuc3RyPWU7dGhpcy5kaWN0PWUuZGljdH1yZWFkQmxvY2soKXtjb25zdCBlPXRoaXMuc3RyLmdldEJ5dGVzKDIpO2lmKCFlfHxlLmxlbmd0aDwyfHwxMjg9PT1lWzBdKXt0aGlzLmVvZj0hMDtyZXR1cm59bGV0IHQsYT10aGlzLmJ1ZmZlckxlbmd0aCxyPWVbMF07aWYocjwxMjgpe3Q9dGhpcy5lbnN1cmVCdWZmZXIoYStyKzEpO3RbYSsrXT1lWzFdO2lmKHI+MCl7Y29uc3QgZT10aGlzLnN0ci5nZXRCeXRlcyhyKTt0LnNldChlLGEpO2ErPXJ9fWVsc2V7cj0yNTctcjt0PXRoaXMuZW5zdXJlQnVmZmVyKGErcisxKTt0LmZpbGwoZVsxXSxhLGErcik7YSs9cn10aGlzLmJ1ZmZlckxlbmd0aD1hfX1jbGFzcyBQYXJzZXJ7Y29uc3RydWN0b3Ioe2xleGVyOmUseHJlZjp0LGFsbG93U3RyZWFtczphPSExLHJlY292ZXJ5TW9kZTpyPSExfSl7dGhpcy5sZXhlcj1lO3RoaXMueHJlZj10O3RoaXMuYWxsb3dTdHJlYW1zPWE7dGhpcy5yZWNvdmVyeU1vZGU9cjt0aGlzLmltYWdlQ2FjaGU9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLl9pbWFnZUlkPTA7dGhpcy5yZWZpbGwoKX1yZWZpbGwoKXt0aGlzLmJ1ZjE9dGhpcy5sZXhlci5nZXRPYmooKTt0aGlzLmJ1ZjI9dGhpcy5sZXhlci5nZXRPYmooKX1zaGlmdCgpe2lmKHRoaXMuYnVmMiBpbnN0YW5jZW9mIENtZCYmIklEIj09PXRoaXMuYnVmMi5jbWQpe3RoaXMuYnVmMT10aGlzLmJ1ZjI7dGhpcy5idWYyPW51bGx9ZWxzZXt0aGlzLmJ1ZjE9dGhpcy5idWYyO3RoaXMuYnVmMj10aGlzLmxleGVyLmdldE9iaigpfX10cnlTaGlmdCgpe3RyeXt0aGlzLnNoaWZ0KCk7cmV0dXJuITB9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7cmV0dXJuITF9fWdldE9iaihlPW51bGwpe2NvbnN0IHQ9dGhpcy5idWYxO3RoaXMuc2hpZnQoKTtpZih0IGluc3RhbmNlb2YgQ21kKXN3aXRjaCh0LmNtZCl7Y2FzZSJCSSI6cmV0dXJuIHRoaXMubWFrZUlubGluZUltYWdlKGUpO2Nhc2UiWyI6Y29uc3QgYT1bXTtmb3IoOyFpc0NtZCh0aGlzLmJ1ZjEsIl0iKSYmdGhpcy5idWYxIT09YWE7KWEucHVzaCh0aGlzLmdldE9iaihlKSk7aWYodGhpcy5idWYxPT09YWEpe2lmKHRoaXMucmVjb3ZlcnlNb2RlKXJldHVybiBhO3Rocm93IG5ldyBQYXJzZXJFT0ZFeGNlcHRpb24oIkVuZCBvZiBmaWxlIGluc2lkZSBhcnJheS4iKX10aGlzLnNoaWZ0KCk7cmV0dXJuIGE7Y2FzZSI8PCI6Y29uc3Qgcj1uZXcgRGljdCh0aGlzLnhyZWYpO2Zvcig7IWlzQ21kKHRoaXMuYnVmMSwiPj4iKSYmdGhpcy5idWYxIT09YWE7KXtpZighKHRoaXMuYnVmMSBpbnN0YW5jZW9mIE5hbWUpKXtpbmZvKCJNYWxmb3JtZWQgZGljdGlvbmFyeToga2V5IG11c3QgYmUgYSBuYW1lIG9iamVjdCIpO3RoaXMuc2hpZnQoKTtjb250aW51ZX1jb25zdCB0PXRoaXMuYnVmMS5uYW1lO3RoaXMuc2hpZnQoKTtpZih0aGlzLmJ1ZjE9PT1hYSlicmVhaztyLnNldCh0LHRoaXMuZ2V0T2JqKGUpKX1pZih0aGlzLmJ1ZjE9PT1hYSl7aWYodGhpcy5yZWNvdmVyeU1vZGUpcmV0dXJuIHI7dGhyb3cgbmV3IFBhcnNlckVPRkV4Y2VwdGlvbigiRW5kIG9mIGZpbGUgaW5zaWRlIGRpY3Rpb25hcnkuIil9aWYoaXNDbWQodGhpcy5idWYyLCJzdHJlYW0iKSlyZXR1cm4gdGhpcy5hbGxvd1N0cmVhbXM/dGhpcy5tYWtlU3RyZWFtKHIsZSk6cjt0aGlzLnNoaWZ0KCk7cmV0dXJuIHI7ZGVmYXVsdDpyZXR1cm4gdH1pZihOdW1iZXIuaXNJbnRlZ2VyKHQpKXtpZihOdW1iZXIuaXNJbnRlZ2VyKHRoaXMuYnVmMSkmJmlzQ21kKHRoaXMuYnVmMiwiUiIpKXtjb25zdCBlPVJlZi5nZXQodCx0aGlzLmJ1ZjEpO3RoaXMuc2hpZnQoKTt0aGlzLnNoaWZ0KCk7cmV0dXJuIGV9cmV0dXJuIHR9cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0JiZlP2UuZGVjcnlwdFN0cmluZyh0KTp0fWZpbmREZWZhdWx0SW5saW5lU3RyZWFtRW5kKGUpe2NvbnN0e2tub3duQ29tbWFuZHM6dH09dGhpcy5sZXhlcixhPWUucG9zO2xldCByLGksbj0wO2Zvcig7LTEhPT0ocj1lLmdldEJ5dGUoKSk7KWlmKDA9PT1uKW49Njk9PT1yPzE6MDtlbHNlIGlmKDE9PT1uKW49NzM9PT1yPzI6MDtlbHNlIGlmKDMyPT09cnx8MTA9PT1yfHwxMz09PXIpe2k9ZS5wb3M7Y29uc3QgYT1lLnBlZWtCeXRlcygxNSkscz1hLmxlbmd0aDtpZigwPT09cylicmVhaztmb3IobGV0IGU9MDtlPHM7ZSsrKXtyPWFbZV07aWYoKDAhPT1yfHwwPT09YVtlKzFdKSYmKDEwIT09ciYmMTMhPT1yJiYocjwzMnx8cj4xMjcpKSl7bj0wO2JyZWFrfX1pZigyIT09biljb250aW51ZTtpZighdCl7d2FybigiZmluZERlZmF1bHRJbmxpbmVTdHJlYW1FbmQgLSBgbGV4ZXIua25vd25Db21tYW5kc2AgaXMgdW5kZWZpbmVkLiIpO2NvbnRpbnVlfWNvbnN0IG89bmV3IExleGVyKG5ldyBTdHJlYW0oZS5wZWVrQnl0ZXMoNzUpKSx0KTtvLl9oZXhTdHJpbmdXYXJuPSgpPT57fTtsZXQgYz0wO2Zvcig7Oyl7Y29uc3QgZT1vLmdldE9iaigpO2lmKGU9PT1hYSl7bj0wO2JyZWFrfWlmKGUgaW5zdGFuY2VvZiBDbWQpe2NvbnN0IGE9dFtlLmNtZF07aWYoIWEpe249MDticmVha31pZihhLnZhcmlhYmxlQXJncz9jPD1hLm51bUFyZ3M6Yz09PWEubnVtQXJncylicmVhaztjPTB9ZWxzZSBjKyt9aWYoMj09PW4pYnJlYWt9ZWxzZSBuPTA7aWYoLTE9PT1yKXt3YXJuKCJmaW5kRGVmYXVsdElubGluZVN0cmVhbUVuZDogUmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aG91dCBmaW5kaW5nIGEgdmFsaWQgRUkgbWFya2VyIik7aWYoaSl7d2FybignLi4uIHRyeWluZyB0byByZWNvdmVyIGJ5IHVzaW5nIHRoZSBsYXN0ICJFSSIgb2NjdXJyZW5jZS4nKTtlLnNraXAoLShlLnBvcy1pKSl9fWxldCBzPTQ7ZS5za2lwKC1zKTtyPWUucGVla0J5dGUoKTtlLnNraXAocyk7aXNXaGl0ZVNwYWNlKHIpfHxzLS07cmV0dXJuIGUucG9zLXMtYX1maW5kRENURGVjb2RlSW5saW5lU3RyZWFtRW5kKGUpe2NvbnN0IHQ9ZS5wb3M7bGV0IGEscixpPSExO2Zvcig7LTEhPT0oYT1lLmdldEJ5dGUoKSk7KWlmKDI1NT09PWEpe3N3aXRjaChlLmdldEJ5dGUoKSl7Y2FzZSAwOmJyZWFrO2Nhc2UgMjU1OmUuc2tpcCgtMSk7YnJlYWs7Y2FzZSAyMTc6aT0hMDticmVhaztjYXNlIDE5MjpjYXNlIDE5MzpjYXNlIDE5NDpjYXNlIDE5NTpjYXNlIDE5NzpjYXNlIDE5ODpjYXNlIDE5OTpjYXNlIDIwMTpjYXNlIDIwMjpjYXNlIDIwMzpjYXNlIDIwNTpjYXNlIDIwNjpjYXNlIDIwNzpjYXNlIDE5NjpjYXNlIDIwNDpjYXNlIDIxODpjYXNlIDIxOTpjYXNlIDIyMDpjYXNlIDIyMTpjYXNlIDIyMjpjYXNlIDIyMzpjYXNlIDIyNDpjYXNlIDIyNTpjYXNlIDIyNjpjYXNlIDIyNzpjYXNlIDIyODpjYXNlIDIyOTpjYXNlIDIzMDpjYXNlIDIzMTpjYXNlIDIzMjpjYXNlIDIzMzpjYXNlIDIzNDpjYXNlIDIzNTpjYXNlIDIzNjpjYXNlIDIzNzpjYXNlIDIzODpjYXNlIDIzOTpjYXNlIDI1NDpyPWUuZ2V0VWludDE2KCk7cj4yP2Uuc2tpcChyLTIpOmUuc2tpcCgtMil9aWYoaSlicmVha31jb25zdCBuPWUucG9zLXQ7aWYoLTE9PT1hKXt3YXJuKCJJbmxpbmUgRENURGVjb2RlIGltYWdlIHN0cmVhbTogRU9JIG1hcmtlciBub3QgZm91bmQsIHNlYXJjaGluZyBmb3IgL0VJLyBpbnN0ZWFkLiIpO2Uuc2tpcCgtbik7cmV0dXJuIHRoaXMuZmluZERlZmF1bHRJbmxpbmVTdHJlYW1FbmQoZSl9dGhpcy5pbmxpbmVTdHJlYW1Ta2lwRUkoZSk7cmV0dXJuIG59ZmluZEFTQ0lJODVEZWNvZGVJbmxpbmVTdHJlYW1FbmQoZSl7Y29uc3QgdD1lLnBvcztsZXQgYTtmb3IoOy0xIT09KGE9ZS5nZXRCeXRlKCkpOylpZigxMjY9PT1hKXtjb25zdCB0PWUucG9zO2E9ZS5wZWVrQnl0ZSgpO2Zvcig7aXNXaGl0ZVNwYWNlKGEpOyl7ZS5za2lwKCk7YT1lLnBlZWtCeXRlKCl9aWYoNjI9PT1hKXtlLnNraXAoKTticmVha31pZihlLnBvcz50KXtjb25zdCB0PWUucGVla0J5dGVzKDIpO2lmKDY5PT09dFswXSYmNzM9PT10WzFdKWJyZWFrfX1jb25zdCByPWUucG9zLXQ7aWYoLTE9PT1hKXt3YXJuKCJJbmxpbmUgQVNDSUk4NURlY29kZSBpbWFnZSBzdHJlYW06IEVPRCBtYXJrZXIgbm90IGZvdW5kLCBzZWFyY2hpbmcgZm9yIC9FSS8gaW5zdGVhZC4iKTtlLnNraXAoLXIpO3JldHVybiB0aGlzLmZpbmREZWZhdWx0SW5saW5lU3RyZWFtRW5kKGUpfXRoaXMuaW5saW5lU3RyZWFtU2tpcEVJKGUpO3JldHVybiByfWZpbmRBU0NJSUhleERlY29kZUlubGluZVN0cmVhbUVuZChlKXtjb25zdCB0PWUucG9zO2xldCBhO2Zvcig7LTEhPT0oYT1lLmdldEJ5dGUoKSkmJjYyIT09YTspO2NvbnN0IHI9ZS5wb3MtdDtpZigtMT09PWEpe3dhcm4oIklubGluZSBBU0NJSUhleERlY29kZSBpbWFnZSBzdHJlYW06IEVPRCBtYXJrZXIgbm90IGZvdW5kLCBzZWFyY2hpbmcgZm9yIC9FSS8gaW5zdGVhZC4iKTtlLnNraXAoLXIpO3JldHVybiB0aGlzLmZpbmREZWZhdWx0SW5saW5lU3RyZWFtRW5kKGUpfXRoaXMuaW5saW5lU3RyZWFtU2tpcEVJKGUpO3JldHVybiByfWlubGluZVN0cmVhbVNraXBFSShlKXtsZXQgdCxhPTA7Zm9yKDstMSE9PSh0PWUuZ2V0Qnl0ZSgpKTspaWYoMD09PWEpYT02OT09PXQ/MTowO2Vsc2UgaWYoMT09PWEpYT03Mz09PXQ/MjowO2Vsc2UgaWYoMj09PWEpYnJlYWt9bWFrZUlubGluZUltYWdlKGUpe2NvbnN0IHQ9dGhpcy5sZXhlcixhPXQuc3RyZWFtLHI9T2JqZWN0LmNyZWF0ZShudWxsKTtsZXQgaTtmb3IoOyFpc0NtZCh0aGlzLmJ1ZjEsIklEIikmJnRoaXMuYnVmMSE9PWFhOyl7aWYoISh0aGlzLmJ1ZjEgaW5zdGFuY2VvZiBOYW1lKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkRpY3Rpb25hcnkga2V5IG11c3QgYmUgYSBuYW1lIG9iamVjdCIpO2NvbnN0IHQ9dGhpcy5idWYxLm5hbWU7dGhpcy5zaGlmdCgpO2lmKHRoaXMuYnVmMT09PWFhKWJyZWFrO3JbdF09dGhpcy5nZXRPYmooZSl9LTEhPT10LmJlZ2luSW5saW5lSW1hZ2VQb3MmJihpPWEucG9zLXQuYmVnaW5JbmxpbmVJbWFnZVBvcyk7Y29uc3Qgbj10aGlzLnhyZWYuZmV0Y2hJZlJlZihyLkZ8fHIuRmlsdGVyKTtsZXQgcztpZihuIGluc3RhbmNlb2YgTmFtZSlzPW4ubmFtZTtlbHNlIGlmKEFycmF5LmlzQXJyYXkobikpe2NvbnN0IGU9dGhpcy54cmVmLmZldGNoSWZSZWYoblswXSk7ZSBpbnN0YW5jZW9mIE5hbWUmJihzPWUubmFtZSl9Y29uc3Qgbz1hLnBvcztsZXQgYyxsO3N3aXRjaChzKXtjYXNlIkRDVCI6Y2FzZSJEQ1REZWNvZGUiOmM9dGhpcy5maW5kRENURGVjb2RlSW5saW5lU3RyZWFtRW5kKGEpO2JyZWFrO2Nhc2UiQTg1IjpjYXNlIkFTQ0lJODVEZWNvZGUiOmM9dGhpcy5maW5kQVNDSUk4NURlY29kZUlubGluZVN0cmVhbUVuZChhKTticmVhaztjYXNlIkFIeCI6Y2FzZSJBU0NJSUhleERlY29kZSI6Yz10aGlzLmZpbmRBU0NJSUhleERlY29kZUlubGluZVN0cmVhbUVuZChhKTticmVhaztkZWZhdWx0OmM9dGhpcy5maW5kRGVmYXVsdElubGluZVN0cmVhbUVuZChhKX1pZihjPDFlMyYmaT4wKXtjb25zdCBlPWEucG9zO2EucG9zPXQuYmVnaW5JbmxpbmVJbWFnZVBvcztsPWZ1bmN0aW9uIGdldElubGluZUltYWdlQ2FjaGVLZXkoZSl7Y29uc3QgdD1bXSxhPWUubGVuZ3RoO2xldCByPTA7Zm9yKDtyPGEtMTspdC5wdXNoKGVbcisrXTw8OHxlW3IrK10pO3I8YSYmdC5wdXNoKGVbcl0pO3JldHVybiBhKyJfIitTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsdCl9KGEuZ2V0Qnl0ZXMoaStjKSk7YS5wb3M9ZTtjb25zdCByPXRoaXMuaW1hZ2VDYWNoZVtsXTtpZih2b2lkIDAhPT1yKXt0aGlzLmJ1ZjI9Q21kLmdldCgiRUkiKTt0aGlzLnNoaWZ0KCk7ci5yZXNldCgpO3JldHVybiByfX1jb25zdCBoPW5ldyBEaWN0KHRoaXMueHJlZik7Zm9yKGNvbnN0IGUgaW4gciloLnNldChlLHJbZV0pO2xldCB1PWEubWFrZVN1YlN0cmVhbShvLGMsaCk7ZSYmKHU9ZS5jcmVhdGVTdHJlYW0odSxjKSk7dT10aGlzLmZpbHRlcih1LGgsYyk7dS5kaWN0PWg7aWYodm9pZCAwIT09bCl7dS5jYWNoZUtleT0iaW5saW5lX2ltZ18iKyArK3RoaXMuX2ltYWdlSWQ7dGhpcy5pbWFnZUNhY2hlW2xdPXV9dGhpcy5idWYyPUNtZC5nZXQoIkVJIik7dGhpcy5zaGlmdCgpO3JldHVybiB1fSNxKGUpe2NvbnN0e3N0cmVhbTp0fT10aGlzLmxleGVyO3QucG9zPWU7Y29uc3QgYT1uZXcgVWludDhBcnJheShbMTAxLDExMCwxMDBdKSxyPWEubGVuZ3RoLGk9W25ldyBVaW50OEFycmF5KFsxMTUsMTE2LDExNCwxMDEsOTcsMTA5XSksbmV3IFVpbnQ4QXJyYXkoWzExNSwxMTYsMTAxLDk3LDEwOV0pLG5ldyBVaW50OEFycmF5KFsxMTUsMTE2LDExNCwxMDEsOTddKV0sbj05LXI7Zm9yKDt0LnBvczx0LmVuZDspe2NvbnN0IHM9dC5wZWVrQnl0ZXMoMjA0OCksbz1zLmxlbmd0aC05O2lmKG88PTApYnJlYWs7bGV0IGM9MDtmb3IoO2M8bzspe2xldCBvPTA7Zm9yKDtvPHImJnNbYytvXT09PWFbb107KW8rKztpZihvPj1yKXtsZXQgcj0hMTtmb3IoY29uc3QgZSBvZiBpKXtjb25zdCB0PWUubGVuZ3RoO2xldCBpPTA7Zm9yKDtpPHQmJnNbYytvK2ldPT09ZVtpXTspaSsrO2lmKGk+PW4pe3I9ITA7YnJlYWt9aWYoaT49dCl7aWYoaXNXaGl0ZVNwYWNlKHNbYytvK2ldKSl7aW5mbyhgRm91bmQgIiR7Ynl0ZXNUb1N0cmluZyhbLi4uYSwuLi5lXSl9IiB3aGVuIHNlYXJjaGluZyBmb3IgZW5kc3RyZWFtIGNvbW1hbmQuYCk7cj0hMH1icmVha319aWYocil7dC5wb3MrPWM7cmV0dXJuIHQucG9zLWV9fWMrK310LnBvcys9b31yZXR1cm4tMX1tYWtlU3RyZWFtKGUsdCl7Y29uc3QgYT10aGlzLmxleGVyO2xldCByPWEuc3RyZWFtO2Euc2tpcFRvTmV4dExpbmUoKTtjb25zdCBpPXIucG9zLTE7bGV0IG49ZS5nZXQoIkxlbmd0aCIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXtpbmZvKGBCYWQgbGVuZ3RoICIke24mJm4udG9TdHJpbmcoKX0iIGluIHN0cmVhbS5gKTtuPTB9ci5wb3M9aStuO2EubmV4dENoYXIoKTtpZih0aGlzLnRyeVNoaWZ0KCkmJmlzQ21kKHRoaXMuYnVmMiwiZW5kc3RyZWFtIikpdGhpcy5zaGlmdCgpO2Vsc2V7bj10aGlzLiNxKGkpO2lmKG48MCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk1pc3NpbmcgZW5kc3RyZWFtIGNvbW1hbmQuIik7YS5uZXh0Q2hhcigpO3RoaXMuc2hpZnQoKTt0aGlzLnNoaWZ0KCl9dGhpcy5zaGlmdCgpO3I9ci5tYWtlU3ViU3RyZWFtKGksbixlKTt0JiYocj10LmNyZWF0ZVN0cmVhbShyLG4pKTtyPXRoaXMuZmlsdGVyKHIsZSxuKTtyLmRpY3Q9ZTtyZXR1cm4gcn1maWx0ZXIoZSx0LGEpe2xldCByPXQuZ2V0KCJGIiwiRmlsdGVyIiksaT10LmdldCgiRFAiLCJEZWNvZGVQYXJtcyIpO2lmKHIgaW5zdGFuY2VvZiBOYW1lKXtBcnJheS5pc0FycmF5KGkpJiZ3YXJuKCIvRGVjb2RlUGFybXMgc2hvdWxkIG5vdCBiZSBhbiBBcnJheSwgd2hlbiAvRmlsdGVyIGlzIGEgTmFtZS4iKTtyZXR1cm4gdGhpcy5tYWtlRmlsdGVyKGUsci5uYW1lLGEsaSl9bGV0IG49YTtpZihBcnJheS5pc0FycmF5KHIpKXtjb25zdCB0PXIsYT1pO2ZvcihsZXQgcz0wLG89dC5sZW5ndGg7czxvOysrcyl7cj10aGlzLnhyZWYuZmV0Y2hJZlJlZih0W3NdKTtpZighKHIgaW5zdGFuY2VvZiBOYW1lKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEJhZCBmaWx0ZXIgbmFtZSAiJHtyfSJgKTtpPW51bGw7QXJyYXkuaXNBcnJheShhKSYmcyBpbiBhJiYoaT10aGlzLnhyZWYuZmV0Y2hJZlJlZihhW3NdKSk7ZT10aGlzLm1ha2VGaWx0ZXIoZSxyLm5hbWUsbixpKTtuPW51bGx9fXJldHVybiBlfW1ha2VGaWx0ZXIoZSx0LGEscil7aWYoMD09PWEpe3dhcm4oYEVtcHR5ICIke3R9IiBzdHJlYW0uYCk7cmV0dXJuIG5ldyBOdWxsU3RyZWFtfXRyeXtzd2l0Y2godCl7Y2FzZSJGbCI6Y2FzZSJGbGF0ZURlY29kZSI6cmV0dXJuIHI/bmV3IFByZWRpY3RvclN0cmVhbShuZXcgRmxhdGVTdHJlYW0oZSxhKSxhLHIpOm5ldyBGbGF0ZVN0cmVhbShlLGEpO2Nhc2UiTFpXIjpjYXNlIkxaV0RlY29kZSI6bGV0IHQ9MTtpZihyKXtyLmhhcygiRWFybHlDaGFuZ2UiKSYmKHQ9ci5nZXQoIkVhcmx5Q2hhbmdlIikpO3JldHVybiBuZXcgUHJlZGljdG9yU3RyZWFtKG5ldyBMWldTdHJlYW0oZSxhLHQpLGEscil9cmV0dXJuIG5ldyBMWldTdHJlYW0oZSxhLHQpO2Nhc2UiRENUIjpjYXNlIkRDVERlY29kZSI6cmV0dXJuIG5ldyBKcGVnU3RyZWFtKGUsYSxyKTtjYXNlIkpQWCI6Y2FzZSJKUFhEZWNvZGUiOnJldHVybiBuZXcgSnB4U3RyZWFtKGUsYSxyKTtjYXNlIkE4NSI6Y2FzZSJBU0NJSTg1RGVjb2RlIjpyZXR1cm4gbmV3IEFzY2lpODVTdHJlYW0oZSxhKTtjYXNlIkFIeCI6Y2FzZSJBU0NJSUhleERlY29kZSI6cmV0dXJuIG5ldyBBc2NpaUhleFN0cmVhbShlLGEpO2Nhc2UiQ0NGIjpjYXNlIkNDSVRURmF4RGVjb2RlIjpyZXR1cm4gbmV3IENDSVRURmF4U3RyZWFtKGUsYSxyKTtjYXNlIlJMIjpjYXNlIlJ1bkxlbmd0aERlY29kZSI6cmV0dXJuIG5ldyBSdW5MZW5ndGhTdHJlYW0oZSxhKTtjYXNlIkpCSUcyRGVjb2RlIjpyZXR1cm4gbmV3IEpiaWcyU3RyZWFtKGUsYSxyKX13YXJuKGBGaWx0ZXIgIiR7dH0iIGlzIG5vdCBzdXBwb3J0ZWQuYCk7cmV0dXJuIGV9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybihgSW52YWxpZCBzdHJlYW06ICIke2V9ImApO3JldHVybiBuZXcgTnVsbFN0cmVhbX19fWNvbnN0IFFhPVsxLDAsMCwwLDAsMCwwLDAsMCwxLDEsMCwxLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDIsMCwwLDIsMiwwLDAsMCwwLDAsMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDAsMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMCwyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDAsMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXTtmdW5jdGlvbiB0b0hleERpZ2l0KGUpe3JldHVybiBlPj00OCYmZTw9NTc/MTUmZTplPj02NSYmZTw9NzB8fGU+PTk3JiZlPD0xMDI/OSsoMTUmZSk6LTF9Y2xhc3MgTGV4ZXJ7Y29uc3RydWN0b3IoZSx0PW51bGwpe3RoaXMuc3RyZWFtPWU7dGhpcy5uZXh0Q2hhcigpO3RoaXMuc3RyQnVmPVtdO3RoaXMua25vd25Db21tYW5kcz10O3RoaXMuX2hleFN0cmluZ051bVdhcm49MDt0aGlzLmJlZ2luSW5saW5lSW1hZ2VQb3M9LTF9bmV4dENoYXIoKXtyZXR1cm4gdGhpcy5jdXJyZW50Q2hhcj10aGlzLnN0cmVhbS5nZXRCeXRlKCl9cGVla0NoYXIoKXtyZXR1cm4gdGhpcy5zdHJlYW0ucGVla0J5dGUoKX1nZXROdW1iZXIoKXtsZXQgZT10aGlzLmN1cnJlbnRDaGFyLHQ9ITEsYT0wLHI9MTtpZig0NT09PWUpe3I9LTE7ZT10aGlzLm5leHRDaGFyKCk7NDU9PT1lJiYoZT10aGlzLm5leHRDaGFyKCkpfWVsc2UgNDM9PT1lJiYoZT10aGlzLm5leHRDaGFyKCkpO2lmKDEwPT09ZXx8MTM9PT1lKWRve2U9dGhpcy5uZXh0Q2hhcigpfXdoaWxlKDEwPT09ZXx8MTM9PT1lKTtpZig0Nj09PWUpe2E9MTA7ZT10aGlzLm5leHRDaGFyKCl9aWYoZTw0OHx8ZT41Nyl7Y29uc3QgdD1gSW52YWxpZCBudW1iZXI6ICR7U3RyaW5nLmZyb21DaGFyQ29kZShlKX0gKGNoYXJDb2RlICR7ZX0pYDtpZihpc1doaXRlU3BhY2UoZSl8fDQwPT09ZXx8NjA9PT1lfHwtMT09PWUpe2luZm8oYExleGVyLmdldE51bWJlciAtICIke3R9Ii5gKTtyZXR1cm4gMH10aHJvdyBuZXcgRm9ybWF0RXJyb3IodCl9bGV0IGk9ZS00OCxuPTAscz0xO2Zvcig7KGU9dGhpcy5uZXh0Q2hhcigpKT49MDspaWYoZT49NDgmJmU8PTU3KXtjb25zdCByPWUtNDg7aWYodCluPTEwKm4rcjtlbHNlezAhPT1hJiYoYSo9MTApO2k9MTAqaStyfX1lbHNlIGlmKDQ2PT09ZSl7aWYoMCE9PWEpYnJlYWs7YT0xfWVsc2UgaWYoNDU9PT1lKXdhcm4oIkJhZGx5IGZvcm1hdHRlZCBudW1iZXI6IG1pbnVzIHNpZ24gaW4gdGhlIG1pZGRsZSIpO2Vsc2V7aWYoNjkhPT1lJiYxMDEhPT1lKWJyZWFrO2U9dGhpcy5wZWVrQ2hhcigpO2lmKDQzPT09ZXx8NDU9PT1lKXtzPTQ1PT09ZT8tMToxO3RoaXMubmV4dENoYXIoKX1lbHNlIGlmKGU8NDh8fGU+NTcpYnJlYWs7dD0hMH0wIT09YSYmKGkvPWEpO3QmJihpKj0xMCoqKHMqbikpO3JldHVybiByKml9Z2V0U3RyaW5nKCl7bGV0IGU9MSx0PSExO2NvbnN0IGE9dGhpcy5zdHJCdWY7YS5sZW5ndGg9MDtsZXQgcj10aGlzLm5leHRDaGFyKCk7Zm9yKDs7KXtsZXQgaT0hMTtzd2l0Y2goMHxyKXtjYXNlLTE6d2FybigiVW50ZXJtaW5hdGVkIHN0cmluZyIpO3Q9ITA7YnJlYWs7Y2FzZSA0MDorK2U7YS5wdXNoKCIoIik7YnJlYWs7Y2FzZSA0MTppZigwPT0tLWUpe3RoaXMubmV4dENoYXIoKTt0PSEwfWVsc2UgYS5wdXNoKCIpIik7YnJlYWs7Y2FzZSA5MjpyPXRoaXMubmV4dENoYXIoKTtzd2l0Y2gocil7Y2FzZS0xOndhcm4oIlVudGVybWluYXRlZCBzdHJpbmciKTt0PSEwO2JyZWFrO2Nhc2UgMTEwOmEucHVzaCgiXG4iKTticmVhaztjYXNlIDExNDphLnB1c2goIlxyIik7YnJlYWs7Y2FzZSAxMTY6YS5wdXNoKCJcdCIpO2JyZWFrO2Nhc2UgOTg6YS5wdXNoKCJcYiIpO2JyZWFrO2Nhc2UgMTAyOmEucHVzaCgiXGYiKTticmVhaztjYXNlIDkyOmNhc2UgNDA6Y2FzZSA0MTphLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShyKSk7YnJlYWs7Y2FzZSA0ODpjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmxldCBlPTE1JnI7cj10aGlzLm5leHRDaGFyKCk7aT0hMDtpZihyPj00OCYmcjw9NTUpe2U9KGU8PDMpKygxNSZyKTtyPXRoaXMubmV4dENoYXIoKTtpZihyPj00OCYmcjw9NTUpe2k9ITE7ZT0oZTw8MykrKDE1JnIpfX1hLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShlKSk7YnJlYWs7Y2FzZSAxMzoxMD09PXRoaXMucGVla0NoYXIoKSYmdGhpcy5uZXh0Q2hhcigpO2JyZWFrO2Nhc2UgMTA6YnJlYWs7ZGVmYXVsdDphLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShyKSl9YnJlYWs7ZGVmYXVsdDphLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShyKSl9aWYodClicmVhaztpfHwocj10aGlzLm5leHRDaGFyKCkpfXJldHVybiBhLmpvaW4oIiIpfWdldE5hbWUoKXtsZXQgZSx0O2NvbnN0IGE9dGhpcy5zdHJCdWY7YS5sZW5ndGg9MDtmb3IoOyhlPXRoaXMubmV4dENoYXIoKSk+PTAmJiFRYVtlXTspaWYoMzU9PT1lKXtlPXRoaXMubmV4dENoYXIoKTtpZihRYVtlXSl7d2FybigiTGV4ZXJfZ2V0TmFtZTogTlVNQkVSIFNJR04gKCMpIHNob3VsZCBiZSBmb2xsb3dlZCBieSBhIGhleGFkZWNpbWFsIG51bWJlci4iKTthLnB1c2goIiMiKTticmVha31jb25zdCByPXRvSGV4RGlnaXQoZSk7aWYoLTEhPT1yKXt0PWU7ZT10aGlzLm5leHRDaGFyKCk7Y29uc3QgaT10b0hleERpZ2l0KGUpO2lmKC0xPT09aSl7d2FybihgTGV4ZXJfZ2V0TmFtZTogSWxsZWdhbCBkaWdpdCAoJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGUpfSkgaW4gaGV4YWRlY2ltYWwgbnVtYmVyLmApO2EucHVzaCgiIyIsU3RyaW5nLmZyb21DaGFyQ29kZSh0KSk7aWYoUWFbZV0pYnJlYWs7YS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpO2NvbnRpbnVlfWEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHI8PDR8aSkpfWVsc2UgYS5wdXNoKCIjIixTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKX1lbHNlIGEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKTthLmxlbmd0aD4xMjcmJndhcm4oYE5hbWUgdG9rZW4gaXMgbG9uZ2VyIHRoYW4gYWxsb3dlZCBieSB0aGUgc3BlYzogJHthLmxlbmd0aH1gKTtyZXR1cm4gTmFtZS5nZXQoYS5qb2luKCIiKSl9X2hleFN0cmluZ1dhcm4oZSl7NSE9dGhpcy5faGV4U3RyaW5nTnVtV2FybisrP3RoaXMuX2hleFN0cmluZ051bVdhcm4+NXx8d2FybihgZ2V0SGV4U3RyaW5nIC0gaWdub3JpbmcgaW52YWxpZCBjaGFyYWN0ZXI6ICR7ZX1gKTp3YXJuKCJnZXRIZXhTdHJpbmcgLSBpZ25vcmluZyBhZGRpdGlvbmFsIGludmFsaWQgY2hhcmFjdGVycy4iKX1nZXRIZXhTdHJpbmcoKXtjb25zdCBlPXRoaXMuc3RyQnVmO2UubGVuZ3RoPTA7bGV0IHQ9dGhpcy5jdXJyZW50Q2hhcixhPS0xLHI9LTE7dGhpcy5faGV4U3RyaW5nTnVtV2Fybj0wO2Zvcig7Oyl7aWYodDwwKXt3YXJuKCJVbnRlcm1pbmF0ZWQgaGV4IHN0cmluZyIpO2JyZWFrfWlmKDYyPT09dCl7dGhpcy5uZXh0Q2hhcigpO2JyZWFrfWlmKDEhPT1RYVt0XSl7cj10b0hleERpZ2l0KHQpO2lmKC0xPT09cil0aGlzLl9oZXhTdHJpbmdXYXJuKHQpO2Vsc2UgaWYoLTE9PT1hKWE9cjtlbHNle2UucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGE8PDR8cikpO2E9LTF9dD10aGlzLm5leHRDaGFyKCl9ZWxzZSB0PXRoaXMubmV4dENoYXIoKX0tMSE9PWEmJmUucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGE8PDQpKTtyZXR1cm4gZS5qb2luKCIiKX1nZXRPYmooKXtsZXQgZT0hMSx0PXRoaXMuY3VycmVudENoYXI7Zm9yKDs7KXtpZih0PDApcmV0dXJuIGFhO2lmKGUpMTAhPT10JiYxMyE9PXR8fChlPSExKTtlbHNlIGlmKDM3PT09dCllPSEwO2Vsc2UgaWYoMSE9PVFhW3RdKWJyZWFrO3Q9dGhpcy5uZXh0Q2hhcigpfXN3aXRjaCgwfHQpe2Nhc2UgNDg6Y2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6Y2FzZSA0MzpjYXNlIDQ1OmNhc2UgNDY6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7Y2FzZSA0MDpyZXR1cm4gdGhpcy5nZXRTdHJpbmcoKTtjYXNlIDQ3OnJldHVybiB0aGlzLmdldE5hbWUoKTtjYXNlIDkxOnRoaXMubmV4dENoYXIoKTtyZXR1cm4gQ21kLmdldCgiWyIpO2Nhc2UgOTM6dGhpcy5uZXh0Q2hhcigpO3JldHVybiBDbWQuZ2V0KCJdIik7Y2FzZSA2MDp0PXRoaXMubmV4dENoYXIoKTtpZig2MD09PXQpe3RoaXMubmV4dENoYXIoKTtyZXR1cm4gQ21kLmdldCgiPDwiKX1yZXR1cm4gdGhpcy5nZXRIZXhTdHJpbmcoKTtjYXNlIDYyOnQ9dGhpcy5uZXh0Q2hhcigpO2lmKDYyPT09dCl7dGhpcy5uZXh0Q2hhcigpO3JldHVybiBDbWQuZ2V0KCI+PiIpfXJldHVybiBDbWQuZ2V0KCI+Iik7Y2FzZSAxMjM6dGhpcy5uZXh0Q2hhcigpO3JldHVybiBDbWQuZ2V0KCJ7Iik7Y2FzZSAxMjU6dGhpcy5uZXh0Q2hhcigpO3JldHVybiBDbWQuZ2V0KCJ9Iik7Y2FzZSA0MTp0aGlzLm5leHRDaGFyKCk7dGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbGxlZ2FsIGNoYXJhY3RlcjogJHt0fWApfWxldCBhPVN0cmluZy5mcm9tQ2hhckNvZGUodCk7aWYodDwzMnx8dD4xMjcpe2NvbnN0IGU9dGhpcy5wZWVrQ2hhcigpO2lmKGU+PTMyJiZlPD0xMjcpe3RoaXMubmV4dENoYXIoKTtyZXR1cm4gQ21kLmdldChhKX19Y29uc3Qgcj10aGlzLmtub3duQ29tbWFuZHM7bGV0IGk9dm9pZCAwIT09cj8uW2FdO2Zvcig7KHQ9dGhpcy5uZXh0Q2hhcigpKT49MCYmIVFhW3RdOyl7Y29uc3QgZT1hK1N0cmluZy5mcm9tQ2hhckNvZGUodCk7aWYoaSYmdm9pZCAwPT09cltlXSlicmVhaztpZigxMjg9PT1hLmxlbmd0aCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYENvbW1hbmQgdG9rZW4gdG9vIGxvbmc6ICR7YS5sZW5ndGh9YCk7YT1lO2k9dm9pZCAwIT09cj8uW2FdfWlmKCJ0cnVlIj09PWEpcmV0dXJuITA7aWYoImZhbHNlIj09PWEpcmV0dXJuITE7aWYoIm51bGwiPT09YSlyZXR1cm4gbnVsbDsiQkkiPT09YSYmKHRoaXMuYmVnaW5JbmxpbmVJbWFnZVBvcz10aGlzLnN0cmVhbS5wb3MpO3JldHVybiBDbWQuZ2V0KGEpfXNraXBUb05leHRMaW5lKCl7bGV0IGU9dGhpcy5jdXJyZW50Q2hhcjtmb3IoO2U+PTA7KXtpZigxMz09PWUpe2U9dGhpcy5uZXh0Q2hhcigpOzEwPT09ZSYmdGhpcy5uZXh0Q2hhcigpO2JyZWFrfWlmKDEwPT09ZSl7dGhpcy5uZXh0Q2hhcigpO2JyZWFrfWU9dGhpcy5uZXh0Q2hhcigpfX19Y2xhc3MgTGluZWFyaXphdGlvbntzdGF0aWMgY3JlYXRlKGUpe2Z1bmN0aW9uIGdldEludChlLHQsYT0hMSl7Y29uc3Qgcj1lLmdldCh0KTtpZihOdW1iZXIuaXNJbnRlZ2VyKHIpJiYoYT9yPj0wOnI+MCkpcmV0dXJuIHI7dGhyb3cgbmV3IEVycm9yKGBUaGUgIiR7dH0iIHBhcmFtZXRlciBpbiB0aGUgbGluZWFyaXphdGlvbiBkaWN0aW9uYXJ5IGlzIGludmFsaWQuYCl9Y29uc3QgdD1uZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIoZSkseHJlZjpudWxsfSksYT10LmdldE9iaigpLHI9dC5nZXRPYmooKSxpPXQuZ2V0T2JqKCksbj10LmdldE9iaigpO2xldCBzLG87aWYoIShOdW1iZXIuaXNJbnRlZ2VyKGEpJiZOdW1iZXIuaXNJbnRlZ2VyKHIpJiZpc0NtZChpLCJvYmoiKSYmbiBpbnN0YW5jZW9mIERpY3QmJiJudW1iZXIiPT10eXBlb2Yocz1uLmdldCgiTGluZWFyaXplZCIpKSYmcz4wKSlyZXR1cm4gbnVsbDtpZigobz1nZXRJbnQobiwiTCIpKSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcignVGhlICJMIiBwYXJhbWV0ZXIgaW4gdGhlIGxpbmVhcml6YXRpb24gZGljdGlvbmFyeSBkb2VzIG5vdCBlcXVhbCB0aGUgc3RyZWFtIGxlbmd0aC4nKTtyZXR1cm57bGVuZ3RoOm8saGludHM6ZnVuY3Rpb24gZ2V0SGludHMoZSl7Y29uc3QgdD1lLmdldCgiSCIpO2xldCBhO2lmKEFycmF5LmlzQXJyYXkodCkmJigyPT09KGE9dC5sZW5ndGgpfHw0PT09YSkpe2ZvcihsZXQgZT0wO2U8YTtlKyspe2NvbnN0IGE9dFtlXTtpZighKE51bWJlci5pc0ludGVnZXIoYSkmJmE+MCkpdGhyb3cgbmV3IEVycm9yKGBIaW50ICgke2V9KSBpbiB0aGUgbGluZWFyaXphdGlvbiBkaWN0aW9uYXJ5IGlzIGludmFsaWQuYCl9cmV0dXJuIHR9dGhyb3cgbmV3IEVycm9yKCJIaW50IGFycmF5IGluIHRoZSBsaW5lYXJpemF0aW9uIGRpY3Rpb25hcnkgaXMgaW52YWxpZC4iKX0obiksb2JqZWN0TnVtYmVyRmlyc3Q6Z2V0SW50KG4sIk8iKSxlbmRGaXJzdDpnZXRJbnQobiwiRSIpLG51bVBhZ2VzOmdldEludChuLCJOIiksbWFpblhSZWZFbnRyaWVzT2Zmc2V0OmdldEludChuLCJUIikscGFnZUZpcnN0Om4uaGFzKCJQIik/Z2V0SW50KG4sIlAiLCEwKTowfX19Y29uc3QgZXI9WyJBZG9iZS1HQjEtVUNTMiIsIkFkb2JlLUNOUzEtVUNTMiIsIkFkb2JlLUphcGFuMS1VQ1MyIiwiQWRvYmUtS29yZWExLVVDUzIiLCI3OC1FVUMtSCIsIjc4LUVVQy1WIiwiNzgtSCIsIjc4LVJLU0otSCIsIjc4LVJLU0otViIsIjc4LVYiLCI3OG1zLVJLU0otSCIsIjc4bXMtUktTSi1WIiwiODNwdi1SS1NKLUgiLCI5MG1zLVJLU0otSCIsIjkwbXMtUktTSi1WIiwiOTBtc3AtUktTSi1IIiwiOTBtc3AtUktTSi1WIiwiOTBwdi1SS1NKLUgiLCI5MHB2LVJLU0otViIsIkFkZC1IIiwiQWRkLVJLU0otSCIsIkFkZC1SS1NKLVYiLCJBZGQtViIsIkFkb2JlLUNOUzEtMCIsIkFkb2JlLUNOUzEtMSIsIkFkb2JlLUNOUzEtMiIsIkFkb2JlLUNOUzEtMyIsIkFkb2JlLUNOUzEtNCIsIkFkb2JlLUNOUzEtNSIsIkFkb2JlLUNOUzEtNiIsIkFkb2JlLUdCMS0wIiwiQWRvYmUtR0IxLTEiLCJBZG9iZS1HQjEtMiIsIkFkb2JlLUdCMS0zIiwiQWRvYmUtR0IxLTQiLCJBZG9iZS1HQjEtNSIsIkFkb2JlLUphcGFuMS0wIiwiQWRvYmUtSmFwYW4xLTEiLCJBZG9iZS1KYXBhbjEtMiIsIkFkb2JlLUphcGFuMS0zIiwiQWRvYmUtSmFwYW4xLTQiLCJBZG9iZS1KYXBhbjEtNSIsIkFkb2JlLUphcGFuMS02IiwiQWRvYmUtS29yZWExLTAiLCJBZG9iZS1Lb3JlYTEtMSIsIkFkb2JlLUtvcmVhMS0yIiwiQjUtSCIsIkI1LVYiLCJCNXBjLUgiLCJCNXBjLVYiLCJDTlMtRVVDLUgiLCJDTlMtRVVDLVYiLCJDTlMxLUgiLCJDTlMxLVYiLCJDTlMyLUgiLCJDTlMyLVYiLCJFVEhLLUI1LUgiLCJFVEhLLUI1LVYiLCJFVGVuLUI1LUgiLCJFVGVuLUI1LVYiLCJFVGVubXMtQjUtSCIsIkVUZW5tcy1CNS1WIiwiRVVDLUgiLCJFVUMtViIsIkV4dC1IIiwiRXh0LVJLU0otSCIsIkV4dC1SS1NKLVYiLCJFeHQtViIsIkdCLUVVQy1IIiwiR0ItRVVDLVYiLCJHQi1IIiwiR0ItViIsIkdCSy1FVUMtSCIsIkdCSy1FVUMtViIsIkdCSzJLLUgiLCJHQksySy1WIiwiR0JLcC1FVUMtSCIsIkdCS3AtRVVDLVYiLCJHQlQtRVVDLUgiLCJHQlQtRVVDLVYiLCJHQlQtSCIsIkdCVC1WIiwiR0JUcGMtRVVDLUgiLCJHQlRwYy1FVUMtViIsIkdCcGMtRVVDLUgiLCJHQnBjLUVVQy1WIiwiSCIsIkhLZGxhLUI1LUgiLCJIS2RsYS1CNS1WIiwiSEtkbGItQjUtSCIsIkhLZGxiLUI1LVYiLCJIS2djY3MtQjUtSCIsIkhLZ2Njcy1CNS1WIiwiSEttMzE0LUI1LUgiLCJIS20zMTQtQjUtViIsIkhLbTQ3MS1CNS1IIiwiSEttNDcxLUI1LVYiLCJIS3Njcy1CNS1IIiwiSEtzY3MtQjUtViIsIkhhbmtha3UiLCJIaXJhZ2FuYSIsIktTQy1FVUMtSCIsIktTQy1FVUMtViIsIktTQy1IIiwiS1NDLUpvaGFiLUgiLCJLU0MtSm9oYWItViIsIktTQy1WIiwiS1NDbXMtVUhDLUgiLCJLU0Ntcy1VSEMtSFctSCIsIktTQ21zLVVIQy1IVy1WIiwiS1NDbXMtVUhDLVYiLCJLU0NwYy1FVUMtSCIsIktTQ3BjLUVVQy1WIiwiS2F0YWthbmEiLCJOV1AtSCIsIk5XUC1WIiwiUktTSi1IIiwiUktTSi1WIiwiUm9tYW4iLCJVbmlDTlMtVUNTMi1IIiwiVW5pQ05TLVVDUzItViIsIlVuaUNOUy1VVEYxNi1IIiwiVW5pQ05TLVVURjE2LVYiLCJVbmlDTlMtVVRGMzItSCIsIlVuaUNOUy1VVEYzMi1WIiwiVW5pQ05TLVVURjgtSCIsIlVuaUNOUy1VVEY4LVYiLCJVbmlHQi1VQ1MyLUgiLCJVbmlHQi1VQ1MyLVYiLCJVbmlHQi1VVEYxNi1IIiwiVW5pR0ItVVRGMTYtViIsIlVuaUdCLVVURjMyLUgiLCJVbmlHQi1VVEYzMi1WIiwiVW5pR0ItVVRGOC1IIiwiVW5pR0ItVVRGOC1WIiwiVW5pSklTLVVDUzItSCIsIlVuaUpJUy1VQ1MyLUhXLUgiLCJVbmlKSVMtVUNTMi1IVy1WIiwiVW5pSklTLVVDUzItViIsIlVuaUpJUy1VVEYxNi1IIiwiVW5pSklTLVVURjE2LVYiLCJVbmlKSVMtVVRGMzItSCIsIlVuaUpJUy1VVEYzMi1WIiwiVW5pSklTLVVURjgtSCIsIlVuaUpJUy1VVEY4LVYiLCJVbmlKSVMyMDA0LVVURjE2LUgiLCJVbmlKSVMyMDA0LVVURjE2LVYiLCJVbmlKSVMyMDA0LVVURjMyLUgiLCJVbmlKSVMyMDA0LVVURjMyLVYiLCJVbmlKSVMyMDA0LVVURjgtSCIsIlVuaUpJUzIwMDQtVVRGOC1WIiwiVW5pSklTUHJvLVVDUzItSFctViIsIlVuaUpJU1Byby1VQ1MyLVYiLCJVbmlKSVNQcm8tVVRGOC1WIiwiVW5pSklTWDAyMTMtVVRGMzItSCIsIlVuaUpJU1gwMjEzLVVURjMyLVYiLCJVbmlKSVNYMDIxMzIwMDQtVVRGMzItSCIsIlVuaUpJU1gwMjEzMjAwNC1VVEYzMi1WIiwiVW5pS1MtVUNTMi1IIiwiVW5pS1MtVUNTMi1WIiwiVW5pS1MtVVRGMTYtSCIsIlVuaUtTLVVURjE2LVYiLCJVbmlLUy1VVEYzMi1IIiwiVW5pS1MtVVRGMzItViIsIlVuaUtTLVVURjgtSCIsIlVuaUtTLVVURjgtViIsIlYiLCJXUC1TeW1ib2wiXSx0cj0yKioyNC0xO2NsYXNzIENNYXB7Y29uc3RydWN0b3IoZT0hMSl7dGhpcy5jb2Rlc3BhY2VSYW5nZXM9W1tdLFtdLFtdLFtdXTt0aGlzLm51bUNvZGVzcGFjZVJhbmdlcz0wO3RoaXMuX21hcD1bXTt0aGlzLm5hbWU9IiI7dGhpcy52ZXJ0aWNhbD0hMTt0aGlzLnVzZUNNYXA9bnVsbDt0aGlzLmJ1aWx0SW5DTWFwPWV9YWRkQ29kZXNwYWNlUmFuZ2UoZSx0LGEpe3RoaXMuY29kZXNwYWNlUmFuZ2VzW2UtMV0ucHVzaCh0LGEpO3RoaXMubnVtQ29kZXNwYWNlUmFuZ2VzKyt9bWFwQ2lkUmFuZ2UoZSx0LGEpe2lmKHQtZT50cil0aHJvdyBuZXcgRXJyb3IoIm1hcENpZFJhbmdlIC0gaWdub3JpbmcgZGF0YSBhYm92ZSBNQVhfTUFQX1JBTkdFLiIpO2Zvcig7ZTw9dDspdGhpcy5fbWFwW2UrK109YSsrfW1hcEJmUmFuZ2UoZSx0LGEpe2lmKHQtZT50cil0aHJvdyBuZXcgRXJyb3IoIm1hcEJmUmFuZ2UgLSBpZ25vcmluZyBkYXRhIGFib3ZlIE1BWF9NQVBfUkFOR0UuIik7Y29uc3Qgcj1hLmxlbmd0aC0xO2Zvcig7ZTw9dDspe3RoaXMuX21hcFtlKytdPWE7Y29uc3QgdD1hLmNoYXJDb2RlQXQocikrMTt0PjI1NT9hPWEuc3Vic3RyaW5nKDAsci0xKStTdHJpbmcuZnJvbUNoYXJDb2RlKGEuY2hhckNvZGVBdChyLTEpKzEpKyJcMCI6YT1hLnN1YnN0cmluZygwLHIpK1N0cmluZy5mcm9tQ2hhckNvZGUodCl9fW1hcEJmUmFuZ2VUb0FycmF5KGUsdCxhKXtpZih0LWU+dHIpdGhyb3cgbmV3IEVycm9yKCJtYXBCZlJhbmdlVG9BcnJheSAtIGlnbm9yaW5nIGRhdGEgYWJvdmUgTUFYX01BUF9SQU5HRS4iKTtjb25zdCByPWEubGVuZ3RoO2xldCBpPTA7Zm9yKDtlPD10JiZpPHI7KXt0aGlzLl9tYXBbZV09YVtpKytdOysrZX19bWFwT25lKGUsdCl7dGhpcy5fbWFwW2VdPXR9bG9va3VwKGUpe3JldHVybiB0aGlzLl9tYXBbZV19Y29udGFpbnMoZSl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX21hcFtlXX1mb3JFYWNoKGUpe2NvbnN0IHQ9dGhpcy5fbWFwLGE9dC5sZW5ndGg7aWYoYTw9NjU1MzYpZm9yKGxldCByPTA7cjxhO3IrKyl2b2lkIDAhPT10W3JdJiZlKHIsdFtyXSk7ZWxzZSBmb3IoY29uc3QgYSBpbiB0KWUoYSx0W2FdKX1jaGFyQ29kZU9mKGUpe2NvbnN0IHQ9dGhpcy5fbWFwO2lmKHQubGVuZ3RoPD02NTUzNilyZXR1cm4gdC5pbmRleE9mKGUpO2Zvcihjb25zdCBhIGluIHQpaWYodFthXT09PWUpcmV0dXJuIDB8YTtyZXR1cm4tMX1nZXRNYXAoKXtyZXR1cm4gdGhpcy5fbWFwfXJlYWRDaGFyQ29kZShlLHQsYSl7bGV0IHI9MDtjb25zdCBpPXRoaXMuY29kZXNwYWNlUmFuZ2VzO2ZvcihsZXQgbj0wLHM9aS5sZW5ndGg7bjxzO24rKyl7cj0ocjw8OHxlLmNoYXJDb2RlQXQodCtuKSk+Pj4wO2NvbnN0IHM9aVtuXTtmb3IobGV0IGU9MCx0PXMubGVuZ3RoO2U8dDspe2NvbnN0IHQ9c1tlKytdLGk9c1tlKytdO2lmKHI+PXQmJnI8PWkpe2EuY2hhcmNvZGU9cjthLmxlbmd0aD1uKzE7cmV0dXJufX19YS5jaGFyY29kZT0wO2EubGVuZ3RoPTF9Z2V0Q2hhckNvZGVMZW5ndGgoZSl7Y29uc3QgdD10aGlzLmNvZGVzcGFjZVJhbmdlcztmb3IobGV0IGE9MCxyPXQubGVuZ3RoO2E8cjthKyspe2NvbnN0IHI9dFthXTtmb3IobGV0IHQ9MCxpPXIubGVuZ3RoO3Q8aTspe2NvbnN0IGk9clt0KytdLG49clt0KytdO2lmKGU+PWkmJmU8PW4pcmV0dXJuIGErMX19cmV0dXJuIDF9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLl9tYXAubGVuZ3RofWdldCBpc0lkZW50aXR5Q01hcCgpe2lmKCJJZGVudGl0eS1IIiE9PXRoaXMubmFtZSYmIklkZW50aXR5LVYiIT09dGhpcy5uYW1lKXJldHVybiExO2lmKDY1NTM2IT09dGhpcy5fbWFwLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IGU9MDtlPDY1NTM2O2UrKylpZih0aGlzLl9tYXBbZV0hPT1lKXJldHVybiExO3JldHVybiEwfX1jbGFzcyBJZGVudGl0eUNNYXAgZXh0ZW5kcyBDTWFwe2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKTt0aGlzLnZlcnRpY2FsPWU7dGhpcy5hZGRDb2Rlc3BhY2VSYW5nZSh0LDAsNjU1MzUpfW1hcENpZFJhbmdlKGUsdCxhKXt1bnJlYWNoYWJsZSgic2hvdWxkIG5vdCBjYWxsIG1hcENpZFJhbmdlIil9bWFwQmZSYW5nZShlLHQsYSl7dW5yZWFjaGFibGUoInNob3VsZCBub3QgY2FsbCBtYXBCZlJhbmdlIil9bWFwQmZSYW5nZVRvQXJyYXkoZSx0LGEpe3VucmVhY2hhYmxlKCJzaG91bGQgbm90IGNhbGwgbWFwQmZSYW5nZVRvQXJyYXkiKX1tYXBPbmUoZSx0KXt1bnJlYWNoYWJsZSgic2hvdWxkIG5vdCBjYWxsIG1hcENpZE9uZSIpfWxvb2t1cChlKXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihlKSYmZTw9NjU1MzU/ZTp2b2lkIDB9Y29udGFpbnMoZSl7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSkmJmU8PTY1NTM1fWZvckVhY2goZSl7Zm9yKGxldCB0PTA7dDw9NjU1MzU7dCsrKWUodCx0KX1jaGFyQ29kZU9mKGUpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPD02NTUzNT9lOi0xfWdldE1hcCgpe2NvbnN0IGU9bmV3IEFycmF5KDY1NTM2KTtmb3IobGV0IHQ9MDt0PD02NTUzNTt0KyspZVt0XT10O3JldHVybiBlfWdldCBsZW5ndGgoKXtyZXR1cm4gNjU1MzZ9Z2V0IGlzSWRlbnRpdHlDTWFwKCl7dW5yZWFjaGFibGUoInNob3VsZCBub3QgYWNjZXNzIC5pc0lkZW50aXR5Q01hcCIpfX1mdW5jdGlvbiBzdHJUb0ludChlKXtsZXQgdD0wO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7YSsrKXQ9dDw8OHxlLmNoYXJDb2RlQXQoYSk7cmV0dXJuIHQ+Pj4wfWZ1bmN0aW9uIGV4cGVjdFN0cmluZyhlKXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJNYWxmb3JtZWQgQ01hcDogZXhwZWN0ZWQgc3RyaW5nLiIpfWZ1bmN0aW9uIGV4cGVjdEludChlKXtpZighTnVtYmVyLmlzSW50ZWdlcihlKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk1hbGZvcm1lZCBDTWFwOiBleHBlY3RlZCBpbnQuIil9ZnVuY3Rpb24gcGFyc2VCZkNoYXIoZSx0KXtmb3IoOzspe2xldCBhPXQuZ2V0T2JqKCk7aWYoYT09PWFhKWJyZWFrO2lmKGlzQ21kKGEsImVuZGJmY2hhciIpKXJldHVybjtleHBlY3RTdHJpbmcoYSk7Y29uc3Qgcj1zdHJUb0ludChhKTthPXQuZ2V0T2JqKCk7ZXhwZWN0U3RyaW5nKGEpO2NvbnN0IGk9YTtlLm1hcE9uZShyLGkpfX1mdW5jdGlvbiBwYXJzZUJmUmFuZ2UoZSx0KXtmb3IoOzspe2xldCBhPXQuZ2V0T2JqKCk7aWYoYT09PWFhKWJyZWFrO2lmKGlzQ21kKGEsImVuZGJmcmFuZ2UiKSlyZXR1cm47ZXhwZWN0U3RyaW5nKGEpO2NvbnN0IHI9c3RyVG9JbnQoYSk7YT10LmdldE9iaigpO2V4cGVjdFN0cmluZyhhKTtjb25zdCBpPXN0clRvSW50KGEpO2E9dC5nZXRPYmooKTtpZihOdW1iZXIuaXNJbnRlZ2VyKGEpfHwic3RyaW5nIj09dHlwZW9mIGEpe2NvbnN0IHQ9TnVtYmVyLmlzSW50ZWdlcihhKT9TdHJpbmcuZnJvbUNoYXJDb2RlKGEpOmE7ZS5tYXBCZlJhbmdlKHIsaSx0KX1lbHNle2lmKCFpc0NtZChhLCJbIikpYnJlYWs7e2E9dC5nZXRPYmooKTtjb25zdCBuPVtdO2Zvcig7IWlzQ21kKGEsIl0iKSYmYSE9PWFhOyl7bi5wdXNoKGEpO2E9dC5nZXRPYmooKX1lLm1hcEJmUmFuZ2VUb0FycmF5KHIsaSxuKX19fXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBiZiByYW5nZS4iKX1mdW5jdGlvbiBwYXJzZUNpZENoYXIoZSx0KXtmb3IoOzspe2xldCBhPXQuZ2V0T2JqKCk7aWYoYT09PWFhKWJyZWFrO2lmKGlzQ21kKGEsImVuZGNpZGNoYXIiKSlyZXR1cm47ZXhwZWN0U3RyaW5nKGEpO2NvbnN0IHI9c3RyVG9JbnQoYSk7YT10LmdldE9iaigpO2V4cGVjdEludChhKTtjb25zdCBpPWE7ZS5tYXBPbmUocixpKX19ZnVuY3Rpb24gcGFyc2VDaWRSYW5nZShlLHQpe2Zvcig7Oyl7bGV0IGE9dC5nZXRPYmooKTtpZihhPT09YWEpYnJlYWs7aWYoaXNDbWQoYSwiZW5kY2lkcmFuZ2UiKSlyZXR1cm47ZXhwZWN0U3RyaW5nKGEpO2NvbnN0IHI9c3RyVG9JbnQoYSk7YT10LmdldE9iaigpO2V4cGVjdFN0cmluZyhhKTtjb25zdCBpPXN0clRvSW50KGEpO2E9dC5nZXRPYmooKTtleHBlY3RJbnQoYSk7Y29uc3Qgbj1hO2UubWFwQ2lkUmFuZ2UocixpLG4pfX1mdW5jdGlvbiBwYXJzZUNvZGVzcGFjZVJhbmdlKGUsdCl7Zm9yKDs7KXtsZXQgYT10LmdldE9iaigpO2lmKGE9PT1hYSlicmVhaztpZihpc0NtZChhLCJlbmRjb2Rlc3BhY2VyYW5nZSIpKXJldHVybjtpZigic3RyaW5nIiE9dHlwZW9mIGEpYnJlYWs7Y29uc3Qgcj1zdHJUb0ludChhKTthPXQuZ2V0T2JqKCk7aWYoInN0cmluZyIhPXR5cGVvZiBhKWJyZWFrO2NvbnN0IGk9c3RyVG9JbnQoYSk7ZS5hZGRDb2Rlc3BhY2VSYW5nZShhLmxlbmd0aCxyLGkpfXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBjb2Rlc3BhY2UgcmFuZ2UuIil9ZnVuY3Rpb24gcGFyc2VXTW9kZShlLHQpe2NvbnN0IGE9dC5nZXRPYmooKTtOdW1iZXIuaXNJbnRlZ2VyKGEpJiYoZS52ZXJ0aWNhbD0hIWEpfWZ1bmN0aW9uIHBhcnNlQ01hcE5hbWUoZSx0KXtjb25zdCBhPXQuZ2V0T2JqKCk7YSBpbnN0YW5jZW9mIE5hbWUmJihlLm5hbWU9YS5uYW1lKX1hc3luYyBmdW5jdGlvbiBwYXJzZUNNYXAoZSx0LGEscil7bGV0IGksbjtlOmZvcig7Oyl0cnl7Y29uc3QgYT10LmdldE9iaigpO2lmKGE9PT1hYSlicmVhaztpZihhIGluc3RhbmNlb2YgTmFtZSl7IldNb2RlIj09PWEubmFtZT9wYXJzZVdNb2RlKGUsdCk6IkNNYXBOYW1lIj09PWEubmFtZSYmcGFyc2VDTWFwTmFtZShlLHQpO2k9YX1lbHNlIGlmKGEgaW5zdGFuY2VvZiBDbWQpc3dpdGNoKGEuY21kKXtjYXNlImVuZGNtYXAiOmJyZWFrIGU7Y2FzZSJ1c2VjbWFwIjppIGluc3RhbmNlb2YgTmFtZSYmKG49aS5uYW1lKTticmVhaztjYXNlImJlZ2luY29kZXNwYWNlcmFuZ2UiOnBhcnNlQ29kZXNwYWNlUmFuZ2UoZSx0KTticmVhaztjYXNlImJlZ2luYmZjaGFyIjpwYXJzZUJmQ2hhcihlLHQpO2JyZWFrO2Nhc2UiYmVnaW5jaWRjaGFyIjpwYXJzZUNpZENoYXIoZSx0KTticmVhaztjYXNlImJlZ2luYmZyYW5nZSI6cGFyc2VCZlJhbmdlKGUsdCk7YnJlYWs7Y2FzZSJiZWdpbmNpZHJhbmdlIjpwYXJzZUNpZFJhbmdlKGUsdCl9fWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlO3dhcm4oIkludmFsaWQgY01hcCBkYXRhOiAiK2UpO2NvbnRpbnVlfSFyJiZuJiYocj1uKTtyZXR1cm4gcj9leHRlbmRDTWFwKGUsYSxyKTplfWFzeW5jIGZ1bmN0aW9uIGV4dGVuZENNYXAoZSx0LGEpe2UudXNlQ01hcD1hd2FpdCBjcmVhdGVCdWlsdEluQ01hcChhLHQpO2lmKDA9PT1lLm51bUNvZGVzcGFjZVJhbmdlcyl7Y29uc3QgdD1lLnVzZUNNYXAuY29kZXNwYWNlUmFuZ2VzO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSsrKWUuY29kZXNwYWNlUmFuZ2VzW2FdPXRbYV0uc2xpY2UoKTtlLm51bUNvZGVzcGFjZVJhbmdlcz1lLnVzZUNNYXAubnVtQ29kZXNwYWNlUmFuZ2VzfWUudXNlQ01hcC5mb3JFYWNoKChmdW5jdGlvbih0LGEpe2UuY29udGFpbnModCl8fGUubWFwT25lKHQsYSl9KSk7cmV0dXJuIGV9YXN5bmMgZnVuY3Rpb24gY3JlYXRlQnVpbHRJbkNNYXAoZSx0KXtpZigiSWRlbnRpdHktSCI9PT1lKXJldHVybiBuZXcgSWRlbnRpdHlDTWFwKCExLDIpO2lmKCJJZGVudGl0eS1WIj09PWUpcmV0dXJuIG5ldyBJZGVudGl0eUNNYXAoITAsMik7aWYoIWVyLmluY2x1ZGVzKGUpKXRocm93IG5ldyBFcnJvcigiVW5rbm93biBDTWFwIG5hbWU6ICIrZSk7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCJCdWlsdC1pbiBDTWFwIHBhcmFtZXRlcnMgYXJlIG5vdCBwcm92aWRlZC4iKTtjb25zdHtjTWFwRGF0YTphLGlzQ29tcHJlc3NlZDpyfT1hd2FpdCB0KGUpLGk9bmV3IENNYXAoITApO2lmKHIpcmV0dXJuKG5ldyBCaW5hcnlDTWFwUmVhZGVyKS5wcm9jZXNzKGEsaSwoZT0+ZXh0ZW5kQ01hcChpLHQsZSkpKTtjb25zdCBuPW5ldyBMZXhlcihuZXcgU3RyZWFtKGEpKTtyZXR1cm4gcGFyc2VDTWFwKGksbix0LG51bGwpfWNsYXNzIENNYXBGYWN0b3J5e3N0YXRpYyBhc3luYyBjcmVhdGUoe2VuY29kaW5nOmUsZmV0Y2hCdWlsdEluQ01hcDp0LHVzZUNNYXA6YX0pe2lmKGUgaW5zdGFuY2VvZiBOYW1lKXJldHVybiBjcmVhdGVCdWlsdEluQ01hcChlLm5hbWUsdCk7aWYoZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pe2NvbnN0IHI9YXdhaXQgcGFyc2VDTWFwKG5ldyBDTWFwLG5ldyBMZXhlcihlKSx0LGEpO3JldHVybiByLmlzSWRlbnRpdHlDTWFwP2NyZWF0ZUJ1aWx0SW5DTWFwKHIubmFtZSx0KTpyfXRocm93IG5ldyBFcnJvcigiRW5jb2RpbmcgcmVxdWlyZWQuIil9fWNvbnN0IGFyPVsiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwic3BhY2UiLCJleGNsYW1zbWFsbCIsIkh1bmdhcnVtbGF1dHNtYWxsIiwiIiwiZG9sbGFyb2xkc3R5bGUiLCJkb2xsYXJzdXBlcmlvciIsImFtcGVyc2FuZHNtYWxsIiwiQWN1dGVzbWFsbCIsInBhcmVubGVmdHN1cGVyaW9yIiwicGFyZW5yaWdodHN1cGVyaW9yIiwidHdvZG90ZW5sZWFkZXIiLCJvbmVkb3RlbmxlYWRlciIsImNvbW1hIiwiaHlwaGVuIiwicGVyaW9kIiwiZnJhY3Rpb24iLCJ6ZXJvb2xkc3R5bGUiLCJvbmVvbGRzdHlsZSIsInR3b29sZHN0eWxlIiwidGhyZWVvbGRzdHlsZSIsImZvdXJvbGRzdHlsZSIsImZpdmVvbGRzdHlsZSIsInNpeG9sZHN0eWxlIiwic2V2ZW5vbGRzdHlsZSIsImVpZ2h0b2xkc3R5bGUiLCJuaW5lb2xkc3R5bGUiLCJjb2xvbiIsInNlbWljb2xvbiIsImNvbW1hc3VwZXJpb3IiLCJ0aHJlZXF1YXJ0ZXJzZW1kYXNoIiwicGVyaW9kc3VwZXJpb3IiLCJxdWVzdGlvbnNtYWxsIiwiIiwiYXN1cGVyaW9yIiwiYnN1cGVyaW9yIiwiY2VudHN1cGVyaW9yIiwiZHN1cGVyaW9yIiwiZXN1cGVyaW9yIiwiIiwiIiwiIiwiaXN1cGVyaW9yIiwiIiwiIiwibHN1cGVyaW9yIiwibXN1cGVyaW9yIiwibnN1cGVyaW9yIiwib3N1cGVyaW9yIiwiIiwiIiwicnN1cGVyaW9yIiwic3N1cGVyaW9yIiwidHN1cGVyaW9yIiwiIiwiZmYiLCJmaSIsImZsIiwiZmZpIiwiZmZsIiwicGFyZW5sZWZ0aW5mZXJpb3IiLCIiLCJwYXJlbnJpZ2h0aW5mZXJpb3IiLCJDaXJjdW1mbGV4c21hbGwiLCJoeXBoZW5zdXBlcmlvciIsIkdyYXZlc21hbGwiLCJBc21hbGwiLCJCc21hbGwiLCJDc21hbGwiLCJEc21hbGwiLCJFc21hbGwiLCJGc21hbGwiLCJHc21hbGwiLCJIc21hbGwiLCJJc21hbGwiLCJKc21hbGwiLCJLc21hbGwiLCJMc21hbGwiLCJNc21hbGwiLCJOc21hbGwiLCJPc21hbGwiLCJQc21hbGwiLCJRc21hbGwiLCJSc21hbGwiLCJTc21hbGwiLCJUc21hbGwiLCJVc21hbGwiLCJWc21hbGwiLCJXc21hbGwiLCJYc21hbGwiLCJZc21hbGwiLCJac21hbGwiLCJjb2xvbm1vbmV0YXJ5Iiwib25lZml0dGVkIiwicnVwaWFoIiwiVGlsZGVzbWFsbCIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsImV4Y2xhbWRvd25zbWFsbCIsImNlbnRvbGRzdHlsZSIsIkxzbGFzaHNtYWxsIiwiIiwiIiwiU2Nhcm9uc21hbGwiLCJaY2Fyb25zbWFsbCIsIkRpZXJlc2lzc21hbGwiLCJCcmV2ZXNtYWxsIiwiQ2Fyb25zbWFsbCIsIiIsIkRvdGFjY2VudHNtYWxsIiwiIiwiIiwiTWFjcm9uc21hbGwiLCIiLCIiLCJmaWd1cmVkYXNoIiwiaHlwaGVuaW5mZXJpb3IiLCIiLCIiLCJPZ29uZWtzbWFsbCIsIlJpbmdzbWFsbCIsIkNlZGlsbGFzbWFsbCIsIiIsIiIsIiIsIm9uZXF1YXJ0ZXIiLCJvbmVoYWxmIiwidGhyZWVxdWFydGVycyIsInF1ZXN0aW9uZG93bnNtYWxsIiwib25lZWlnaHRoIiwidGhyZWVlaWdodGhzIiwiZml2ZWVpZ2h0aHMiLCJzZXZlbmVpZ2h0aHMiLCJvbmV0aGlyZCIsInR3b3RoaXJkcyIsIiIsIiIsInplcm9zdXBlcmlvciIsIm9uZXN1cGVyaW9yIiwidHdvc3VwZXJpb3IiLCJ0aHJlZXN1cGVyaW9yIiwiZm91cnN1cGVyaW9yIiwiZml2ZXN1cGVyaW9yIiwic2l4c3VwZXJpb3IiLCJzZXZlbnN1cGVyaW9yIiwiZWlnaHRzdXBlcmlvciIsIm5pbmVzdXBlcmlvciIsInplcm9pbmZlcmlvciIsIm9uZWluZmVyaW9yIiwidHdvaW5mZXJpb3IiLCJ0aHJlZWluZmVyaW9yIiwiZm91cmluZmVyaW9yIiwiZml2ZWluZmVyaW9yIiwic2l4aW5mZXJpb3IiLCJzZXZlbmluZmVyaW9yIiwiZWlnaHRpbmZlcmlvciIsIm5pbmVpbmZlcmlvciIsImNlbnRpbmZlcmlvciIsImRvbGxhcmluZmVyaW9yIiwicGVyaW9kaW5mZXJpb3IiLCJjb21tYWluZmVyaW9yIiwiQWdyYXZlc21hbGwiLCJBYWN1dGVzbWFsbCIsIkFjaXJjdW1mbGV4c21hbGwiLCJBdGlsZGVzbWFsbCIsIkFkaWVyZXNpc3NtYWxsIiwiQXJpbmdzbWFsbCIsIkFFc21hbGwiLCJDY2VkaWxsYXNtYWxsIiwiRWdyYXZlc21hbGwiLCJFYWN1dGVzbWFsbCIsIkVjaXJjdW1mbGV4c21hbGwiLCJFZGllcmVzaXNzbWFsbCIsIklncmF2ZXNtYWxsIiwiSWFjdXRlc21hbGwiLCJJY2lyY3VtZmxleHNtYWxsIiwiSWRpZXJlc2lzc21hbGwiLCJFdGhzbWFsbCIsIk50aWxkZXNtYWxsIiwiT2dyYXZlc21hbGwiLCJPYWN1dGVzbWFsbCIsIk9jaXJjdW1mbGV4c21hbGwiLCJPdGlsZGVzbWFsbCIsIk9kaWVyZXNpc3NtYWxsIiwiT0VzbWFsbCIsIk9zbGFzaHNtYWxsIiwiVWdyYXZlc21hbGwiLCJVYWN1dGVzbWFsbCIsIlVjaXJjdW1mbGV4c21hbGwiLCJVZGllcmVzaXNzbWFsbCIsIllhY3V0ZXNtYWxsIiwiVGhvcm5zbWFsbCIsIllkaWVyZXNpc3NtYWxsIl0scnI9WyIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJzcGFjZSIsImV4Y2xhbXNtYWxsIiwiSHVuZ2FydW1sYXV0c21hbGwiLCJjZW50b2xkc3R5bGUiLCJkb2xsYXJvbGRzdHlsZSIsImRvbGxhcnN1cGVyaW9yIiwiYW1wZXJzYW5kc21hbGwiLCJBY3V0ZXNtYWxsIiwicGFyZW5sZWZ0c3VwZXJpb3IiLCJwYXJlbnJpZ2h0c3VwZXJpb3IiLCJ0d29kb3RlbmxlYWRlciIsIm9uZWRvdGVubGVhZGVyIiwiY29tbWEiLCJoeXBoZW4iLCJwZXJpb2QiLCJmcmFjdGlvbiIsInplcm9vbGRzdHlsZSIsIm9uZW9sZHN0eWxlIiwidHdvb2xkc3R5bGUiLCJ0aHJlZW9sZHN0eWxlIiwiZm91cm9sZHN0eWxlIiwiZml2ZW9sZHN0eWxlIiwic2l4b2xkc3R5bGUiLCJzZXZlbm9sZHN0eWxlIiwiZWlnaHRvbGRzdHlsZSIsIm5pbmVvbGRzdHlsZSIsImNvbG9uIiwic2VtaWNvbG9uIiwiIiwidGhyZWVxdWFydGVyc2VtZGFzaCIsIiIsInF1ZXN0aW9uc21hbGwiLCIiLCIiLCIiLCIiLCJFdGhzbWFsbCIsIiIsIiIsIm9uZXF1YXJ0ZXIiLCJvbmVoYWxmIiwidGhyZWVxdWFydGVycyIsIm9uZWVpZ2h0aCIsInRocmVlZWlnaHRocyIsImZpdmVlaWdodGhzIiwic2V2ZW5laWdodGhzIiwib25ldGhpcmQiLCJ0d290aGlyZHMiLCIiLCIiLCIiLCIiLCIiLCIiLCJmZiIsImZpIiwiZmwiLCJmZmkiLCJmZmwiLCJwYXJlbmxlZnRpbmZlcmlvciIsIiIsInBhcmVucmlnaHRpbmZlcmlvciIsIkNpcmN1bWZsZXhzbWFsbCIsImh5cGhlbmluZmVyaW9yIiwiR3JhdmVzbWFsbCIsIkFzbWFsbCIsIkJzbWFsbCIsIkNzbWFsbCIsIkRzbWFsbCIsIkVzbWFsbCIsIkZzbWFsbCIsIkdzbWFsbCIsIkhzbWFsbCIsIklzbWFsbCIsIkpzbWFsbCIsIktzbWFsbCIsIkxzbWFsbCIsIk1zbWFsbCIsIk5zbWFsbCIsIk9zbWFsbCIsIlBzbWFsbCIsIlFzbWFsbCIsIlJzbWFsbCIsIlNzbWFsbCIsIlRzbWFsbCIsIlVzbWFsbCIsIlZzbWFsbCIsIldzbWFsbCIsIlhzbWFsbCIsIllzbWFsbCIsIlpzbWFsbCIsImNvbG9ubW9uZXRhcnkiLCJvbmVmaXR0ZWQiLCJydXBpYWgiLCJUaWxkZXNtYWxsIiwiIiwiIiwiYXN1cGVyaW9yIiwiY2VudHN1cGVyaW9yIiwiIiwiIiwiIiwiIiwiQWFjdXRlc21hbGwiLCJBZ3JhdmVzbWFsbCIsIkFjaXJjdW1mbGV4c21hbGwiLCJBZGllcmVzaXNzbWFsbCIsIkF0aWxkZXNtYWxsIiwiQXJpbmdzbWFsbCIsIkNjZWRpbGxhc21hbGwiLCJFYWN1dGVzbWFsbCIsIkVncmF2ZXNtYWxsIiwiRWNpcmN1bWZsZXhzbWFsbCIsIkVkaWVyZXNpc3NtYWxsIiwiSWFjdXRlc21hbGwiLCJJZ3JhdmVzbWFsbCIsIkljaXJjdW1mbGV4c21hbGwiLCJJZGllcmVzaXNzbWFsbCIsIk50aWxkZXNtYWxsIiwiT2FjdXRlc21hbGwiLCJPZ3JhdmVzbWFsbCIsIk9jaXJjdW1mbGV4c21hbGwiLCJPZGllcmVzaXNzbWFsbCIsIk90aWxkZXNtYWxsIiwiVWFjdXRlc21hbGwiLCJVZ3JhdmVzbWFsbCIsIlVjaXJjdW1mbGV4c21hbGwiLCJVZGllcmVzaXNzbWFsbCIsIiIsImVpZ2h0c3VwZXJpb3IiLCJmb3VyaW5mZXJpb3IiLCJ0aHJlZWluZmVyaW9yIiwic2l4aW5mZXJpb3IiLCJlaWdodGluZmVyaW9yIiwic2V2ZW5pbmZlcmlvciIsIlNjYXJvbnNtYWxsIiwiIiwiY2VudGluZmVyaW9yIiwidHdvaW5mZXJpb3IiLCIiLCJEaWVyZXNpc3NtYWxsIiwiIiwiQ2Fyb25zbWFsbCIsIm9zdXBlcmlvciIsImZpdmVpbmZlcmlvciIsIiIsImNvbW1haW5mZXJpb3IiLCJwZXJpb2RpbmZlcmlvciIsIllhY3V0ZXNtYWxsIiwiIiwiZG9sbGFyaW5mZXJpb3IiLCIiLCIiLCJUaG9ybnNtYWxsIiwiIiwibmluZWluZmVyaW9yIiwiemVyb2luZmVyaW9yIiwiWmNhcm9uc21hbGwiLCJBRXNtYWxsIiwiT3NsYXNoc21hbGwiLCJxdWVzdGlvbmRvd25zbWFsbCIsIm9uZWluZmVyaW9yIiwiTHNsYXNoc21hbGwiLCIiLCIiLCIiLCIiLCIiLCIiLCJDZWRpbGxhc21hbGwiLCIiLCIiLCIiLCIiLCIiLCJPRXNtYWxsIiwiZmlndXJlZGFzaCIsImh5cGhlbnN1cGVyaW9yIiwiIiwiIiwiIiwiIiwiZXhjbGFtZG93bnNtYWxsIiwiIiwiWWRpZXJlc2lzc21hbGwiLCIiLCJvbmVzdXBlcmlvciIsInR3b3N1cGVyaW9yIiwidGhyZWVzdXBlcmlvciIsImZvdXJzdXBlcmlvciIsImZpdmVzdXBlcmlvciIsInNpeHN1cGVyaW9yIiwic2V2ZW5zdXBlcmlvciIsIm5pbmVzdXBlcmlvciIsInplcm9zdXBlcmlvciIsIiIsImVzdXBlcmlvciIsInJzdXBlcmlvciIsInRzdXBlcmlvciIsIiIsIiIsImlzdXBlcmlvciIsInNzdXBlcmlvciIsImRzdXBlcmlvciIsIiIsIiIsIiIsIiIsIiIsImxzdXBlcmlvciIsIk9nb25la3NtYWxsIiwiQnJldmVzbWFsbCIsIk1hY3JvbnNtYWxsIiwiYnN1cGVyaW9yIiwibnN1cGVyaW9yIiwibXN1cGVyaW9yIiwiY29tbWFzdXBlcmlvciIsInBlcmlvZHN1cGVyaW9yIiwiRG90YWNjZW50c21hbGwiLCJSaW5nc21hbGwiLCIiLCIiLCIiLCIiXSxpcj1bIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsInNwYWNlIiwiZXhjbGFtIiwicXVvdGVkYmwiLCJudW1iZXJzaWduIiwiZG9sbGFyIiwicGVyY2VudCIsImFtcGVyc2FuZCIsInF1b3Rlc2luZ2xlIiwicGFyZW5sZWZ0IiwicGFyZW5yaWdodCIsImFzdGVyaXNrIiwicGx1cyIsImNvbW1hIiwiaHlwaGVuIiwicGVyaW9kIiwic2xhc2giLCJ6ZXJvIiwib25lIiwidHdvIiwidGhyZWUiLCJmb3VyIiwiZml2ZSIsInNpeCIsInNldmVuIiwiZWlnaHQiLCJuaW5lIiwiY29sb24iLCJzZW1pY29sb24iLCJsZXNzIiwiZXF1YWwiLCJncmVhdGVyIiwicXVlc3Rpb24iLCJhdCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJUIiwiVSIsIlYiLCJXIiwiWCIsIlkiLCJaIiwiYnJhY2tldGxlZnQiLCJiYWNrc2xhc2giLCJicmFja2V0cmlnaHQiLCJhc2NpaWNpcmN1bSIsInVuZGVyc2NvcmUiLCJncmF2ZSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiYnJhY2VsZWZ0IiwiYmFyIiwiYnJhY2VyaWdodCIsImFzY2lpdGlsZGUiLCIiLCJBZGllcmVzaXMiLCJBcmluZyIsIkNjZWRpbGxhIiwiRWFjdXRlIiwiTnRpbGRlIiwiT2RpZXJlc2lzIiwiVWRpZXJlc2lzIiwiYWFjdXRlIiwiYWdyYXZlIiwiYWNpcmN1bWZsZXgiLCJhZGllcmVzaXMiLCJhdGlsZGUiLCJhcmluZyIsImNjZWRpbGxhIiwiZWFjdXRlIiwiZWdyYXZlIiwiZWNpcmN1bWZsZXgiLCJlZGllcmVzaXMiLCJpYWN1dGUiLCJpZ3JhdmUiLCJpY2lyY3VtZmxleCIsImlkaWVyZXNpcyIsIm50aWxkZSIsIm9hY3V0ZSIsIm9ncmF2ZSIsIm9jaXJjdW1mbGV4Iiwib2RpZXJlc2lzIiwib3RpbGRlIiwidWFjdXRlIiwidWdyYXZlIiwidWNpcmN1bWZsZXgiLCJ1ZGllcmVzaXMiLCJkYWdnZXIiLCJkZWdyZWUiLCJjZW50Iiwic3RlcmxpbmciLCJzZWN0aW9uIiwiYnVsbGV0IiwicGFyYWdyYXBoIiwiZ2VybWFuZGJscyIsInJlZ2lzdGVyZWQiLCJjb3B5cmlnaHQiLCJ0cmFkZW1hcmsiLCJhY3V0ZSIsImRpZXJlc2lzIiwibm90ZXF1YWwiLCJBRSIsIk9zbGFzaCIsImluZmluaXR5IiwicGx1c21pbnVzIiwibGVzc2VxdWFsIiwiZ3JlYXRlcmVxdWFsIiwieWVuIiwibXUiLCJwYXJ0aWFsZGlmZiIsInN1bW1hdGlvbiIsInByb2R1Y3QiLCJwaSIsImludGVncmFsIiwib3JkZmVtaW5pbmUiLCJvcmRtYXNjdWxpbmUiLCJPbWVnYSIsImFlIiwib3NsYXNoIiwicXVlc3Rpb25kb3duIiwiZXhjbGFtZG93biIsImxvZ2ljYWxub3QiLCJyYWRpY2FsIiwiZmxvcmluIiwiYXBwcm94ZXF1YWwiLCJEZWx0YSIsImd1aWxsZW1vdGxlZnQiLCJndWlsbGVtb3RyaWdodCIsImVsbGlwc2lzIiwic3BhY2UiLCJBZ3JhdmUiLCJBdGlsZGUiLCJPdGlsZGUiLCJPRSIsIm9lIiwiZW5kYXNoIiwiZW1kYXNoIiwicXVvdGVkYmxsZWZ0IiwicXVvdGVkYmxyaWdodCIsInF1b3RlbGVmdCIsInF1b3RlcmlnaHQiLCJkaXZpZGUiLCJsb3plbmdlIiwieWRpZXJlc2lzIiwiWWRpZXJlc2lzIiwiZnJhY3Rpb24iLCJjdXJyZW5jeSIsImd1aWxzaW5nbGxlZnQiLCJndWlsc2luZ2xyaWdodCIsImZpIiwiZmwiLCJkYWdnZXJkYmwiLCJwZXJpb2RjZW50ZXJlZCIsInF1b3Rlc2luZ2xiYXNlIiwicXVvdGVkYmxiYXNlIiwicGVydGhvdXNhbmQiLCJBY2lyY3VtZmxleCIsIkVjaXJjdW1mbGV4IiwiQWFjdXRlIiwiRWRpZXJlc2lzIiwiRWdyYXZlIiwiSWFjdXRlIiwiSWNpcmN1bWZsZXgiLCJJZGllcmVzaXMiLCJJZ3JhdmUiLCJPYWN1dGUiLCJPY2lyY3VtZmxleCIsImFwcGxlIiwiT2dyYXZlIiwiVWFjdXRlIiwiVWNpcmN1bWZsZXgiLCJVZ3JhdmUiLCJkb3RsZXNzaSIsImNpcmN1bWZsZXgiLCJ0aWxkZSIsIm1hY3JvbiIsImJyZXZlIiwiZG90YWNjZW50IiwicmluZyIsImNlZGlsbGEiLCJodW5nYXJ1bWxhdXQiLCJvZ29uZWsiLCJjYXJvbiJdLG5yPVsiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwic3BhY2UiLCJleGNsYW0iLCJxdW90ZWRibCIsIm51bWJlcnNpZ24iLCJkb2xsYXIiLCJwZXJjZW50IiwiYW1wZXJzYW5kIiwicXVvdGVyaWdodCIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwicXVvdGVsZWZ0IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJicmFjZWxlZnQiLCJiYXIiLCJicmFjZXJpZ2h0IiwiYXNjaWl0aWxkZSIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsImV4Y2xhbWRvd24iLCJjZW50Iiwic3RlcmxpbmciLCJmcmFjdGlvbiIsInllbiIsImZsb3JpbiIsInNlY3Rpb24iLCJjdXJyZW5jeSIsInF1b3Rlc2luZ2xlIiwicXVvdGVkYmxsZWZ0IiwiZ3VpbGxlbW90bGVmdCIsImd1aWxzaW5nbGxlZnQiLCJndWlsc2luZ2xyaWdodCIsImZpIiwiZmwiLCIiLCJlbmRhc2giLCJkYWdnZXIiLCJkYWdnZXJkYmwiLCJwZXJpb2RjZW50ZXJlZCIsIiIsInBhcmFncmFwaCIsImJ1bGxldCIsInF1b3Rlc2luZ2xiYXNlIiwicXVvdGVkYmxiYXNlIiwicXVvdGVkYmxyaWdodCIsImd1aWxsZW1vdHJpZ2h0IiwiZWxsaXBzaXMiLCJwZXJ0aG91c2FuZCIsIiIsInF1ZXN0aW9uZG93biIsIiIsImdyYXZlIiwiYWN1dGUiLCJjaXJjdW1mbGV4IiwidGlsZGUiLCJtYWNyb24iLCJicmV2ZSIsImRvdGFjY2VudCIsImRpZXJlc2lzIiwiIiwicmluZyIsImNlZGlsbGEiLCIiLCJodW5nYXJ1bWxhdXQiLCJvZ29uZWsiLCJjYXJvbiIsImVtZGFzaCIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIkFFIiwiIiwib3JkZmVtaW5pbmUiLCIiLCIiLCIiLCIiLCJMc2xhc2giLCJPc2xhc2giLCJPRSIsIm9yZG1hc2N1bGluZSIsIiIsIiIsIiIsIiIsIiIsImFlIiwiIiwiIiwiIiwiZG90bGVzc2kiLCIiLCIiLCJsc2xhc2giLCJvc2xhc2giLCJvZSIsImdlcm1hbmRibHMiLCIiLCIiLCIiLCIiXSxzcj1bIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsInNwYWNlIiwiZXhjbGFtIiwicXVvdGVkYmwiLCJudW1iZXJzaWduIiwiZG9sbGFyIiwicGVyY2VudCIsImFtcGVyc2FuZCIsInF1b3Rlc2luZ2xlIiwicGFyZW5sZWZ0IiwicGFyZW5yaWdodCIsImFzdGVyaXNrIiwicGx1cyIsImNvbW1hIiwiaHlwaGVuIiwicGVyaW9kIiwic2xhc2giLCJ6ZXJvIiwib25lIiwidHdvIiwidGhyZWUiLCJmb3VyIiwiZml2ZSIsInNpeCIsInNldmVuIiwiZWlnaHQiLCJuaW5lIiwiY29sb24iLCJzZW1pY29sb24iLCJsZXNzIiwiZXF1YWwiLCJncmVhdGVyIiwicXVlc3Rpb24iLCJhdCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJUIiwiVSIsIlYiLCJXIiwiWCIsIlkiLCJaIiwiYnJhY2tldGxlZnQiLCJiYWNrc2xhc2giLCJicmFja2V0cmlnaHQiLCJhc2NpaWNpcmN1bSIsInVuZGVyc2NvcmUiLCJncmF2ZSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiYnJhY2VsZWZ0IiwiYmFyIiwiYnJhY2VyaWdodCIsImFzY2lpdGlsZGUiLCJidWxsZXQiLCJFdXJvIiwiYnVsbGV0IiwicXVvdGVzaW5nbGJhc2UiLCJmbG9yaW4iLCJxdW90ZWRibGJhc2UiLCJlbGxpcHNpcyIsImRhZ2dlciIsImRhZ2dlcmRibCIsImNpcmN1bWZsZXgiLCJwZXJ0aG91c2FuZCIsIlNjYXJvbiIsImd1aWxzaW5nbGxlZnQiLCJPRSIsImJ1bGxldCIsIlpjYXJvbiIsImJ1bGxldCIsImJ1bGxldCIsInF1b3RlbGVmdCIsInF1b3RlcmlnaHQiLCJxdW90ZWRibGxlZnQiLCJxdW90ZWRibHJpZ2h0IiwiYnVsbGV0IiwiZW5kYXNoIiwiZW1kYXNoIiwidGlsZGUiLCJ0cmFkZW1hcmsiLCJzY2Fyb24iLCJndWlsc2luZ2xyaWdodCIsIm9lIiwiYnVsbGV0IiwiemNhcm9uIiwiWWRpZXJlc2lzIiwic3BhY2UiLCJleGNsYW1kb3duIiwiY2VudCIsInN0ZXJsaW5nIiwiY3VycmVuY3kiLCJ5ZW4iLCJicm9rZW5iYXIiLCJzZWN0aW9uIiwiZGllcmVzaXMiLCJjb3B5cmlnaHQiLCJvcmRmZW1pbmluZSIsImd1aWxsZW1vdGxlZnQiLCJsb2dpY2Fsbm90IiwiaHlwaGVuIiwicmVnaXN0ZXJlZCIsIm1hY3JvbiIsImRlZ3JlZSIsInBsdXNtaW51cyIsInR3b3N1cGVyaW9yIiwidGhyZWVzdXBlcmlvciIsImFjdXRlIiwibXUiLCJwYXJhZ3JhcGgiLCJwZXJpb2RjZW50ZXJlZCIsImNlZGlsbGEiLCJvbmVzdXBlcmlvciIsIm9yZG1hc2N1bGluZSIsImd1aWxsZW1vdHJpZ2h0Iiwib25lcXVhcnRlciIsIm9uZWhhbGYiLCJ0aHJlZXF1YXJ0ZXJzIiwicXVlc3Rpb25kb3duIiwiQWdyYXZlIiwiQWFjdXRlIiwiQWNpcmN1bWZsZXgiLCJBdGlsZGUiLCJBZGllcmVzaXMiLCJBcmluZyIsIkFFIiwiQ2NlZGlsbGEiLCJFZ3JhdmUiLCJFYWN1dGUiLCJFY2lyY3VtZmxleCIsIkVkaWVyZXNpcyIsIklncmF2ZSIsIklhY3V0ZSIsIkljaXJjdW1mbGV4IiwiSWRpZXJlc2lzIiwiRXRoIiwiTnRpbGRlIiwiT2dyYXZlIiwiT2FjdXRlIiwiT2NpcmN1bWZsZXgiLCJPdGlsZGUiLCJPZGllcmVzaXMiLCJtdWx0aXBseSIsIk9zbGFzaCIsIlVncmF2ZSIsIlVhY3V0ZSIsIlVjaXJjdW1mbGV4IiwiVWRpZXJlc2lzIiwiWWFjdXRlIiwiVGhvcm4iLCJnZXJtYW5kYmxzIiwiYWdyYXZlIiwiYWFjdXRlIiwiYWNpcmN1bWZsZXgiLCJhdGlsZGUiLCJhZGllcmVzaXMiLCJhcmluZyIsImFlIiwiY2NlZGlsbGEiLCJlZ3JhdmUiLCJlYWN1dGUiLCJlY2lyY3VtZmxleCIsImVkaWVyZXNpcyIsImlncmF2ZSIsImlhY3V0ZSIsImljaXJjdW1mbGV4IiwiaWRpZXJlc2lzIiwiZXRoIiwibnRpbGRlIiwib2dyYXZlIiwib2FjdXRlIiwib2NpcmN1bWZsZXgiLCJvdGlsZGUiLCJvZGllcmVzaXMiLCJkaXZpZGUiLCJvc2xhc2giLCJ1Z3JhdmUiLCJ1YWN1dGUiLCJ1Y2lyY3VtZmxleCIsInVkaWVyZXNpcyIsInlhY3V0ZSIsInRob3JuIiwieWRpZXJlc2lzIl0sb3I9WyIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJzcGFjZSIsImV4Y2xhbSIsInVuaXZlcnNhbCIsIm51bWJlcnNpZ24iLCJleGlzdGVudGlhbCIsInBlcmNlbnQiLCJhbXBlcnNhbmQiLCJzdWNodGhhdCIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3Rlcmlza21hdGgiLCJwbHVzIiwiY29tbWEiLCJtaW51cyIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiY29uZ3J1ZW50IiwiQWxwaGEiLCJCZXRhIiwiQ2hpIiwiRGVsdGEiLCJFcHNpbG9uIiwiUGhpIiwiR2FtbWEiLCJFdGEiLCJJb3RhIiwidGhldGExIiwiS2FwcGEiLCJMYW1iZGEiLCJNdSIsIk51IiwiT21pY3JvbiIsIlBpIiwiVGhldGEiLCJSaG8iLCJTaWdtYSIsIlRhdSIsIlVwc2lsb24iLCJzaWdtYTEiLCJPbWVnYSIsIlhpIiwiUHNpIiwiWmV0YSIsImJyYWNrZXRsZWZ0IiwidGhlcmVmb3JlIiwiYnJhY2tldHJpZ2h0IiwicGVycGVuZGljdWxhciIsInVuZGVyc2NvcmUiLCJyYWRpY2FsZXgiLCJhbHBoYSIsImJldGEiLCJjaGkiLCJkZWx0YSIsImVwc2lsb24iLCJwaGkiLCJnYW1tYSIsImV0YSIsImlvdGEiLCJwaGkxIiwia2FwcGEiLCJsYW1iZGEiLCJtdSIsIm51Iiwib21pY3JvbiIsInBpIiwidGhldGEiLCJyaG8iLCJzaWdtYSIsInRhdSIsInVwc2lsb24iLCJvbWVnYTEiLCJvbWVnYSIsInhpIiwicHNpIiwiemV0YSIsImJyYWNlbGVmdCIsImJhciIsImJyYWNlcmlnaHQiLCJzaW1pbGFyIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiRXVybyIsIlVwc2lsb24xIiwibWludXRlIiwibGVzc2VxdWFsIiwiZnJhY3Rpb24iLCJpbmZpbml0eSIsImZsb3JpbiIsImNsdWIiLCJkaWFtb25kIiwiaGVhcnQiLCJzcGFkZSIsImFycm93Ym90aCIsImFycm93bGVmdCIsImFycm93dXAiLCJhcnJvd3JpZ2h0IiwiYXJyb3dkb3duIiwiZGVncmVlIiwicGx1c21pbnVzIiwic2Vjb25kIiwiZ3JlYXRlcmVxdWFsIiwibXVsdGlwbHkiLCJwcm9wb3J0aW9uYWwiLCJwYXJ0aWFsZGlmZiIsImJ1bGxldCIsImRpdmlkZSIsIm5vdGVxdWFsIiwiZXF1aXZhbGVuY2UiLCJhcHByb3hlcXVhbCIsImVsbGlwc2lzIiwiYXJyb3d2ZXJ0ZXgiLCJhcnJvd2hvcml6ZXgiLCJjYXJyaWFnZXJldHVybiIsImFsZXBoIiwiSWZyYWt0dXIiLCJSZnJha3R1ciIsIndlaWVyc3RyYXNzIiwiY2lyY2xlbXVsdGlwbHkiLCJjaXJjbGVwbHVzIiwiZW1wdHlzZXQiLCJpbnRlcnNlY3Rpb24iLCJ1bmlvbiIsInByb3BlcnN1cGVyc2V0IiwicmVmbGV4c3VwZXJzZXQiLCJub3RzdWJzZXQiLCJwcm9wZXJzdWJzZXQiLCJyZWZsZXhzdWJzZXQiLCJlbGVtZW50Iiwibm90ZWxlbWVudCIsImFuZ2xlIiwiZ3JhZGllbnQiLCJyZWdpc3RlcnNlcmlmIiwiY29weXJpZ2h0c2VyaWYiLCJ0cmFkZW1hcmtzZXJpZiIsInByb2R1Y3QiLCJyYWRpY2FsIiwiZG90bWF0aCIsImxvZ2ljYWxub3QiLCJsb2dpY2FsYW5kIiwibG9naWNhbG9yIiwiYXJyb3dkYmxib3RoIiwiYXJyb3dkYmxsZWZ0IiwiYXJyb3dkYmx1cCIsImFycm93ZGJscmlnaHQiLCJhcnJvd2RibGRvd24iLCJsb3plbmdlIiwiYW5nbGVsZWZ0IiwicmVnaXN0ZXJzYW5zIiwiY29weXJpZ2h0c2FucyIsInRyYWRlbWFya3NhbnMiLCJzdW1tYXRpb24iLCJwYXJlbmxlZnR0cCIsInBhcmVubGVmdGV4IiwicGFyZW5sZWZ0YnQiLCJicmFja2V0bGVmdHRwIiwiYnJhY2tldGxlZnRleCIsImJyYWNrZXRsZWZ0YnQiLCJicmFjZWxlZnR0cCIsImJyYWNlbGVmdG1pZCIsImJyYWNlbGVmdGJ0IiwiYnJhY2VleCIsIiIsImFuZ2xlcmlnaHQiLCJpbnRlZ3JhbCIsImludGVncmFsdHAiLCJpbnRlZ3JhbGV4IiwiaW50ZWdyYWxidCIsInBhcmVucmlnaHR0cCIsInBhcmVucmlnaHRleCIsInBhcmVucmlnaHRidCIsImJyYWNrZXRyaWdodHRwIiwiYnJhY2tldHJpZ2h0ZXgiLCJicmFja2V0cmlnaHRidCIsImJyYWNlcmlnaHR0cCIsImJyYWNlcmlnaHRtaWQiLCJicmFjZXJpZ2h0YnQiLCIiXSxjcj1bIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsInNwYWNlIiwiYTEiLCJhMiIsImEyMDIiLCJhMyIsImE0IiwiYTUiLCJhMTE5IiwiYTExOCIsImExMTciLCJhMTEiLCJhMTIiLCJhMTMiLCJhMTQiLCJhMTUiLCJhMTYiLCJhMTA1IiwiYTE3IiwiYTE4IiwiYTE5IiwiYTIwIiwiYTIxIiwiYTIyIiwiYTIzIiwiYTI0IiwiYTI1IiwiYTI2IiwiYTI3IiwiYTI4IiwiYTYiLCJhNyIsImE4IiwiYTkiLCJhMTAiLCJhMjkiLCJhMzAiLCJhMzEiLCJhMzIiLCJhMzMiLCJhMzQiLCJhMzUiLCJhMzYiLCJhMzciLCJhMzgiLCJhMzkiLCJhNDAiLCJhNDEiLCJhNDIiLCJhNDMiLCJhNDQiLCJhNDUiLCJhNDYiLCJhNDciLCJhNDgiLCJhNDkiLCJhNTAiLCJhNTEiLCJhNTIiLCJhNTMiLCJhNTQiLCJhNTUiLCJhNTYiLCJhNTciLCJhNTgiLCJhNTkiLCJhNjAiLCJhNjEiLCJhNjIiLCJhNjMiLCJhNjQiLCJhNjUiLCJhNjYiLCJhNjciLCJhNjgiLCJhNjkiLCJhNzAiLCJhNzEiLCJhNzIiLCJhNzMiLCJhNzQiLCJhMjAzIiwiYTc1IiwiYTIwNCIsImE3NiIsImE3NyIsImE3OCIsImE3OSIsImE4MSIsImE4MiIsImE4MyIsImE4NCIsImE5NyIsImE5OCIsImE5OSIsImExMDAiLCIiLCJhODkiLCJhOTAiLCJhOTMiLCJhOTQiLCJhOTEiLCJhOTIiLCJhMjA1IiwiYTg1IiwiYTIwNiIsImE4NiIsImE4NyIsImE4OCIsImE5NSIsImE5NiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsImExMDEiLCJhMTAyIiwiYTEwMyIsImExMDQiLCJhMTA2IiwiYTEwNyIsImExMDgiLCJhMTEyIiwiYTExMSIsImExMTAiLCJhMTA5IiwiYTEyMCIsImExMjEiLCJhMTIyIiwiYTEyMyIsImExMjQiLCJhMTI1IiwiYTEyNiIsImExMjciLCJhMTI4IiwiYTEyOSIsImExMzAiLCJhMTMxIiwiYTEzMiIsImExMzMiLCJhMTM0IiwiYTEzNSIsImExMzYiLCJhMTM3IiwiYTEzOCIsImExMzkiLCJhMTQwIiwiYTE0MSIsImExNDIiLCJhMTQzIiwiYTE0NCIsImExNDUiLCJhMTQ2IiwiYTE0NyIsImExNDgiLCJhMTQ5IiwiYTE1MCIsImExNTEiLCJhMTUyIiwiYTE1MyIsImExNTQiLCJhMTU1IiwiYTE1NiIsImExNTciLCJhMTU4IiwiYTE1OSIsImExNjAiLCJhMTYxIiwiYTE2MyIsImExNjQiLCJhMTk2IiwiYTE2NSIsImExOTIiLCJhMTY2IiwiYTE2NyIsImExNjgiLCJhMTY5IiwiYTE3MCIsImExNzEiLCJhMTcyIiwiYTE3MyIsImExNjIiLCJhMTc0IiwiYTE3NSIsImExNzYiLCJhMTc3IiwiYTE3OCIsImExNzkiLCJhMTkzIiwiYTE4MCIsImExOTkiLCJhMTgxIiwiYTIwMCIsImExODIiLCIiLCJhMjAxIiwiYTE4MyIsImExODQiLCJhMTk3IiwiYTE4NSIsImExOTQiLCJhMTk4IiwiYTE4NiIsImExOTUiLCJhMTg3IiwiYTE4OCIsImExODkiLCJhMTkwIiwiYTE5MSIsIiJdO2Z1bmN0aW9uIGdldEVuY29kaW5nKGUpe3N3aXRjaChlKXtjYXNlIldpbkFuc2lFbmNvZGluZyI6cmV0dXJuIHNyO2Nhc2UiU3RhbmRhcmRFbmNvZGluZyI6cmV0dXJuIG5yO2Nhc2UiTWFjUm9tYW5FbmNvZGluZyI6cmV0dXJuIGlyO2Nhc2UiU3ltYm9sU2V0RW5jb2RpbmciOnJldHVybiBvcjtjYXNlIlphcGZEaW5nYmF0c0VuY29kaW5nIjpyZXR1cm4gY3I7Y2FzZSJFeHBlcnRFbmNvZGluZyI6cmV0dXJuIGFyO2Nhc2UiTWFjRXhwZXJ0RW5jb2RpbmciOnJldHVybiBycjtkZWZhdWx0OnJldHVybiBudWxsfX1jb25zdCBscj1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2UuQT02NTtlLkFFPTE5ODtlLkFFYWN1dGU9NTA4O2UuQUVtYWNyb249NDgyO2UuQUVzbWFsbD02MzQ2MjtlLkFhY3V0ZT0xOTM7ZS5BYWN1dGVzbWFsbD02MzQ1NztlLkFicmV2ZT0yNTg7ZS5BYnJldmVhY3V0ZT03ODU0O2UuQWJyZXZlY3lyaWxsaWM9MTIzMjtlLkFicmV2ZWRvdGJlbG93PTc4NjI7ZS5BYnJldmVncmF2ZT03ODU2O2UuQWJyZXZlaG9va2Fib3ZlPTc4NTg7ZS5BYnJldmV0aWxkZT03ODYwO2UuQWNhcm9uPTQ2MTtlLkFjaXJjbGU9OTM5ODtlLkFjaXJjdW1mbGV4PTE5NDtlLkFjaXJjdW1mbGV4YWN1dGU9Nzg0NDtlLkFjaXJjdW1mbGV4ZG90YmVsb3c9Nzg1MjtlLkFjaXJjdW1mbGV4Z3JhdmU9Nzg0NjtlLkFjaXJjdW1mbGV4aG9va2Fib3ZlPTc4NDg7ZS5BY2lyY3VtZmxleHNtYWxsPTYzNDU4O2UuQWNpcmN1bWZsZXh0aWxkZT03ODUwO2UuQWN1dGU9NjMxNzc7ZS5BY3V0ZXNtYWxsPTYzNDEyO2UuQWN5cmlsbGljPTEwNDA7ZS5BZGJsZ3JhdmU9NTEyO2UuQWRpZXJlc2lzPTE5NjtlLkFkaWVyZXNpc2N5cmlsbGljPTEyMzQ7ZS5BZGllcmVzaXNtYWNyb249NDc4O2UuQWRpZXJlc2lzc21hbGw9NjM0NjA7ZS5BZG90YmVsb3c9Nzg0MDtlLkFkb3RtYWNyb249NDgwO2UuQWdyYXZlPTE5MjtlLkFncmF2ZXNtYWxsPTYzNDU2O2UuQWhvb2thYm92ZT03ODQyO2UuQWllY3lyaWxsaWM9MTIzNjtlLkFpbnZlcnRlZGJyZXZlPTUxNDtlLkFscGhhPTkxMztlLkFscGhhdG9ub3M9OTAyO2UuQW1hY3Jvbj0yNTY7ZS5BbW9ub3NwYWNlPTY1MzEzO2UuQW9nb25laz0yNjA7ZS5BcmluZz0xOTc7ZS5BcmluZ2FjdXRlPTUwNjtlLkFyaW5nYmVsb3c9NzY4MDtlLkFyaW5nc21hbGw9NjM0NjE7ZS5Bc21hbGw9NjMzMjk7ZS5BdGlsZGU9MTk1O2UuQXRpbGRlc21hbGw9NjM0NTk7ZS5BeWJhcm1lbmlhbj0xMzI5O2UuQj02NjtlLkJjaXJjbGU9OTM5OTtlLkJkb3RhY2NlbnQ9NzY4MjtlLkJkb3RiZWxvdz03Njg0O2UuQmVjeXJpbGxpYz0xMDQxO2UuQmVuYXJtZW5pYW49MTMzMDtlLkJldGE9OTE0O2UuQmhvb2s9Mzg1O2UuQmxpbmViZWxvdz03Njg2O2UuQm1vbm9zcGFjZT02NTMxNDtlLkJyZXZlc21hbGw9NjMyMjA7ZS5Cc21hbGw9NjMzMzA7ZS5CdG9wYmFyPTM4NjtlLkM9Njc7ZS5DYWFybWVuaWFuPTEzNDI7ZS5DYWN1dGU9MjYyO2UuQ2Fyb249NjMxNzg7ZS5DYXJvbnNtYWxsPTYzMjIxO2UuQ2Nhcm9uPTI2ODtlLkNjZWRpbGxhPTE5OTtlLkNjZWRpbGxhYWN1dGU9NzY4ODtlLkNjZWRpbGxhc21hbGw9NjM0NjM7ZS5DY2lyY2xlPTk0MDA7ZS5DY2lyY3VtZmxleD0yNjQ7ZS5DZG90PTI2NjtlLkNkb3RhY2NlbnQ9MjY2O2UuQ2VkaWxsYXNtYWxsPTYzNDE2O2UuQ2hhYXJtZW5pYW49MTM1MztlLkNoZWFia2hhc2lhbmN5cmlsbGljPTEyMTI7ZS5DaGVjeXJpbGxpYz0xMDYzO2UuQ2hlZGVzY2VuZGVyYWJraGFzaWFuY3lyaWxsaWM9MTIxNDtlLkNoZWRlc2NlbmRlcmN5cmlsbGljPTEyMDY7ZS5DaGVkaWVyZXNpc2N5cmlsbGljPTEyNjg7ZS5DaGVoYXJtZW5pYW49MTM0NztlLkNoZWtoYWthc3NpYW5jeXJpbGxpYz0xMjI3O2UuQ2hldmVydGljYWxzdHJva2VjeXJpbGxpYz0xMjA4O2UuQ2hpPTkzNTtlLkNob29rPTM5MTtlLkNpcmN1bWZsZXhzbWFsbD02MzIyMjtlLkNtb25vc3BhY2U9NjUzMTU7ZS5Db2FybWVuaWFuPTEzNjE7ZS5Dc21hbGw9NjMzMzE7ZS5EPTY4O2UuRFo9NDk3O2UuRFpjYXJvbj00NTI7ZS5EYWFybWVuaWFuPTEzMzI7ZS5EYWZyaWNhbj0zOTM7ZS5EY2Fyb249MjcwO2UuRGNlZGlsbGE9NzY5NjtlLkRjaXJjbGU9OTQwMTtlLkRjaXJjdW1mbGV4YmVsb3c9NzY5ODtlLkRjcm9hdD0yNzI7ZS5EZG90YWNjZW50PTc2OTA7ZS5EZG90YmVsb3c9NzY5MjtlLkRlY3lyaWxsaWM9MTA0NDtlLkRlaWNvcHRpYz0xMDA2O2UuRGVsdGE9ODcxMDtlLkRlbHRhZ3JlZWs9OTE2O2UuRGhvb2s9Mzk0O2UuRGllcmVzaXM9NjMxNzk7ZS5EaWVyZXNpc0FjdXRlPTYzMTgwO2UuRGllcmVzaXNHcmF2ZT02MzE4MTtlLkRpZXJlc2lzc21hbGw9NjM0MDA7ZS5EaWdhbW1hZ3JlZWs9OTg4O2UuRGplY3lyaWxsaWM9MTAyNjtlLkRsaW5lYmVsb3c9NzY5NDtlLkRtb25vc3BhY2U9NjUzMTY7ZS5Eb3RhY2NlbnRzbWFsbD02MzIyMztlLkRzbGFzaD0yNzI7ZS5Ec21hbGw9NjMzMzI7ZS5EdG9wYmFyPTM5NTtlLkR6PTQ5ODtlLkR6Y2Fyb249NDUzO2UuRHplYWJraGFzaWFuY3lyaWxsaWM9MTI0ODtlLkR6ZWN5cmlsbGljPTEwMjk7ZS5EemhlY3lyaWxsaWM9MTAzOTtlLkU9Njk7ZS5FYWN1dGU9MjAxO2UuRWFjdXRlc21hbGw9NjM0NjU7ZS5FYnJldmU9Mjc2O2UuRWNhcm9uPTI4MjtlLkVjZWRpbGxhYnJldmU9NzcwODtlLkVjaGFybWVuaWFuPTEzMzM7ZS5FY2lyY2xlPTk0MDI7ZS5FY2lyY3VtZmxleD0yMDI7ZS5FY2lyY3VtZmxleGFjdXRlPTc4NzA7ZS5FY2lyY3VtZmxleGJlbG93PTc3MDQ7ZS5FY2lyY3VtZmxleGRvdGJlbG93PTc4Nzg7ZS5FY2lyY3VtZmxleGdyYXZlPTc4NzI7ZS5FY2lyY3VtZmxleGhvb2thYm92ZT03ODc0O2UuRWNpcmN1bWZsZXhzbWFsbD02MzQ2NjtlLkVjaXJjdW1mbGV4dGlsZGU9Nzg3NjtlLkVjeXJpbGxpYz0xMDI4O2UuRWRibGdyYXZlPTUxNjtlLkVkaWVyZXNpcz0yMDM7ZS5FZGllcmVzaXNzbWFsbD02MzQ2NztlLkVkb3Q9Mjc4O2UuRWRvdGFjY2VudD0yNzg7ZS5FZG90YmVsb3c9Nzg2NDtlLkVmY3lyaWxsaWM9MTA2MDtlLkVncmF2ZT0yMDA7ZS5FZ3JhdmVzbWFsbD02MzQ2NDtlLkVoYXJtZW5pYW49MTMzNTtlLkVob29rYWJvdmU9Nzg2NjtlLkVpZ2h0cm9tYW49ODU1MTtlLkVpbnZlcnRlZGJyZXZlPTUxODtlLkVpb3RpZmllZGN5cmlsbGljPTExMjQ7ZS5FbGN5cmlsbGljPTEwNTE7ZS5FbGV2ZW5yb21hbj04NTU0O2UuRW1hY3Jvbj0yNzQ7ZS5FbWFjcm9uYWN1dGU9NzcwMjtlLkVtYWNyb25ncmF2ZT03NzAwO2UuRW1jeXJpbGxpYz0xMDUyO2UuRW1vbm9zcGFjZT02NTMxNztlLkVuY3lyaWxsaWM9MTA1MztlLkVuZGVzY2VuZGVyY3lyaWxsaWM9MTE4NjtlLkVuZz0zMzA7ZS5FbmdoZWN5cmlsbGljPTExODg7ZS5Fbmhvb2tjeXJpbGxpYz0xMjIzO2UuRW9nb25laz0yODA7ZS5Fb3Blbj00MDA7ZS5FcHNpbG9uPTkxNztlLkVwc2lsb250b25vcz05MDQ7ZS5FcmN5cmlsbGljPTEwNTY7ZS5FcmV2ZXJzZWQ9Mzk4O2UuRXJldmVyc2VkY3lyaWxsaWM9MTA2OTtlLkVzY3lyaWxsaWM9MTA1NztlLkVzZGVzY2VuZGVyY3lyaWxsaWM9MTE5NDtlLkVzaD00MjU7ZS5Fc21hbGw9NjMzMzM7ZS5FdGE9OTE5O2UuRXRhcm1lbmlhbj0xMzM2O2UuRXRhdG9ub3M9OTA1O2UuRXRoPTIwODtlLkV0aHNtYWxsPTYzNDcyO2UuRXRpbGRlPTc4Njg7ZS5FdGlsZGViZWxvdz03NzA2O2UuRXVybz04MzY0O2UuRXpoPTQzOTtlLkV6aGNhcm9uPTQ5NDtlLkV6aHJldmVyc2VkPTQ0MDtlLkY9NzA7ZS5GY2lyY2xlPTk0MDM7ZS5GZG90YWNjZW50PTc3MTA7ZS5GZWhhcm1lbmlhbj0xMzY2O2UuRmVpY29wdGljPTk5NjtlLkZob29rPTQwMTtlLkZpdGFjeXJpbGxpYz0xMTM4O2UuRml2ZXJvbWFuPTg1NDg7ZS5GbW9ub3NwYWNlPTY1MzE4O2UuRm91cnJvbWFuPTg1NDc7ZS5Gc21hbGw9NjMzMzQ7ZS5HPTcxO2UuR0JzcXVhcmU9MTMxOTE7ZS5HYWN1dGU9NTAwO2UuR2FtbWE9OTE1O2UuR2FtbWFhZnJpY2FuPTQwNDtlLkdhbmdpYWNvcHRpYz0xMDAyO2UuR2JyZXZlPTI4NjtlLkdjYXJvbj00ODY7ZS5HY2VkaWxsYT0yOTA7ZS5HY2lyY2xlPTk0MDQ7ZS5HY2lyY3VtZmxleD0yODQ7ZS5HY29tbWFhY2NlbnQ9MjkwO2UuR2RvdD0yODg7ZS5HZG90YWNjZW50PTI4ODtlLkdlY3lyaWxsaWM9MTA0MztlLkdoYWRhcm1lbmlhbj0xMzQ2O2UuR2hlbWlkZGxlaG9va2N5cmlsbGljPTExNzI7ZS5HaGVzdHJva2VjeXJpbGxpYz0xMTcwO2UuR2hldXB0dXJuY3lyaWxsaWM9MTE2ODtlLkdob29rPTQwMztlLkdpbWFybWVuaWFuPTEzMzE7ZS5HamVjeXJpbGxpYz0xMDI3O2UuR21hY3Jvbj03NzEyO2UuR21vbm9zcGFjZT02NTMxOTtlLkdyYXZlPTYzMTgyO2UuR3JhdmVzbWFsbD02MzMyODtlLkdzbWFsbD02MzMzNTtlLkdzbWFsbGhvb2s9NjY3O2UuR3N0cm9rZT00ODQ7ZS5IPTcyO2UuSDE4NTMzPTk2Nzk7ZS5IMTg1NDM9OTY0MjtlLkgxODU1MT05NjQzO2UuSDIyMDczPTk2MzM7ZS5IUHNxdWFyZT0xMzI1OTtlLkhhYWJraGFzaWFuY3lyaWxsaWM9MTE5MjtlLkhhZGVzY2VuZGVyY3lyaWxsaWM9MTIwMjtlLkhhcmRzaWduY3lyaWxsaWM9MTA2NjtlLkhiYXI9Mjk0O2UuSGJyZXZlYmVsb3c9NzcyMjtlLkhjZWRpbGxhPTc3MjA7ZS5IY2lyY2xlPTk0MDU7ZS5IY2lyY3VtZmxleD0yOTI7ZS5IZGllcmVzaXM9NzcxODtlLkhkb3RhY2NlbnQ9NzcxNDtlLkhkb3RiZWxvdz03NzE2O2UuSG1vbm9zcGFjZT02NTMyMDtlLkhvYXJtZW5pYW49MTM0NDtlLkhvcmljb3B0aWM9MWUzO2UuSHNtYWxsPTYzMzM2O2UuSHVuZ2FydW1sYXV0PTYzMTgzO2UuSHVuZ2FydW1sYXV0c21hbGw9NjMyMjQ7ZS5IenNxdWFyZT0xMzIwMDtlLkk9NzM7ZS5JQWN5cmlsbGljPTEwNzE7ZS5JSj0zMDY7ZS5JVWN5cmlsbGljPTEwNzA7ZS5JYWN1dGU9MjA1O2UuSWFjdXRlc21hbGw9NjM0Njk7ZS5JYnJldmU9MzAwO2UuSWNhcm9uPTQ2MztlLkljaXJjbGU9OTQwNjtlLkljaXJjdW1mbGV4PTIwNjtlLkljaXJjdW1mbGV4c21hbGw9NjM0NzA7ZS5JY3lyaWxsaWM9MTAzMDtlLklkYmxncmF2ZT01MjA7ZS5JZGllcmVzaXM9MjA3O2UuSWRpZXJlc2lzYWN1dGU9NzcyNjtlLklkaWVyZXNpc2N5cmlsbGljPTEyNTI7ZS5JZGllcmVzaXNzbWFsbD02MzQ3MTtlLklkb3Q9MzA0O2UuSWRvdGFjY2VudD0zMDQ7ZS5JZG90YmVsb3c9Nzg4MjtlLkllYnJldmVjeXJpbGxpYz0xMjM4O2UuSWVjeXJpbGxpYz0xMDQ1O2UuSWZyYWt0dXI9ODQ2NTtlLklncmF2ZT0yMDQ7ZS5JZ3JhdmVzbWFsbD02MzQ2ODtlLklob29rYWJvdmU9Nzg4MDtlLklpY3lyaWxsaWM9MTA0ODtlLklpbnZlcnRlZGJyZXZlPTUyMjtlLklpc2hvcnRjeXJpbGxpYz0xMDQ5O2UuSW1hY3Jvbj0yOTg7ZS5JbWFjcm9uY3lyaWxsaWM9MTI1MDtlLkltb25vc3BhY2U9NjUzMjE7ZS5Jbmlhcm1lbmlhbj0xMzM5O2UuSW9jeXJpbGxpYz0xMDI1O2UuSW9nb25laz0zMDI7ZS5Jb3RhPTkyMTtlLklvdGFhZnJpY2FuPTQwNjtlLklvdGFkaWVyZXNpcz05Mzg7ZS5Jb3RhdG9ub3M9OTA2O2UuSXNtYWxsPTYzMzM3O2UuSXN0cm9rZT00MDc7ZS5JdGlsZGU9Mjk2O2UuSXRpbGRlYmVsb3c9NzcyNDtlLkl6aGl0c2FjeXJpbGxpYz0xMTQwO2UuSXpoaXRzYWRibGdyYXZlY3lyaWxsaWM9MTE0MjtlLko9NzQ7ZS5KYWFybWVuaWFuPTEzNDU7ZS5KY2lyY2xlPTk0MDc7ZS5KY2lyY3VtZmxleD0zMDg7ZS5KZWN5cmlsbGljPTEwMzI7ZS5KaGVoYXJtZW5pYW49MTM1NTtlLkptb25vc3BhY2U9NjUzMjI7ZS5Kc21hbGw9NjMzMzg7ZS5LPTc1O2UuS0JzcXVhcmU9MTMxODk7ZS5LS3NxdWFyZT0xMzI2MTtlLkthYmFzaGtpcmN5cmlsbGljPTExODQ7ZS5LYWN1dGU9NzcyODtlLkthY3lyaWxsaWM9MTA1MDtlLkthZGVzY2VuZGVyY3lyaWxsaWM9MTE3ODtlLkthaG9va2N5cmlsbGljPTEyMTk7ZS5LYXBwYT05MjI7ZS5LYXN0cm9rZWN5cmlsbGljPTExODI7ZS5LYXZlcnRpY2Fsc3Ryb2tlY3lyaWxsaWM9MTE4MDtlLktjYXJvbj00ODg7ZS5LY2VkaWxsYT0zMTA7ZS5LY2lyY2xlPTk0MDg7ZS5LY29tbWFhY2NlbnQ9MzEwO2UuS2RvdGJlbG93PTc3MzA7ZS5LZWhhcm1lbmlhbj0xMzY0O2UuS2VuYXJtZW5pYW49MTM0MztlLktoYWN5cmlsbGljPTEwNjE7ZS5LaGVpY29wdGljPTk5ODtlLktob29rPTQwODtlLktqZWN5cmlsbGljPTEwMzY7ZS5LbGluZWJlbG93PTc3MzI7ZS5LbW9ub3NwYWNlPTY1MzIzO2UuS29wcGFjeXJpbGxpYz0xMTUyO2UuS29wcGFncmVlaz05OTA7ZS5Lc2ljeXJpbGxpYz0xMTM0O2UuS3NtYWxsPTYzMzM5O2UuTD03NjtlLkxKPTQ1NTtlLkxMPTYzMTY3O2UuTGFjdXRlPTMxMztlLkxhbWJkYT05MjM7ZS5MY2Fyb249MzE3O2UuTGNlZGlsbGE9MzE1O2UuTGNpcmNsZT05NDA5O2UuTGNpcmN1bWZsZXhiZWxvdz03NzQwO2UuTGNvbW1hYWNjZW50PTMxNTtlLkxkb3Q9MzE5O2UuTGRvdGFjY2VudD0zMTk7ZS5MZG90YmVsb3c9NzczNDtlLkxkb3RiZWxvd21hY3Jvbj03NzM2O2UuTGl3bmFybWVuaWFuPTEzNDA7ZS5Maj00NTY7ZS5MamVjeXJpbGxpYz0xMDMzO2UuTGxpbmViZWxvdz03NzM4O2UuTG1vbm9zcGFjZT02NTMyNDtlLkxzbGFzaD0zMjE7ZS5Mc2xhc2hzbWFsbD02MzIyNTtlLkxzbWFsbD02MzM0MDtlLk09Nzc7ZS5NQnNxdWFyZT0xMzE5MDtlLk1hY3Jvbj02MzE4NDtlLk1hY3JvbnNtYWxsPTYzNDA3O2UuTWFjdXRlPTc3NDI7ZS5NY2lyY2xlPTk0MTA7ZS5NZG90YWNjZW50PTc3NDQ7ZS5NZG90YmVsb3c9Nzc0NjtlLk1lbmFybWVuaWFuPTEzNDg7ZS5NbW9ub3NwYWNlPTY1MzI1O2UuTXNtYWxsPTYzMzQxO2UuTXR1cm5lZD00MTI7ZS5NdT05MjQ7ZS5OPTc4O2UuTko9NDU4O2UuTmFjdXRlPTMyMztlLk5jYXJvbj0zMjc7ZS5OY2VkaWxsYT0zMjU7ZS5OY2lyY2xlPTk0MTE7ZS5OY2lyY3VtZmxleGJlbG93PTc3NTQ7ZS5OY29tbWFhY2NlbnQ9MzI1O2UuTmRvdGFjY2VudD03NzQ4O2UuTmRvdGJlbG93PTc3NTA7ZS5OaG9va2xlZnQ9NDEzO2UuTmluZXJvbWFuPTg1NTI7ZS5Oaj00NTk7ZS5OamVjeXJpbGxpYz0xMDM0O2UuTmxpbmViZWxvdz03NzUyO2UuTm1vbm9zcGFjZT02NTMyNjtlLk5vd2FybWVuaWFuPTEzNTA7ZS5Oc21hbGw9NjMzNDI7ZS5OdGlsZGU9MjA5O2UuTnRpbGRlc21hbGw9NjM0NzM7ZS5OdT05MjU7ZS5PPTc5O2UuT0U9MzM4O2UuT0VzbWFsbD02MzIyNjtlLk9hY3V0ZT0yMTE7ZS5PYWN1dGVzbWFsbD02MzQ3NTtlLk9iYXJyZWRjeXJpbGxpYz0xMjU2O2UuT2JhcnJlZGRpZXJlc2lzY3lyaWxsaWM9MTI1ODtlLk9icmV2ZT0zMzQ7ZS5PY2Fyb249NDY1O2UuT2NlbnRlcmVkdGlsZGU9NDE1O2UuT2NpcmNsZT05NDEyO2UuT2NpcmN1bWZsZXg9MjEyO2UuT2NpcmN1bWZsZXhhY3V0ZT03ODg4O2UuT2NpcmN1bWZsZXhkb3RiZWxvdz03ODk2O2UuT2NpcmN1bWZsZXhncmF2ZT03ODkwO2UuT2NpcmN1bWZsZXhob29rYWJvdmU9Nzg5MjtlLk9jaXJjdW1mbGV4c21hbGw9NjM0NzY7ZS5PY2lyY3VtZmxleHRpbGRlPTc4OTQ7ZS5PY3lyaWxsaWM9MTA1NDtlLk9kYmxhY3V0ZT0zMzY7ZS5PZGJsZ3JhdmU9NTI0O2UuT2RpZXJlc2lzPTIxNDtlLk9kaWVyZXNpc2N5cmlsbGljPTEyNTQ7ZS5PZGllcmVzaXNzbWFsbD02MzQ3ODtlLk9kb3RiZWxvdz03ODg0O2UuT2dvbmVrc21hbGw9NjMyMjc7ZS5PZ3JhdmU9MjEwO2UuT2dyYXZlc21hbGw9NjM0NzQ7ZS5PaGFybWVuaWFuPTEzNjU7ZS5PaG09ODQ4NjtlLk9ob29rYWJvdmU9Nzg4NjtlLk9ob3JuPTQxNjtlLk9ob3JuYWN1dGU9Nzg5ODtlLk9ob3JuZG90YmVsb3c9NzkwNjtlLk9ob3JuZ3JhdmU9NzkwMDtlLk9ob3JuaG9va2Fib3ZlPTc5MDI7ZS5PaG9ybnRpbGRlPTc5MDQ7ZS5PaHVuZ2FydW1sYXV0PTMzNjtlLk9pPTQxODtlLk9pbnZlcnRlZGJyZXZlPTUyNjtlLk9tYWNyb249MzMyO2UuT21hY3JvbmFjdXRlPTc3NjI7ZS5PbWFjcm9uZ3JhdmU9Nzc2MDtlLk9tZWdhPTg0ODY7ZS5PbWVnYWN5cmlsbGljPTExMjA7ZS5PbWVnYWdyZWVrPTkzNztlLk9tZWdhcm91bmRjeXJpbGxpYz0xMTQ2O2UuT21lZ2F0aXRsb2N5cmlsbGljPTExNDg7ZS5PbWVnYXRvbm9zPTkxMTtlLk9taWNyb249OTI3O2UuT21pY3JvbnRvbm9zPTkwODtlLk9tb25vc3BhY2U9NjUzMjc7ZS5PbmVyb21hbj04NTQ0O2UuT29nb25laz00OTA7ZS5Pb2dvbmVrbWFjcm9uPTQ5MjtlLk9vcGVuPTM5MDtlLk9zbGFzaD0yMTY7ZS5Pc2xhc2hhY3V0ZT01MTA7ZS5Pc2xhc2hzbWFsbD02MzQ4MDtlLk9zbWFsbD02MzM0MztlLk9zdHJva2VhY3V0ZT01MTA7ZS5PdGN5cmlsbGljPTExNTA7ZS5PdGlsZGU9MjEzO2UuT3RpbGRlYWN1dGU9Nzc1NjtlLk90aWxkZWRpZXJlc2lzPTc3NTg7ZS5PdGlsZGVzbWFsbD02MzQ3NztlLlA9ODA7ZS5QYWN1dGU9Nzc2NDtlLlBjaXJjbGU9OTQxMztlLlBkb3RhY2NlbnQ9Nzc2NjtlLlBlY3lyaWxsaWM9MTA1NTtlLlBlaGFybWVuaWFuPTEzNTQ7ZS5QZW1pZGRsZWhvb2tjeXJpbGxpYz0xMTkwO2UuUGhpPTkzNDtlLlBob29rPTQyMDtlLlBpPTkyODtlLlBpd3Jhcm1lbmlhbj0xMzYzO2UuUG1vbm9zcGFjZT02NTMyODtlLlBzaT05MzY7ZS5Qc2ljeXJpbGxpYz0xMTM2O2UuUHNtYWxsPTYzMzQ0O2UuUT04MTtlLlFjaXJjbGU9OTQxNDtlLlFtb25vc3BhY2U9NjUzMjk7ZS5Rc21hbGw9NjMzNDU7ZS5SPTgyO2UuUmFhcm1lbmlhbj0xMzU2O2UuUmFjdXRlPTM0MDtlLlJjYXJvbj0zNDQ7ZS5SY2VkaWxsYT0zNDI7ZS5SY2lyY2xlPTk0MTU7ZS5SY29tbWFhY2NlbnQ9MzQyO2UuUmRibGdyYXZlPTUyODtlLlJkb3RhY2NlbnQ9Nzc2ODtlLlJkb3RiZWxvdz03NzcwO2UuUmRvdGJlbG93bWFjcm9uPTc3NzI7ZS5SZWhhcm1lbmlhbj0xMzYwO2UuUmZyYWt0dXI9ODQ3NjtlLlJobz05Mjk7ZS5SaW5nc21hbGw9NjMyMjg7ZS5SaW52ZXJ0ZWRicmV2ZT01MzA7ZS5SbGluZWJlbG93PTc3NzQ7ZS5SbW9ub3NwYWNlPTY1MzMwO2UuUnNtYWxsPTYzMzQ2O2UuUnNtYWxsaW52ZXJ0ZWQ9NjQxO2UuUnNtYWxsaW52ZXJ0ZWRzdXBlcmlvcj02OTQ7ZS5TPTgzO2UuU0YwMTAwMDA9OTQ4NDtlLlNGMDIwMDAwPTk0OTI7ZS5TRjAzMDAwMD05NDg4O2UuU0YwNDAwMDA9OTQ5NjtlLlNGMDUwMDAwPTk1MzI7ZS5TRjA2MDAwMD05NTE2O2UuU0YwNzAwMDA9OTUyNDtlLlNGMDgwMDAwPTk1MDA7ZS5TRjA5MDAwMD05NTA4O2UuU0YxMDAwMDA9OTQ3MjtlLlNGMTEwMDAwPTk0NzQ7ZS5TRjE5MDAwMD05NTY5O2UuU0YyMDAwMDA9OTU3MDtlLlNGMjEwMDAwPTk1NTg7ZS5TRjIyMDAwMD05NTU3O2UuU0YyMzAwMDA9OTU3MTtlLlNGMjQwMDAwPTk1NTM7ZS5TRjI1MDAwMD05NTU5O2UuU0YyNjAwMDA9OTU2NTtlLlNGMjcwMDAwPTk1NjQ7ZS5TRjI4MDAwMD05NTYzO2UuU0YzNjAwMDA9OTU2NjtlLlNGMzcwMDAwPTk1Njc7ZS5TRjM4MDAwMD05NTYyO2UuU0YzOTAwMDA9OTU1NjtlLlNGNDAwMDAwPTk1Nzc7ZS5TRjQxMDAwMD05NTc0O2UuU0Y0MjAwMDA9OTU2ODtlLlNGNDMwMDAwPTk1NTI7ZS5TRjQ0MDAwMD05NTgwO2UuU0Y0NTAwMDA9OTU3NTtlLlNGNDYwMDAwPTk1NzY7ZS5TRjQ3MDAwMD05NTcyO2UuU0Y0ODAwMDA9OTU3MztlLlNGNDkwMDAwPTk1NjE7ZS5TRjUwMDAwMD05NTYwO2UuU0Y1MTAwMDA9OTU1NDtlLlNGNTIwMDAwPTk1NTU7ZS5TRjUzMDAwMD05NTc5O2UuU0Y1NDAwMDA9OTU3ODtlLlNhY3V0ZT0zNDY7ZS5TYWN1dGVkb3RhY2NlbnQ9Nzc4MDtlLlNhbXBpZ3JlZWs9OTkyO2UuU2Nhcm9uPTM1MjtlLlNjYXJvbmRvdGFjY2VudD03NzgyO2UuU2Nhcm9uc21hbGw9NjMyMjk7ZS5TY2VkaWxsYT0zNTA7ZS5TY2h3YT0zOTk7ZS5TY2h3YWN5cmlsbGljPTEyNDA7ZS5TY2h3YWRpZXJlc2lzY3lyaWxsaWM9MTI0MjtlLlNjaXJjbGU9OTQxNjtlLlNjaXJjdW1mbGV4PTM0ODtlLlNjb21tYWFjY2VudD01MzY7ZS5TZG90YWNjZW50PTc3NzY7ZS5TZG90YmVsb3c9Nzc3ODtlLlNkb3RiZWxvd2RvdGFjY2VudD03Nzg0O2UuU2VoYXJtZW5pYW49MTM1NztlLlNldmVucm9tYW49ODU1MDtlLlNoYWFybWVuaWFuPTEzNTE7ZS5TaGFjeXJpbGxpYz0xMDY0O2UuU2hjaGFjeXJpbGxpYz0xMDY1O2UuU2hlaWNvcHRpYz05OTQ7ZS5TaGhhY3lyaWxsaWM9MTIxMDtlLlNoaW1hY29wdGljPTEwMDQ7ZS5TaWdtYT05MzE7ZS5TaXhyb21hbj04NTQ5O2UuU21vbm9zcGFjZT02NTMzMTtlLlNvZnRzaWduY3lyaWxsaWM9MTA2ODtlLlNzbWFsbD02MzM0NztlLlN0aWdtYWdyZWVrPTk4NjtlLlQ9ODQ7ZS5UYXU9OTMyO2UuVGJhcj0zNTg7ZS5UY2Fyb249MzU2O2UuVGNlZGlsbGE9MzU0O2UuVGNpcmNsZT05NDE3O2UuVGNpcmN1bWZsZXhiZWxvdz03NzkyO2UuVGNvbW1hYWNjZW50PTM1NDtlLlRkb3RhY2NlbnQ9Nzc4NjtlLlRkb3RiZWxvdz03Nzg4O2UuVGVjeXJpbGxpYz0xMDU4O2UuVGVkZXNjZW5kZXJjeXJpbGxpYz0xMTk2O2UuVGVucm9tYW49ODU1MztlLlRldHNlY3lyaWxsaWM9MTIwNDtlLlRoZXRhPTkyMDtlLlRob29rPTQyODtlLlRob3JuPTIyMjtlLlRob3Juc21hbGw9NjM0ODY7ZS5UaHJlZXJvbWFuPTg1NDY7ZS5UaWxkZXNtYWxsPTYzMjMwO2UuVGl3bmFybWVuaWFuPTEzNTk7ZS5UbGluZWJlbG93PTc3OTA7ZS5UbW9ub3NwYWNlPTY1MzMyO2UuVG9hcm1lbmlhbj0xMzM3O2UuVG9uZWZpdmU9NDQ0O2UuVG9uZXNpeD0zODg7ZS5Ub25ldHdvPTQyMztlLlRyZXRyb2ZsZXhob29rPTQzMDtlLlRzZWN5cmlsbGljPTEwNjI7ZS5Uc2hlY3lyaWxsaWM9MTAzNTtlLlRzbWFsbD02MzM0ODtlLlR3ZWx2ZXJvbWFuPTg1NTU7ZS5Ud29yb21hbj04NTQ1O2UuVT04NTtlLlVhY3V0ZT0yMTg7ZS5VYWN1dGVzbWFsbD02MzQ4MjtlLlVicmV2ZT0zNjQ7ZS5VY2Fyb249NDY3O2UuVWNpcmNsZT05NDE4O2UuVWNpcmN1bWZsZXg9MjE5O2UuVWNpcmN1bWZsZXhiZWxvdz03Nzk4O2UuVWNpcmN1bWZsZXhzbWFsbD02MzQ4MztlLlVjeXJpbGxpYz0xMDU5O2UuVWRibGFjdXRlPTM2ODtlLlVkYmxncmF2ZT01MzI7ZS5VZGllcmVzaXM9MjIwO2UuVWRpZXJlc2lzYWN1dGU9NDcxO2UuVWRpZXJlc2lzYmVsb3c9Nzc5NDtlLlVkaWVyZXNpc2Nhcm9uPTQ3MztlLlVkaWVyZXNpc2N5cmlsbGljPTEyNjQ7ZS5VZGllcmVzaXNncmF2ZT00NzU7ZS5VZGllcmVzaXNtYWNyb249NDY5O2UuVWRpZXJlc2lzc21hbGw9NjM0ODQ7ZS5VZG90YmVsb3c9NzkwODtlLlVncmF2ZT0yMTc7ZS5VZ3JhdmVzbWFsbD02MzQ4MTtlLlVob29rYWJvdmU9NzkxMDtlLlVob3JuPTQzMTtlLlVob3JuYWN1dGU9NzkxMjtlLlVob3JuZG90YmVsb3c9NzkyMDtlLlVob3JuZ3JhdmU9NzkxNDtlLlVob3JuaG9va2Fib3ZlPTc5MTY7ZS5VaG9ybnRpbGRlPTc5MTg7ZS5VaHVuZ2FydW1sYXV0PTM2ODtlLlVodW5nYXJ1bWxhdXRjeXJpbGxpYz0xMjY2O2UuVWludmVydGVkYnJldmU9NTM0O2UuVWtjeXJpbGxpYz0xMTQ0O2UuVW1hY3Jvbj0zNjI7ZS5VbWFjcm9uY3lyaWxsaWM9MTI2MjtlLlVtYWNyb25kaWVyZXNpcz03ODAyO2UuVW1vbm9zcGFjZT02NTMzMztlLlVvZ29uZWs9MzcwO2UuVXBzaWxvbj05MzM7ZS5VcHNpbG9uMT05Nzg7ZS5VcHNpbG9uYWN1dGVob29rc3ltYm9sZ3JlZWs9OTc5O2UuVXBzaWxvbmFmcmljYW49NDMzO2UuVXBzaWxvbmRpZXJlc2lzPTkzOTtlLlVwc2lsb25kaWVyZXNpc2hvb2tzeW1ib2xncmVlaz05ODA7ZS5VcHNpbG9uaG9va3N5bWJvbD05Nzg7ZS5VcHNpbG9udG9ub3M9OTEwO2UuVXJpbmc9MzY2O2UuVXNob3J0Y3lyaWxsaWM9MTAzODtlLlVzbWFsbD02MzM0OTtlLlVzdHJhaWdodGN5cmlsbGljPTExOTg7ZS5Vc3RyYWlnaHRzdHJva2VjeXJpbGxpYz0xMjAwO2UuVXRpbGRlPTM2MDtlLlV0aWxkZWFjdXRlPTc4MDA7ZS5VdGlsZGViZWxvdz03Nzk2O2UuVj04NjtlLlZjaXJjbGU9OTQxOTtlLlZkb3RiZWxvdz03ODA2O2UuVmVjeXJpbGxpYz0xMDQyO2UuVmV3YXJtZW5pYW49MTM1ODtlLlZob29rPTQzNDtlLlZtb25vc3BhY2U9NjUzMzQ7ZS5Wb2FybWVuaWFuPTEzNTI7ZS5Wc21hbGw9NjMzNTA7ZS5WdGlsZGU9NzgwNDtlLlc9ODc7ZS5XYWN1dGU9NzgxMDtlLldjaXJjbGU9OTQyMDtlLldjaXJjdW1mbGV4PTM3MjtlLldkaWVyZXNpcz03ODEyO2UuV2RvdGFjY2VudD03ODE0O2UuV2RvdGJlbG93PTc4MTY7ZS5XZ3JhdmU9NzgwODtlLldtb25vc3BhY2U9NjUzMzU7ZS5Xc21hbGw9NjMzNTE7ZS5YPTg4O2UuWGNpcmNsZT05NDIxO2UuWGRpZXJlc2lzPTc4MjA7ZS5YZG90YWNjZW50PTc4MTg7ZS5YZWhhcm1lbmlhbj0xMzQxO2UuWGk9OTI2O2UuWG1vbm9zcGFjZT02NTMzNjtlLlhzbWFsbD02MzM1MjtlLlk9ODk7ZS5ZYWN1dGU9MjIxO2UuWWFjdXRlc21hbGw9NjM0ODU7ZS5ZYXRjeXJpbGxpYz0xMTIyO2UuWWNpcmNsZT05NDIyO2UuWWNpcmN1bWZsZXg9Mzc0O2UuWWRpZXJlc2lzPTM3NjtlLllkaWVyZXNpc3NtYWxsPTYzNDg3O2UuWWRvdGFjY2VudD03ODIyO2UuWWRvdGJlbG93PTc5MjQ7ZS5ZZXJpY3lyaWxsaWM9MTA2NztlLlllcnVkaWVyZXNpc2N5cmlsbGljPTEyNzI7ZS5ZZ3JhdmU9NzkyMjtlLllob29rPTQzNTtlLllob29rYWJvdmU9NzkyNjtlLllpYXJtZW5pYW49MTM0OTtlLllpY3lyaWxsaWM9MTAzMTtlLllpd25hcm1lbmlhbj0xMzYyO2UuWW1vbm9zcGFjZT02NTMzNztlLllzbWFsbD02MzM1MztlLll0aWxkZT03OTI4O2UuWXVzYmlnY3lyaWxsaWM9MTEzMDtlLll1c2JpZ2lvdGlmaWVkY3lyaWxsaWM9MTEzMjtlLll1c2xpdHRsZWN5cmlsbGljPTExMjY7ZS5ZdXNsaXR0bGVpb3RpZmllZGN5cmlsbGljPTExMjg7ZS5aPTkwO2UuWmFhcm1lbmlhbj0xMzM0O2UuWmFjdXRlPTM3NztlLlpjYXJvbj0zODE7ZS5aY2Fyb25zbWFsbD02MzIzMTtlLlpjaXJjbGU9OTQyMztlLlpjaXJjdW1mbGV4PTc4MjQ7ZS5aZG90PTM3OTtlLlpkb3RhY2NlbnQ9Mzc5O2UuWmRvdGJlbG93PTc4MjY7ZS5aZWN5cmlsbGljPTEwNDc7ZS5aZWRlc2NlbmRlcmN5cmlsbGljPTExNzY7ZS5aZWRpZXJlc2lzY3lyaWxsaWM9MTI0NjtlLlpldGE9OTE4O2UuWmhlYXJtZW5pYW49MTMzODtlLlpoZWJyZXZlY3lyaWxsaWM9MTIxNztlLlpoZWN5cmlsbGljPTEwNDY7ZS5aaGVkZXNjZW5kZXJjeXJpbGxpYz0xMTc0O2UuWmhlZGllcmVzaXNjeXJpbGxpYz0xMjQ0O2UuWmxpbmViZWxvdz03ODI4O2UuWm1vbm9zcGFjZT02NTMzODtlLlpzbWFsbD02MzM1NDtlLlpzdHJva2U9NDM3O2UuYT05NztlLmFhYmVuZ2FsaT0yNDM4O2UuYWFjdXRlPTIyNTtlLmFhZGV2YT0yMzEwO2UuYWFndWphcmF0aT0yNjk0O2UuYWFndXJtdWtoaT0yNTY2O2UuYWFtYXRyYWd1cm11a2hpPTI2MjI7ZS5hYXJ1c3F1YXJlPTEzMDU5O2UuYWF2b3dlbHNpZ25iZW5nYWxpPTI0OTQ7ZS5hYXZvd2Vsc2lnbmRldmE9MjM2NjtlLmFhdm93ZWxzaWduZ3VqYXJhdGk9Mjc1MDtlLmFiYnJldmlhdGlvbm1hcmthcm1lbmlhbj0xMzc1O2UuYWJicmV2aWF0aW9uc2lnbmRldmE9MjQxNjtlLmFiZW5nYWxpPTI0Mzc7ZS5hYm9wb21vZm89MTI1NzA7ZS5hYnJldmU9MjU5O2UuYWJyZXZlYWN1dGU9Nzg1NTtlLmFicmV2ZWN5cmlsbGljPTEyMzM7ZS5hYnJldmVkb3RiZWxvdz03ODYzO2UuYWJyZXZlZ3JhdmU9Nzg1NztlLmFicmV2ZWhvb2thYm92ZT03ODU5O2UuYWJyZXZldGlsZGU9Nzg2MTtlLmFjYXJvbj00NjI7ZS5hY2lyY2xlPTk0MjQ7ZS5hY2lyY3VtZmxleD0yMjY7ZS5hY2lyY3VtZmxleGFjdXRlPTc4NDU7ZS5hY2lyY3VtZmxleGRvdGJlbG93PTc4NTM7ZS5hY2lyY3VtZmxleGdyYXZlPTc4NDc7ZS5hY2lyY3VtZmxleGhvb2thYm92ZT03ODQ5O2UuYWNpcmN1bWZsZXh0aWxkZT03ODUxO2UuYWN1dGU9MTgwO2UuYWN1dGViZWxvd2NtYj03OTE7ZS5hY3V0ZWNtYj03Njk7ZS5hY3V0ZWNvbWI9NzY5O2UuYWN1dGVkZXZhPTIzODg7ZS5hY3V0ZWxvd21vZD03MTk7ZS5hY3V0ZXRvbmVjbWI9ODMzO2UuYWN5cmlsbGljPTEwNzI7ZS5hZGJsZ3JhdmU9NTEzO2UuYWRkYWtndXJtdWtoaT0yNjczO2UuYWRldmE9MjMwOTtlLmFkaWVyZXNpcz0yMjg7ZS5hZGllcmVzaXNjeXJpbGxpYz0xMjM1O2UuYWRpZXJlc2lzbWFjcm9uPTQ3OTtlLmFkb3RiZWxvdz03ODQxO2UuYWRvdG1hY3Jvbj00ODE7ZS5hZT0yMzA7ZS5hZWFjdXRlPTUwOTtlLmFla29yZWFuPTEyNjI0O2UuYWVtYWNyb249NDgzO2UuYWZpaTAwMjA4PTgyMTM7ZS5hZmlpMDg5NDE9ODM1NjtlLmFmaWkxMDAxNz0xMDQwO2UuYWZpaTEwMDE4PTEwNDE7ZS5hZmlpMTAwMTk9MTA0MjtlLmFmaWkxMDAyMD0xMDQzO2UuYWZpaTEwMDIxPTEwNDQ7ZS5hZmlpMTAwMjI9MTA0NTtlLmFmaWkxMDAyMz0xMDI1O2UuYWZpaTEwMDI0PTEwNDY7ZS5hZmlpMTAwMjU9MTA0NztlLmFmaWkxMDAyNj0xMDQ4O2UuYWZpaTEwMDI3PTEwNDk7ZS5hZmlpMTAwMjg9MTA1MDtlLmFmaWkxMDAyOT0xMDUxO2UuYWZpaTEwMDMwPTEwNTI7ZS5hZmlpMTAwMzE9MTA1MztlLmFmaWkxMDAzMj0xMDU0O2UuYWZpaTEwMDMzPTEwNTU7ZS5hZmlpMTAwMzQ9MTA1NjtlLmFmaWkxMDAzNT0xMDU3O2UuYWZpaTEwMDM2PTEwNTg7ZS5hZmlpMTAwMzc9MTA1OTtlLmFmaWkxMDAzOD0xMDYwO2UuYWZpaTEwMDM5PTEwNjE7ZS5hZmlpMTAwNDA9MTA2MjtlLmFmaWkxMDA0MT0xMDYzO2UuYWZpaTEwMDQyPTEwNjQ7ZS5hZmlpMTAwNDM9MTA2NTtlLmFmaWkxMDA0ND0xMDY2O2UuYWZpaTEwMDQ1PTEwNjc7ZS5hZmlpMTAwNDY9MTA2ODtlLmFmaWkxMDA0Nz0xMDY5O2UuYWZpaTEwMDQ4PTEwNzA7ZS5hZmlpMTAwNDk9MTA3MTtlLmFmaWkxMDA1MD0xMTY4O2UuYWZpaTEwMDUxPTEwMjY7ZS5hZmlpMTAwNTI9MTAyNztlLmFmaWkxMDA1Mz0xMDI4O2UuYWZpaTEwMDU0PTEwMjk7ZS5hZmlpMTAwNTU9MTAzMDtlLmFmaWkxMDA1Nj0xMDMxO2UuYWZpaTEwMDU3PTEwMzI7ZS5hZmlpMTAwNTg9MTAzMztlLmFmaWkxMDA1OT0xMDM0O2UuYWZpaTEwMDYwPTEwMzU7ZS5hZmlpMTAwNjE9MTAzNjtlLmFmaWkxMDA2Mj0xMDM4O2UuYWZpaTEwMDYzPTYzMTcyO2UuYWZpaTEwMDY0PTYzMTczO2UuYWZpaTEwMDY1PTEwNzI7ZS5hZmlpMTAwNjY9MTA3MztlLmFmaWkxMDA2Nz0xMDc0O2UuYWZpaTEwMDY4PTEwNzU7ZS5hZmlpMTAwNjk9MTA3NjtlLmFmaWkxMDA3MD0xMDc3O2UuYWZpaTEwMDcxPTExMDU7ZS5hZmlpMTAwNzI9MTA3ODtlLmFmaWkxMDA3Mz0xMDc5O2UuYWZpaTEwMDc0PTEwODA7ZS5hZmlpMTAwNzU9MTA4MTtlLmFmaWkxMDA3Nj0xMDgyO2UuYWZpaTEwMDc3PTEwODM7ZS5hZmlpMTAwNzg9MTA4NDtlLmFmaWkxMDA3OT0xMDg1O2UuYWZpaTEwMDgwPTEwODY7ZS5hZmlpMTAwODE9MTA4NztlLmFmaWkxMDA4Mj0xMDg4O2UuYWZpaTEwMDgzPTEwODk7ZS5hZmlpMTAwODQ9MTA5MDtlLmFmaWkxMDA4NT0xMDkxO2UuYWZpaTEwMDg2PTEwOTI7ZS5hZmlpMTAwODc9MTA5MztlLmFmaWkxMDA4OD0xMDk0O2UuYWZpaTEwMDg5PTEwOTU7ZS5hZmlpMTAwOTA9MTA5NjtlLmFmaWkxMDA5MT0xMDk3O2UuYWZpaTEwMDkyPTEwOTg7ZS5hZmlpMTAwOTM9MTA5OTtlLmFmaWkxMDA5ND0xMTAwO2UuYWZpaTEwMDk1PTExMDE7ZS5hZmlpMTAwOTY9MTEwMjtlLmFmaWkxMDA5Nz0xMTAzO2UuYWZpaTEwMDk4PTExNjk7ZS5hZmlpMTAwOTk9MTEwNjtlLmFmaWkxMDEwMD0xMTA3O2UuYWZpaTEwMTAxPTExMDg7ZS5hZmlpMTAxMDI9MTEwOTtlLmFmaWkxMDEwMz0xMTEwO2UuYWZpaTEwMTA0PTExMTE7ZS5hZmlpMTAxMDU9MTExMjtlLmFmaWkxMDEwNj0xMTEzO2UuYWZpaTEwMTA3PTExMTQ7ZS5hZmlpMTAxMDg9MTExNTtlLmFmaWkxMDEwOT0xMTE2O2UuYWZpaTEwMTEwPTExMTg7ZS5hZmlpMTAxNDU9MTAzOTtlLmFmaWkxMDE0Nj0xMTIyO2UuYWZpaTEwMTQ3PTExMzg7ZS5hZmlpMTAxNDg9MTE0MDtlLmFmaWkxMDE5Mj02MzE3NDtlLmFmaWkxMDE5Mz0xMTE5O2UuYWZpaTEwMTk0PTExMjM7ZS5hZmlpMTAxOTU9MTEzOTtlLmFmaWkxMDE5Nj0xMTQxO2UuYWZpaTEwODMxPTYzMTc1O2UuYWZpaTEwODMyPTYzMTc2O2UuYWZpaTEwODQ2PTEyNDE7ZS5hZmlpMjk5PTgyMDY7ZS5hZmlpMzAwPTgyMDc7ZS5hZmlpMzAxPTgyMDU7ZS5hZmlpNTczODE9MTY0MjtlLmFmaWk1NzM4OD0xNTQ4O2UuYWZpaTU3MzkyPTE2MzI7ZS5hZmlpNTczOTM9MTYzMztlLmFmaWk1NzM5ND0xNjM0O2UuYWZpaTU3Mzk1PTE2MzU7ZS5hZmlpNTczOTY9MTYzNjtlLmFmaWk1NzM5Nz0xNjM3O2UuYWZpaTU3Mzk4PTE2Mzg7ZS5hZmlpNTczOTk9MTYzOTtlLmFmaWk1NzQwMD0xNjQwO2UuYWZpaTU3NDAxPTE2NDE7ZS5hZmlpNTc0MDM9MTU2MztlLmFmaWk1NzQwNz0xNTY3O2UuYWZpaTU3NDA5PTE1Njk7ZS5hZmlpNTc0MTA9MTU3MDtlLmFmaWk1NzQxMT0xNTcxO2UuYWZpaTU3NDEyPTE1NzI7ZS5hZmlpNTc0MTM9MTU3MztlLmFmaWk1NzQxND0xNTc0O2UuYWZpaTU3NDE1PTE1NzU7ZS5hZmlpNTc0MTY9MTU3NjtlLmFmaWk1NzQxNz0xNTc3O2UuYWZpaTU3NDE4PTE1Nzg7ZS5hZmlpNTc0MTk9MTU3OTtlLmFmaWk1NzQyMD0xNTgwO2UuYWZpaTU3NDIxPTE1ODE7ZS5hZmlpNTc0MjI9MTU4MjtlLmFmaWk1NzQyMz0xNTgzO2UuYWZpaTU3NDI0PTE1ODQ7ZS5hZmlpNTc0MjU9MTU4NTtlLmFmaWk1NzQyNj0xNTg2O2UuYWZpaTU3NDI3PTE1ODc7ZS5hZmlpNTc0Mjg9MTU4ODtlLmFmaWk1NzQyOT0xNTg5O2UuYWZpaTU3NDMwPTE1OTA7ZS5hZmlpNTc0MzE9MTU5MTtlLmFmaWk1NzQzMj0xNTkyO2UuYWZpaTU3NDMzPTE1OTM7ZS5hZmlpNTc0MzQ9MTU5NDtlLmFmaWk1NzQ0MD0xNjAwO2UuYWZpaTU3NDQxPTE2MDE7ZS5hZmlpNTc0NDI9MTYwMjtlLmFmaWk1NzQ0Mz0xNjAzO2UuYWZpaTU3NDQ0PTE2MDQ7ZS5hZmlpNTc0NDU9MTYwNTtlLmFmaWk1NzQ0Nj0xNjA2O2UuYWZpaTU3NDQ4PTE2MDg7ZS5hZmlpNTc0NDk9MTYwOTtlLmFmaWk1NzQ1MD0xNjEwO2UuYWZpaTU3NDUxPTE2MTE7ZS5hZmlpNTc0NTI9MTYxMjtlLmFmaWk1NzQ1Mz0xNjEzO2UuYWZpaTU3NDU0PTE2MTQ7ZS5hZmlpNTc0NTU9MTYxNTtlLmFmaWk1NzQ1Nj0xNjE2O2UuYWZpaTU3NDU3PTE2MTc7ZS5hZmlpNTc0NTg9MTYxODtlLmFmaWk1NzQ3MD0xNjA3O2UuYWZpaTU3NTA1PTE3MDA7ZS5hZmlpNTc1MDY9MTY2MjtlLmFmaWk1NzUwNz0xNjcwO2UuYWZpaTU3NTA4PTE2ODg7ZS5hZmlpNTc1MDk9MTcxMTtlLmFmaWk1NzUxMT0xNjU3O2UuYWZpaTU3NTEyPTE2NzI7ZS5hZmlpNTc1MTM9MTY4MTtlLmFmaWk1NzUxND0xNzIyO2UuYWZpaTU3NTE5PTE3NDY7ZS5hZmlpNTc1MzQ9MTc0OTtlLmFmaWk1NzYzNj04MzYyO2UuYWZpaTU3NjQ1PTE0NzA7ZS5hZmlpNTc2NTg9MTQ3NTtlLmFmaWk1NzY2ND0xNDg4O2UuYWZpaTU3NjY1PTE0ODk7ZS5hZmlpNTc2NjY9MTQ5MDtlLmFmaWk1NzY2Nz0xNDkxO2UuYWZpaTU3NjY4PTE0OTI7ZS5hZmlpNTc2Njk9MTQ5MztlLmFmaWk1NzY3MD0xNDk0O2UuYWZpaTU3NjcxPTE0OTU7ZS5hZmlpNTc2NzI9MTQ5NjtlLmFmaWk1NzY3Mz0xNDk3O2UuYWZpaTU3Njc0PTE0OTg7ZS5hZmlpNTc2NzU9MTQ5OTtlLmFmaWk1NzY3Nj0xNTAwO2UuYWZpaTU3Njc3PTE1MDE7ZS5hZmlpNTc2Nzg9MTUwMjtlLmFmaWk1NzY3OT0xNTAzO2UuYWZpaTU3NjgwPTE1MDQ7ZS5hZmlpNTc2ODE9MTUwNTtlLmFmaWk1NzY4Mj0xNTA2O2UuYWZpaTU3NjgzPTE1MDc7ZS5hZmlpNTc2ODQ9MTUwODtlLmFmaWk1NzY4NT0xNTA5O2UuYWZpaTU3Njg2PTE1MTA7ZS5hZmlpNTc2ODc9MTUxMTtlLmFmaWk1NzY4OD0xNTEyO2UuYWZpaTU3Njg5PTE1MTM7ZS5hZmlpNTc2OTA9MTUxNDtlLmFmaWk1NzY5ND02NDI5ODtlLmFmaWk1NzY5NT02NDI5OTtlLmFmaWk1NzcwMD02NDMzMTtlLmFmaWk1NzcwNT02NDI4NztlLmFmaWk1NzcxNj0xNTIwO2UuYWZpaTU3NzE3PTE1MjE7ZS5hZmlpNTc3MTg9MTUyMjtlLmFmaWk1NzcyMz02NDMwOTtlLmFmaWk1Nzc5Mz0xNDYwO2UuYWZpaTU3Nzk0PTE0NjE7ZS5hZmlpNTc3OTU9MTQ2MjtlLmFmaWk1Nzc5Nj0xNDY3O2UuYWZpaTU3Nzk3PTE0NjQ7ZS5hZmlpNTc3OTg9MTQ2MztlLmFmaWk1Nzc5OT0xNDU2O2UuYWZpaTU3ODAwPTE0NTg7ZS5hZmlpNTc4MDE9MTQ1NztlLmFmaWk1NzgwMj0xNDU5O2UuYWZpaTU3ODAzPTE0NzQ7ZS5hZmlpNTc4MDQ9MTQ3MztlLmFmaWk1NzgwNj0xNDY1O2UuYWZpaTU3ODA3PTE0Njg7ZS5hZmlpNTc4Mzk9MTQ2OTtlLmFmaWk1Nzg0MT0xNDcxO2UuYWZpaTU3ODQyPTE0NzI7ZS5hZmlpNTc5Mjk9NzAwO2UuYWZpaTYxMjQ4PTg0NTM7ZS5hZmlpNjEyODk9ODQ2NztlLmFmaWk2MTM1Mj04NDcwO2UuYWZpaTYxNTczPTgyMzY7ZS5hZmlpNjE1NzQ9ODIzNztlLmFmaWk2MTU3NT04MjM4O2UuYWZpaTYxNjY0PTgyMDQ7ZS5hZmlpNjMxNjc9MTY0NTtlLmFmaWk2NDkzNz03MDE7ZS5hZ3JhdmU9MjI0O2UuYWd1amFyYXRpPTI2OTM7ZS5hZ3VybXVraGk9MjU2NTtlLmFoaXJhZ2FuYT0xMjM1NDtlLmFob29rYWJvdmU9Nzg0MztlLmFpYmVuZ2FsaT0yNDQ4O2UuYWlib3BvbW9mbz0xMjU3NDtlLmFpZGV2YT0yMzIwO2UuYWllY3lyaWxsaWM9MTIzNztlLmFpZ3VqYXJhdGk9MjcwNDtlLmFpZ3VybXVraGk9MjU3NjtlLmFpbWF0cmFndXJtdWtoaT0yNjMyO2UuYWluYXJhYmljPTE1OTM7ZS5haW5maW5hbGFyYWJpYz02NTIyNjtlLmFpbmluaXRpYWxhcmFiaWM9NjUyMjc7ZS5haW5tZWRpYWxhcmFiaWM9NjUyMjg7ZS5haW52ZXJ0ZWRicmV2ZT01MTU7ZS5haXZvd2Vsc2lnbmJlbmdhbGk9MjUwNDtlLmFpdm93ZWxzaWduZGV2YT0yMzc2O2UuYWl2b3dlbHNpZ25ndWphcmF0aT0yNzYwO2UuYWthdGFrYW5hPTEyNDUwO2UuYWthdGFrYW5haGFsZndpZHRoPTY1MzkzO2UuYWtvcmVhbj0xMjYyMztlLmFsZWY9MTQ4ODtlLmFsZWZhcmFiaWM9MTU3NTtlLmFsZWZkYWdlc2hoZWJyZXc9NjQzMDQ7ZS5hbGVmZmluYWxhcmFiaWM9NjUxNjY7ZS5hbGVmaGFtemFhYm92ZWFyYWJpYz0xNTcxO2UuYWxlZmhhbXphYWJvdmVmaW5hbGFyYWJpYz02NTE1NjtlLmFsZWZoYW16YWJlbG93YXJhYmljPTE1NzM7ZS5hbGVmaGFtemFiZWxvd2ZpbmFsYXJhYmljPTY1MTYwO2UuYWxlZmhlYnJldz0xNDg4O2UuYWxlZmxhbWVkaGVicmV3PTY0MzM1O2UuYWxlZm1hZGRhYWJvdmVhcmFiaWM9MTU3MDtlLmFsZWZtYWRkYWFib3ZlZmluYWxhcmFiaWM9NjUxNTQ7ZS5hbGVmbWFrc3VyYWFyYWJpYz0xNjA5O2UuYWxlZm1ha3N1cmFmaW5hbGFyYWJpYz02NTI2NDtlLmFsZWZtYWtzdXJhaW5pdGlhbGFyYWJpYz02NTI2NztlLmFsZWZtYWtzdXJhbWVkaWFsYXJhYmljPTY1MjY4O2UuYWxlZnBhdGFoaGVicmV3PTY0MzAyO2UuYWxlZnFhbWF0c2hlYnJldz02NDMwMztlLmFsZXBoPTg1MDE7ZS5hbGxlcXVhbD04NzgwO2UuYWxwaGE9OTQ1O2UuYWxwaGF0b25vcz05NDA7ZS5hbWFjcm9uPTI1NztlLmFtb25vc3BhY2U9NjUzNDU7ZS5hbXBlcnNhbmQ9Mzg7ZS5hbXBlcnNhbmRtb25vc3BhY2U9NjUyODY7ZS5hbXBlcnNhbmRzbWFsbD02MzI3MDtlLmFtc3F1YXJlPTEzMjUwO2UuYW5ib3BvbW9mbz0xMjU3ODtlLmFuZ2JvcG9tb2ZvPTEyNTgwO2UuYW5nYnJhY2tldGxlZnQ9MTIyOTY7ZS5hbmdicmFja2V0cmlnaHQ9MTIyOTc7ZS5hbmdraGFua2h1dGhhaT0zNjc0O2UuYW5nbGU9ODczNjtlLmFuZ2xlYnJhY2tldGxlZnQ9MTIyOTY7ZS5hbmdsZWJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODc7ZS5hbmdsZWJyYWNrZXRyaWdodD0xMjI5NztlLmFuZ2xlYnJhY2tldHJpZ2h0dmVydGljYWw9NjUwODg7ZS5hbmdsZWxlZnQ9OTAwMTtlLmFuZ2xlcmlnaHQ9OTAwMjtlLmFuZ3N0cm9tPTg0OTE7ZS5hbm90ZWxlaWE9OTAzO2UuYW51ZGF0dGFkZXZhPTIzODY7ZS5hbnVzdmFyYWJlbmdhbGk9MjQzNDtlLmFudXN2YXJhZGV2YT0yMzA2O2UuYW51c3ZhcmFndWphcmF0aT0yNjkwO2UuYW9nb25laz0yNjE7ZS5hcGFhdG9zcXVhcmU9MTMwNTY7ZS5hcGFyZW49OTM3MjtlLmFwb3N0cm9waGVhcm1lbmlhbj0xMzcwO2UuYXBvc3Ryb3BoZW1vZD03MDA7ZS5hcHBsZT02Mzc0MztlLmFwcHJvYWNoZXM9ODc4NDtlLmFwcHJveGVxdWFsPTg3NzY7ZS5hcHByb3hlcXVhbG9yaW1hZ2U9ODc4NjtlLmFwcHJveGltYXRlbHllcXVhbD04NzczO2UuYXJhZWFla29yZWFuPTEyNjg2O2UuYXJhZWFrb3JlYW49MTI2ODU7ZS5hcmM9ODk3ODtlLmFyaWdodGhhbGZyaW5nPTc4MzQ7ZS5hcmluZz0yMjk7ZS5hcmluZ2FjdXRlPTUwNztlLmFyaW5nYmVsb3c9NzY4MTtlLmFycm93Ym90aD04NTk2O2UuYXJyb3dkYXNoZG93bj04Njc1O2UuYXJyb3dkYXNobGVmdD04NjcyO2UuYXJyb3dkYXNocmlnaHQ9ODY3NDtlLmFycm93ZGFzaHVwPTg2NzM7ZS5hcnJvd2RibGJvdGg9ODY2MDtlLmFycm93ZGJsZG93bj04NjU5O2UuYXJyb3dkYmxsZWZ0PTg2NTY7ZS5hcnJvd2RibHJpZ2h0PTg2NTg7ZS5hcnJvd2RibHVwPTg2NTc7ZS5hcnJvd2Rvd249ODU5NTtlLmFycm93ZG93bmxlZnQ9ODYwMTtlLmFycm93ZG93bnJpZ2h0PTg2MDA7ZS5hcnJvd2Rvd253aGl0ZT04NjgxO2UuYXJyb3doZWFkZG93bm1vZD03MDk7ZS5hcnJvd2hlYWRsZWZ0bW9kPTcwNjtlLmFycm93aGVhZHJpZ2h0bW9kPTcwNztlLmFycm93aGVhZHVwbW9kPTcwODtlLmFycm93aG9yaXpleD02MzcxOTtlLmFycm93bGVmdD04NTkyO2UuYXJyb3dsZWZ0ZGJsPTg2NTY7ZS5hcnJvd2xlZnRkYmxzdHJva2U9ODY1MztlLmFycm93bGVmdG92ZXJyaWdodD04NjQ2O2UuYXJyb3dsZWZ0d2hpdGU9ODY3ODtlLmFycm93cmlnaHQ9ODU5NDtlLmFycm93cmlnaHRkYmxzdHJva2U9ODY1NTtlLmFycm93cmlnaHRoZWF2eT0xMDE0MjtlLmFycm93cmlnaHRvdmVybGVmdD04NjQ0O2UuYXJyb3dyaWdodHdoaXRlPTg2ODA7ZS5hcnJvd3RhYmxlZnQ9ODY3NjtlLmFycm93dGFicmlnaHQ9ODY3NztlLmFycm93dXA9ODU5MztlLmFycm93dXBkbj04NTk3O2UuYXJyb3d1cGRuYnNlPTg2MTY7ZS5hcnJvd3VwZG93bmJhc2U9ODYxNjtlLmFycm93dXBsZWZ0PTg1OTg7ZS5hcnJvd3VwbGVmdG9mZG93bj04NjQ1O2UuYXJyb3d1cHJpZ2h0PTg1OTk7ZS5hcnJvd3Vwd2hpdGU9ODY3OTtlLmFycm93dmVydGV4PTYzNzE4O2UuYXNjaWljaXJjdW09OTQ7ZS5hc2NpaWNpcmN1bW1vbm9zcGFjZT02NTM0MjtlLmFzY2lpdGlsZGU9MTI2O2UuYXNjaWl0aWxkZW1vbm9zcGFjZT02NTM3NDtlLmFzY3JpcHQ9NTkzO2UuYXNjcmlwdHR1cm5lZD01OTQ7ZS5hc21hbGxoaXJhZ2FuYT0xMjM1MztlLmFzbWFsbGthdGFrYW5hPTEyNDQ5O2UuYXNtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODM7ZS5hc3Rlcmlzaz00MjtlLmFzdGVyaXNrYWx0b25lYXJhYmljPTE2NDU7ZS5hc3Rlcmlza2FyYWJpYz0xNjQ1O2UuYXN0ZXJpc2ttYXRoPTg3Mjc7ZS5hc3Rlcmlza21vbm9zcGFjZT02NTI5MDtlLmFzdGVyaXNrc21hbGw9NjUxMjE7ZS5hc3RlcmlzbT04MjU4O2UuYXN1cGVyaW9yPTYzMjA5O2UuYXN5bXB0b3RpY2FsbHllcXVhbD04NzcxO2UuYXQ9NjQ7ZS5hdGlsZGU9MjI3O2UuYXRtb25vc3BhY2U9NjUzMTI7ZS5hdHNtYWxsPTY1MTMxO2UuYXR1cm5lZD01OTI7ZS5hdWJlbmdhbGk9MjQ1MjtlLmF1Ym9wb21vZm89MTI1NzY7ZS5hdWRldmE9MjMyNDtlLmF1Z3VqYXJhdGk9MjcwODtlLmF1Z3VybXVraGk9MjU4MDtlLmF1bGVuZ3RobWFya2JlbmdhbGk9MjUxOTtlLmF1bWF0cmFndXJtdWtoaT0yNjM2O2UuYXV2b3dlbHNpZ25iZW5nYWxpPTI1MDg7ZS5hdXZvd2Vsc2lnbmRldmE9MjM4MDtlLmF1dm93ZWxzaWduZ3VqYXJhdGk9Mjc2NDtlLmF2YWdyYWhhZGV2YT0yMzY1O2UuYXliYXJtZW5pYW49MTM3NztlLmF5aW49MTUwNjtlLmF5aW5hbHRvbmVoZWJyZXc9NjQyODg7ZS5heWluaGVicmV3PTE1MDY7ZS5iPTk4O2UuYmFiZW5nYWxpPTI0NzY7ZS5iYWNrc2xhc2g9OTI7ZS5iYWNrc2xhc2htb25vc3BhY2U9NjUzNDA7ZS5iYWRldmE9MjM0ODtlLmJhZ3VqYXJhdGk9MjczMjtlLmJhZ3VybXVraGk9MjYwNDtlLmJhaGlyYWdhbmE9MTI0MDA7ZS5iYWh0dGhhaT0zNjQ3O2UuYmFrYXRha2FuYT0xMjQ5NjtlLmJhcj0xMjQ7ZS5iYXJtb25vc3BhY2U9NjUzNzI7ZS5iYm9wb21vZm89MTI1NDk7ZS5iY2lyY2xlPTk0MjU7ZS5iZG90YWNjZW50PTc2ODM7ZS5iZG90YmVsb3c9NzY4NTtlLmJlYW1lZHNpeHRlZW50aG5vdGVzPTk4MzY7ZS5iZWNhdXNlPTg3NTc7ZS5iZWN5cmlsbGljPTEwNzM7ZS5iZWhhcmFiaWM9MTU3NjtlLmJlaGZpbmFsYXJhYmljPTY1MTY4O2UuYmVoaW5pdGlhbGFyYWJpYz02NTE2OTtlLmJlaGlyYWdhbmE9MTI0MDk7ZS5iZWhtZWRpYWxhcmFiaWM9NjUxNzA7ZS5iZWhtZWVtaW5pdGlhbGFyYWJpYz02NDY3MTtlLmJlaG1lZW1pc29sYXRlZGFyYWJpYz02NDUyMDtlLmJlaG5vb25maW5hbGFyYWJpYz02NDYyMTtlLmJla2F0YWthbmE9MTI1MDU7ZS5iZW5hcm1lbmlhbj0xMzc4O2UuYmV0PTE0ODk7ZS5iZXRhPTk0NjtlLmJldGFzeW1ib2xncmVlaz05NzY7ZS5iZXRkYWdlc2g9NjQzMDU7ZS5iZXRkYWdlc2hoZWJyZXc9NjQzMDU7ZS5iZXRoZWJyZXc9MTQ4OTtlLmJldHJhZmVoZWJyZXc9NjQzMzI7ZS5iaGFiZW5nYWxpPTI0Nzc7ZS5iaGFkZXZhPTIzNDk7ZS5iaGFndWphcmF0aT0yNzMzO2UuYmhhZ3VybXVraGk9MjYwNTtlLmJob29rPTU5NTtlLmJpaGlyYWdhbmE9MTI0MDM7ZS5iaWthdGFrYW5hPTEyNDk5O2UuYmlsYWJpYWxjbGljaz02NjQ7ZS5iaW5kaWd1cm11a2hpPTI1NjI7ZS5iaXJ1c3F1YXJlPTEzMTA1O2UuYmxhY2tjaXJjbGU9OTY3OTtlLmJsYWNrZGlhbW9uZD05NjcwO2UuYmxhY2tkb3ducG9pbnRpbmd0cmlhbmdsZT05NjYwO2UuYmxhY2tsZWZ0cG9pbnRpbmdwb2ludGVyPTk2Njg7ZS5ibGFja2xlZnRwb2ludGluZ3RyaWFuZ2xlPTk2NjQ7ZS5ibGFja2xlbnRpY3VsYXJicmFja2V0bGVmdD0xMjMwNDtlLmJsYWNrbGVudGljdWxhcmJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODM7ZS5ibGFja2xlbnRpY3VsYXJicmFja2V0cmlnaHQ9MTIzMDU7ZS5ibGFja2xlbnRpY3VsYXJicmFja2V0cmlnaHR2ZXJ0aWNhbD02NTA4NDtlLmJsYWNrbG93ZXJsZWZ0dHJpYW5nbGU9OTY5OTtlLmJsYWNrbG93ZXJyaWdodHRyaWFuZ2xlPTk2OTg7ZS5ibGFja3JlY3RhbmdsZT05NjQ0O2UuYmxhY2tyaWdodHBvaW50aW5ncG9pbnRlcj05NjU4O2UuYmxhY2tyaWdodHBvaW50aW5ndHJpYW5nbGU9OTY1NDtlLmJsYWNrc21hbGxzcXVhcmU9OTY0MjtlLmJsYWNrc21pbGluZ2ZhY2U9OTc4NztlLmJsYWNrc3F1YXJlPTk2MzI7ZS5ibGFja3N0YXI9OTczMztlLmJsYWNrdXBwZXJsZWZ0dHJpYW5nbGU9OTcwMDtlLmJsYWNrdXBwZXJyaWdodHRyaWFuZ2xlPTk3MDE7ZS5ibGFja3VwcG9pbnRpbmdzbWFsbHRyaWFuZ2xlPTk2NTI7ZS5ibGFja3VwcG9pbnRpbmd0cmlhbmdsZT05NjUwO2UuYmxhbms9OTI1MTtlLmJsaW5lYmVsb3c9NzY4NztlLmJsb2NrPTk2MDg7ZS5ibW9ub3NwYWNlPTY1MzQ2O2UuYm9iYWltYWl0aGFpPTM2MTA7ZS5ib2hpcmFnYW5hPTEyNDEyO2UuYm9rYXRha2FuYT0xMjUwODtlLmJwYXJlbj05MzczO2UuYnFzcXVhcmU9MTMyNTE7ZS5icmFjZWV4PTYzNzMyO2UuYnJhY2VsZWZ0PTEyMztlLmJyYWNlbGVmdGJ0PTYzNzMxO2UuYnJhY2VsZWZ0bWlkPTYzNzMwO2UuYnJhY2VsZWZ0bW9ub3NwYWNlPTY1MzcxO2UuYnJhY2VsZWZ0c21hbGw9NjUxMTU7ZS5icmFjZWxlZnR0cD02MzcyOTtlLmJyYWNlbGVmdHZlcnRpY2FsPTY1MDc5O2UuYnJhY2VyaWdodD0xMjU7ZS5icmFjZXJpZ2h0YnQ9NjM3NDI7ZS5icmFjZXJpZ2h0bWlkPTYzNzQxO2UuYnJhY2VyaWdodG1vbm9zcGFjZT02NTM3MztlLmJyYWNlcmlnaHRzbWFsbD02NTExNjtlLmJyYWNlcmlnaHR0cD02Mzc0MDtlLmJyYWNlcmlnaHR2ZXJ0aWNhbD02NTA4MDtlLmJyYWNrZXRsZWZ0PTkxO2UuYnJhY2tldGxlZnRidD02MzcyODtlLmJyYWNrZXRsZWZ0ZXg9NjM3Mjc7ZS5icmFja2V0bGVmdG1vbm9zcGFjZT02NTMzOTtlLmJyYWNrZXRsZWZ0dHA9NjM3MjY7ZS5icmFja2V0cmlnaHQ9OTM7ZS5icmFja2V0cmlnaHRidD02MzczOTtlLmJyYWNrZXRyaWdodGV4PTYzNzM4O2UuYnJhY2tldHJpZ2h0bW9ub3NwYWNlPTY1MzQxO2UuYnJhY2tldHJpZ2h0dHA9NjM3Mzc7ZS5icmV2ZT03Mjg7ZS5icmV2ZWJlbG93Y21iPTgxNDtlLmJyZXZlY21iPTc3NDtlLmJyZXZlaW52ZXJ0ZWRiZWxvd2NtYj04MTU7ZS5icmV2ZWludmVydGVkY21iPTc4NTtlLmJyZXZlaW52ZXJ0ZWRkb3VibGVjbWI9ODY1O2UuYnJpZGdlYmVsb3djbWI9ODEwO2UuYnJpZGdlaW52ZXJ0ZWRiZWxvd2NtYj04MjY7ZS5icm9rZW5iYXI9MTY2O2UuYnN0cm9rZT0zODQ7ZS5ic3VwZXJpb3I9NjMyMTA7ZS5idG9wYmFyPTM4NztlLmJ1aGlyYWdhbmE9MTI0MDY7ZS5idWthdGFrYW5hPTEyNTAyO2UuYnVsbGV0PTgyMjY7ZS5idWxsZXRpbnZlcnNlPTk2ODg7ZS5idWxsZXRvcGVyYXRvcj04NzI5O2UuYnVsbHNleWU9OTY3ODtlLmM9OTk7ZS5jYWFybWVuaWFuPTEzOTA7ZS5jYWJlbmdhbGk9MjQ1ODtlLmNhY3V0ZT0yNjM7ZS5jYWRldmE9MjMzMDtlLmNhZ3VqYXJhdGk9MjcxNDtlLmNhZ3VybXVraGk9MjU4NjtlLmNhbHNxdWFyZT0xMzE5MjtlLmNhbmRyYWJpbmR1YmVuZ2FsaT0yNDMzO2UuY2FuZHJhYmluZHVjbWI9Nzg0O2UuY2FuZHJhYmluZHVkZXZhPTIzMDU7ZS5jYW5kcmFiaW5kdWd1amFyYXRpPTI2ODk7ZS5jYXBzbG9jaz04NjgyO2UuY2FyZW9mPTg0NTM7ZS5jYXJvbj03MTE7ZS5jYXJvbmJlbG93Y21iPTgxMjtlLmNhcm9uY21iPTc4MDtlLmNhcnJpYWdlcmV0dXJuPTg2Mjk7ZS5jYm9wb21vZm89MTI1Njg7ZS5jY2Fyb249MjY5O2UuY2NlZGlsbGE9MjMxO2UuY2NlZGlsbGFhY3V0ZT03Njg5O2UuY2NpcmNsZT05NDI2O2UuY2NpcmN1bWZsZXg9MjY1O2UuY2N1cmw9NTk3O2UuY2RvdD0yNjc7ZS5jZG90YWNjZW50PTI2NztlLmNkc3F1YXJlPTEzMjUzO2UuY2VkaWxsYT0xODQ7ZS5jZWRpbGxhY21iPTgwNztlLmNlbnQ9MTYyO2UuY2VudGlncmFkZT04NDUxO2UuY2VudGluZmVyaW9yPTYzMTk5O2UuY2VudG1vbm9zcGFjZT02NTUwNDtlLmNlbnRvbGRzdHlsZT02MzM5NDtlLmNlbnRzdXBlcmlvcj02MzIwMDtlLmNoYWFybWVuaWFuPTE0MDE7ZS5jaGFiZW5nYWxpPTI0NTk7ZS5jaGFkZXZhPTIzMzE7ZS5jaGFndWphcmF0aT0yNzE1O2UuY2hhZ3VybXVraGk9MjU4NztlLmNoYm9wb21vZm89MTI1NjQ7ZS5jaGVhYmtoYXNpYW5jeXJpbGxpYz0xMjEzO2UuY2hlY2ttYXJrPTEwMDAzO2UuY2hlY3lyaWxsaWM9MTA5NTtlLmNoZWRlc2NlbmRlcmFia2hhc2lhbmN5cmlsbGljPTEyMTU7ZS5jaGVkZXNjZW5kZXJjeXJpbGxpYz0xMjA3O2UuY2hlZGllcmVzaXNjeXJpbGxpYz0xMjY5O2UuY2hlaGFybWVuaWFuPTEzOTU7ZS5jaGVraGFrYXNzaWFuY3lyaWxsaWM9MTIyODtlLmNoZXZlcnRpY2Fsc3Ryb2tlY3lyaWxsaWM9MTIwOTtlLmNoaT05Njc7ZS5jaGlldWNoYWNpcmNsZWtvcmVhbj0xMjkxOTtlLmNoaWV1Y2hhcGFyZW5rb3JlYW49MTI4MjM7ZS5jaGlldWNoY2lyY2xla29yZWFuPTEyOTA1O2UuY2hpZXVjaGtvcmVhbj0xMjYxODtlLmNoaWV1Y2hwYXJlbmtvcmVhbj0xMjgwOTtlLmNob2NoYW5ndGhhaT0zNTk0O2UuY2hvY2hhbnRoYWk9MzU5MjtlLmNob2NoaW5ndGhhaT0zNTkzO2UuY2hvY2hvZXRoYWk9MzU5NjtlLmNob29rPTM5MjtlLmNpZXVjYWNpcmNsZWtvcmVhbj0xMjkxODtlLmNpZXVjYXBhcmVua29yZWFuPTEyODIyO2UuY2lldWNjaXJjbGVrb3JlYW49MTI5MDQ7ZS5jaWV1Y2tvcmVhbj0xMjYxNjtlLmNpZXVjcGFyZW5rb3JlYW49MTI4MDg7ZS5jaWV1Y3VwYXJlbmtvcmVhbj0xMjgyODtlLmNpcmNsZT05Njc1O2UuY2lyY2xlY29weXJ0PTE2OTtlLmNpcmNsZW11bHRpcGx5PTg4NTU7ZS5jaXJjbGVvdD04ODU3O2UuY2lyY2xlcGx1cz04ODUzO2UuY2lyY2xlcG9zdGFsbWFyaz0xMjM0MjtlLmNpcmNsZXdpdGhsZWZ0aGFsZmJsYWNrPTk2ODA7ZS5jaXJjbGV3aXRocmlnaHRoYWxmYmxhY2s9OTY4MTtlLmNpcmN1bWZsZXg9NzEwO2UuY2lyY3VtZmxleGJlbG93Y21iPTgxMztlLmNpcmN1bWZsZXhjbWI9NzcwO2UuY2xlYXI9ODk5OTtlLmNsaWNrYWx2ZW9sYXI9NDUwO2UuY2xpY2tkZW50YWw9NDQ4O2UuY2xpY2tsYXRlcmFsPTQ0OTtlLmNsaWNrcmV0cm9mbGV4PTQ1MTtlLmNsdWI9OTgyNztlLmNsdWJzdWl0YmxhY2s9OTgyNztlLmNsdWJzdWl0d2hpdGU9OTgzMTtlLmNtY3ViZWRzcXVhcmU9MTMyMjA7ZS5jbW9ub3NwYWNlPTY1MzQ3O2UuY21zcXVhcmVkc3F1YXJlPTEzMjE2O2UuY29hcm1lbmlhbj0xNDA5O2UuY29sb249NTg7ZS5jb2xvbm1vbmV0YXJ5PTgzNTM7ZS5jb2xvbm1vbm9zcGFjZT02NTMwNjtlLmNvbG9uc2lnbj04MzUzO2UuY29sb25zbWFsbD02NTEwOTtlLmNvbG9udHJpYW5ndWxhcmhhbGZtb2Q9NzIxO2UuY29sb250cmlhbmd1bGFybW9kPTcyMDtlLmNvbW1hPTQ0O2UuY29tbWFhYm92ZWNtYj03ODc7ZS5jb21tYWFib3ZlcmlnaHRjbWI9Nzg5O2UuY29tbWFhY2NlbnQ9NjMxNzE7ZS5jb21tYWFyYWJpYz0xNTQ4O2UuY29tbWFhcm1lbmlhbj0xMzczO2UuY29tbWFpbmZlcmlvcj02MzIwMTtlLmNvbW1hbW9ub3NwYWNlPTY1MjkyO2UuY29tbWFyZXZlcnNlZGFib3ZlY21iPTc4ODtlLmNvbW1hcmV2ZXJzZWRtb2Q9NzAxO2UuY29tbWFzbWFsbD02NTEwNDtlLmNvbW1hc3VwZXJpb3I9NjMyMDI7ZS5jb21tYXR1cm5lZGFib3ZlY21iPTc4NjtlLmNvbW1hdHVybmVkbW9kPTY5OTtlLmNvbXBhc3M9OTc4ODtlLmNvbmdydWVudD04NzczO2UuY29udG91cmludGVncmFsPTg3NTA7ZS5jb250cm9sPTg5NjM7ZS5jb250cm9sQUNLPTY7ZS5jb250cm9sQkVMPTc7ZS5jb250cm9sQlM9ODtlLmNvbnRyb2xDQU49MjQ7ZS5jb250cm9sQ1I9MTM7ZS5jb250cm9sREMxPTE3O2UuY29udHJvbERDMj0xODtlLmNvbnRyb2xEQzM9MTk7ZS5jb250cm9sREM0PTIwO2UuY29udHJvbERFTD0xMjc7ZS5jb250cm9sRExFPTE2O2UuY29udHJvbEVNPTI1O2UuY29udHJvbEVOUT01O2UuY29udHJvbEVPVD00O2UuY29udHJvbEVTQz0yNztlLmNvbnRyb2xFVEI9MjM7ZS5jb250cm9sRVRYPTM7ZS5jb250cm9sRkY9MTI7ZS5jb250cm9sRlM9Mjg7ZS5jb250cm9sR1M9Mjk7ZS5jb250cm9sSFQ9OTtlLmNvbnRyb2xMRj0xMDtlLmNvbnRyb2xOQUs9MjE7ZS5jb250cm9sTlVMTD0wO2UuY29udHJvbFJTPTMwO2UuY29udHJvbFNJPTE1O2UuY29udHJvbFNPPTE0O2UuY29udHJvbFNPVD0yO2UuY29udHJvbFNUWD0xO2UuY29udHJvbFNVQj0yNjtlLmNvbnRyb2xTWU49MjI7ZS5jb250cm9sVVM9MzE7ZS5jb250cm9sVlQ9MTE7ZS5jb3B5cmlnaHQ9MTY5O2UuY29weXJpZ2h0c2Fucz02MzcyMTtlLmNvcHlyaWdodHNlcmlmPTYzMTkzO2UuY29ybmVyYnJhY2tldGxlZnQ9MTIzMDA7ZS5jb3JuZXJicmFja2V0bGVmdGhhbGZ3aWR0aD02NTM3ODtlLmNvcm5lcmJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODk7ZS5jb3JuZXJicmFja2V0cmlnaHQ9MTIzMDE7ZS5jb3JuZXJicmFja2V0cmlnaHRoYWxmd2lkdGg9NjUzNzk7ZS5jb3JuZXJicmFja2V0cmlnaHR2ZXJ0aWNhbD02NTA5MDtlLmNvcnBvcmF0aW9uc3F1YXJlPTEzMTgzO2UuY29zcXVhcmU9MTMyNTU7ZS5jb3Zlcmtnc3F1YXJlPTEzMjU0O2UuY3BhcmVuPTkzNzQ7ZS5jcnV6ZWlybz04MzU0O2UuY3N0cmV0Y2hlZD02NjM7ZS5jdXJseWFuZD04OTExO2UuY3VybHlvcj04OTEwO2UuY3VycmVuY3k9MTY0O2UuY3lyQnJldmU9NjMxODU7ZS5jeXJGbGV4PTYzMTg2O2UuY3lyYnJldmU9NjMxODg7ZS5jeXJmbGV4PTYzMTg5O2UuZD0xMDA7ZS5kYWFybWVuaWFuPTEzODA7ZS5kYWJlbmdhbGk9MjQ3MDtlLmRhZGFyYWJpYz0xNTkwO2UuZGFkZXZhPTIzNDI7ZS5kYWRmaW5hbGFyYWJpYz02NTIxNDtlLmRhZGluaXRpYWxhcmFiaWM9NjUyMTU7ZS5kYWRtZWRpYWxhcmFiaWM9NjUyMTY7ZS5kYWdlc2g9MTQ2ODtlLmRhZ2VzaGhlYnJldz0xNDY4O2UuZGFnZ2VyPTgyMjQ7ZS5kYWdnZXJkYmw9ODIyNTtlLmRhZ3VqYXJhdGk9MjcyNjtlLmRhZ3VybXVraGk9MjU5ODtlLmRhaGlyYWdhbmE9MTIzODQ7ZS5kYWthdGFrYW5hPTEyNDgwO2UuZGFsYXJhYmljPTE1ODM7ZS5kYWxldD0xNDkxO2UuZGFsZXRkYWdlc2g9NjQzMDc7ZS5kYWxldGRhZ2VzaGhlYnJldz02NDMwNztlLmRhbGV0aGVicmV3PTE0OTE7ZS5kYWxmaW5hbGFyYWJpYz02NTE5NDtlLmRhbW1hYXJhYmljPTE2MTU7ZS5kYW1tYWxvd2FyYWJpYz0xNjE1O2UuZGFtbWF0YW5hbHRvbmVhcmFiaWM9MTYxMjtlLmRhbW1hdGFuYXJhYmljPTE2MTI7ZS5kYW5kYT0yNDA0O2UuZGFyZ2FoZWJyZXc9MTQ0NztlLmRhcmdhbGVmdGhlYnJldz0xNDQ3O2UuZGFzaWFwbmV1bWF0YWN5cmlsbGljY21iPTExNTc7ZS5kYmxHcmF2ZT02MzE4NztlLmRibGFuZ2xlYnJhY2tldGxlZnQ9MTIyOTg7ZS5kYmxhbmdsZWJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODU7ZS5kYmxhbmdsZWJyYWNrZXRyaWdodD0xMjI5OTtlLmRibGFuZ2xlYnJhY2tldHJpZ2h0dmVydGljYWw9NjUwODY7ZS5kYmxhcmNoaW52ZXJ0ZWRiZWxvd2NtYj04MTE7ZS5kYmxhcnJvd2xlZnQ9ODY2MDtlLmRibGFycm93cmlnaHQ9ODY1ODtlLmRibGRhbmRhPTI0MDU7ZS5kYmxncmF2ZT02MzE5MDtlLmRibGdyYXZlY21iPTc4MztlLmRibGludGVncmFsPTg3NDg7ZS5kYmxsb3dsaW5lPTgyMTU7ZS5kYmxsb3dsaW5lY21iPTgxOTtlLmRibG92ZXJsaW5lY21iPTgzMTtlLmRibHByaW1lbW9kPTY5ODtlLmRibHZlcnRpY2FsYmFyPTgyMTQ7ZS5kYmx2ZXJ0aWNhbGxpbmVhYm92ZWNtYj03ODI7ZS5kYm9wb21vZm89MTI1NTM7ZS5kYnNxdWFyZT0xMzI1NjtlLmRjYXJvbj0yNzE7ZS5kY2VkaWxsYT03Njk3O2UuZGNpcmNsZT05NDI3O2UuZGNpcmN1bWZsZXhiZWxvdz03Njk5O2UuZGNyb2F0PTI3MztlLmRkYWJlbmdhbGk9MjQ2NTtlLmRkYWRldmE9MjMzNztlLmRkYWd1amFyYXRpPTI3MjE7ZS5kZGFndXJtdWtoaT0yNTkzO2UuZGRhbGFyYWJpYz0xNjcyO2UuZGRhbGZpbmFsYXJhYmljPTY0MzkzO2UuZGRkaGFkZXZhPTIzOTY7ZS5kZGhhYmVuZ2FsaT0yNDY2O2UuZGRoYWRldmE9MjMzODtlLmRkaGFndWphcmF0aT0yNzIyO2UuZGRoYWd1cm11a2hpPTI1OTQ7ZS5kZG90YWNjZW50PTc2OTE7ZS5kZG90YmVsb3c9NzY5MztlLmRlY2ltYWxzZXBhcmF0b3JhcmFiaWM9MTY0MztlLmRlY2ltYWxzZXBhcmF0b3JwZXJzaWFuPTE2NDM7ZS5kZWN5cmlsbGljPTEwNzY7ZS5kZWdyZWU9MTc2O2UuZGVoaWhlYnJldz0xNDUzO2UuZGVoaXJhZ2FuYT0xMjM5MTtlLmRlaWNvcHRpYz0xMDA3O2UuZGVrYXRha2FuYT0xMjQ4NztlLmRlbGV0ZWxlZnQ9OTAwMztlLmRlbGV0ZXJpZ2h0PTg5OTg7ZS5kZWx0YT05NDg7ZS5kZWx0YXR1cm5lZD0zOTc7ZS5kZW5vbWluYXRvcm1pbnVzb25lbnVtZXJhdG9yYmVuZ2FsaT0yNTUyO2UuZGV6aD02NzY7ZS5kaGFiZW5nYWxpPTI0NzE7ZS5kaGFkZXZhPTIzNDM7ZS5kaGFndWphcmF0aT0yNzI3O2UuZGhhZ3VybXVraGk9MjU5OTtlLmRob29rPTU5OTtlLmRpYWx5dGlrYXRvbm9zPTkwMTtlLmRpYWx5dGlrYXRvbm9zY21iPTgzNjtlLmRpYW1vbmQ9OTgzMDtlLmRpYW1vbmRzdWl0d2hpdGU9OTgyNjtlLmRpZXJlc2lzPTE2ODtlLmRpZXJlc2lzYWN1dGU9NjMxOTE7ZS5kaWVyZXNpc2JlbG93Y21iPTgwNDtlLmRpZXJlc2lzY21iPTc3NjtlLmRpZXJlc2lzZ3JhdmU9NjMxOTI7ZS5kaWVyZXNpc3Rvbm9zPTkwMTtlLmRpaGlyYWdhbmE9MTIzODY7ZS5kaWthdGFrYW5hPTEyNDgyO2UuZGl0dG9tYXJrPTEyMjkxO2UuZGl2aWRlPTI0NztlLmRpdmlkZXM9ODczOTtlLmRpdmlzaW9uc2xhc2g9ODcyNTtlLmRqZWN5cmlsbGljPTExMDY7ZS5ka3NoYWRlPTk2MTk7ZS5kbGluZWJlbG93PTc2OTU7ZS5kbHNxdWFyZT0xMzIwNztlLmRtYWNyb249MjczO2UuZG1vbm9zcGFjZT02NTM0ODtlLmRuYmxvY2s9OTYwNDtlLmRvY2hhZGF0aGFpPTM1OTg7ZS5kb2Rla3RoYWk9MzYwNDtlLmRvaGlyYWdhbmE9MTIzOTM7ZS5kb2thdGFrYW5hPTEyNDg5O2UuZG9sbGFyPTM2O2UuZG9sbGFyaW5mZXJpb3I9NjMyMDM7ZS5kb2xsYXJtb25vc3BhY2U9NjUyODQ7ZS5kb2xsYXJvbGRzdHlsZT02MzI2ODtlLmRvbGxhcnNtYWxsPTY1MTI5O2UuZG9sbGFyc3VwZXJpb3I9NjMyMDQ7ZS5kb25nPTgzNjM7ZS5kb3J1c3F1YXJlPTEzMDk0O2UuZG90YWNjZW50PTcyOTtlLmRvdGFjY2VudGNtYj03NzU7ZS5kb3RiZWxvd2NtYj04MDM7ZS5kb3RiZWxvd2NvbWI9ODAzO2UuZG90a2F0YWthbmE9MTI1Mzk7ZS5kb3RsZXNzaT0zMDU7ZS5kb3RsZXNzaj02MzE2NjtlLmRvdGxlc3Nqc3Ryb2tlaG9vaz02NDQ7ZS5kb3RtYXRoPTg5MDE7ZS5kb3R0ZWRjaXJjbGU9OTY3NjtlLmRvdWJsZXlvZHBhdGFoPTY0Mjg3O2UuZG91YmxleW9kcGF0YWhoZWJyZXc9NjQyODc7ZS5kb3dudGFja2JlbG93Y21iPTc5ODtlLmRvd250YWNrbW9kPTcyNTtlLmRwYXJlbj05Mzc1O2UuZHN1cGVyaW9yPTYzMjExO2UuZHRhaWw9NTk4O2UuZHRvcGJhcj0zOTY7ZS5kdWhpcmFnYW5hPTEyMzg5O2UuZHVrYXRha2FuYT0xMjQ4NTtlLmR6PTQ5OTtlLmR6YWx0b25lPTY3NTtlLmR6Y2Fyb249NDU0O2UuZHpjdXJsPTY3NztlLmR6ZWFia2hhc2lhbmN5cmlsbGljPTEyNDk7ZS5kemVjeXJpbGxpYz0xMTA5O2UuZHpoZWN5cmlsbGljPTExMTk7ZS5lPTEwMTtlLmVhY3V0ZT0yMzM7ZS5lYXJ0aD05NzkzO2UuZWJlbmdhbGk9MjQ0NztlLmVib3BvbW9mbz0xMjU3MjtlLmVicmV2ZT0yNzc7ZS5lY2FuZHJhZGV2YT0yMzE3O2UuZWNhbmRyYWd1amFyYXRpPTI3MDE7ZS5lY2FuZHJhdm93ZWxzaWduZGV2YT0yMzczO2UuZWNhbmRyYXZvd2Vsc2lnbmd1amFyYXRpPTI3NTc7ZS5lY2Fyb249MjgzO2UuZWNlZGlsbGFicmV2ZT03NzA5O2UuZWNoYXJtZW5pYW49MTM4MTtlLmVjaHlpd25hcm1lbmlhbj0xNDE1O2UuZWNpcmNsZT05NDI4O2UuZWNpcmN1bWZsZXg9MjM0O2UuZWNpcmN1bWZsZXhhY3V0ZT03ODcxO2UuZWNpcmN1bWZsZXhiZWxvdz03NzA1O2UuZWNpcmN1bWZsZXhkb3RiZWxvdz03ODc5O2UuZWNpcmN1bWZsZXhncmF2ZT03ODczO2UuZWNpcmN1bWZsZXhob29rYWJvdmU9Nzg3NTtlLmVjaXJjdW1mbGV4dGlsZGU9Nzg3NztlLmVjeXJpbGxpYz0xMTA4O2UuZWRibGdyYXZlPTUxNztlLmVkZXZhPTIzMTk7ZS5lZGllcmVzaXM9MjM1O2UuZWRvdD0yNzk7ZS5lZG90YWNjZW50PTI3OTtlLmVkb3RiZWxvdz03ODY1O2UuZWVndXJtdWtoaT0yNTc1O2UuZWVtYXRyYWd1cm11a2hpPTI2MzE7ZS5lZmN5cmlsbGljPTEwOTI7ZS5lZ3JhdmU9MjMyO2UuZWd1amFyYXRpPTI3MDM7ZS5laGFybWVuaWFuPTEzODM7ZS5laGJvcG9tb2ZvPTEyNTczO2UuZWhpcmFnYW5hPTEyMzYwO2UuZWhvb2thYm92ZT03ODY3O2UuZWlib3BvbW9mbz0xMjU3NTtlLmVpZ2h0PTU2O2UuZWlnaHRhcmFiaWM9MTY0MDtlLmVpZ2h0YmVuZ2FsaT0yNTQyO2UuZWlnaHRjaXJjbGU9OTMxOTtlLmVpZ2h0Y2lyY2xlaW52ZXJzZXNhbnNzZXJpZj0xMDEyOTtlLmVpZ2h0ZGV2YT0yNDE0O2UuZWlnaHRlZW5jaXJjbGU9OTMyOTtlLmVpZ2h0ZWVucGFyZW49OTM0OTtlLmVpZ2h0ZWVucGVyaW9kPTkzNjk7ZS5laWdodGd1amFyYXRpPTI3OTg7ZS5laWdodGd1cm11a2hpPTI2NzA7ZS5laWdodGhhY2thcmFiaWM9MTY0MDtlLmVpZ2h0aGFuZ3pob3U9MTIzMjg7ZS5laWdodGhub3RlYmVhbWVkPTk4MzU7ZS5laWdodGlkZW9ncmFwaGljcGFyZW49MTI4Mzk7ZS5laWdodGluZmVyaW9yPTgzMjg7ZS5laWdodG1vbm9zcGFjZT02NTMwNDtlLmVpZ2h0b2xkc3R5bGU9NjMyODg7ZS5laWdodHBhcmVuPTkzMzk7ZS5laWdodHBlcmlvZD05MzU5O2UuZWlnaHRwZXJzaWFuPTE3ODQ7ZS5laWdodHJvbWFuPTg1Njc7ZS5laWdodHN1cGVyaW9yPTgzMTI7ZS5laWdodHRoYWk9MzY3MjtlLmVpbnZlcnRlZGJyZXZlPTUxOTtlLmVpb3RpZmllZGN5cmlsbGljPTExMjU7ZS5la2F0YWthbmE9MTI0NTY7ZS5la2F0YWthbmFoYWxmd2lkdGg9NjUzOTY7ZS5la29ua2FyZ3VybXVraGk9MjY3NjtlLmVrb3JlYW49MTI2Mjg7ZS5lbGN5cmlsbGljPTEwODM7ZS5lbGVtZW50PTg3MTI7ZS5lbGV2ZW5jaXJjbGU9OTMyMjtlLmVsZXZlbnBhcmVuPTkzNDI7ZS5lbGV2ZW5wZXJpb2Q9OTM2MjtlLmVsZXZlbnJvbWFuPTg1NzA7ZS5lbGxpcHNpcz04MjMwO2UuZWxsaXBzaXN2ZXJ0aWNhbD04OTQyO2UuZW1hY3Jvbj0yNzU7ZS5lbWFjcm9uYWN1dGU9NzcwMztlLmVtYWNyb25ncmF2ZT03NzAxO2UuZW1jeXJpbGxpYz0xMDg0O2UuZW1kYXNoPTgyMTI7ZS5lbWRhc2h2ZXJ0aWNhbD02NTA3MztlLmVtb25vc3BhY2U9NjUzNDk7ZS5lbXBoYXNpc21hcmthcm1lbmlhbj0xMzcxO2UuZW1wdHlzZXQ9ODcwOTtlLmVuYm9wb21vZm89MTI1Nzk7ZS5lbmN5cmlsbGljPTEwODU7ZS5lbmRhc2g9ODIxMTtlLmVuZGFzaHZlcnRpY2FsPTY1MDc0O2UuZW5kZXNjZW5kZXJjeXJpbGxpYz0xMTg3O2UuZW5nPTMzMTtlLmVuZ2JvcG9tb2ZvPTEyNTgxO2UuZW5naGVjeXJpbGxpYz0xMTg5O2UuZW5ob29rY3lyaWxsaWM9MTIyNDtlLmVuc3BhY2U9ODE5NDtlLmVvZ29uZWs9MjgxO2UuZW9rb3JlYW49MTI2Mjc7ZS5lb3Blbj02MDM7ZS5lb3BlbmNsb3NlZD02NjY7ZS5lb3BlbnJldmVyc2VkPTYwNDtlLmVvcGVucmV2ZXJzZWRjbG9zZWQ9NjA2O2UuZW9wZW5yZXZlcnNlZGhvb2s9NjA1O2UuZXBhcmVuPTkzNzY7ZS5lcHNpbG9uPTk0OTtlLmVwc2lsb250b25vcz05NDE7ZS5lcXVhbD02MTtlLmVxdWFsbW9ub3NwYWNlPTY1MzA5O2UuZXF1YWxzbWFsbD02NTEyNjtlLmVxdWFsc3VwZXJpb3I9ODMxNjtlLmVxdWl2YWxlbmNlPTg4MDE7ZS5lcmJvcG9tb2ZvPTEyNTgyO2UuZXJjeXJpbGxpYz0xMDg4O2UuZXJldmVyc2VkPTYwMDtlLmVyZXZlcnNlZGN5cmlsbGljPTExMDE7ZS5lc2N5cmlsbGljPTEwODk7ZS5lc2Rlc2NlbmRlcmN5cmlsbGljPTExOTU7ZS5lc2g9NjQzO2UuZXNoY3VybD02NDY7ZS5lc2hvcnRkZXZhPTIzMTg7ZS5lc2hvcnR2b3dlbHNpZ25kZXZhPTIzNzQ7ZS5lc2hyZXZlcnNlZGxvb3A9NDI2O2UuZXNoc3F1YXRyZXZlcnNlZD02NDU7ZS5lc21hbGxoaXJhZ2FuYT0xMjM1OTtlLmVzbWFsbGthdGFrYW5hPTEyNDU1O2UuZXNtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODY7ZS5lc3RpbWF0ZWQ9ODQ5NDtlLmVzdXBlcmlvcj02MzIxMjtlLmV0YT05NTE7ZS5ldGFybWVuaWFuPTEzODQ7ZS5ldGF0b25vcz05NDI7ZS5ldGg9MjQwO2UuZXRpbGRlPTc4Njk7ZS5ldGlsZGViZWxvdz03NzA3O2UuZXRuYWh0YWZvdWtoaGVicmV3PTE0MjU7ZS5ldG5haHRhZm91a2hsZWZ0aGVicmV3PTE0MjU7ZS5ldG5haHRhaGVicmV3PTE0MjU7ZS5ldG5haHRhbGVmdGhlYnJldz0xNDI1O2UuZXR1cm5lZD00Nzc7ZS5ldWtvcmVhbj0xMjY0MTtlLmV1cm89ODM2NDtlLmV2b3dlbHNpZ25iZW5nYWxpPTI1MDM7ZS5ldm93ZWxzaWduZGV2YT0yMzc1O2UuZXZvd2Vsc2lnbmd1amFyYXRpPTI3NTk7ZS5leGNsYW09MzM7ZS5leGNsYW1hcm1lbmlhbj0xMzcyO2UuZXhjbGFtZGJsPTgyNTI7ZS5leGNsYW1kb3duPTE2MTtlLmV4Y2xhbWRvd25zbWFsbD02MzM5MztlLmV4Y2xhbW1vbm9zcGFjZT02NTI4MTtlLmV4Y2xhbXNtYWxsPTYzMjY1O2UuZXhpc3RlbnRpYWw9ODcwNztlLmV6aD02NTg7ZS5lemhjYXJvbj00OTU7ZS5lemhjdXJsPTY1OTtlLmV6aHJldmVyc2VkPTQ0MTtlLmV6aHRhaWw9NDQyO2UuZj0xMDI7ZS5mYWRldmE9MjM5ODtlLmZhZ3VybXVraGk9MjY1NDtlLmZhaHJlbmhlaXQ9ODQ1NztlLmZhdGhhYXJhYmljPTE2MTQ7ZS5mYXRoYWxvd2FyYWJpYz0xNjE0O2UuZmF0aGF0YW5hcmFiaWM9MTYxMTtlLmZib3BvbW9mbz0xMjU1MjtlLmZjaXJjbGU9OTQyOTtlLmZkb3RhY2NlbnQ9NzcxMTtlLmZlaGFyYWJpYz0xNjAxO2UuZmVoYXJtZW5pYW49MTQxNDtlLmZlaGZpbmFsYXJhYmljPTY1MjM0O2UuZmVoaW5pdGlhbGFyYWJpYz02NTIzNTtlLmZlaG1lZGlhbGFyYWJpYz02NTIzNjtlLmZlaWNvcHRpYz05OTc7ZS5mZW1hbGU9OTc5MjtlLmZmPTY0MjU2O2UuZl9mPTY0MjU2O2UuZmZpPTY0MjU5O2UuZl9mX2k9NjQyNTk7ZS5mZmw9NjQyNjA7ZS5mX2ZfbD02NDI2MDtlLmZpPTY0MjU3O2UuZl9pPTY0MjU3O2UuZmlmdGVlbmNpcmNsZT05MzI2O2UuZmlmdGVlbnBhcmVuPTkzNDY7ZS5maWZ0ZWVucGVyaW9kPTkzNjY7ZS5maWd1cmVkYXNoPTgyMTA7ZS5maWxsZWRib3g9OTYzMjtlLmZpbGxlZHJlY3Q9OTY0NDtlLmZpbmFsa2FmPTE0OTg7ZS5maW5hbGthZmRhZ2VzaD02NDMxNDtlLmZpbmFsa2FmZGFnZXNoaGVicmV3PTY0MzE0O2UuZmluYWxrYWZoZWJyZXc9MTQ5ODtlLmZpbmFsbWVtPTE1MDE7ZS5maW5hbG1lbWhlYnJldz0xNTAxO2UuZmluYWxudW49MTUwMztlLmZpbmFsbnVuaGVicmV3PTE1MDM7ZS5maW5hbHBlPTE1MDc7ZS5maW5hbHBlaGVicmV3PTE1MDc7ZS5maW5hbHRzYWRpPTE1MDk7ZS5maW5hbHRzYWRpaGVicmV3PTE1MDk7ZS5maXJzdHRvbmVjaGluZXNlPTcxMztlLmZpc2hleWU9OTY3MztlLmZpdGFjeXJpbGxpYz0xMTM5O2UuZml2ZT01MztlLmZpdmVhcmFiaWM9MTYzNztlLmZpdmViZW5nYWxpPTI1Mzk7ZS5maXZlY2lyY2xlPTkzMTY7ZS5maXZlY2lyY2xlaW52ZXJzZXNhbnNzZXJpZj0xMDEyNjtlLmZpdmVkZXZhPTI0MTE7ZS5maXZlZWlnaHRocz04NTQxO2UuZml2ZWd1amFyYXRpPTI3OTU7ZS5maXZlZ3VybXVraGk9MjY2NztlLmZpdmVoYWNrYXJhYmljPTE2Mzc7ZS5maXZlaGFuZ3pob3U9MTIzMjU7ZS5maXZlaWRlb2dyYXBoaWNwYXJlbj0xMjgzNjtlLmZpdmVpbmZlcmlvcj04MzI1O2UuZml2ZW1vbm9zcGFjZT02NTMwMTtlLmZpdmVvbGRzdHlsZT02MzI4NTtlLmZpdmVwYXJlbj05MzM2O2UuZml2ZXBlcmlvZD05MzU2O2UuZml2ZXBlcnNpYW49MTc4MTtlLmZpdmVyb21hbj04NTY0O2UuZml2ZXN1cGVyaW9yPTgzMDk7ZS5maXZldGhhaT0zNjY5O2UuZmw9NjQyNTg7ZS5mX2w9NjQyNTg7ZS5mbG9yaW49NDAyO2UuZm1vbm9zcGFjZT02NTM1MDtlLmZtc3F1YXJlPTEzMjA5O2UuZm9mYW50aGFpPTM2MTU7ZS5mb2ZhdGhhaT0zNjEzO2UuZm9uZ21hbnRoYWk9MzY2MztlLmZvcmFsbD04NzA0O2UuZm91cj01MjtlLmZvdXJhcmFiaWM9MTYzNjtlLmZvdXJiZW5nYWxpPTI1Mzg7ZS5mb3VyY2lyY2xlPTkzMTU7ZS5mb3VyY2lyY2xlaW52ZXJzZXNhbnNzZXJpZj0xMDEyNTtlLmZvdXJkZXZhPTI0MTA7ZS5mb3VyZ3VqYXJhdGk9Mjc5NDtlLmZvdXJndXJtdWtoaT0yNjY2O2UuZm91cmhhY2thcmFiaWM9MTYzNjtlLmZvdXJoYW5nemhvdT0xMjMyNDtlLmZvdXJpZGVvZ3JhcGhpY3BhcmVuPTEyODM1O2UuZm91cmluZmVyaW9yPTgzMjQ7ZS5mb3VybW9ub3NwYWNlPTY1MzAwO2UuZm91cm51bWVyYXRvcmJlbmdhbGk9MjU1MTtlLmZvdXJvbGRzdHlsZT02MzI4NDtlLmZvdXJwYXJlbj05MzM1O2UuZm91cnBlcmlvZD05MzU1O2UuZm91cnBlcnNpYW49MTc4MDtlLmZvdXJyb21hbj04NTYzO2UuZm91cnN1cGVyaW9yPTgzMDg7ZS5mb3VydGVlbmNpcmNsZT05MzI1O2UuZm91cnRlZW5wYXJlbj05MzQ1O2UuZm91cnRlZW5wZXJpb2Q9OTM2NTtlLmZvdXJ0aGFpPTM2Njg7ZS5mb3VydGh0b25lY2hpbmVzZT03MTU7ZS5mcGFyZW49OTM3NztlLmZyYWN0aW9uPTgyNjA7ZS5mcmFuYz04MzU1O2UuZz0xMDM7ZS5nYWJlbmdhbGk9MjQ1NTtlLmdhY3V0ZT01MDE7ZS5nYWRldmE9MjMyNztlLmdhZmFyYWJpYz0xNzExO2UuZ2FmZmluYWxhcmFiaWM9NjQ0MDM7ZS5nYWZpbml0aWFsYXJhYmljPTY0NDA0O2UuZ2FmbWVkaWFsYXJhYmljPTY0NDA1O2UuZ2FndWphcmF0aT0yNzExO2UuZ2FndXJtdWtoaT0yNTgzO2UuZ2FoaXJhZ2FuYT0xMjM2NDtlLmdha2F0YWthbmE9MTI0NjA7ZS5nYW1tYT05NDc7ZS5nYW1tYWxhdGluc21hbGw9NjExO2UuZ2FtbWFzdXBlcmlvcj03MzY7ZS5nYW5naWFjb3B0aWM9MTAwMztlLmdib3BvbW9mbz0xMjU1NztlLmdicmV2ZT0yODc7ZS5nY2Fyb249NDg3O2UuZ2NlZGlsbGE9MjkxO2UuZ2NpcmNsZT05NDMwO2UuZ2NpcmN1bWZsZXg9Mjg1O2UuZ2NvbW1hYWNjZW50PTI5MTtlLmdkb3Q9Mjg5O2UuZ2RvdGFjY2VudD0yODk7ZS5nZWN5cmlsbGljPTEwNzU7ZS5nZWhpcmFnYW5hPTEyMzcwO2UuZ2VrYXRha2FuYT0xMjQ2NjtlLmdlb21ldHJpY2FsbHllcXVhbD04Nzg1O2UuZ2VyZXNoYWNjZW50aGVicmV3PTE0MzY7ZS5nZXJlc2hoZWJyZXc9MTUyMztlLmdlcmVzaG11cWRhbWhlYnJldz0xNDM3O2UuZ2VybWFuZGJscz0yMjM7ZS5nZXJzaGF5aW1hY2NlbnRoZWJyZXc9MTQzODtlLmdlcnNoYXlpbWhlYnJldz0xNTI0O2UuZ2V0YW1hcms9MTIzMDc7ZS5naGFiZW5nYWxpPTI0NTY7ZS5naGFkYXJtZW5pYW49MTM5NDtlLmdoYWRldmE9MjMyODtlLmdoYWd1amFyYXRpPTI3MTI7ZS5naGFndXJtdWtoaT0yNTg0O2UuZ2hhaW5hcmFiaWM9MTU5NDtlLmdoYWluZmluYWxhcmFiaWM9NjUyMzA7ZS5naGFpbmluaXRpYWxhcmFiaWM9NjUyMzE7ZS5naGFpbm1lZGlhbGFyYWJpYz02NTIzMjtlLmdoZW1pZGRsZWhvb2tjeXJpbGxpYz0xMTczO2UuZ2hlc3Ryb2tlY3lyaWxsaWM9MTE3MTtlLmdoZXVwdHVybmN5cmlsbGljPTExNjk7ZS5naGhhZGV2YT0yMzk0O2UuZ2hoYWd1cm11a2hpPTI2NTA7ZS5naG9vaz02MDg7ZS5naHpzcXVhcmU9MTMyMDM7ZS5naWhpcmFnYW5hPTEyMzY2O2UuZ2lrYXRha2FuYT0xMjQ2MjtlLmdpbWFybWVuaWFuPTEzNzk7ZS5naW1lbD0xNDkwO2UuZ2ltZWxkYWdlc2g9NjQzMDY7ZS5naW1lbGRhZ2VzaGhlYnJldz02NDMwNjtlLmdpbWVsaGVicmV3PTE0OTA7ZS5namVjeXJpbGxpYz0xMTA3O2UuZ2xvdHRhbGludmVydGVkc3Ryb2tlPTQ0NjtlLmdsb3R0YWxzdG9wPTY2MDtlLmdsb3R0YWxzdG9waW52ZXJ0ZWQ9NjYyO2UuZ2xvdHRhbHN0b3Btb2Q9NzA0O2UuZ2xvdHRhbHN0b3ByZXZlcnNlZD02NjE7ZS5nbG90dGFsc3RvcHJldmVyc2VkbW9kPTcwNTtlLmdsb3R0YWxzdG9wcmV2ZXJzZWRzdXBlcmlvcj03NDA7ZS5nbG90dGFsc3RvcHN0cm9rZT02NzM7ZS5nbG90dGFsc3RvcHN0cm9rZXJldmVyc2VkPTY3NDtlLmdtYWNyb249NzcxMztlLmdtb25vc3BhY2U9NjUzNTE7ZS5nb2hpcmFnYW5hPTEyMzcyO2UuZ29rYXRha2FuYT0xMjQ2ODtlLmdwYXJlbj05Mzc4O2UuZ3Bhc3F1YXJlPTEzMjI4O2UuZ3JhZGllbnQ9ODcxMTtlLmdyYXZlPTk2O2UuZ3JhdmViZWxvd2NtYj03OTA7ZS5ncmF2ZWNtYj03Njg7ZS5ncmF2ZWNvbWI9NzY4O2UuZ3JhdmVkZXZhPTIzODc7ZS5ncmF2ZWxvd21vZD03MTg7ZS5ncmF2ZW1vbm9zcGFjZT02NTM0NDtlLmdyYXZldG9uZWNtYj04MzI7ZS5ncmVhdGVyPTYyO2UuZ3JlYXRlcmVxdWFsPTg4MDU7ZS5ncmVhdGVyZXF1YWxvcmxlc3M9ODkyMztlLmdyZWF0ZXJtb25vc3BhY2U9NjUzMTA7ZS5ncmVhdGVyb3JlcXVpdmFsZW50PTg4MTk7ZS5ncmVhdGVyb3JsZXNzPTg4MjM7ZS5ncmVhdGVyb3ZlcmVxdWFsPTg4MDc7ZS5ncmVhdGVyc21hbGw9NjUxMjU7ZS5nc2NyaXB0PTYwOTtlLmdzdHJva2U9NDg1O2UuZ3VoaXJhZ2FuYT0xMjM2ODtlLmd1aWxsZW1vdGxlZnQ9MTcxO2UuZ3VpbGxlbW90cmlnaHQ9MTg3O2UuZ3VpbHNpbmdsbGVmdD04MjQ5O2UuZ3VpbHNpbmdscmlnaHQ9ODI1MDtlLmd1a2F0YWthbmE9MTI0NjQ7ZS5ndXJhbXVzcXVhcmU9MTMwODA7ZS5neXNxdWFyZT0xMzI1NztlLmg9MTA0O2UuaGFhYmtoYXNpYW5jeXJpbGxpYz0xMTkzO2UuaGFhbHRvbmVhcmFiaWM9MTcyOTtlLmhhYmVuZ2FsaT0yNDg5O2UuaGFkZXNjZW5kZXJjeXJpbGxpYz0xMjAzO2UuaGFkZXZhPTIzNjE7ZS5oYWd1amFyYXRpPTI3NDU7ZS5oYWd1cm11a2hpPTI2MTc7ZS5oYWhhcmFiaWM9MTU4MTtlLmhhaGZpbmFsYXJhYmljPTY1MTg2O2UuaGFoaW5pdGlhbGFyYWJpYz02NTE4NztlLmhhaGlyYWdhbmE9MTIzOTk7ZS5oYWhtZWRpYWxhcmFiaWM9NjUxODg7ZS5oYWl0dXNxdWFyZT0xMzA5ODtlLmhha2F0YWthbmE9MTI0OTU7ZS5oYWthdGFrYW5haGFsZndpZHRoPTY1NDE4O2UuaGFsYW50Z3VybXVraGk9MjYzNztlLmhhbXphYXJhYmljPTE1Njk7ZS5oYW16YWxvd2FyYWJpYz0xNTY5O2UuaGFuZ3VsZmlsbGVyPTEyNjQ0O2UuaGFyZHNpZ25jeXJpbGxpYz0xMDk4O2UuaGFycG9vbmxlZnRiYXJidXA9ODYzNjtlLmhhcnBvb25yaWdodGJhcmJ1cD04NjQwO2UuaGFzcXVhcmU9MTMyNTg7ZS5oYXRhZnBhdGFoPTE0NTg7ZS5oYXRhZnBhdGFoMTY9MTQ1ODtlLmhhdGFmcGF0YWgyMz0xNDU4O2UuaGF0YWZwYXRhaDJmPTE0NTg7ZS5oYXRhZnBhdGFoaGVicmV3PTE0NTg7ZS5oYXRhZnBhdGFobmFycm93aGVicmV3PTE0NTg7ZS5oYXRhZnBhdGFocXVhcnRlcmhlYnJldz0xNDU4O2UuaGF0YWZwYXRhaHdpZGVoZWJyZXc9MTQ1ODtlLmhhdGFmcWFtYXRzPTE0NTk7ZS5oYXRhZnFhbWF0czFiPTE0NTk7ZS5oYXRhZnFhbWF0czI4PTE0NTk7ZS5oYXRhZnFhbWF0czM0PTE0NTk7ZS5oYXRhZnFhbWF0c2hlYnJldz0xNDU5O2UuaGF0YWZxYW1hdHNuYXJyb3doZWJyZXc9MTQ1OTtlLmhhdGFmcWFtYXRzcXVhcnRlcmhlYnJldz0xNDU5O2UuaGF0YWZxYW1hdHN3aWRlaGVicmV3PTE0NTk7ZS5oYXRhZnNlZ29sPTE0NTc7ZS5oYXRhZnNlZ29sMTc9MTQ1NztlLmhhdGFmc2Vnb2wyND0xNDU3O2UuaGF0YWZzZWdvbDMwPTE0NTc7ZS5oYXRhZnNlZ29saGVicmV3PTE0NTc7ZS5oYXRhZnNlZ29sbmFycm93aGVicmV3PTE0NTc7ZS5oYXRhZnNlZ29scXVhcnRlcmhlYnJldz0xNDU3O2UuaGF0YWZzZWdvbHdpZGVoZWJyZXc9MTQ1NztlLmhiYXI9Mjk1O2UuaGJvcG9tb2ZvPTEyNTU5O2UuaGJyZXZlYmVsb3c9NzcyMztlLmhjZWRpbGxhPTc3MjE7ZS5oY2lyY2xlPTk0MzE7ZS5oY2lyY3VtZmxleD0yOTM7ZS5oZGllcmVzaXM9NzcxOTtlLmhkb3RhY2NlbnQ9NzcxNTtlLmhkb3RiZWxvdz03NzE3O2UuaGU9MTQ5MjtlLmhlYXJ0PTk4Mjk7ZS5oZWFydHN1aXRibGFjaz05ODI5O2UuaGVhcnRzdWl0d2hpdGU9OTgyNTtlLmhlZGFnZXNoPTY0MzA4O2UuaGVkYWdlc2hoZWJyZXc9NjQzMDg7ZS5oZWhhbHRvbmVhcmFiaWM9MTcyOTtlLmhlaGFyYWJpYz0xNjA3O2UuaGVoZWJyZXc9MTQ5MjtlLmhlaGZpbmFsYWx0b25lYXJhYmljPTY0NDIzO2UuaGVoZmluYWxhbHR0d29hcmFiaWM9NjUyNTg7ZS5oZWhmaW5hbGFyYWJpYz02NTI1ODtlLmhlaGhhbXphYWJvdmVmaW5hbGFyYWJpYz02NDQyMTtlLmhlaGhhbXphYWJvdmVpc29sYXRlZGFyYWJpYz02NDQyMDtlLmhlaGluaXRpYWxhbHRvbmVhcmFiaWM9NjQ0MjQ7ZS5oZWhpbml0aWFsYXJhYmljPTY1MjU5O2UuaGVoaXJhZ2FuYT0xMjQwODtlLmhlaG1lZGlhbGFsdG9uZWFyYWJpYz02NDQyNTtlLmhlaG1lZGlhbGFyYWJpYz02NTI2MDtlLmhlaXNlaWVyYXNxdWFyZT0xMzE3OTtlLmhla2F0YWthbmE9MTI1MDQ7ZS5oZWthdGFrYW5haGFsZndpZHRoPTY1NDIxO2UuaGVrdXRhYXJ1c3F1YXJlPTEzMTEwO2UuaGVuZ2hvb2s9NjE1O2UuaGVydXR1c3F1YXJlPTEzMTEzO2UuaGV0PTE0OTU7ZS5oZXRoZWJyZXc9MTQ5NTtlLmhob29rPTYxNDtlLmhob29rc3VwZXJpb3I9Njg5O2UuaGlldWhhY2lyY2xla29yZWFuPTEyOTIzO2UuaGlldWhhcGFyZW5rb3JlYW49MTI4Mjc7ZS5oaWV1aGNpcmNsZWtvcmVhbj0xMjkwOTtlLmhpZXVoa29yZWFuPTEyNjIyO2UuaGlldWhwYXJlbmtvcmVhbj0xMjgxMztlLmhpaGlyYWdhbmE9MTI0MDI7ZS5oaWthdGFrYW5hPTEyNDk4O2UuaGlrYXRha2FuYWhhbGZ3aWR0aD02NTQxOTtlLmhpcmlxPTE0NjA7ZS5oaXJpcTE0PTE0NjA7ZS5oaXJpcTIxPTE0NjA7ZS5oaXJpcTJkPTE0NjA7ZS5oaXJpcWhlYnJldz0xNDYwO2UuaGlyaXFuYXJyb3doZWJyZXc9MTQ2MDtlLmhpcmlxcXVhcnRlcmhlYnJldz0xNDYwO2UuaGlyaXF3aWRlaGVicmV3PTE0NjA7ZS5obGluZWJlbG93PTc4MzA7ZS5obW9ub3NwYWNlPTY1MzUyO2UuaG9hcm1lbmlhbj0xMzkyO2UuaG9oaXB0aGFpPTM2Mjc7ZS5ob2hpcmFnYW5hPTEyNDExO2UuaG9rYXRha2FuYT0xMjUwNztlLmhva2F0YWthbmFoYWxmd2lkdGg9NjU0MjI7ZS5ob2xhbT0xNDY1O2UuaG9sYW0xOT0xNDY1O2UuaG9sYW0yNj0xNDY1O2UuaG9sYW0zMj0xNDY1O2UuaG9sYW1oZWJyZXc9MTQ2NTtlLmhvbGFtbmFycm93aGVicmV3PTE0NjU7ZS5ob2xhbXF1YXJ0ZXJoZWJyZXc9MTQ2NTtlLmhvbGFtd2lkZWhlYnJldz0xNDY1O2UuaG9ub2todWt0aGFpPTM2MzA7ZS5ob29rYWJvdmVjb21iPTc3NztlLmhvb2tjbWI9Nzc3O2UuaG9va3BhbGF0YWxpemVkYmVsb3djbWI9ODAxO2UuaG9va3JldHJvZmxleGJlbG93Y21iPTgwMjtlLmhvb25zcXVhcmU9MTMxMjI7ZS5ob3JpY29wdGljPTEwMDE7ZS5ob3Jpem9udGFsYmFyPTgyMTM7ZS5ob3JuY21iPTc5NTtlLmhvdHNwcmluZ3M9OTgzMjtlLmhvdXNlPTg5NjI7ZS5ocGFyZW49OTM3OTtlLmhzdXBlcmlvcj02ODg7ZS5odHVybmVkPTYxMztlLmh1aGlyYWdhbmE9MTI0MDU7ZS5odWlpdG9zcXVhcmU9MTMxMDc7ZS5odWthdGFrYW5hPTEyNTAxO2UuaHVrYXRha2FuYWhhbGZ3aWR0aD02NTQyMDtlLmh1bmdhcnVtbGF1dD03MzM7ZS5odW5nYXJ1bWxhdXRjbWI9Nzc5O2UuaHY9NDA1O2UuaHlwaGVuPTQ1O2UuaHlwaGVuaW5mZXJpb3I9NjMyMDU7ZS5oeXBoZW5tb25vc3BhY2U9NjUyOTM7ZS5oeXBoZW5zbWFsbD02NTEyMztlLmh5cGhlbnN1cGVyaW9yPTYzMjA2O2UuaHlwaGVudHdvPTgyMDg7ZS5pPTEwNTtlLmlhY3V0ZT0yMzc7ZS5pYWN5cmlsbGljPTExMDM7ZS5pYmVuZ2FsaT0yNDM5O2UuaWJvcG9tb2ZvPTEyNTgzO2UuaWJyZXZlPTMwMTtlLmljYXJvbj00NjQ7ZS5pY2lyY2xlPTk0MzI7ZS5pY2lyY3VtZmxleD0yMzg7ZS5pY3lyaWxsaWM9MTExMDtlLmlkYmxncmF2ZT01MjE7ZS5pZGVvZ3JhcGhlYXJ0aGNpcmNsZT0xMjk0MztlLmlkZW9ncmFwaGZpcmVjaXJjbGU9MTI5Mzk7ZS5pZGVvZ3JhcGhpY2FsbGlhbmNlcGFyZW49MTI4NjM7ZS5pZGVvZ3JhcGhpY2NhbGxwYXJlbj0xMjg1ODtlLmlkZW9ncmFwaGljY2VudHJlY2lyY2xlPTEyOTY1O2UuaWRlb2dyYXBoaWNjbG9zZT0xMjI5NDtlLmlkZW9ncmFwaGljY29tbWE9MTIyODk7ZS5pZGVvZ3JhcGhpY2NvbW1hbGVmdD02NTM4MDtlLmlkZW9ncmFwaGljY29uZ3JhdHVsYXRpb25wYXJlbj0xMjg1NTtlLmlkZW9ncmFwaGljY29ycmVjdGNpcmNsZT0xMjk2MztlLmlkZW9ncmFwaGljZWFydGhwYXJlbj0xMjg0NztlLmlkZW9ncmFwaGljZW50ZXJwcmlzZXBhcmVuPTEyODYxO2UuaWRlb2dyYXBoaWNleGNlbGxlbnRjaXJjbGU9MTI5NTc7ZS5pZGVvZ3JhcGhpY2Zlc3RpdmFscGFyZW49MTI4NjQ7ZS5pZGVvZ3JhcGhpY2ZpbmFuY2lhbGNpcmNsZT0xMjk1MDtlLmlkZW9ncmFwaGljZmluYW5jaWFscGFyZW49MTI4NTQ7ZS5pZGVvZ3JhcGhpY2ZpcmVwYXJlbj0xMjg0MztlLmlkZW9ncmFwaGljaGF2ZXBhcmVuPTEyODUwO2UuaWRlb2dyYXBoaWNoaWdoY2lyY2xlPTEyOTY0O2UuaWRlb2dyYXBoaWNpdGVyYXRpb25tYXJrPTEyMjkzO2UuaWRlb2dyYXBoaWNsYWJvcmNpcmNsZT0xMjk1MjtlLmlkZW9ncmFwaGljbGFib3JwYXJlbj0xMjg1NjtlLmlkZW9ncmFwaGljbGVmdGNpcmNsZT0xMjk2NztlLmlkZW9ncmFwaGljbG93Y2lyY2xlPTEyOTY2O2UuaWRlb2dyYXBoaWNtZWRpY2luZWNpcmNsZT0xMjk2OTtlLmlkZW9ncmFwaGljbWV0YWxwYXJlbj0xMjg0NjtlLmlkZW9ncmFwaGljbW9vbnBhcmVuPTEyODQyO2UuaWRlb2dyYXBoaWNuYW1lcGFyZW49MTI4NTI7ZS5pZGVvZ3JhcGhpY3BlcmlvZD0xMjI5MDtlLmlkZW9ncmFwaGljcHJpbnRjaXJjbGU9MTI5NTg7ZS5pZGVvZ3JhcGhpY3JlYWNocGFyZW49MTI4Njc7ZS5pZGVvZ3JhcGhpY3JlcHJlc2VudHBhcmVuPTEyODU3O2UuaWRlb2dyYXBoaWNyZXNvdXJjZXBhcmVuPTEyODYyO2UuaWRlb2dyYXBoaWNyaWdodGNpcmNsZT0xMjk2ODtlLmlkZW9ncmFwaGljc2VjcmV0Y2lyY2xlPTEyOTUzO2UuaWRlb2dyYXBoaWNzZWxmcGFyZW49MTI4NjY7ZS5pZGVvZ3JhcGhpY3NvY2lldHlwYXJlbj0xMjg1MTtlLmlkZW9ncmFwaGljc3BhY2U9MTIyODg7ZS5pZGVvZ3JhcGhpY3NwZWNpYWxwYXJlbj0xMjg1MztlLmlkZW9ncmFwaGljc3RvY2twYXJlbj0xMjg0OTtlLmlkZW9ncmFwaGljc3R1ZHlwYXJlbj0xMjg1OTtlLmlkZW9ncmFwaGljc3VucGFyZW49MTI4NDg7ZS5pZGVvZ3JhcGhpY3N1cGVydmlzZXBhcmVuPTEyODYwO2UuaWRlb2dyYXBoaWN3YXRlcnBhcmVuPTEyODQ0O2UuaWRlb2dyYXBoaWN3b29kcGFyZW49MTI4NDU7ZS5pZGVvZ3JhcGhpY3plcm89MTIyOTU7ZS5pZGVvZ3JhcGhtZXRhbGNpcmNsZT0xMjk0MjtlLmlkZW9ncmFwaG1vb25jaXJjbGU9MTI5Mzg7ZS5pZGVvZ3JhcGhuYW1lY2lyY2xlPTEyOTQ4O2UuaWRlb2dyYXBoc3VuY2lyY2xlPTEyOTQ0O2UuaWRlb2dyYXBod2F0ZXJjaXJjbGU9MTI5NDA7ZS5pZGVvZ3JhcGh3b29kY2lyY2xlPTEyOTQxO2UuaWRldmE9MjMxMTtlLmlkaWVyZXNpcz0yMzk7ZS5pZGllcmVzaXNhY3V0ZT03NzI3O2UuaWRpZXJlc2lzY3lyaWxsaWM9MTI1MztlLmlkb3RiZWxvdz03ODgzO2UuaWVicmV2ZWN5cmlsbGljPTEyMzk7ZS5pZWN5cmlsbGljPTEwNzc7ZS5pZXVuZ2FjaXJjbGVrb3JlYW49MTI5MTc7ZS5pZXVuZ2FwYXJlbmtvcmVhbj0xMjgyMTtlLmlldW5nY2lyY2xla29yZWFuPTEyOTAzO2UuaWV1bmdrb3JlYW49MTI2MTU7ZS5pZXVuZ3BhcmVua29yZWFuPTEyODA3O2UuaWdyYXZlPTIzNjtlLmlndWphcmF0aT0yNjk1O2UuaWd1cm11a2hpPTI1Njc7ZS5paGlyYWdhbmE9MTIzNTY7ZS5paG9va2Fib3ZlPTc4ODE7ZS5paWJlbmdhbGk9MjQ0MDtlLmlpY3lyaWxsaWM9MTA4MDtlLmlpZGV2YT0yMzEyO2UuaWlndWphcmF0aT0yNjk2O2UuaWlndXJtdWtoaT0yNTY4O2UuaWltYXRyYWd1cm11a2hpPTI2MjQ7ZS5paW52ZXJ0ZWRicmV2ZT01MjM7ZS5paXNob3J0Y3lyaWxsaWM9MTA4MTtlLmlpdm93ZWxzaWduYmVuZ2FsaT0yNDk2O2UuaWl2b3dlbHNpZ25kZXZhPTIzNjg7ZS5paXZvd2Vsc2lnbmd1amFyYXRpPTI3NTI7ZS5paj0zMDc7ZS5pa2F0YWthbmE9MTI0NTI7ZS5pa2F0YWthbmFoYWxmd2lkdGg9NjUzOTQ7ZS5pa29yZWFuPTEyNjQzO2UuaWxkZT03MzI7ZS5pbHV5aGVicmV3PTE0NTI7ZS5pbWFjcm9uPTI5OTtlLmltYWNyb25jeXJpbGxpYz0xMjUxO2UuaW1hZ2VvcmFwcHJveGltYXRlbHllcXVhbD04Nzg3O2UuaW1hdHJhZ3VybXVraGk9MjYyMztlLmltb25vc3BhY2U9NjUzNTM7ZS5pbmNyZW1lbnQ9ODcxMDtlLmluZmluaXR5PTg3MzQ7ZS5pbmlhcm1lbmlhbj0xMzg3O2UuaW50ZWdyYWw9ODc0NztlLmludGVncmFsYm90dG9tPTg5OTM7ZS5pbnRlZ3JhbGJ0PTg5OTM7ZS5pbnRlZ3JhbGV4PTYzNzMzO2UuaW50ZWdyYWx0b3A9ODk5MjtlLmludGVncmFsdHA9ODk5MjtlLmludGVyc2VjdGlvbj04NzQ1O2UuaW50aXNxdWFyZT0xMzA2MTtlLmludmJ1bGxldD05Njg4O2UuaW52Y2lyY2xlPTk2ODk7ZS5pbnZzbWlsZWZhY2U9OTc4NztlLmlvY3lyaWxsaWM9MTEwNTtlLmlvZ29uZWs9MzAzO2UuaW90YT05NTM7ZS5pb3RhZGllcmVzaXM9OTcwO2UuaW90YWRpZXJlc2lzdG9ub3M9OTEyO2UuaW90YWxhdGluPTYxNztlLmlvdGF0b25vcz05NDM7ZS5pcGFyZW49OTM4MDtlLmlyaWd1cm11a2hpPTI2NzQ7ZS5pc21hbGxoaXJhZ2FuYT0xMjM1NTtlLmlzbWFsbGthdGFrYW5hPTEyNDUxO2UuaXNtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODQ7ZS5pc3NoYXJiZW5nYWxpPTI1NTQ7ZS5pc3Ryb2tlPTYxNjtlLmlzdXBlcmlvcj02MzIxMztlLml0ZXJhdGlvbmhpcmFnYW5hPTEyNDQ1O2UuaXRlcmF0aW9ua2F0YWthbmE9MTI1NDE7ZS5pdGlsZGU9Mjk3O2UuaXRpbGRlYmVsb3c9NzcyNTtlLml1Ym9wb21vZm89MTI1ODU7ZS5pdWN5cmlsbGljPTExMDI7ZS5pdm93ZWxzaWduYmVuZ2FsaT0yNDk1O2UuaXZvd2Vsc2lnbmRldmE9MjM2NztlLml2b3dlbHNpZ25ndWphcmF0aT0yNzUxO2UuaXpoaXRzYWN5cmlsbGljPTExNDE7ZS5pemhpdHNhZGJsZ3JhdmVjeXJpbGxpYz0xMTQzO2Uuaj0xMDY7ZS5qYWFybWVuaWFuPTEzOTM7ZS5qYWJlbmdhbGk9MjQ2MDtlLmphZGV2YT0yMzMyO2UuamFndWphcmF0aT0yNzE2O2UuamFndXJtdWtoaT0yNTg4O2UuamJvcG9tb2ZvPTEyNTYwO2UuamNhcm9uPTQ5NjtlLmpjaXJjbGU9OTQzMztlLmpjaXJjdW1mbGV4PTMwOTtlLmpjcm9zc2VkdGFpbD02Njk7ZS5qZG90bGVzc3N0cm9rZT02MDc7ZS5qZWN5cmlsbGljPTExMTI7ZS5qZWVtYXJhYmljPTE1ODA7ZS5qZWVtZmluYWxhcmFiaWM9NjUxODI7ZS5qZWVtaW5pdGlhbGFyYWJpYz02NTE4MztlLmplZW1tZWRpYWxhcmFiaWM9NjUxODQ7ZS5qZWhhcmFiaWM9MTY4ODtlLmplaGZpbmFsYXJhYmljPTY0Mzk1O2UuamhhYmVuZ2FsaT0yNDYxO2UuamhhZGV2YT0yMzMzO2UuamhhZ3VqYXJhdGk9MjcxNztlLmpoYWd1cm11a2hpPTI1ODk7ZS5qaGVoYXJtZW5pYW49MTQwMztlLmppcz0xMjI5MjtlLmptb25vc3BhY2U9NjUzNTQ7ZS5qcGFyZW49OTM4MTtlLmpzdXBlcmlvcj02OTA7ZS5rPTEwNztlLmthYmFzaGtpcmN5cmlsbGljPTExODU7ZS5rYWJlbmdhbGk9MjQ1MztlLmthY3V0ZT03NzI5O2Uua2FjeXJpbGxpYz0xMDgyO2Uua2FkZXNjZW5kZXJjeXJpbGxpYz0xMTc5O2Uua2FkZXZhPTIzMjU7ZS5rYWY9MTQ5OTtlLmthZmFyYWJpYz0xNjAzO2Uua2FmZGFnZXNoPTY0MzE1O2Uua2FmZGFnZXNoaGVicmV3PTY0MzE1O2Uua2FmZmluYWxhcmFiaWM9NjUyNDI7ZS5rYWZoZWJyZXc9MTQ5OTtlLmthZmluaXRpYWxhcmFiaWM9NjUyNDM7ZS5rYWZtZWRpYWxhcmFiaWM9NjUyNDQ7ZS5rYWZyYWZlaGVicmV3PTY0MzMzO2Uua2FndWphcmF0aT0yNzA5O2Uua2FndXJtdWtoaT0yNTgxO2Uua2FoaXJhZ2FuYT0xMjM2MztlLmthaG9va2N5cmlsbGljPTEyMjA7ZS5rYWthdGFrYW5hPTEyNDU5O2Uua2FrYXRha2FuYWhhbGZ3aWR0aD02NTM5ODtlLmthcHBhPTk1NDtlLmthcHBhc3ltYm9sZ3JlZWs9MTAwODtlLmthcHllb3VubWlldW1rb3JlYW49MTI2NTc7ZS5rYXB5ZW91bnBoaWV1cGhrb3JlYW49MTI2NzY7ZS5rYXB5ZW91bnBpZXVwa29yZWFuPTEyNjY0O2Uua2FweWVvdW5zc2FuZ3BpZXVwa29yZWFuPTEyNjY1O2Uua2Fyb3JpaXNxdWFyZT0xMzA2OTtlLmthc2hpZGFhdXRvYXJhYmljPTE2MDA7ZS5rYXNoaWRhYXV0b25vc2lkZWJlYXJpbmdhcmFiaWM9MTYwMDtlLmthc21hbGxrYXRha2FuYT0xMjUzMztlLmthc3F1YXJlPTEzMTg4O2Uua2FzcmFhcmFiaWM9MTYxNjtlLmthc3JhdGFuYXJhYmljPTE2MTM7ZS5rYXN0cm9rZWN5cmlsbGljPTExODM7ZS5rYXRhaGlyYXByb2xvbmdtYXJraGFsZndpZHRoPTY1MzkyO2Uua2F2ZXJ0aWNhbHN0cm9rZWN5cmlsbGljPTExODE7ZS5rYm9wb21vZm89MTI1NTg7ZS5rY2Fsc3F1YXJlPTEzMTkzO2Uua2Nhcm9uPTQ4OTtlLmtjZWRpbGxhPTMxMTtlLmtjaXJjbGU9OTQzNDtlLmtjb21tYWFjY2VudD0zMTE7ZS5rZG90YmVsb3c9NzczMTtlLmtlaGFybWVuaWFuPTE0MTI7ZS5rZWhpcmFnYW5hPTEyMzY5O2Uua2VrYXRha2FuYT0xMjQ2NTtlLmtla2F0YWthbmFoYWxmd2lkdGg9NjU0MDE7ZS5rZW5hcm1lbmlhbj0xMzkxO2Uua2VzbWFsbGthdGFrYW5hPTEyNTM0O2Uua2dyZWVubGFuZGljPTMxMjtlLmtoYWJlbmdhbGk9MjQ1NDtlLmtoYWN5cmlsbGljPTEwOTM7ZS5raGFkZXZhPTIzMjY7ZS5raGFndWphcmF0aT0yNzEwO2Uua2hhZ3VybXVraGk9MjU4MjtlLmtoYWhhcmFiaWM9MTU4MjtlLmtoYWhmaW5hbGFyYWJpYz02NTE5MDtlLmtoYWhpbml0aWFsYXJhYmljPTY1MTkxO2Uua2hhaG1lZGlhbGFyYWJpYz02NTE5MjtlLmtoZWljb3B0aWM9OTk5O2Uua2hoYWRldmE9MjM5MztlLmtoaGFndXJtdWtoaT0yNjQ5O2Uua2hpZXVraGFjaXJjbGVrb3JlYW49MTI5MjA7ZS5raGlldWtoYXBhcmVua29yZWFuPTEyODI0O2Uua2hpZXVraGNpcmNsZWtvcmVhbj0xMjkwNjtlLmtoaWV1a2hrb3JlYW49MTI2MTk7ZS5raGlldWtocGFyZW5rb3JlYW49MTI4MTA7ZS5raG9raGFpdGhhaT0zNTg2O2Uua2hva2hvbnRoYWk9MzU4OTtlLmtob2todWF0dGhhaT0zNTg3O2Uua2hva2h3YWl0aGFpPTM1ODg7ZS5raG9tdXR0aGFpPTM2NzU7ZS5raG9vaz00MDk7ZS5raG9yYWtoYW5ndGhhaT0zNTkwO2Uua2h6c3F1YXJlPTEzMjAxO2Uua2loaXJhZ2FuYT0xMjM2NTtlLmtpa2F0YWthbmE9MTI0NjE7ZS5raWthdGFrYW5haGFsZndpZHRoPTY1Mzk5O2Uua2lyb2d1cmFtdXNxdWFyZT0xMzA3NztlLmtpcm9tZWV0b3J1c3F1YXJlPTEzMDc4O2Uua2lyb3NxdWFyZT0xMzA3NjtlLmtpeWVva2FjaXJjbGVrb3JlYW49MTI5MTA7ZS5raXllb2thcGFyZW5rb3JlYW49MTI4MTQ7ZS5raXllb2tjaXJjbGVrb3JlYW49MTI4OTY7ZS5raXllb2trb3JlYW49MTI1OTM7ZS5raXllb2twYXJlbmtvcmVhbj0xMjgwMDtlLmtpeWVva3Npb3Nrb3JlYW49MTI1OTU7ZS5ramVjeXJpbGxpYz0xMTE2O2Uua2xpbmViZWxvdz03NzMzO2Uua2xzcXVhcmU9MTMyMDg7ZS5rbWN1YmVkc3F1YXJlPTEzMjIyO2Uua21vbm9zcGFjZT02NTM1NTtlLmttc3F1YXJlZHNxdWFyZT0xMzIxODtlLmtvaGlyYWdhbmE9MTIzNzE7ZS5rb2htc3F1YXJlPTEzMjQ4O2Uua29rYWl0aGFpPTM1ODU7ZS5rb2thdGFrYW5hPTEyNDY3O2Uua29rYXRha2FuYWhhbGZ3aWR0aD02NTQwMjtlLmtvb3Bvc3F1YXJlPTEzMDg2O2Uua29wcGFjeXJpbGxpYz0xMTUzO2Uua29yZWFuc3RhbmRhcmRzeW1ib2w9MTI5Mjc7ZS5rb3JvbmlzY21iPTgzNTtlLmtwYXJlbj05MzgyO2Uua3Bhc3F1YXJlPTEzMjI2O2Uua3NpY3lyaWxsaWM9MTEzNTtlLmt0c3F1YXJlPTEzMjYzO2Uua3R1cm5lZD02NzA7ZS5rdWhpcmFnYW5hPTEyMzY3O2Uua3VrYXRha2FuYT0xMjQ2MztlLmt1a2F0YWthbmFoYWxmd2lkdGg9NjU0MDA7ZS5rdnNxdWFyZT0xMzI0MDtlLmt3c3F1YXJlPTEzMjQ2O2UubD0xMDg7ZS5sYWJlbmdhbGk9MjQ4MjtlLmxhY3V0ZT0zMTQ7ZS5sYWRldmE9MjM1NDtlLmxhZ3VqYXJhdGk9MjczODtlLmxhZ3VybXVraGk9MjYxMDtlLmxha2toYW5neWFvdGhhaT0zNjUzO2UubGFtYWxlZmZpbmFsYXJhYmljPTY1Mjc2O2UubGFtYWxlZmhhbXphYWJvdmVmaW5hbGFyYWJpYz02NTI3MjtlLmxhbWFsZWZoYW16YWFib3ZlaXNvbGF0ZWRhcmFiaWM9NjUyNzE7ZS5sYW1hbGVmaGFtemFiZWxvd2ZpbmFsYXJhYmljPTY1Mjc0O2UubGFtYWxlZmhhbXphYmVsb3dpc29sYXRlZGFyYWJpYz02NTI3MztlLmxhbWFsZWZpc29sYXRlZGFyYWJpYz02NTI3NTtlLmxhbWFsZWZtYWRkYWFib3ZlZmluYWxhcmFiaWM9NjUyNzA7ZS5sYW1hbGVmbWFkZGFhYm92ZWlzb2xhdGVkYXJhYmljPTY1MjY5O2UubGFtYXJhYmljPTE2MDQ7ZS5sYW1iZGE9OTU1O2UubGFtYmRhc3Ryb2tlPTQxMTtlLmxhbWVkPTE1MDA7ZS5sYW1lZGRhZ2VzaD02NDMxNjtlLmxhbWVkZGFnZXNoaGVicmV3PTY0MzE2O2UubGFtZWRoZWJyZXc9MTUwMDtlLmxhbWZpbmFsYXJhYmljPTY1MjQ2O2UubGFtaGFoaW5pdGlhbGFyYWJpYz02NDcxNDtlLmxhbWluaXRpYWxhcmFiaWM9NjUyNDc7ZS5sYW1qZWVtaW5pdGlhbGFyYWJpYz02NDcxMztlLmxhbWtoYWhpbml0aWFsYXJhYmljPTY0NzE1O2UubGFtbGFtaGVoaXNvbGF0ZWRhcmFiaWM9NjUwMTA7ZS5sYW1tZWRpYWxhcmFiaWM9NjUyNDg7ZS5sYW1tZWVtaGFoaW5pdGlhbGFyYWJpYz02NDkwNDtlLmxhbW1lZW1pbml0aWFsYXJhYmljPTY0NzE2O2UubGFyZ2VjaXJjbGU9OTcxMTtlLmxiYXI9NDEwO2UubGJlbHQ9NjIwO2UubGJvcG9tb2ZvPTEyNTU2O2UubGNhcm9uPTMxODtlLmxjZWRpbGxhPTMxNjtlLmxjaXJjbGU9OTQzNTtlLmxjaXJjdW1mbGV4YmVsb3c9Nzc0MTtlLmxjb21tYWFjY2VudD0zMTY7ZS5sZG90PTMyMDtlLmxkb3RhY2NlbnQ9MzIwO2UubGRvdGJlbG93PTc3MzU7ZS5sZG90YmVsb3dtYWNyb249NzczNztlLmxlZnRhbmdsZWFib3ZlY21iPTc5NDtlLmxlZnR0YWNrYmVsb3djbWI9NzkyO2UubGVzcz02MDtlLmxlc3NlcXVhbD04ODA0O2UubGVzc2VxdWFsb3JncmVhdGVyPTg5MjI7ZS5sZXNzbW9ub3NwYWNlPTY1MzA4O2UubGVzc29yZXF1aXZhbGVudD04ODE4O2UubGVzc29yZ3JlYXRlcj04ODIyO2UubGVzc292ZXJlcXVhbD04ODA2O2UubGVzc3NtYWxsPTY1MTI0O2UubGV6aD02MjI7ZS5sZmJsb2NrPTk2MTI7ZS5saG9va3JldHJvZmxleD02MjE7ZS5saXJhPTgzNTY7ZS5saXduYXJtZW5pYW49MTM4ODtlLmxqPTQ1NztlLmxqZWN5cmlsbGljPTExMTM7ZS5sbD02MzE2ODtlLmxsYWRldmE9MjM1NTtlLmxsYWd1amFyYXRpPTI3Mzk7ZS5sbGluZWJlbG93PTc3Mzk7ZS5sbGxhZGV2YT0yMzU2O2UubGx2b2NhbGljYmVuZ2FsaT0yNTI5O2UubGx2b2NhbGljZGV2YT0yNDAxO2UubGx2b2NhbGljdm93ZWxzaWduYmVuZ2FsaT0yNTMxO2UubGx2b2NhbGljdm93ZWxzaWduZGV2YT0yNDAzO2UubG1pZGRsZXRpbGRlPTYxOTtlLmxtb25vc3BhY2U9NjUzNTY7ZS5sbXNxdWFyZT0xMzI2NDtlLmxvY2h1bGF0aGFpPTM2Mjg7ZS5sb2dpY2FsYW5kPTg3NDM7ZS5sb2dpY2Fsbm90PTE3MjtlLmxvZ2ljYWxub3RyZXZlcnNlZD04OTc2O2UubG9naWNhbG9yPTg3NDQ7ZS5sb2xpbmd0aGFpPTM2MjE7ZS5sb25ncz0zODM7ZS5sb3dsaW5lY2VudGVybGluZT02NTEwMjtlLmxvd2xpbmVjbWI9ODE4O2UubG93bGluZWRhc2hlZD02NTEwMTtlLmxvemVuZ2U9OTY3NDtlLmxwYXJlbj05MzgzO2UubHNsYXNoPTMyMjtlLmxzcXVhcmU9ODQ2NztlLmxzdXBlcmlvcj02MzIxNDtlLmx0c2hhZGU9OTYxNztlLmx1dGhhaT0zNjIyO2UubHZvY2FsaWNiZW5nYWxpPTI0NDQ7ZS5sdm9jYWxpY2RldmE9MjMxNjtlLmx2b2NhbGljdm93ZWxzaWduYmVuZ2FsaT0yNTMwO2UubHZvY2FsaWN2b3dlbHNpZ25kZXZhPTI0MDI7ZS5seHNxdWFyZT0xMzI2NztlLm09MTA5O2UubWFiZW5nYWxpPTI0Nzg7ZS5tYWNyb249MTc1O2UubWFjcm9uYmVsb3djbWI9ODE3O2UubWFjcm9uY21iPTc3MjtlLm1hY3Jvbmxvd21vZD03MTc7ZS5tYWNyb25tb25vc3BhY2U9NjU1MDc7ZS5tYWN1dGU9Nzc0MztlLm1hZGV2YT0yMzUwO2UubWFndWphcmF0aT0yNzM0O2UubWFndXJtdWtoaT0yNjA2O2UubWFoYXBha2hoZWJyZXc9MTQ0NDtlLm1haGFwYWtobGVmdGhlYnJldz0xNDQ0O2UubWFoaXJhZ2FuYT0xMjQxNDtlLm1haWNoYXR0YXdhbG93bGVmdHRoYWk9NjM2Mzc7ZS5tYWljaGF0dGF3YWxvd3JpZ2h0dGhhaT02MzYzNjtlLm1haWNoYXR0YXdhdGhhaT0zNjU5O2UubWFpY2hhdHRhd2F1cHBlcmxlZnR0aGFpPTYzNjM1O2UubWFpZWtsb3dsZWZ0dGhhaT02MzYyODtlLm1haWVrbG93cmlnaHR0aGFpPTYzNjI3O2UubWFpZWt0aGFpPTM2NTY7ZS5tYWlla3VwcGVybGVmdHRoYWk9NjM2MjY7ZS5tYWloYW5ha2F0bGVmdHRoYWk9NjM2MjA7ZS5tYWloYW5ha2F0dGhhaT0zNjMzO2UubWFpdGFpa2h1bGVmdHRoYWk9NjM2MjU7ZS5tYWl0YWlraHV0aGFpPTM2NTU7ZS5tYWl0aG9sb3dsZWZ0dGhhaT02MzYzMTtlLm1haXRob2xvd3JpZ2h0dGhhaT02MzYzMDtlLm1haXRob3RoYWk9MzY1NztlLm1haXRob3VwcGVybGVmdHRoYWk9NjM2Mjk7ZS5tYWl0cmlsb3dsZWZ0dGhhaT02MzYzNDtlLm1haXRyaWxvd3JpZ2h0dGhhaT02MzYzMztlLm1haXRyaXRoYWk9MzY1ODtlLm1haXRyaXVwcGVybGVmdHRoYWk9NjM2MzI7ZS5tYWl5YW1va3RoYWk9MzY1NDtlLm1ha2F0YWthbmE9MTI1MTA7ZS5tYWthdGFrYW5haGFsZndpZHRoPTY1NDIzO2UubWFsZT05Nzk0O2UubWFuc3lvbnNxdWFyZT0xMzEyNztlLm1hcWFmaGVicmV3PTE0NzA7ZS5tYXJzPTk3OTQ7ZS5tYXNvcmFjaXJjbGVoZWJyZXc9MTQ1NTtlLm1hc3F1YXJlPTEzMTg3O2UubWJvcG9tb2ZvPTEyNTUxO2UubWJzcXVhcmU9MTMyNjg7ZS5tY2lyY2xlPTk0MzY7ZS5tY3ViZWRzcXVhcmU9MTMyMjE7ZS5tZG90YWNjZW50PTc3NDU7ZS5tZG90YmVsb3c9Nzc0NztlLm1lZW1hcmFiaWM9MTYwNTtlLm1lZW1maW5hbGFyYWJpYz02NTI1MDtlLm1lZW1pbml0aWFsYXJhYmljPTY1MjUxO2UubWVlbW1lZGlhbGFyYWJpYz02NTI1MjtlLm1lZW1tZWVtaW5pdGlhbGFyYWJpYz02NDcyMTtlLm1lZW1tZWVtaXNvbGF0ZWRhcmFiaWM9NjQ1ODQ7ZS5tZWV0b3J1c3F1YXJlPTEzMTMzO2UubWVoaXJhZ2FuYT0xMjQxNztlLm1laXppZXJhc3F1YXJlPTEzMTgyO2UubWVrYXRha2FuYT0xMjUxMztlLm1la2F0YWthbmFoYWxmd2lkdGg9NjU0MjY7ZS5tZW09MTUwMjtlLm1lbWRhZ2VzaD02NDMxODtlLm1lbWRhZ2VzaGhlYnJldz02NDMxODtlLm1lbWhlYnJldz0xNTAyO2UubWVuYXJtZW5pYW49MTM5NjtlLm1lcmtoYWhlYnJldz0xNDQ1O2UubWVya2hha2VmdWxhaGVicmV3PTE0NDY7ZS5tZXJraGFrZWZ1bGFsZWZ0aGVicmV3PTE0NDY7ZS5tZXJraGFsZWZ0aGVicmV3PTE0NDU7ZS5taG9vaz02MjU7ZS5taHpzcXVhcmU9MTMyMDI7ZS5taWRkbGVkb3RrYXRha2FuYWhhbGZ3aWR0aD02NTM4MTtlLm1pZGRvdD0xODM7ZS5taWV1bWFjaXJjbGVrb3JlYW49MTI5MTQ7ZS5taWV1bWFwYXJlbmtvcmVhbj0xMjgxODtlLm1pZXVtY2lyY2xla29yZWFuPTEyOTAwO2UubWlldW1rb3JlYW49MTI2MDk7ZS5taWV1bXBhbnNpb3Nrb3JlYW49MTI2NTY7ZS5taWV1bXBhcmVua29yZWFuPTEyODA0O2UubWlldW1waWV1cGtvcmVhbj0xMjY1NDtlLm1pZXVtc2lvc2tvcmVhbj0xMjY1NTtlLm1paGlyYWdhbmE9MTI0MTU7ZS5taWthdGFrYW5hPTEyNTExO2UubWlrYXRha2FuYWhhbGZ3aWR0aD02NTQyNDtlLm1pbnVzPTg3MjI7ZS5taW51c2JlbG93Y21iPTgwMDtlLm1pbnVzY2lyY2xlPTg4NTQ7ZS5taW51c21vZD03Mjc7ZS5taW51c3BsdXM9ODcyMztlLm1pbnV0ZT04MjQyO2UubWlyaWJhYXJ1c3F1YXJlPTEzMTMwO2UubWlyaXNxdWFyZT0xMzEyOTtlLm1sb25nbGVndHVybmVkPTYyNDtlLm1sc3F1YXJlPTEzMjA2O2UubW1jdWJlZHNxdWFyZT0xMzIxOTtlLm1tb25vc3BhY2U9NjUzNTc7ZS5tbXNxdWFyZWRzcXVhcmU9MTMyMTU7ZS5tb2hpcmFnYW5hPTEyNDE4O2UubW9obXNxdWFyZT0xMzI0OTtlLm1va2F0YWthbmE9MTI1MTQ7ZS5tb2thdGFrYW5haGFsZndpZHRoPTY1NDI3O2UubW9sc3F1YXJlPTEzMjcwO2UubW9tYXRoYWk9MzYxNztlLm1vdmVyc3NxdWFyZT0xMzIyMztlLm1vdmVyc3NxdWFyZWRzcXVhcmU9MTMyMjQ7ZS5tcGFyZW49OTM4NDtlLm1wYXNxdWFyZT0xMzIyNztlLm1zc3F1YXJlPTEzMjM1O2UubXN1cGVyaW9yPTYzMjE1O2UubXR1cm5lZD02MjM7ZS5tdT0xODE7ZS5tdTE9MTgxO2UubXVhc3F1YXJlPTEzMTg2O2UubXVjaGdyZWF0ZXI9ODgxMTtlLm11Y2hsZXNzPTg4MTA7ZS5tdWZzcXVhcmU9MTMxOTY7ZS5tdWdyZWVrPTk1NjtlLm11Z3NxdWFyZT0xMzE5NztlLm11aGlyYWdhbmE9MTI0MTY7ZS5tdWthdGFrYW5hPTEyNTEyO2UubXVrYXRha2FuYWhhbGZ3aWR0aD02NTQyNTtlLm11bHNxdWFyZT0xMzIwNTtlLm11bHRpcGx5PTIxNTtlLm11bXNxdWFyZT0xMzIxMTtlLm11bmFoaGVicmV3PTE0NDM7ZS5tdW5haGxlZnRoZWJyZXc9MTQ0MztlLm11c2ljYWxub3RlPTk4MzQ7ZS5tdXNpY2Fsbm90ZWRibD05ODM1O2UubXVzaWNmbGF0c2lnbj05ODM3O2UubXVzaWNzaGFycHNpZ249OTgzOTtlLm11c3NxdWFyZT0xMzIzNDtlLm11dnNxdWFyZT0xMzIzODtlLm11d3NxdWFyZT0xMzI0NDtlLm12bWVnYXNxdWFyZT0xMzI0MTtlLm12c3F1YXJlPTEzMjM5O2UubXdtZWdhc3F1YXJlPTEzMjQ3O2UubXdzcXVhcmU9MTMyNDU7ZS5uPTExMDtlLm5hYmVuZ2FsaT0yNDcyO2UubmFibGE9ODcxMTtlLm5hY3V0ZT0zMjQ7ZS5uYWRldmE9MjM0NDtlLm5hZ3VqYXJhdGk9MjcyODtlLm5hZ3VybXVraGk9MjYwMDtlLm5haGlyYWdhbmE9MTIzOTQ7ZS5uYWthdGFrYW5hPTEyNDkwO2UubmFrYXRha2FuYWhhbGZ3aWR0aD02NTQxMztlLm5hcG9zdHJvcGhlPTMyOTtlLm5hc3F1YXJlPTEzMTg1O2UubmJvcG9tb2ZvPTEyNTU1O2UubmJzcGFjZT0xNjA7ZS5uY2Fyb249MzI4O2UubmNlZGlsbGE9MzI2O2UubmNpcmNsZT05NDM3O2UubmNpcmN1bWZsZXhiZWxvdz03NzU1O2UubmNvbW1hYWNjZW50PTMyNjtlLm5kb3RhY2NlbnQ9Nzc0OTtlLm5kb3RiZWxvdz03NzUxO2UubmVoaXJhZ2FuYT0xMjM5NztlLm5la2F0YWthbmE9MTI0OTM7ZS5uZWthdGFrYW5haGFsZndpZHRoPTY1NDE2O2UubmV3c2hlcWVsc2lnbj04MzYyO2UubmZzcXVhcmU9MTMxOTU7ZS5uZ2FiZW5nYWxpPTI0NTc7ZS5uZ2FkZXZhPTIzMjk7ZS5uZ2FndWphcmF0aT0yNzEzO2UubmdhZ3VybXVraGk9MjU4NTtlLm5nb25ndXRoYWk9MzU5MTtlLm5oaXJhZ2FuYT0xMjQzNTtlLm5ob29rbGVmdD02MjY7ZS5uaG9va3JldHJvZmxleD02Mjc7ZS5uaWV1bmFjaXJjbGVrb3JlYW49MTI5MTE7ZS5uaWV1bmFwYXJlbmtvcmVhbj0xMjgxNTtlLm5pZXVuY2lldWNrb3JlYW49MTI1OTc7ZS5uaWV1bmNpcmNsZWtvcmVhbj0xMjg5NztlLm5pZXVuaGlldWhrb3JlYW49MTI1OTg7ZS5uaWV1bmtvcmVhbj0xMjU5NjtlLm5pZXVucGFuc2lvc2tvcmVhbj0xMjY0ODtlLm5pZXVucGFyZW5rb3JlYW49MTI4MDE7ZS5uaWV1bnNpb3Nrb3JlYW49MTI2NDc7ZS5uaWV1bnRpa2V1dGtvcmVhbj0xMjY0NjtlLm5paGlyYWdhbmE9MTIzOTU7ZS5uaWthdGFrYW5hPTEyNDkxO2UubmlrYXRha2FuYWhhbGZ3aWR0aD02NTQxNDtlLm5pa2hhaGl0bGVmdHRoYWk9NjM2NDE7ZS5uaWtoYWhpdHRoYWk9MzY2MTtlLm5pbmU9NTc7ZS5uaW5lYXJhYmljPTE2NDE7ZS5uaW5lYmVuZ2FsaT0yNTQzO2UubmluZWNpcmNsZT05MzIwO2UubmluZWNpcmNsZWludmVyc2VzYW5zc2VyaWY9MTAxMzA7ZS5uaW5lZGV2YT0yNDE1O2UubmluZWd1amFyYXRpPTI3OTk7ZS5uaW5lZ3VybXVraGk9MjY3MTtlLm5pbmVoYWNrYXJhYmljPTE2NDE7ZS5uaW5laGFuZ3pob3U9MTIzMjk7ZS5uaW5laWRlb2dyYXBoaWNwYXJlbj0xMjg0MDtlLm5pbmVpbmZlcmlvcj04MzI5O2UubmluZW1vbm9zcGFjZT02NTMwNTtlLm5pbmVvbGRzdHlsZT02MzI4OTtlLm5pbmVwYXJlbj05MzQwO2UubmluZXBlcmlvZD05MzYwO2UubmluZXBlcnNpYW49MTc4NTtlLm5pbmVyb21hbj04NTY4O2UubmluZXN1cGVyaW9yPTgzMTM7ZS5uaW5ldGVlbmNpcmNsZT05MzMwO2UubmluZXRlZW5wYXJlbj05MzUwO2UubmluZXRlZW5wZXJpb2Q9OTM3MDtlLm5pbmV0aGFpPTM2NzM7ZS5uaj00NjA7ZS5uamVjeXJpbGxpYz0xMTE0O2UubmthdGFrYW5hPTEyNTMxO2UubmthdGFrYW5haGFsZndpZHRoPTY1NDM3O2UubmxlZ3JpZ2h0bG9uZz00MTQ7ZS5ubGluZWJlbG93PTc3NTM7ZS5ubW9ub3NwYWNlPTY1MzU4O2Uubm1zcXVhcmU9MTMyMTA7ZS5ubmFiZW5nYWxpPTI0Njc7ZS5ubmFkZXZhPTIzMzk7ZS5ubmFndWphcmF0aT0yNzIzO2Uubm5hZ3VybXVraGk9MjU5NTtlLm5ubmFkZXZhPTIzNDU7ZS5ub2hpcmFnYW5hPTEyMzk4O2Uubm9rYXRha2FuYT0xMjQ5NDtlLm5va2F0YWthbmFoYWxmd2lkdGg9NjU0MTc7ZS5ub25icmVha2luZ3NwYWNlPTE2MDtlLm5vbmVudGhhaT0zNjAzO2Uubm9udXRoYWk9MzYwOTtlLm5vb25hcmFiaWM9MTYwNjtlLm5vb25maW5hbGFyYWJpYz02NTI1NDtlLm5vb25naHVubmFhcmFiaWM9MTcyMjtlLm5vb25naHVubmFmaW5hbGFyYWJpYz02NDQxNTtlLm5vb25pbml0aWFsYXJhYmljPTY1MjU1O2Uubm9vbmplZW1pbml0aWFsYXJhYmljPTY0NzIyO2Uubm9vbmplZW1pc29sYXRlZGFyYWJpYz02NDU4NztlLm5vb25tZWRpYWxhcmFiaWM9NjUyNTY7ZS5ub29ubWVlbWluaXRpYWxhcmFiaWM9NjQ3MjU7ZS5ub29ubWVlbWlzb2xhdGVkYXJhYmljPTY0NTkwO2Uubm9vbm5vb25maW5hbGFyYWJpYz02NDY1MztlLm5vdGNvbnRhaW5zPTg3MTY7ZS5ub3RlbGVtZW50PTg3MTM7ZS5ub3RlbGVtZW50b2Y9ODcxMztlLm5vdGVxdWFsPTg4MDA7ZS5ub3RncmVhdGVyPTg4MTU7ZS5ub3RncmVhdGVybm9yZXF1YWw9ODgxNztlLm5vdGdyZWF0ZXJub3JsZXNzPTg4MjU7ZS5ub3RpZGVudGljYWw9ODgwMjtlLm5vdGxlc3M9ODgxNDtlLm5vdGxlc3Nub3JlcXVhbD04ODE2O2Uubm90cGFyYWxsZWw9ODc0MjtlLm5vdHByZWNlZGVzPTg4MzI7ZS5ub3RzdWJzZXQ9ODgzNjtlLm5vdHN1Y2NlZWRzPTg4MzM7ZS5ub3RzdXBlcnNldD04ODM3O2Uubm93YXJtZW5pYW49MTM5ODtlLm5wYXJlbj05Mzg1O2UubnNzcXVhcmU9MTMyMzM7ZS5uc3VwZXJpb3I9ODMxOTtlLm50aWxkZT0yNDE7ZS5udT05NTc7ZS5udWhpcmFnYW5hPTEyMzk2O2UubnVrYXRha2FuYT0xMjQ5MjtlLm51a2F0YWthbmFoYWxmd2lkdGg9NjU0MTU7ZS5udWt0YWJlbmdhbGk9MjQ5MjtlLm51a3RhZGV2YT0yMzY0O2UubnVrdGFndWphcmF0aT0yNzQ4O2UubnVrdGFndXJtdWtoaT0yNjIwO2UubnVtYmVyc2lnbj0zNTtlLm51bWJlcnNpZ25tb25vc3BhY2U9NjUyODM7ZS5udW1iZXJzaWduc21hbGw9NjUxMTk7ZS5udW1lcmFsc2lnbmdyZWVrPTg4NDtlLm51bWVyYWxzaWdubG93ZXJncmVlaz04ODU7ZS5udW1lcm89ODQ3MDtlLm51bj0xNTA0O2UubnVuZGFnZXNoPTY0MzIwO2UubnVuZGFnZXNoaGVicmV3PTY0MzIwO2UubnVuaGVicmV3PTE1MDQ7ZS5udnNxdWFyZT0xMzIzNztlLm53c3F1YXJlPTEzMjQzO2UubnlhYmVuZ2FsaT0yNDYyO2UubnlhZGV2YT0yMzM0O2UubnlhZ3VqYXJhdGk9MjcxODtlLm55YWd1cm11a2hpPTI1OTA7ZS5vPTExMTtlLm9hY3V0ZT0yNDM7ZS5vYW5ndGhhaT0zNjI5O2Uub2JhcnJlZD02Mjk7ZS5vYmFycmVkY3lyaWxsaWM9MTI1NztlLm9iYXJyZWRkaWVyZXNpc2N5cmlsbGljPTEyNTk7ZS5vYmVuZ2FsaT0yNDUxO2Uub2JvcG9tb2ZvPTEyNTcxO2Uub2JyZXZlPTMzNTtlLm9jYW5kcmFkZXZhPTIzMjE7ZS5vY2FuZHJhZ3VqYXJhdGk9MjcwNTtlLm9jYW5kcmF2b3dlbHNpZ25kZXZhPTIzNzc7ZS5vY2FuZHJhdm93ZWxzaWduZ3VqYXJhdGk9Mjc2MTtlLm9jYXJvbj00NjY7ZS5vY2lyY2xlPTk0Mzg7ZS5vY2lyY3VtZmxleD0yNDQ7ZS5vY2lyY3VtZmxleGFjdXRlPTc4ODk7ZS5vY2lyY3VtZmxleGRvdGJlbG93PTc4OTc7ZS5vY2lyY3VtZmxleGdyYXZlPTc4OTE7ZS5vY2lyY3VtZmxleGhvb2thYm92ZT03ODkzO2Uub2NpcmN1bWZsZXh0aWxkZT03ODk1O2Uub2N5cmlsbGljPTEwODY7ZS5vZGJsYWN1dGU9MzM3O2Uub2RibGdyYXZlPTUyNTtlLm9kZXZhPTIzMjM7ZS5vZGllcmVzaXM9MjQ2O2Uub2RpZXJlc2lzY3lyaWxsaWM9MTI1NTtlLm9kb3RiZWxvdz03ODg1O2Uub2U9MzM5O2Uub2Vrb3JlYW49MTI2MzQ7ZS5vZ29uZWs9NzMxO2Uub2dvbmVrY21iPTgwODtlLm9ncmF2ZT0yNDI7ZS5vZ3VqYXJhdGk9MjcwNztlLm9oYXJtZW5pYW49MTQxMztlLm9oaXJhZ2FuYT0xMjM2MjtlLm9ob29rYWJvdmU9Nzg4NztlLm9ob3JuPTQxNztlLm9ob3JuYWN1dGU9Nzg5OTtlLm9ob3JuZG90YmVsb3c9NzkwNztlLm9ob3JuZ3JhdmU9NzkwMTtlLm9ob3JuaG9va2Fib3ZlPTc5MDM7ZS5vaG9ybnRpbGRlPTc5MDU7ZS5vaHVuZ2FydW1sYXV0PTMzNztlLm9pPTQxOTtlLm9pbnZlcnRlZGJyZXZlPTUyNztlLm9rYXRha2FuYT0xMjQ1ODtlLm9rYXRha2FuYWhhbGZ3aWR0aD02NTM5NztlLm9rb3JlYW49MTI2MzE7ZS5vbGVoZWJyZXc9MTQ1MTtlLm9tYWNyb249MzMzO2Uub21hY3JvbmFjdXRlPTc3NjM7ZS5vbWFjcm9uZ3JhdmU9Nzc2MTtlLm9tZGV2YT0yMzg0O2Uub21lZ2E9OTY5O2Uub21lZ2ExPTk4MjtlLm9tZWdhY3lyaWxsaWM9MTEyMTtlLm9tZWdhbGF0aW5jbG9zZWQ9NjMxO2Uub21lZ2Fyb3VuZGN5cmlsbGljPTExNDc7ZS5vbWVnYXRpdGxvY3lyaWxsaWM9MTE0OTtlLm9tZWdhdG9ub3M9OTc0O2Uub21ndWphcmF0aT0yNzY4O2Uub21pY3Jvbj05NTk7ZS5vbWljcm9udG9ub3M9OTcyO2Uub21vbm9zcGFjZT02NTM1OTtlLm9uZT00OTtlLm9uZWFyYWJpYz0xNjMzO2Uub25lYmVuZ2FsaT0yNTM1O2Uub25lY2lyY2xlPTkzMTI7ZS5vbmVjaXJjbGVpbnZlcnNlc2Fuc3NlcmlmPTEwMTIyO2Uub25lZGV2YT0yNDA3O2Uub25lZG90ZW5sZWFkZXI9ODIyODtlLm9uZWVpZ2h0aD04NTM5O2Uub25lZml0dGVkPTYzMTk2O2Uub25lZ3VqYXJhdGk9Mjc5MTtlLm9uZWd1cm11a2hpPTI2NjM7ZS5vbmVoYWNrYXJhYmljPTE2MzM7ZS5vbmVoYWxmPTE4OTtlLm9uZWhhbmd6aG91PTEyMzIxO2Uub25laWRlb2dyYXBoaWNwYXJlbj0xMjgzMjtlLm9uZWluZmVyaW9yPTgzMjE7ZS5vbmVtb25vc3BhY2U9NjUyOTc7ZS5vbmVudW1lcmF0b3JiZW5nYWxpPTI1NDg7ZS5vbmVvbGRzdHlsZT02MzI4MTtlLm9uZXBhcmVuPTkzMzI7ZS5vbmVwZXJpb2Q9OTM1MjtlLm9uZXBlcnNpYW49MTc3NztlLm9uZXF1YXJ0ZXI9MTg4O2Uub25lcm9tYW49ODU2MDtlLm9uZXN1cGVyaW9yPTE4NTtlLm9uZXRoYWk9MzY2NTtlLm9uZXRoaXJkPTg1MzE7ZS5vb2dvbmVrPTQ5MTtlLm9vZ29uZWttYWNyb249NDkzO2Uub29ndXJtdWtoaT0yNTc5O2Uub29tYXRyYWd1cm11a2hpPTI2MzU7ZS5vb3Blbj01OTY7ZS5vcGFyZW49OTM4NjtlLm9wZW5idWxsZXQ9OTcwMjtlLm9wdGlvbj04OTk3O2Uub3JkZmVtaW5pbmU9MTcwO2Uub3JkbWFzY3VsaW5lPTE4NjtlLm9ydGhvZ29uYWw9ODczNTtlLm9zaG9ydGRldmE9MjMyMjtlLm9zaG9ydHZvd2Vsc2lnbmRldmE9MjM3ODtlLm9zbGFzaD0yNDg7ZS5vc2xhc2hhY3V0ZT01MTE7ZS5vc21hbGxoaXJhZ2FuYT0xMjM2MTtlLm9zbWFsbGthdGFrYW5hPTEyNDU3O2Uub3NtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODc7ZS5vc3Ryb2tlYWN1dGU9NTExO2Uub3N1cGVyaW9yPTYzMjE2O2Uub3RjeXJpbGxpYz0xMTUxO2Uub3RpbGRlPTI0NTtlLm90aWxkZWFjdXRlPTc3NTc7ZS5vdGlsZGVkaWVyZXNpcz03NzU5O2Uub3Vib3BvbW9mbz0xMjU3NztlLm92ZXJsaW5lPTgyNTQ7ZS5vdmVybGluZWNlbnRlcmxpbmU9NjUwOTg7ZS5vdmVybGluZWNtYj03NzM7ZS5vdmVybGluZWRhc2hlZD02NTA5NztlLm92ZXJsaW5lZGJsd2F2eT02NTEwMDtlLm92ZXJsaW5ld2F2eT02NTA5OTtlLm92ZXJzY29yZT0xNzU7ZS5vdm93ZWxzaWduYmVuZ2FsaT0yNTA3O2Uub3Zvd2Vsc2lnbmRldmE9MjM3OTtlLm92b3dlbHNpZ25ndWphcmF0aT0yNzYzO2UucD0xMTI7ZS5wYWFtcHNzcXVhcmU9MTMxODQ7ZS5wYWFzZW50b3NxdWFyZT0xMzA5OTtlLnBhYmVuZ2FsaT0yNDc0O2UucGFjdXRlPTc3NjU7ZS5wYWRldmE9MjM0NjtlLnBhZ2Vkb3duPTg2NzE7ZS5wYWdldXA9ODY3MDtlLnBhZ3VqYXJhdGk9MjczMDtlLnBhZ3VybXVraGk9MjYwMjtlLnBhaGlyYWdhbmE9MTI0MDE7ZS5wYWl5YW5ub2l0aGFpPTM2MzE7ZS5wYWthdGFrYW5hPTEyNDk3O2UucGFsYXRhbGl6YXRpb25jeXJpbGxpY2NtYj0xMTU2O2UucGFsb2Noa2FjeXJpbGxpYz0xMjE2O2UucGFuc2lvc2tvcmVhbj0xMjY3MTtlLnBhcmFncmFwaD0xODI7ZS5wYXJhbGxlbD04NzQxO2UucGFyZW5sZWZ0PTQwO2UucGFyZW5sZWZ0YWx0b25lYXJhYmljPTY0ODMwO2UucGFyZW5sZWZ0YnQ9NjM3MjU7ZS5wYXJlbmxlZnRleD02MzcyNDtlLnBhcmVubGVmdGluZmVyaW9yPTgzMzM7ZS5wYXJlbmxlZnRtb25vc3BhY2U9NjUyODg7ZS5wYXJlbmxlZnRzbWFsbD02NTExMztlLnBhcmVubGVmdHN1cGVyaW9yPTgzMTc7ZS5wYXJlbmxlZnR0cD02MzcyMztlLnBhcmVubGVmdHZlcnRpY2FsPTY1MDc3O2UucGFyZW5yaWdodD00MTtlLnBhcmVucmlnaHRhbHRvbmVhcmFiaWM9NjQ4MzE7ZS5wYXJlbnJpZ2h0YnQ9NjM3MzY7ZS5wYXJlbnJpZ2h0ZXg9NjM3MzU7ZS5wYXJlbnJpZ2h0aW5mZXJpb3I9ODMzNDtlLnBhcmVucmlnaHRtb25vc3BhY2U9NjUyODk7ZS5wYXJlbnJpZ2h0c21hbGw9NjUxMTQ7ZS5wYXJlbnJpZ2h0c3VwZXJpb3I9ODMxODtlLnBhcmVucmlnaHR0cD02MzczNDtlLnBhcmVucmlnaHR2ZXJ0aWNhbD02NTA3ODtlLnBhcnRpYWxkaWZmPTg3MDY7ZS5wYXNlcWhlYnJldz0xNDcyO2UucGFzaHRhaGVicmV3PTE0MzM7ZS5wYXNxdWFyZT0xMzIyNTtlLnBhdGFoPTE0NjM7ZS5wYXRhaDExPTE0NjM7ZS5wYXRhaDFkPTE0NjM7ZS5wYXRhaDJhPTE0NjM7ZS5wYXRhaGhlYnJldz0xNDYzO2UucGF0YWhuYXJyb3doZWJyZXc9MTQ2MztlLnBhdGFocXVhcnRlcmhlYnJldz0xNDYzO2UucGF0YWh3aWRlaGVicmV3PTE0NjM7ZS5wYXplcmhlYnJldz0xNDQxO2UucGJvcG9tb2ZvPTEyNTUwO2UucGNpcmNsZT05NDM5O2UucGRvdGFjY2VudD03NzY3O2UucGU9MTUwODtlLnBlY3lyaWxsaWM9MTA4NztlLnBlZGFnZXNoPTY0MzI0O2UucGVkYWdlc2hoZWJyZXc9NjQzMjQ7ZS5wZWV6aXNxdWFyZT0xMzExNTtlLnBlZmluYWxkYWdlc2hoZWJyZXc9NjQzMjM7ZS5wZWhhcmFiaWM9MTY2MjtlLnBlaGFybWVuaWFuPTE0MDI7ZS5wZWhlYnJldz0xNTA4O2UucGVoZmluYWxhcmFiaWM9NjQzNDM7ZS5wZWhpbml0aWFsYXJhYmljPTY0MzQ0O2UucGVoaXJhZ2FuYT0xMjQxMDtlLnBlaG1lZGlhbGFyYWJpYz02NDM0NTtlLnBla2F0YWthbmE9MTI1MDY7ZS5wZW1pZGRsZWhvb2tjeXJpbGxpYz0xMTkxO2UucGVyYWZlaGVicmV3PTY0MzM0O2UucGVyY2VudD0zNztlLnBlcmNlbnRhcmFiaWM9MTY0MjtlLnBlcmNlbnRtb25vc3BhY2U9NjUyODU7ZS5wZXJjZW50c21hbGw9NjUxMzA7ZS5wZXJpb2Q9NDY7ZS5wZXJpb2Rhcm1lbmlhbj0xNDE3O2UucGVyaW9kY2VudGVyZWQ9MTgzO2UucGVyaW9kaGFsZndpZHRoPTY1Mzc3O2UucGVyaW9kaW5mZXJpb3I9NjMyMDc7ZS5wZXJpb2Rtb25vc3BhY2U9NjUyOTQ7ZS5wZXJpb2RzbWFsbD02NTEwNjtlLnBlcmlvZHN1cGVyaW9yPTYzMjA4O2UucGVyaXNwb21lbmlncmVla2NtYj04MzQ7ZS5wZXJwZW5kaWN1bGFyPTg4Njk7ZS5wZXJ0aG91c2FuZD04MjQwO2UucGVzZXRhPTgzNTk7ZS5wZnNxdWFyZT0xMzE5NDtlLnBoYWJlbmdhbGk9MjQ3NTtlLnBoYWRldmE9MjM0NztlLnBoYWd1amFyYXRpPTI3MzE7ZS5waGFndXJtdWtoaT0yNjAzO2UucGhpPTk2NjtlLnBoaTE9OTgxO2UucGhpZXVwaGFjaXJjbGVrb3JlYW49MTI5MjI7ZS5waGlldXBoYXBhcmVua29yZWFuPTEyODI2O2UucGhpZXVwaGNpcmNsZWtvcmVhbj0xMjkwODtlLnBoaWV1cGhrb3JlYW49MTI2MjE7ZS5waGlldXBocGFyZW5rb3JlYW49MTI4MTI7ZS5waGlsYXRpbj02MzI7ZS5waGludGh1dGhhaT0zNjQyO2UucGhpc3ltYm9sZ3JlZWs9OTgxO2UucGhvb2s9NDIxO2UucGhvcGhhbnRoYWk9MzYxNDtlLnBob3BodW5ndGhhaT0zNjEyO2UucGhvc2FtcGhhb3RoYWk9MzYxNjtlLnBpPTk2MDtlLnBpZXVwYWNpcmNsZWtvcmVhbj0xMjkxNTtlLnBpZXVwYXBhcmVua29yZWFuPTEyODE5O2UucGlldXBjaWV1Y2tvcmVhbj0xMjY2MjtlLnBpZXVwY2lyY2xla29yZWFuPTEyOTAxO2UucGlldXBraXllb2trb3JlYW49MTI2NTg7ZS5waWV1cGtvcmVhbj0xMjYxMDtlLnBpZXVwcGFyZW5rb3JlYW49MTI4MDU7ZS5waWV1cHNpb3NraXllb2trb3JlYW49MTI2NjA7ZS5waWV1cHNpb3Nrb3JlYW49MTI2MTI7ZS5waWV1cHNpb3N0aWtldXRrb3JlYW49MTI2NjE7ZS5waWV1cHRoaWV1dGhrb3JlYW49MTI2NjM7ZS5waWV1cHRpa2V1dGtvcmVhbj0xMjY1OTtlLnBpaGlyYWdhbmE9MTI0MDQ7ZS5waWthdGFrYW5hPTEyNTAwO2UucGlzeW1ib2xncmVlaz05ODI7ZS5waXdyYXJtZW5pYW49MTQxMTtlLnBsYW5ja292ZXIycGk9ODQ2MztlLnBsYW5ja292ZXIycGkxPTg0NjM7ZS5wbHVzPTQzO2UucGx1c2JlbG93Y21iPTc5OTtlLnBsdXNjaXJjbGU9ODg1MztlLnBsdXNtaW51cz0xNzc7ZS5wbHVzbW9kPTcyNjtlLnBsdXNtb25vc3BhY2U9NjUyOTE7ZS5wbHVzc21hbGw9NjUxMjI7ZS5wbHVzc3VwZXJpb3I9ODMxNDtlLnBtb25vc3BhY2U9NjUzNjA7ZS5wbXNxdWFyZT0xMzI3MjtlLnBvaGlyYWdhbmE9MTI0MTM7ZS5wb2ludGluZ2luZGV4ZG93bndoaXRlPTk3NTk7ZS5wb2ludGluZ2luZGV4bGVmdHdoaXRlPTk3NTY7ZS5wb2ludGluZ2luZGV4cmlnaHR3aGl0ZT05NzU4O2UucG9pbnRpbmdpbmRleHVwd2hpdGU9OTc1NztlLnBva2F0YWthbmE9MTI1MDk7ZS5wb3BsYXRoYWk9MzYxMTtlLnBvc3RhbG1hcms9MTIzMDY7ZS5wb3N0YWxtYXJrZmFjZT0xMjMyMDtlLnBwYXJlbj05Mzg3O2UucHJlY2VkZXM9ODgyNjtlLnByZXNjcmlwdGlvbj04NDc4O2UucHJpbWVtb2Q9Njk3O2UucHJpbWVyZXZlcnNlZD04MjQ1O2UucHJvZHVjdD04NzE5O2UucHJvamVjdGl2ZT04OTY1O2UucHJvbG9uZ2Vka2FuYT0xMjU0MDtlLnByb3BlbGxvcj04OTg0O2UucHJvcGVyc3Vic2V0PTg4MzQ7ZS5wcm9wZXJzdXBlcnNldD04ODM1O2UucHJvcG9ydGlvbj04NzU5O2UucHJvcG9ydGlvbmFsPTg3MzM7ZS5wc2k9OTY4O2UucHNpY3lyaWxsaWM9MTEzNztlLnBzaWxpcG5ldW1hdGFjeXJpbGxpY2NtYj0xMTU4O2UucHNzcXVhcmU9MTMyMzI7ZS5wdWhpcmFnYW5hPTEyNDA3O2UucHVrYXRha2FuYT0xMjUwMztlLnB2c3F1YXJlPTEzMjM2O2UucHdzcXVhcmU9MTMyNDI7ZS5xPTExMztlLnFhZGV2YT0yMzkyO2UucWFkbWFoZWJyZXc9MTQ0ODtlLnFhZmFyYWJpYz0xNjAyO2UucWFmZmluYWxhcmFiaWM9NjUyMzg7ZS5xYWZpbml0aWFsYXJhYmljPTY1MjM5O2UucWFmbWVkaWFsYXJhYmljPTY1MjQwO2UucWFtYXRzPTE0NjQ7ZS5xYW1hdHMxMD0xNDY0O2UucWFtYXRzMWE9MTQ2NDtlLnFhbWF0czFjPTE0NjQ7ZS5xYW1hdHMyNz0xNDY0O2UucWFtYXRzMjk9MTQ2NDtlLnFhbWF0czMzPTE0NjQ7ZS5xYW1hdHNkZT0xNDY0O2UucWFtYXRzaGVicmV3PTE0NjQ7ZS5xYW1hdHNuYXJyb3doZWJyZXc9MTQ2NDtlLnFhbWF0c3FhdGFuaGVicmV3PTE0NjQ7ZS5xYW1hdHNxYXRhbm5hcnJvd2hlYnJldz0xNDY0O2UucWFtYXRzcWF0YW5xdWFydGVyaGVicmV3PTE0NjQ7ZS5xYW1hdHNxYXRhbndpZGVoZWJyZXc9MTQ2NDtlLnFhbWF0c3F1YXJ0ZXJoZWJyZXc9MTQ2NDtlLnFhbWF0c3dpZGVoZWJyZXc9MTQ2NDtlLnFhcm5leXBhcmFoZWJyZXc9MTQzOTtlLnFib3BvbW9mbz0xMjU2MTtlLnFjaXJjbGU9OTQ0MDtlLnFob29rPTY3MjtlLnFtb25vc3BhY2U9NjUzNjE7ZS5xb2Y9MTUxMTtlLnFvZmRhZ2VzaD02NDMyNztlLnFvZmRhZ2VzaGhlYnJldz02NDMyNztlLnFvZmhlYnJldz0xNTExO2UucXBhcmVuPTkzODg7ZS5xdWFydGVybm90ZT05ODMzO2UucXVidXRzPTE0Njc7ZS5xdWJ1dHMxOD0xNDY3O2UucXVidXRzMjU9MTQ2NztlLnF1YnV0czMxPTE0Njc7ZS5xdWJ1dHNoZWJyZXc9MTQ2NztlLnF1YnV0c25hcnJvd2hlYnJldz0xNDY3O2UucXVidXRzcXVhcnRlcmhlYnJldz0xNDY3O2UucXVidXRzd2lkZWhlYnJldz0xNDY3O2UucXVlc3Rpb249NjM7ZS5xdWVzdGlvbmFyYWJpYz0xNTY3O2UucXVlc3Rpb25hcm1lbmlhbj0xMzc0O2UucXVlc3Rpb25kb3duPTE5MTtlLnF1ZXN0aW9uZG93bnNtYWxsPTYzNDIzO2UucXVlc3Rpb25ncmVlaz04OTQ7ZS5xdWVzdGlvbm1vbm9zcGFjZT02NTMxMTtlLnF1ZXN0aW9uc21hbGw9NjMyOTU7ZS5xdW90ZWRibD0zNDtlLnF1b3RlZGJsYmFzZT04MjIyO2UucXVvdGVkYmxsZWZ0PTgyMjA7ZS5xdW90ZWRibG1vbm9zcGFjZT02NTI4MjtlLnF1b3RlZGJscHJpbWU9MTIzMTg7ZS5xdW90ZWRibHByaW1lcmV2ZXJzZWQ9MTIzMTc7ZS5xdW90ZWRibHJpZ2h0PTgyMjE7ZS5xdW90ZWxlZnQ9ODIxNjtlLnF1b3RlbGVmdHJldmVyc2VkPTgyMTk7ZS5xdW90ZXJldmVyc2VkPTgyMTk7ZS5xdW90ZXJpZ2h0PTgyMTc7ZS5xdW90ZXJpZ2h0bj0zMjk7ZS5xdW90ZXNpbmdsYmFzZT04MjE4O2UucXVvdGVzaW5nbGU9Mzk7ZS5xdW90ZXNpbmdsZW1vbm9zcGFjZT02NTI4NztlLnI9MTE0O2UucmFhcm1lbmlhbj0xNDA0O2UucmFiZW5nYWxpPTI0ODA7ZS5yYWN1dGU9MzQxO2UucmFkZXZhPTIzNTI7ZS5yYWRpY2FsPTg3MzA7ZS5yYWRpY2FsZXg9NjM3MTc7ZS5yYWRvdmVyc3NxdWFyZT0xMzIzMDtlLnJhZG92ZXJzc3F1YXJlZHNxdWFyZT0xMzIzMTtlLnJhZHNxdWFyZT0xMzIyOTtlLnJhZmU9MTQ3MTtlLnJhZmVoZWJyZXc9MTQ3MTtlLnJhZ3VqYXJhdGk9MjczNjtlLnJhZ3VybXVraGk9MjYwODtlLnJhaGlyYWdhbmE9MTI0MjU7ZS5yYWthdGFrYW5hPTEyNTIxO2UucmFrYXRha2FuYWhhbGZ3aWR0aD02NTQzMTtlLnJhbG93ZXJkaWFnb25hbGJlbmdhbGk9MjU0NTtlLnJhbWlkZGxlZGlhZ29uYWxiZW5nYWxpPTI1NDQ7ZS5yYW1zaG9ybj02MTI7ZS5yYXRpbz04NzU4O2UucmJvcG9tb2ZvPTEyNTY2O2UucmNhcm9uPTM0NTtlLnJjZWRpbGxhPTM0MztlLnJjaXJjbGU9OTQ0MTtlLnJjb21tYWFjY2VudD0zNDM7ZS5yZGJsZ3JhdmU9NTI5O2UucmRvdGFjY2VudD03NzY5O2UucmRvdGJlbG93PTc3NzE7ZS5yZG90YmVsb3dtYWNyb249Nzc3MztlLnJlZmVyZW5jZW1hcms9ODI1MTtlLnJlZmxleHN1YnNldD04ODM4O2UucmVmbGV4c3VwZXJzZXQ9ODgzOTtlLnJlZ2lzdGVyZWQ9MTc0O2UucmVnaXN0ZXJzYW5zPTYzNzIwO2UucmVnaXN0ZXJzZXJpZj02MzE5NDtlLnJlaGFyYWJpYz0xNTg1O2UucmVoYXJtZW5pYW49MTQwODtlLnJlaGZpbmFsYXJhYmljPTY1MTk4O2UucmVoaXJhZ2FuYT0xMjQyODtlLnJla2F0YWthbmE9MTI1MjQ7ZS5yZWthdGFrYW5haGFsZndpZHRoPTY1NDM0O2UucmVzaD0xNTEyO2UucmVzaGRhZ2VzaGhlYnJldz02NDMyODtlLnJlc2hoZWJyZXc9MTUxMjtlLnJldmVyc2VkdGlsZGU9ODc2NTtlLnJldmlhaGVicmV3PTE0MzE7ZS5yZXZpYW11Z3Jhc2hoZWJyZXc9MTQzMTtlLnJldmxvZ2ljYWxub3Q9ODk3NjtlLnJmaXNoaG9vaz02Mzg7ZS5yZmlzaGhvb2tyZXZlcnNlZD02Mzk7ZS5yaGFiZW5nYWxpPTI1MjU7ZS5yaGFkZXZhPTIzOTc7ZS5yaG89OTYxO2Uucmhvb2s9NjM3O2Uucmhvb2t0dXJuZWQ9NjM1O2Uucmhvb2t0dXJuZWRzdXBlcmlvcj02OTM7ZS5yaG9zeW1ib2xncmVlaz0xMDA5O2UucmhvdGljaG9va21vZD03MzQ7ZS5yaWV1bGFjaXJjbGVrb3JlYW49MTI5MTM7ZS5yaWV1bGFwYXJlbmtvcmVhbj0xMjgxNztlLnJpZXVsY2lyY2xla29yZWFuPTEyODk5O2UucmlldWxoaWV1aGtvcmVhbj0xMjYwODtlLnJpZXVsa2l5ZW9ra29yZWFuPTEyNjAyO2UucmlldWxraXllb2tzaW9za29yZWFuPTEyNjQ5O2UucmlldWxrb3JlYW49MTI2MDE7ZS5yaWV1bG1pZXVta29yZWFuPTEyNjAzO2UucmlldWxwYW5zaW9za29yZWFuPTEyNjUyO2UucmlldWxwYXJlbmtvcmVhbj0xMjgwMztlLnJpZXVscGhpZXVwaGtvcmVhbj0xMjYwNztlLnJpZXVscGlldXBrb3JlYW49MTI2MDQ7ZS5yaWV1bHBpZXVwc2lvc2tvcmVhbj0xMjY1MTtlLnJpZXVsc2lvc2tvcmVhbj0xMjYwNTtlLnJpZXVsdGhpZXV0aGtvcmVhbj0xMjYwNjtlLnJpZXVsdGlrZXV0a29yZWFuPTEyNjUwO2UucmlldWx5ZW9yaW5oaWV1aGtvcmVhbj0xMjY1MztlLnJpZ2h0YW5nbGU9ODczNTtlLnJpZ2h0dGFja2JlbG93Y21iPTc5MztlLnJpZ2h0dHJpYW5nbGU9ODg5NTtlLnJpaGlyYWdhbmE9MTI0MjY7ZS5yaWthdGFrYW5hPTEyNTIyO2UucmlrYXRha2FuYWhhbGZ3aWR0aD02NTQzMjtlLnJpbmc9NzMwO2UucmluZ2JlbG93Y21iPTgwNTtlLnJpbmdjbWI9Nzc4O2UucmluZ2hhbGZsZWZ0PTcwMztlLnJpbmdoYWxmbGVmdGFybWVuaWFuPTEzNjk7ZS5yaW5naGFsZmxlZnRiZWxvd2NtYj03OTY7ZS5yaW5naGFsZmxlZnRjZW50ZXJlZD03MjM7ZS5yaW5naGFsZnJpZ2h0PTcwMjtlLnJpbmdoYWxmcmlnaHRiZWxvd2NtYj04MjU7ZS5yaW5naGFsZnJpZ2h0Y2VudGVyZWQ9NzIyO2UucmludmVydGVkYnJldmU9NTMxO2Uucml0dG9ydXNxdWFyZT0xMzEzNztlLnJsaW5lYmVsb3c9Nzc3NTtlLnJsb25nbGVnPTYzNjtlLnJsb25nbGVndHVybmVkPTYzNDtlLnJtb25vc3BhY2U9NjUzNjI7ZS5yb2hpcmFnYW5hPTEyNDI5O2Uucm9rYXRha2FuYT0xMjUyNTtlLnJva2F0YWthbmFoYWxmd2lkdGg9NjU0MzU7ZS5yb3J1YXRoYWk9MzYxOTtlLnJwYXJlbj05Mzg5O2UucnJhYmVuZ2FsaT0yNTI0O2UucnJhZGV2YT0yMzUzO2UucnJhZ3VybXVraGk9MjY1MjtlLnJyZWhhcmFiaWM9MTY4MTtlLnJyZWhmaW5hbGFyYWJpYz02NDM5NztlLnJydm9jYWxpY2JlbmdhbGk9MjUyODtlLnJydm9jYWxpY2RldmE9MjQwMDtlLnJydm9jYWxpY2d1amFyYXRpPTI3ODQ7ZS5ycnZvY2FsaWN2b3dlbHNpZ25iZW5nYWxpPTI1MDA7ZS5ycnZvY2FsaWN2b3dlbHNpZ25kZXZhPTIzNzI7ZS5ycnZvY2FsaWN2b3dlbHNpZ25ndWphcmF0aT0yNzU2O2UucnN1cGVyaW9yPTYzMjE3O2UucnRibG9jaz05NjE2O2UucnR1cm5lZD02MzM7ZS5ydHVybmVkc3VwZXJpb3I9NjkyO2UucnVoaXJhZ2FuYT0xMjQyNztlLnJ1a2F0YWthbmE9MTI1MjM7ZS5ydWthdGFrYW5haGFsZndpZHRoPTY1NDMzO2UucnVwZWVtYXJrYmVuZ2FsaT0yNTQ2O2UucnVwZWVzaWduYmVuZ2FsaT0yNTQ3O2UucnVwaWFoPTYzMTk3O2UucnV0aGFpPTM2MjA7ZS5ydm9jYWxpY2JlbmdhbGk9MjQ0MztlLnJ2b2NhbGljZGV2YT0yMzE1O2UucnZvY2FsaWNndWphcmF0aT0yNjk5O2UucnZvY2FsaWN2b3dlbHNpZ25iZW5nYWxpPTI0OTk7ZS5ydm9jYWxpY3Zvd2Vsc2lnbmRldmE9MjM3MTtlLnJ2b2NhbGljdm93ZWxzaWduZ3VqYXJhdGk9Mjc1NTtlLnM9MTE1O2Uuc2FiZW5nYWxpPTI0ODg7ZS5zYWN1dGU9MzQ3O2Uuc2FjdXRlZG90YWNjZW50PTc3ODE7ZS5zYWRhcmFiaWM9MTU4OTtlLnNhZGV2YT0yMzYwO2Uuc2FkZmluYWxhcmFiaWM9NjUyMTA7ZS5zYWRpbml0aWFsYXJhYmljPTY1MjExO2Uuc2FkbWVkaWFsYXJhYmljPTY1MjEyO2Uuc2FndWphcmF0aT0yNzQ0O2Uuc2FndXJtdWtoaT0yNjE2O2Uuc2FoaXJhZ2FuYT0xMjM3MztlLnNha2F0YWthbmE9MTI0Njk7ZS5zYWthdGFrYW5haGFsZndpZHRoPTY1NDAzO2Uuc2FsbGFsbGFob3VhbGF5aGV3YXNhbGxhbWFyYWJpYz02NTAxODtlLnNhbWVraD0xNTA1O2Uuc2FtZWtoZGFnZXNoPTY0MzIxO2Uuc2FtZWtoZGFnZXNoaGVicmV3PTY0MzIxO2Uuc2FtZWtoaGVicmV3PTE1MDU7ZS5zYXJhYWF0aGFpPTM2MzQ7ZS5zYXJhYWV0aGFpPTM2NDk7ZS5zYXJhYWltYWltYWxhaXRoYWk9MzY1MjtlLnNhcmFhaW1haW11YW50aGFpPTM2NTE7ZS5zYXJhYW10aGFpPTM2MzU7ZS5zYXJhYXRoYWk9MzYzMjtlLnNhcmFldGhhaT0zNjQ4O2Uuc2FyYWlpbGVmdHRoYWk9NjM2MjI7ZS5zYXJhaWl0aGFpPTM2Mzc7ZS5zYXJhaWxlZnR0aGFpPTYzNjIxO2Uuc2FyYWl0aGFpPTM2MzY7ZS5zYXJhb3RoYWk9MzY1MDtlLnNhcmF1ZWVsZWZ0dGhhaT02MzYyNDtlLnNhcmF1ZWV0aGFpPTM2Mzk7ZS5zYXJhdWVsZWZ0dGhhaT02MzYyMztlLnNhcmF1ZXRoYWk9MzYzODtlLnNhcmF1dGhhaT0zNjQwO2Uuc2FyYXV1dGhhaT0zNjQxO2Uuc2JvcG9tb2ZvPTEyNTY5O2Uuc2Nhcm9uPTM1MztlLnNjYXJvbmRvdGFjY2VudD03NzgzO2Uuc2NlZGlsbGE9MzUxO2Uuc2Nod2E9NjAxO2Uuc2Nod2FjeXJpbGxpYz0xMjQxO2Uuc2Nod2FkaWVyZXNpc2N5cmlsbGljPTEyNDM7ZS5zY2h3YWhvb2s9NjAyO2Uuc2NpcmNsZT05NDQyO2Uuc2NpcmN1bWZsZXg9MzQ5O2Uuc2NvbW1hYWNjZW50PTUzNztlLnNkb3RhY2NlbnQ9Nzc3NztlLnNkb3RiZWxvdz03Nzc5O2Uuc2RvdGJlbG93ZG90YWNjZW50PTc3ODU7ZS5zZWFndWxsYmVsb3djbWI9ODI4O2Uuc2Vjb25kPTgyNDM7ZS5zZWNvbmR0b25lY2hpbmVzZT03MTQ7ZS5zZWN0aW9uPTE2NztlLnNlZW5hcmFiaWM9MTU4NztlLnNlZW5maW5hbGFyYWJpYz02NTIwMjtlLnNlZW5pbml0aWFsYXJhYmljPTY1MjAzO2Uuc2Vlbm1lZGlhbGFyYWJpYz02NTIwNDtlLnNlZ29sPTE0NjI7ZS5zZWdvbDEzPTE0NjI7ZS5zZWdvbDFmPTE0NjI7ZS5zZWdvbDJjPTE0NjI7ZS5zZWdvbGhlYnJldz0xNDYyO2Uuc2Vnb2xuYXJyb3doZWJyZXc9MTQ2MjtlLnNlZ29scXVhcnRlcmhlYnJldz0xNDYyO2Uuc2Vnb2x0YWhlYnJldz0xNDI2O2Uuc2Vnb2x3aWRlaGVicmV3PTE0NjI7ZS5zZWhhcm1lbmlhbj0xNDA1O2Uuc2VoaXJhZ2FuYT0xMjM3OTtlLnNla2F0YWthbmE9MTI0NzU7ZS5zZWthdGFrYW5haGFsZndpZHRoPTY1NDA2O2Uuc2VtaWNvbG9uPTU5O2Uuc2VtaWNvbG9uYXJhYmljPTE1NjM7ZS5zZW1pY29sb25tb25vc3BhY2U9NjUzMDc7ZS5zZW1pY29sb25zbWFsbD02NTEwODtlLnNlbWl2b2ljZWRtYXJra2FuYT0xMjQ0NDtlLnNlbWl2b2ljZWRtYXJra2FuYWhhbGZ3aWR0aD02NTQzOTtlLnNlbnRpc3F1YXJlPTEzMDkwO2Uuc2VudG9zcXVhcmU9MTMwOTE7ZS5zZXZlbj01NTtlLnNldmVuYXJhYmljPTE2Mzk7ZS5zZXZlbmJlbmdhbGk9MjU0MTtlLnNldmVuY2lyY2xlPTkzMTg7ZS5zZXZlbmNpcmNsZWludmVyc2VzYW5zc2VyaWY9MTAxMjg7ZS5zZXZlbmRldmE9MjQxMztlLnNldmVuZWlnaHRocz04NTQyO2Uuc2V2ZW5ndWphcmF0aT0yNzk3O2Uuc2V2ZW5ndXJtdWtoaT0yNjY5O2Uuc2V2ZW5oYWNrYXJhYmljPTE2Mzk7ZS5zZXZlbmhhbmd6aG91PTEyMzI3O2Uuc2V2ZW5pZGVvZ3JhcGhpY3BhcmVuPTEyODM4O2Uuc2V2ZW5pbmZlcmlvcj04MzI3O2Uuc2V2ZW5tb25vc3BhY2U9NjUzMDM7ZS5zZXZlbm9sZHN0eWxlPTYzMjg3O2Uuc2V2ZW5wYXJlbj05MzM4O2Uuc2V2ZW5wZXJpb2Q9OTM1ODtlLnNldmVucGVyc2lhbj0xNzgzO2Uuc2V2ZW5yb21hbj04NTY2O2Uuc2V2ZW5zdXBlcmlvcj04MzExO2Uuc2V2ZW50ZWVuY2lyY2xlPTkzMjg7ZS5zZXZlbnRlZW5wYXJlbj05MzQ4O2Uuc2V2ZW50ZWVucGVyaW9kPTkzNjg7ZS5zZXZlbnRoYWk9MzY3MTtlLnNmdGh5cGhlbj0xNzM7ZS5zaGFhcm1lbmlhbj0xMzk5O2Uuc2hhYmVuZ2FsaT0yNDg2O2Uuc2hhY3lyaWxsaWM9MTA5NjtlLnNoYWRkYWFyYWJpYz0xNjE3O2Uuc2hhZGRhZGFtbWFhcmFiaWM9NjQ2MDk7ZS5zaGFkZGFkYW1tYXRhbmFyYWJpYz02NDYwNjtlLnNoYWRkYWZhdGhhYXJhYmljPTY0NjA4O2Uuc2hhZGRha2FzcmFhcmFiaWM9NjQ2MTA7ZS5zaGFkZGFrYXNyYXRhbmFyYWJpYz02NDYwNztlLnNoYWRlPTk2MTg7ZS5zaGFkZWRhcms9OTYxOTtlLnNoYWRlbGlnaHQ9OTYxNztlLnNoYWRlbWVkaXVtPTk2MTg7ZS5zaGFkZXZhPTIzNTg7ZS5zaGFndWphcmF0aT0yNzQyO2Uuc2hhZ3VybXVraGk9MjYxNDtlLnNoYWxzaGVsZXRoZWJyZXc9MTQyNztlLnNoYm9wb21vZm89MTI1NjU7ZS5zaGNoYWN5cmlsbGljPTEwOTc7ZS5zaGVlbmFyYWJpYz0xNTg4O2Uuc2hlZW5maW5hbGFyYWJpYz02NTIwNjtlLnNoZWVuaW5pdGlhbGFyYWJpYz02NTIwNztlLnNoZWVubWVkaWFsYXJhYmljPTY1MjA4O2Uuc2hlaWNvcHRpYz05OTU7ZS5zaGVxZWw9ODM2MjtlLnNoZXFlbGhlYnJldz04MzYyO2Uuc2hldmE9MTQ1NjtlLnNoZXZhMTE1PTE0NTY7ZS5zaGV2YTE1PTE0NTY7ZS5zaGV2YTIyPTE0NTY7ZS5zaGV2YTJlPTE0NTY7ZS5zaGV2YWhlYnJldz0xNDU2O2Uuc2hldmFuYXJyb3doZWJyZXc9MTQ1NjtlLnNoZXZhcXVhcnRlcmhlYnJldz0xNDU2O2Uuc2hldmF3aWRlaGVicmV3PTE0NTY7ZS5zaGhhY3lyaWxsaWM9MTIxMTtlLnNoaW1hY29wdGljPTEwMDU7ZS5zaGluPTE1MTM7ZS5zaGluZGFnZXNoPTY0MzI5O2Uuc2hpbmRhZ2VzaGhlYnJldz02NDMyOTtlLnNoaW5kYWdlc2hzaGluZG90PTY0MzAwO2Uuc2hpbmRhZ2VzaHNoaW5kb3RoZWJyZXc9NjQzMDA7ZS5zaGluZGFnZXNoc2luZG90PTY0MzAxO2Uuc2hpbmRhZ2VzaHNpbmRvdGhlYnJldz02NDMwMTtlLnNoaW5kb3RoZWJyZXc9MTQ3MztlLnNoaW5oZWJyZXc9MTUxMztlLnNoaW5zaGluZG90PTY0Mjk4O2Uuc2hpbnNoaW5kb3RoZWJyZXc9NjQyOTg7ZS5zaGluc2luZG90PTY0Mjk5O2Uuc2hpbnNpbmRvdGhlYnJldz02NDI5OTtlLnNob29rPTY0MjtlLnNpZ21hPTk2MztlLnNpZ21hMT05NjI7ZS5zaWdtYWZpbmFsPTk2MjtlLnNpZ21hbHVuYXRlc3ltYm9sZ3JlZWs9MTAxMDtlLnNpaGlyYWdhbmE9MTIzNzU7ZS5zaWthdGFrYW5hPTEyNDcxO2Uuc2lrYXRha2FuYWhhbGZ3aWR0aD02NTQwNDtlLnNpbHVxaGVicmV3PTE0Njk7ZS5zaWx1cWxlZnRoZWJyZXc9MTQ2OTtlLnNpbWlsYXI9ODc2NDtlLnNpbmRvdGhlYnJldz0xNDc0O2Uuc2lvc2FjaXJjbGVrb3JlYW49MTI5MTY7ZS5zaW9zYXBhcmVua29yZWFuPTEyODIwO2Uuc2lvc2NpZXVja29yZWFuPTEyNjcwO2Uuc2lvc2NpcmNsZWtvcmVhbj0xMjkwMjtlLnNpb3NraXllb2trb3JlYW49MTI2NjY7ZS5zaW9za29yZWFuPTEyNjEzO2Uuc2lvc25pZXVua29yZWFuPTEyNjY3O2Uuc2lvc3BhcmVua29yZWFuPTEyODA2O2Uuc2lvc3BpZXVwa29yZWFuPTEyNjY5O2Uuc2lvc3Rpa2V1dGtvcmVhbj0xMjY2ODtlLnNpeD01NDtlLnNpeGFyYWJpYz0xNjM4O2Uuc2l4YmVuZ2FsaT0yNTQwO2Uuc2l4Y2lyY2xlPTkzMTc7ZS5zaXhjaXJjbGVpbnZlcnNlc2Fuc3NlcmlmPTEwMTI3O2Uuc2l4ZGV2YT0yNDEyO2Uuc2l4Z3VqYXJhdGk9Mjc5NjtlLnNpeGd1cm11a2hpPTI2Njg7ZS5zaXhoYWNrYXJhYmljPTE2Mzg7ZS5zaXhoYW5nemhvdT0xMjMyNjtlLnNpeGlkZW9ncmFwaGljcGFyZW49MTI4Mzc7ZS5zaXhpbmZlcmlvcj04MzI2O2Uuc2l4bW9ub3NwYWNlPTY1MzAyO2Uuc2l4b2xkc3R5bGU9NjMyODY7ZS5zaXhwYXJlbj05MzM3O2Uuc2l4cGVyaW9kPTkzNTc7ZS5zaXhwZXJzaWFuPTE3ODI7ZS5zaXhyb21hbj04NTY1O2Uuc2l4c3VwZXJpb3I9ODMxMDtlLnNpeHRlZW5jaXJjbGU9OTMyNztlLnNpeHRlZW5jdXJyZW5jeWRlbm9taW5hdG9yYmVuZ2FsaT0yNTUzO2Uuc2l4dGVlbnBhcmVuPTkzNDc7ZS5zaXh0ZWVucGVyaW9kPTkzNjc7ZS5zaXh0aGFpPTM2NzA7ZS5zbGFzaD00NztlLnNsYXNobW9ub3NwYWNlPTY1Mjk1O2Uuc2xvbmc9MzgzO2Uuc2xvbmdkb3RhY2NlbnQ9NzgzNTtlLnNtaWxlZmFjZT05Nzg2O2Uuc21vbm9zcGFjZT02NTM2MztlLnNvZnBhc3VxaGVicmV3PTE0NzU7ZS5zb2Z0aHlwaGVuPTE3MztlLnNvZnRzaWduY3lyaWxsaWM9MTEwMDtlLnNvaGlyYWdhbmE9MTIzODE7ZS5zb2thdGFrYW5hPTEyNDc3O2Uuc29rYXRha2FuYWhhbGZ3aWR0aD02NTQwNztlLnNvbGlkdXNsb25nb3ZlcmxheWNtYj04MjQ7ZS5zb2xpZHVzc2hvcnRvdmVybGF5Y21iPTgyMztlLnNvcnVzaXRoYWk9MzYyNTtlLnNvc2FsYXRoYWk9MzYyNDtlLnNvc290aGFpPTM1OTU7ZS5zb3N1YXRoYWk9MzYyNjtlLnNwYWNlPTMyO2Uuc3BhY2VoYWNrYXJhYmljPTMyO2Uuc3BhZGU9OTgyNDtlLnNwYWRlc3VpdGJsYWNrPTk4MjQ7ZS5zcGFkZXN1aXR3aGl0ZT05ODI4O2Uuc3BhcmVuPTkzOTA7ZS5zcXVhcmViZWxvd2NtYj04Mjc7ZS5zcXVhcmVjYz0xMzI1MjtlLnNxdWFyZWNtPTEzMjEzO2Uuc3F1YXJlZGlhZ29uYWxjcm9zc2hhdGNoZmlsbD05NjQxO2Uuc3F1YXJlaG9yaXpvbnRhbGZpbGw9OTYzNjtlLnNxdWFyZWtnPTEzMTk5O2Uuc3F1YXJla209MTMyMTQ7ZS5zcXVhcmVrbWNhcGl0YWw9MTMyNjI7ZS5zcXVhcmVsbj0xMzI2NTtlLnNxdWFyZWxvZz0xMzI2NjtlLnNxdWFyZW1nPTEzMTk4O2Uuc3F1YXJlbWlsPTEzMjY5O2Uuc3F1YXJlbW09MTMyMTI7ZS5zcXVhcmVtc3F1YXJlZD0xMzIxNztlLnNxdWFyZW9ydGhvZ29uYWxjcm9zc2hhdGNoZmlsbD05NjM4O2Uuc3F1YXJldXBwZXJsZWZ0dG9sb3dlcnJpZ2h0ZmlsbD05NjM5O2Uuc3F1YXJldXBwZXJyaWdodHRvbG93ZXJsZWZ0ZmlsbD05NjQwO2Uuc3F1YXJldmVydGljYWxmaWxsPTk2Mzc7ZS5zcXVhcmV3aGl0ZXdpdGhzbWFsbGJsYWNrPTk2MzU7ZS5zcnNxdWFyZT0xMzI3NTtlLnNzYWJlbmdhbGk9MjQ4NztlLnNzYWRldmE9MjM1OTtlLnNzYWd1amFyYXRpPTI3NDM7ZS5zc2FuZ2NpZXVja29yZWFuPTEyNjE3O2Uuc3NhbmdoaWV1aGtvcmVhbj0xMjY3NztlLnNzYW5naWV1bmdrb3JlYW49MTI2NzI7ZS5zc2FuZ2tpeWVva2tvcmVhbj0xMjU5NDtlLnNzYW5nbmlldW5rb3JlYW49MTI2NDU7ZS5zc2FuZ3BpZXVwa29yZWFuPTEyNjExO2Uuc3NhbmdzaW9za29yZWFuPTEyNjE0O2Uuc3Nhbmd0aWtldXRrb3JlYW49MTI2MDA7ZS5zc3VwZXJpb3I9NjMyMTg7ZS5zdGVybGluZz0xNjM7ZS5zdGVybGluZ21vbm9zcGFjZT02NTUwNTtlLnN0cm9rZWxvbmdvdmVybGF5Y21iPTgyMjtlLnN0cm9rZXNob3J0b3ZlcmxheWNtYj04MjE7ZS5zdWJzZXQ9ODgzNDtlLnN1YnNldG5vdGVxdWFsPTg4NDI7ZS5zdWJzZXRvcmVxdWFsPTg4Mzg7ZS5zdWNjZWVkcz04ODI3O2Uuc3VjaHRoYXQ9ODcxNTtlLnN1aGlyYWdhbmE9MTIzNzc7ZS5zdWthdGFrYW5hPTEyNDczO2Uuc3VrYXRha2FuYWhhbGZ3aWR0aD02NTQwNTtlLnN1a3VuYXJhYmljPTE2MTg7ZS5zdW1tYXRpb249ODcyMTtlLnN1bj05Nzg4O2Uuc3VwZXJzZXQ9ODgzNTtlLnN1cGVyc2V0bm90ZXF1YWw9ODg0MztlLnN1cGVyc2V0b3JlcXVhbD04ODM5O2Uuc3ZzcXVhcmU9MTMyNzY7ZS5zeW91d2FlcmFzcXVhcmU9MTMxODA7ZS50PTExNjtlLnRhYmVuZ2FsaT0yNDY4O2UudGFja2Rvd249ODg2ODtlLnRhY2tsZWZ0PTg4Njc7ZS50YWRldmE9MjM0MDtlLnRhZ3VqYXJhdGk9MjcyNDtlLnRhZ3VybXVraGk9MjU5NjtlLnRhaGFyYWJpYz0xNTkxO2UudGFoZmluYWxhcmFiaWM9NjUyMTg7ZS50YWhpbml0aWFsYXJhYmljPTY1MjE5O2UudGFoaXJhZ2FuYT0xMjM4MztlLnRhaG1lZGlhbGFyYWJpYz02NTIyMDtlLnRhaXN5b3VlcmFzcXVhcmU9MTMxODE7ZS50YWthdGFrYW5hPTEyNDc5O2UudGFrYXRha2FuYWhhbGZ3aWR0aD02NTQwODtlLnRhdHdlZWxhcmFiaWM9MTYwMDtlLnRhdT05NjQ7ZS50YXY9MTUxNDtlLnRhdmRhZ2VzPTY0MzMwO2UudGF2ZGFnZXNoPTY0MzMwO2UudGF2ZGFnZXNoaGVicmV3PTY0MzMwO2UudGF2aGVicmV3PTE1MTQ7ZS50YmFyPTM1OTtlLnRib3BvbW9mbz0xMjU1NDtlLnRjYXJvbj0zNTc7ZS50Y2N1cmw9NjgwO2UudGNlZGlsbGE9MzU1O2UudGNoZWhhcmFiaWM9MTY3MDtlLnRjaGVoZmluYWxhcmFiaWM9NjQzNzk7ZS50Y2hlaGluaXRpYWxhcmFiaWM9NjQzODA7ZS50Y2hlaG1lZGlhbGFyYWJpYz02NDM4MTtlLnRjaXJjbGU9OTQ0MztlLnRjaXJjdW1mbGV4YmVsb3c9Nzc5MztlLnRjb21tYWFjY2VudD0zNTU7ZS50ZGllcmVzaXM9NzgzMTtlLnRkb3RhY2NlbnQ9Nzc4NztlLnRkb3RiZWxvdz03Nzg5O2UudGVjeXJpbGxpYz0xMDkwO2UudGVkZXNjZW5kZXJjeXJpbGxpYz0xMTk3O2UudGVoYXJhYmljPTE1Nzg7ZS50ZWhmaW5hbGFyYWJpYz02NTE3NDtlLnRlaGhhaGluaXRpYWxhcmFiaWM9NjQ2NzQ7ZS50ZWhoYWhpc29sYXRlZGFyYWJpYz02NDUyNDtlLnRlaGluaXRpYWxhcmFiaWM9NjUxNzU7ZS50ZWhpcmFnYW5hPTEyMzkwO2UudGVoamVlbWluaXRpYWxhcmFiaWM9NjQ2NzM7ZS50ZWhqZWVtaXNvbGF0ZWRhcmFiaWM9NjQ1MjM7ZS50ZWhtYXJidXRhYXJhYmljPTE1Nzc7ZS50ZWhtYXJidXRhZmluYWxhcmFiaWM9NjUxNzI7ZS50ZWhtZWRpYWxhcmFiaWM9NjUxNzY7ZS50ZWhtZWVtaW5pdGlhbGFyYWJpYz02NDY3NjtlLnRlaG1lZW1pc29sYXRlZGFyYWJpYz02NDUyNjtlLnRlaG5vb25maW5hbGFyYWJpYz02NDYyNztlLnRla2F0YWthbmE9MTI0ODY7ZS50ZWthdGFrYW5haGFsZndpZHRoPTY1NDExO2UudGVsZXBob25lPTg0ODE7ZS50ZWxlcGhvbmVibGFjaz05NzQyO2UudGVsaXNoYWdlZG9sYWhlYnJldz0xNDQwO2UudGVsaXNoYXFldGFuYWhlYnJldz0xNDQ5O2UudGVuY2lyY2xlPTkzMjE7ZS50ZW5pZGVvZ3JhcGhpY3BhcmVuPTEyODQxO2UudGVucGFyZW49OTM0MTtlLnRlbnBlcmlvZD05MzYxO2UudGVucm9tYW49ODU2OTtlLnRlc2g9Njc5O2UudGV0PTE0OTY7ZS50ZXRkYWdlc2g9NjQzMTI7ZS50ZXRkYWdlc2hoZWJyZXc9NjQzMTI7ZS50ZXRoZWJyZXc9MTQ5NjtlLnRldHNlY3lyaWxsaWM9MTIwNTtlLnRldmlyaGVicmV3PTE0MzU7ZS50ZXZpcmxlZnRoZWJyZXc9MTQzNTtlLnRoYWJlbmdhbGk9MjQ2OTtlLnRoYWRldmE9MjM0MTtlLnRoYWd1amFyYXRpPTI3MjU7ZS50aGFndXJtdWtoaT0yNTk3O2UudGhhbGFyYWJpYz0xNTg0O2UudGhhbGZpbmFsYXJhYmljPTY1MTk2O2UudGhhbnRoYWtoYXRsb3dsZWZ0dGhhaT02MzY0MDtlLnRoYW50aGFraGF0bG93cmlnaHR0aGFpPTYzNjM5O2UudGhhbnRoYWtoYXR0aGFpPTM2NjA7ZS50aGFudGhha2hhdHVwcGVybGVmdHRoYWk9NjM2Mzg7ZS50aGVoYXJhYmljPTE1Nzk7ZS50aGVoZmluYWxhcmFiaWM9NjUxNzg7ZS50aGVoaW5pdGlhbGFyYWJpYz02NTE3OTtlLnRoZWhtZWRpYWxhcmFiaWM9NjUxODA7ZS50aGVyZWV4aXN0cz04NzA3O2UudGhlcmVmb3JlPTg3NTY7ZS50aGV0YT05NTI7ZS50aGV0YTE9OTc3O2UudGhldGFzeW1ib2xncmVlaz05Nzc7ZS50aGlldXRoYWNpcmNsZWtvcmVhbj0xMjkyMTtlLnRoaWV1dGhhcGFyZW5rb3JlYW49MTI4MjU7ZS50aGlldXRoY2lyY2xla29yZWFuPTEyOTA3O2UudGhpZXV0aGtvcmVhbj0xMjYyMDtlLnRoaWV1dGhwYXJlbmtvcmVhbj0xMjgxMTtlLnRoaXJ0ZWVuY2lyY2xlPTkzMjQ7ZS50aGlydGVlbnBhcmVuPTkzNDQ7ZS50aGlydGVlbnBlcmlvZD05MzY0O2UudGhvbmFuZ21vbnRob3RoYWk9MzYwMTtlLnRob29rPTQyOTtlLnRob3BodXRoYW90aGFpPTM2MDI7ZS50aG9ybj0yNTQ7ZS50aG90aGFoYW50aGFpPTM2MDc7ZS50aG90aGFudGhhaT0zNjAwO2UudGhvdGhvbmd0aGFpPTM2MDg7ZS50aG90aHVuZ3RoYWk9MzYwNjtlLnRob3VzYW5kY3lyaWxsaWM9MTE1NDtlLnRob3VzYW5kc3NlcGFyYXRvcmFyYWJpYz0xNjQ0O2UudGhvdXNhbmRzc2VwYXJhdG9ycGVyc2lhbj0xNjQ0O2UudGhyZWU9NTE7ZS50aHJlZWFyYWJpYz0xNjM1O2UudGhyZWViZW5nYWxpPTI1Mzc7ZS50aHJlZWNpcmNsZT05MzE0O2UudGhyZWVjaXJjbGVpbnZlcnNlc2Fuc3NlcmlmPTEwMTI0O2UudGhyZWVkZXZhPTI0MDk7ZS50aHJlZWVpZ2h0aHM9ODU0MDtlLnRocmVlZ3VqYXJhdGk9Mjc5MztlLnRocmVlZ3VybXVraGk9MjY2NTtlLnRocmVlaGFja2FyYWJpYz0xNjM1O2UudGhyZWVoYW5nemhvdT0xMjMyMztlLnRocmVlaWRlb2dyYXBoaWNwYXJlbj0xMjgzNDtlLnRocmVlaW5mZXJpb3I9ODMyMztlLnRocmVlbW9ub3NwYWNlPTY1Mjk5O2UudGhyZWVudW1lcmF0b3JiZW5nYWxpPTI1NTA7ZS50aHJlZW9sZHN0eWxlPTYzMjgzO2UudGhyZWVwYXJlbj05MzM0O2UudGhyZWVwZXJpb2Q9OTM1NDtlLnRocmVlcGVyc2lhbj0xNzc5O2UudGhyZWVxdWFydGVycz0xOTA7ZS50aHJlZXF1YXJ0ZXJzZW1kYXNoPTYzMTk4O2UudGhyZWVyb21hbj04NTYyO2UudGhyZWVzdXBlcmlvcj0xNzk7ZS50aHJlZXRoYWk9MzY2NztlLnRoenNxdWFyZT0xMzIwNDtlLnRpaGlyYWdhbmE9MTIzODU7ZS50aWthdGFrYW5hPTEyNDgxO2UudGlrYXRha2FuYWhhbGZ3aWR0aD02NTQwOTtlLnRpa2V1dGFjaXJjbGVrb3JlYW49MTI5MTI7ZS50aWtldXRhcGFyZW5rb3JlYW49MTI4MTY7ZS50aWtldXRjaXJjbGVrb3JlYW49MTI4OTg7ZS50aWtldXRrb3JlYW49MTI1OTk7ZS50aWtldXRwYXJlbmtvcmVhbj0xMjgwMjtlLnRpbGRlPTczMjtlLnRpbGRlYmVsb3djbWI9ODE2O2UudGlsZGVjbWI9NzcxO2UudGlsZGVjb21iPTc3MTtlLnRpbGRlZG91YmxlY21iPTg2NDtlLnRpbGRlb3BlcmF0b3I9ODc2NDtlLnRpbGRlb3ZlcmxheWNtYj04MjA7ZS50aWxkZXZlcnRpY2FsY21iPTgzMDtlLnRpbWVzY2lyY2xlPTg4NTU7ZS50aXBlaGFoZWJyZXc9MTQzMDtlLnRpcGVoYWxlZnRoZWJyZXc9MTQzMDtlLnRpcHBpZ3VybXVraGk9MjY3MjtlLnRpdGxvY3lyaWxsaWNjbWI9MTE1NTtlLnRpd25hcm1lbmlhbj0xNDA3O2UudGxpbmViZWxvdz03NzkxO2UudG1vbm9zcGFjZT02NTM2NDtlLnRvYXJtZW5pYW49MTM4NTtlLnRvaGlyYWdhbmE9MTIzOTI7ZS50b2thdGFrYW5hPTEyNDg4O2UudG9rYXRha2FuYWhhbGZ3aWR0aD02NTQxMjtlLnRvbmViYXJleHRyYWhpZ2htb2Q9NzQxO2UudG9uZWJhcmV4dHJhbG93bW9kPTc0NTtlLnRvbmViYXJoaWdobW9kPTc0MjtlLnRvbmViYXJsb3dtb2Q9NzQ0O2UudG9uZWJhcm1pZG1vZD03NDM7ZS50b25lZml2ZT00NDU7ZS50b25lc2l4PTM4OTtlLnRvbmV0d289NDI0O2UudG9ub3M9OTAwO2UudG9uc3F1YXJlPTEzMDk1O2UudG9wYXRha3RoYWk9MzU5OTtlLnRvcnRvaXNlc2hlbGxicmFja2V0bGVmdD0xMjMwODtlLnRvcnRvaXNlc2hlbGxicmFja2V0bGVmdHNtYWxsPTY1MTE3O2UudG9ydG9pc2VzaGVsbGJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODE7ZS50b3J0b2lzZXNoZWxsYnJhY2tldHJpZ2h0PTEyMzA5O2UudG9ydG9pc2VzaGVsbGJyYWNrZXRyaWdodHNtYWxsPTY1MTE4O2UudG9ydG9pc2VzaGVsbGJyYWNrZXRyaWdodHZlcnRpY2FsPTY1MDgyO2UudG90YW90aGFpPTM2MDU7ZS50cGFsYXRhbGhvb2s9NDI3O2UudHBhcmVuPTkzOTE7ZS50cmFkZW1hcms9ODQ4MjtlLnRyYWRlbWFya3NhbnM9NjM3MjI7ZS50cmFkZW1hcmtzZXJpZj02MzE5NTtlLnRyZXRyb2ZsZXhob29rPTY0ODtlLnRyaWFnZG49OTY2MDtlLnRyaWFnbGY9OTY2ODtlLnRyaWFncnQ9OTY1ODtlLnRyaWFndXA9OTY1MDtlLnRzPTY3ODtlLnRzYWRpPTE1MTA7ZS50c2FkaWRhZ2VzaD02NDMyNjtlLnRzYWRpZGFnZXNoaGVicmV3PTY0MzI2O2UudHNhZGloZWJyZXc9MTUxMDtlLnRzZWN5cmlsbGljPTEwOTQ7ZS50c2VyZT0xNDYxO2UudHNlcmUxMj0xNDYxO2UudHNlcmUxZT0xNDYxO2UudHNlcmUyYj0xNDYxO2UudHNlcmVoZWJyZXc9MTQ2MTtlLnRzZXJlbmFycm93aGVicmV3PTE0NjE7ZS50c2VyZXF1YXJ0ZXJoZWJyZXc9MTQ2MTtlLnRzZXJld2lkZWhlYnJldz0xNDYxO2UudHNoZWN5cmlsbGljPTExMTU7ZS50c3VwZXJpb3I9NjMyMTk7ZS50dGFiZW5nYWxpPTI0NjM7ZS50dGFkZXZhPTIzMzU7ZS50dGFndWphcmF0aT0yNzE5O2UudHRhZ3VybXVraGk9MjU5MTtlLnR0ZWhhcmFiaWM9MTY1NztlLnR0ZWhmaW5hbGFyYWJpYz02NDM1OTtlLnR0ZWhpbml0aWFsYXJhYmljPTY0MzYwO2UudHRlaG1lZGlhbGFyYWJpYz02NDM2MTtlLnR0aGFiZW5nYWxpPTI0NjQ7ZS50dGhhZGV2YT0yMzM2O2UudHRoYWd1amFyYXRpPTI3MjA7ZS50dGhhZ3VybXVraGk9MjU5MjtlLnR0dXJuZWQ9NjQ3O2UudHVoaXJhZ2FuYT0xMjM4ODtlLnR1a2F0YWthbmE9MTI0ODQ7ZS50dWthdGFrYW5haGFsZndpZHRoPTY1NDEwO2UudHVzbWFsbGhpcmFnYW5hPTEyMzg3O2UudHVzbWFsbGthdGFrYW5hPTEyNDgzO2UudHVzbWFsbGthdGFrYW5haGFsZndpZHRoPTY1MzkxO2UudHdlbHZlY2lyY2xlPTkzMjM7ZS50d2VsdmVwYXJlbj05MzQzO2UudHdlbHZlcGVyaW9kPTkzNjM7ZS50d2VsdmVyb21hbj04NTcxO2UudHdlbnR5Y2lyY2xlPTkzMzE7ZS50d2VudHloYW5nemhvdT0yMTMxNjtlLnR3ZW50eXBhcmVuPTkzNTE7ZS50d2VudHlwZXJpb2Q9OTM3MTtlLnR3bz01MDtlLnR3b2FyYWJpYz0xNjM0O2UudHdvYmVuZ2FsaT0yNTM2O2UudHdvY2lyY2xlPTkzMTM7ZS50d29jaXJjbGVpbnZlcnNlc2Fuc3NlcmlmPTEwMTIzO2UudHdvZGV2YT0yNDA4O2UudHdvZG90ZW5sZWFkZXI9ODIyOTtlLnR3b2RvdGxlYWRlcj04MjI5O2UudHdvZG90bGVhZGVydmVydGljYWw9NjUwNzI7ZS50d29ndWphcmF0aT0yNzkyO2UudHdvZ3VybXVraGk9MjY2NDtlLnR3b2hhY2thcmFiaWM9MTYzNDtlLnR3b2hhbmd6aG91PTEyMzIyO2UudHdvaWRlb2dyYXBoaWNwYXJlbj0xMjgzMztlLnR3b2luZmVyaW9yPTgzMjI7ZS50d29tb25vc3BhY2U9NjUyOTg7ZS50d29udW1lcmF0b3JiZW5nYWxpPTI1NDk7ZS50d29vbGRzdHlsZT02MzI4MjtlLnR3b3BhcmVuPTkzMzM7ZS50d29wZXJpb2Q9OTM1MztlLnR3b3BlcnNpYW49MTc3ODtlLnR3b3JvbWFuPTg1NjE7ZS50d29zdHJva2U9NDQzO2UudHdvc3VwZXJpb3I9MTc4O2UudHdvdGhhaT0zNjY2O2UudHdvdGhpcmRzPTg1MzI7ZS51PTExNztlLnVhY3V0ZT0yNTA7ZS51YmFyPTY0OTtlLnViZW5nYWxpPTI0NDE7ZS51Ym9wb21vZm89MTI1ODQ7ZS51YnJldmU9MzY1O2UudWNhcm9uPTQ2ODtlLnVjaXJjbGU9OTQ0NDtlLnVjaXJjdW1mbGV4PTI1MTtlLnVjaXJjdW1mbGV4YmVsb3c9Nzc5OTtlLnVjeXJpbGxpYz0xMDkxO2UudWRhdHRhZGV2YT0yMzg1O2UudWRibGFjdXRlPTM2OTtlLnVkYmxncmF2ZT01MzM7ZS51ZGV2YT0yMzEzO2UudWRpZXJlc2lzPTI1MjtlLnVkaWVyZXNpc2FjdXRlPTQ3MjtlLnVkaWVyZXNpc2JlbG93PTc3OTU7ZS51ZGllcmVzaXNjYXJvbj00NzQ7ZS51ZGllcmVzaXNjeXJpbGxpYz0xMjY1O2UudWRpZXJlc2lzZ3JhdmU9NDc2O2UudWRpZXJlc2lzbWFjcm9uPTQ3MDtlLnVkb3RiZWxvdz03OTA5O2UudWdyYXZlPTI0OTtlLnVndWphcmF0aT0yNjk3O2UudWd1cm11a2hpPTI1Njk7ZS51aGlyYWdhbmE9MTIzNTg7ZS51aG9va2Fib3ZlPTc5MTE7ZS51aG9ybj00MzI7ZS51aG9ybmFjdXRlPTc5MTM7ZS51aG9ybmRvdGJlbG93PTc5MjE7ZS51aG9ybmdyYXZlPTc5MTU7ZS51aG9ybmhvb2thYm92ZT03OTE3O2UudWhvcm50aWxkZT03OTE5O2UudWh1bmdhcnVtbGF1dD0zNjk7ZS51aHVuZ2FydW1sYXV0Y3lyaWxsaWM9MTI2NztlLnVpbnZlcnRlZGJyZXZlPTUzNTtlLnVrYXRha2FuYT0xMjQ1NDtlLnVrYXRha2FuYWhhbGZ3aWR0aD02NTM5NTtlLnVrY3lyaWxsaWM9MTE0NTtlLnVrb3JlYW49MTI2MzY7ZS51bWFjcm9uPTM2MztlLnVtYWNyb25jeXJpbGxpYz0xMjYzO2UudW1hY3JvbmRpZXJlc2lzPTc4MDM7ZS51bWF0cmFndXJtdWtoaT0yNjI1O2UudW1vbm9zcGFjZT02NTM2NTtlLnVuZGVyc2NvcmU9OTU7ZS51bmRlcnNjb3JlZGJsPTgyMTU7ZS51bmRlcnNjb3JlbW9ub3NwYWNlPTY1MzQzO2UudW5kZXJzY29yZXZlcnRpY2FsPTY1MDc1O2UudW5kZXJzY29yZXdhdnk9NjUxMDM7ZS51bmlvbj04NzQ2O2UudW5pdmVyc2FsPTg3MDQ7ZS51b2dvbmVrPTM3MTtlLnVwYXJlbj05MzkyO2UudXBibG9jaz05NjAwO2UudXBwZXJkb3RoZWJyZXc9MTQ3NjtlLnVwc2lsb249OTY1O2UudXBzaWxvbmRpZXJlc2lzPTk3MTtlLnVwc2lsb25kaWVyZXNpc3Rvbm9zPTk0NDtlLnVwc2lsb25sYXRpbj02NTA7ZS51cHNpbG9udG9ub3M9OTczO2UudXB0YWNrYmVsb3djbWI9Nzk3O2UudXB0YWNrbW9kPTcyNDtlLnVyYWd1cm11a2hpPTI2NzU7ZS51cmluZz0zNjc7ZS51c2hvcnRjeXJpbGxpYz0xMTE4O2UudXNtYWxsaGlyYWdhbmE9MTIzNTc7ZS51c21hbGxrYXRha2FuYT0xMjQ1MztlLnVzbWFsbGthdGFrYW5haGFsZndpZHRoPTY1Mzg1O2UudXN0cmFpZ2h0Y3lyaWxsaWM9MTE5OTtlLnVzdHJhaWdodHN0cm9rZWN5cmlsbGljPTEyMDE7ZS51dGlsZGU9MzYxO2UudXRpbGRlYWN1dGU9NzgwMTtlLnV0aWxkZWJlbG93PTc3OTc7ZS51dWJlbmdhbGk9MjQ0MjtlLnV1ZGV2YT0yMzE0O2UudXVndWphcmF0aT0yNjk4O2UudXVndXJtdWtoaT0yNTcwO2UudXVtYXRyYWd1cm11a2hpPTI2MjY7ZS51dXZvd2Vsc2lnbmJlbmdhbGk9MjQ5ODtlLnV1dm93ZWxzaWduZGV2YT0yMzcwO2UudXV2b3dlbHNpZ25ndWphcmF0aT0yNzU0O2UudXZvd2Vsc2lnbmJlbmdhbGk9MjQ5NztlLnV2b3dlbHNpZ25kZXZhPTIzNjk7ZS51dm93ZWxzaWduZ3VqYXJhdGk9Mjc1MztlLnY9MTE4O2UudmFkZXZhPTIzNTc7ZS52YWd1amFyYXRpPTI3NDE7ZS52YWd1cm11a2hpPTI2MTM7ZS52YWthdGFrYW5hPTEyNTM1O2UudmF2PTE0OTM7ZS52YXZkYWdlc2g9NjQzMDk7ZS52YXZkYWdlc2g2NT02NDMwOTtlLnZhdmRhZ2VzaGhlYnJldz02NDMwOTtlLnZhdmhlYnJldz0xNDkzO2UudmF2aG9sYW09NjQzMzE7ZS52YXZob2xhbWhlYnJldz02NDMzMTtlLnZhdnZhdmhlYnJldz0xNTIwO2UudmF2eW9kaGVicmV3PTE1MjE7ZS52Y2lyY2xlPTk0NDU7ZS52ZG90YmVsb3c9NzgwNztlLnZlY3lyaWxsaWM9MTA3NDtlLnZlaGFyYWJpYz0xNzAwO2UudmVoZmluYWxhcmFiaWM9NjQzNjM7ZS52ZWhpbml0aWFsYXJhYmljPTY0MzY0O2UudmVobWVkaWFsYXJhYmljPTY0MzY1O2UudmVrYXRha2FuYT0xMjUzNztlLnZlbnVzPTk3OTI7ZS52ZXJ0aWNhbGJhcj0xMjQ7ZS52ZXJ0aWNhbGxpbmVhYm92ZWNtYj03ODE7ZS52ZXJ0aWNhbGxpbmViZWxvd2NtYj04MDk7ZS52ZXJ0aWNhbGxpbmVsb3dtb2Q9NzE2O2UudmVydGljYWxsaW5lbW9kPTcxMjtlLnZld2FybWVuaWFuPTE0MDY7ZS52aG9vaz02NTE7ZS52aWthdGFrYW5hPTEyNTM2O2UudmlyYW1hYmVuZ2FsaT0yNTA5O2UudmlyYW1hZGV2YT0yMzgxO2UudmlyYW1hZ3VqYXJhdGk9Mjc2NTtlLnZpc2FyZ2FiZW5nYWxpPTI0MzU7ZS52aXNhcmdhZGV2YT0yMzA3O2UudmlzYXJnYWd1amFyYXRpPTI2OTE7ZS52bW9ub3NwYWNlPTY1MzY2O2Uudm9hcm1lbmlhbj0xNDAwO2Uudm9pY2VkaXRlcmF0aW9uaGlyYWdhbmE9MTI0NDY7ZS52b2ljZWRpdGVyYXRpb25rYXRha2FuYT0xMjU0MjtlLnZvaWNlZG1hcmtrYW5hPTEyNDQzO2Uudm9pY2VkbWFya2thbmFoYWxmd2lkdGg9NjU0Mzg7ZS52b2thdGFrYW5hPTEyNTM4O2UudnBhcmVuPTkzOTM7ZS52dGlsZGU9NzgwNTtlLnZ0dXJuZWQ9NjUyO2UudnVoaXJhZ2FuYT0xMjQzNjtlLnZ1a2F0YWthbmE9MTI1MzI7ZS53PTExOTtlLndhY3V0ZT03ODExO2Uud2Fla29yZWFuPTEyNjMzO2Uud2FoaXJhZ2FuYT0xMjQzMTtlLndha2F0YWthbmE9MTI1Mjc7ZS53YWthdGFrYW5haGFsZndpZHRoPTY1NDM2O2Uud2Frb3JlYW49MTI2MzI7ZS53YXNtYWxsaGlyYWdhbmE9MTI0MzA7ZS53YXNtYWxsa2F0YWthbmE9MTI1MjY7ZS53YXR0b3NxdWFyZT0xMzE0MztlLndhdmVkYXNoPTEyMzE2O2Uud2F2eXVuZGVyc2NvcmV2ZXJ0aWNhbD02NTA3NjtlLndhd2FyYWJpYz0xNjA4O2Uud2F3ZmluYWxhcmFiaWM9NjUyNjI7ZS53YXdoYW16YWFib3ZlYXJhYmljPTE1NzI7ZS53YXdoYW16YWFib3ZlZmluYWxhcmFiaWM9NjUxNTg7ZS53YnNxdWFyZT0xMzI3NztlLndjaXJjbGU9OTQ0NjtlLndjaXJjdW1mbGV4PTM3MztlLndkaWVyZXNpcz03ODEzO2Uud2RvdGFjY2VudD03ODE1O2Uud2RvdGJlbG93PTc4MTc7ZS53ZWhpcmFnYW5hPTEyNDMzO2Uud2VpZXJzdHJhc3M9ODQ3MjtlLndla2F0YWthbmE9MTI1Mjk7ZS53ZWtvcmVhbj0xMjYzODtlLndlb2tvcmVhbj0xMjYzNztlLndncmF2ZT03ODA5O2Uud2hpdGVidWxsZXQ9OTcwMjtlLndoaXRlY2lyY2xlPTk2NzU7ZS53aGl0ZWNpcmNsZWludmVyc2U9OTY4OTtlLndoaXRlY29ybmVyYnJhY2tldGxlZnQ9MTIzMDI7ZS53aGl0ZWNvcm5lcmJyYWNrZXRsZWZ0dmVydGljYWw9NjUwOTE7ZS53aGl0ZWNvcm5lcmJyYWNrZXRyaWdodD0xMjMwMztlLndoaXRlY29ybmVyYnJhY2tldHJpZ2h0dmVydGljYWw9NjUwOTI7ZS53aGl0ZWRpYW1vbmQ9OTY3MTtlLndoaXRlZGlhbW9uZGNvbnRhaW5pbmdibGFja3NtYWxsZGlhbW9uZD05NjcyO2Uud2hpdGVkb3ducG9pbnRpbmdzbWFsbHRyaWFuZ2xlPTk2NjM7ZS53aGl0ZWRvd25wb2ludGluZ3RyaWFuZ2xlPTk2NjE7ZS53aGl0ZWxlZnRwb2ludGluZ3NtYWxsdHJpYW5nbGU9OTY2NztlLndoaXRlbGVmdHBvaW50aW5ndHJpYW5nbGU9OTY2NTtlLndoaXRlbGVudGljdWxhcmJyYWNrZXRsZWZ0PTEyMzEwO2Uud2hpdGVsZW50aWN1bGFyYnJhY2tldHJpZ2h0PTEyMzExO2Uud2hpdGVyaWdodHBvaW50aW5nc21hbGx0cmlhbmdsZT05NjU3O2Uud2hpdGVyaWdodHBvaW50aW5ndHJpYW5nbGU9OTY1NTtlLndoaXRlc21hbGxzcXVhcmU9OTY0MztlLndoaXRlc21pbGluZ2ZhY2U9OTc4NjtlLndoaXRlc3F1YXJlPTk2MzM7ZS53aGl0ZXN0YXI9OTczNDtlLndoaXRldGVsZXBob25lPTk3NDM7ZS53aGl0ZXRvcnRvaXNlc2hlbGxicmFja2V0bGVmdD0xMjMxMjtlLndoaXRldG9ydG9pc2VzaGVsbGJyYWNrZXRyaWdodD0xMjMxMztlLndoaXRldXBwb2ludGluZ3NtYWxsdHJpYW5nbGU9OTY1MztlLndoaXRldXBwb2ludGluZ3RyaWFuZ2xlPTk2NTE7ZS53aWhpcmFnYW5hPTEyNDMyO2Uud2lrYXRha2FuYT0xMjUyODtlLndpa29yZWFuPTEyNjM5O2Uud21vbm9zcGFjZT02NTM2NztlLndvaGlyYWdhbmE9MTI0MzQ7ZS53b2thdGFrYW5hPTEyNTMwO2Uud29rYXRha2FuYWhhbGZ3aWR0aD02NTM4MjtlLndvbj04MzYxO2Uud29ubW9ub3NwYWNlPTY1NTEwO2Uud293YWVudGhhaT0zNjIzO2Uud3BhcmVuPTkzOTQ7ZS53cmluZz03ODMyO2Uud3N1cGVyaW9yPTY5NTtlLnd0dXJuZWQ9NjUzO2Uud3lubj00NDc7ZS54PTEyMDtlLnhhYm92ZWNtYj04Mjk7ZS54Ym9wb21vZm89MTI1NjI7ZS54Y2lyY2xlPTk0NDc7ZS54ZGllcmVzaXM9NzgyMTtlLnhkb3RhY2NlbnQ9NzgxOTtlLnhlaGFybWVuaWFuPTEzODk7ZS54aT05NTg7ZS54bW9ub3NwYWNlPTY1MzY4O2UueHBhcmVuPTkzOTU7ZS54c3VwZXJpb3I9NzM5O2UueT0xMjE7ZS55YWFkb3NxdWFyZT0xMzEzNDtlLnlhYmVuZ2FsaT0yNDc5O2UueWFjdXRlPTI1MztlLnlhZGV2YT0yMzUxO2UueWFla29yZWFuPTEyNjI2O2UueWFndWphcmF0aT0yNzM1O2UueWFndXJtdWtoaT0yNjA3O2UueWFoaXJhZ2FuYT0xMjQyMDtlLnlha2F0YWthbmE9MTI1MTY7ZS55YWthdGFrYW5haGFsZndpZHRoPTY1NDI4O2UueWFrb3JlYW49MTI2MjU7ZS55YW1ha2thbnRoYWk9MzY2MjtlLnlhc21hbGxoaXJhZ2FuYT0xMjQxOTtlLnlhc21hbGxrYXRha2FuYT0xMjUxNTtlLnlhc21hbGxrYXRha2FuYWhhbGZ3aWR0aD02NTM4ODtlLnlhdGN5cmlsbGljPTExMjM7ZS55Y2lyY2xlPTk0NDg7ZS55Y2lyY3VtZmxleD0zNzU7ZS55ZGllcmVzaXM9MjU1O2UueWRvdGFjY2VudD03ODIzO2UueWRvdGJlbG93PTc5MjU7ZS55ZWhhcmFiaWM9MTYxMDtlLnllaGJhcnJlZWFyYWJpYz0xNzQ2O2UueWVoYmFycmVlZmluYWxhcmFiaWM9NjQ0MzE7ZS55ZWhmaW5hbGFyYWJpYz02NTI2NjtlLnllaGhhbXphYWJvdmVhcmFiaWM9MTU3NDtlLnllaGhhbXphYWJvdmVmaW5hbGFyYWJpYz02NTE2MjtlLnllaGhhbXphYWJvdmVpbml0aWFsYXJhYmljPTY1MTYzO2UueWVoaGFtemFhYm92ZW1lZGlhbGFyYWJpYz02NTE2NDtlLnllaGluaXRpYWxhcmFiaWM9NjUyNjc7ZS55ZWhtZWRpYWxhcmFiaWM9NjUyNjg7ZS55ZWhtZWVtaW5pdGlhbGFyYWJpYz02NDczMztlLnllaG1lZW1pc29sYXRlZGFyYWJpYz02NDYwMDtlLnllaG5vb25maW5hbGFyYWJpYz02NDY2MDtlLnllaHRocmVlZG90c2JlbG93YXJhYmljPTE3NDU7ZS55ZWtvcmVhbj0xMjYzMDtlLnllbj0xNjU7ZS55ZW5tb25vc3BhY2U9NjU1MDk7ZS55ZW9rb3JlYW49MTI2Mjk7ZS55ZW9yaW5oaWV1aGtvcmVhbj0xMjY3ODtlLnllcmFoYmVueW9tb2hlYnJldz0xNDUwO2UueWVyYWhiZW55b21vbGVmdGhlYnJldz0xNDUwO2UueWVyaWN5cmlsbGljPTEwOTk7ZS55ZXJ1ZGllcmVzaXNjeXJpbGxpYz0xMjczO2UueWVzaWV1bmdrb3JlYW49MTI2NzM7ZS55ZXNpZXVuZ3BhbnNpb3Nrb3JlYW49MTI2NzU7ZS55ZXNpZXVuZ3Npb3Nrb3JlYW49MTI2NzQ7ZS55ZXRpdmhlYnJldz0xNDM0O2UueWdyYXZlPTc5MjM7ZS55aG9vaz00MzY7ZS55aG9va2Fib3ZlPTc5Mjc7ZS55aWFybWVuaWFuPTEzOTc7ZS55aWN5cmlsbGljPTExMTE7ZS55aWtvcmVhbj0xMjY0MjtlLnlpbnlhbmc9OTc3NTtlLnlpd25hcm1lbmlhbj0xNDEwO2UueW1vbm9zcGFjZT02NTM2OTtlLnlvZD0xNDk3O2UueW9kZGFnZXNoPTY0MzEzO2UueW9kZGFnZXNoaGVicmV3PTY0MzEzO2UueW9kaGVicmV3PTE0OTc7ZS55b2R5b2RoZWJyZXc9MTUyMjtlLnlvZHlvZHBhdGFoaGVicmV3PTY0Mjg3O2UueW9oaXJhZ2FuYT0xMjQyNDtlLnlvaWtvcmVhbj0xMjY4MTtlLnlva2F0YWthbmE9MTI1MjA7ZS55b2thdGFrYW5haGFsZndpZHRoPTY1NDMwO2UueW9rb3JlYW49MTI2MzU7ZS55b3NtYWxsaGlyYWdhbmE9MTI0MjM7ZS55b3NtYWxsa2F0YWthbmE9MTI1MTk7ZS55b3NtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzOTA7ZS55b3RncmVlaz0xMDExO2UueW95YWVrb3JlYW49MTI2ODA7ZS55b3lha29yZWFuPTEyNjc5O2UueW95YWt0aGFpPTM2MTg7ZS55b3lpbmd0aGFpPTM1OTc7ZS55cGFyZW49OTM5NjtlLnlwb2dlZ3JhbW1lbmk9ODkwO2UueXBvZ2VncmFtbWVuaWdyZWVrY21iPTgzNztlLnlyPTQyMjtlLnlyaW5nPTc4MzM7ZS55c3VwZXJpb3I9Njk2O2UueXRpbGRlPTc5Mjk7ZS55dHVybmVkPTY1NDtlLnl1aGlyYWdhbmE9MTI0MjI7ZS55dWlrb3JlYW49MTI2ODQ7ZS55dWthdGFrYW5hPTEyNTE4O2UueXVrYXRha2FuYWhhbGZ3aWR0aD02NTQyOTtlLnl1a29yZWFuPTEyNjQwO2UueXVzYmlnY3lyaWxsaWM9MTEzMTtlLnl1c2JpZ2lvdGlmaWVkY3lyaWxsaWM9MTEzMztlLnl1c2xpdHRsZWN5cmlsbGljPTExMjc7ZS55dXNsaXR0bGVpb3RpZmllZGN5cmlsbGljPTExMjk7ZS55dXNtYWxsaGlyYWdhbmE9MTI0MjE7ZS55dXNtYWxsa2F0YWthbmE9MTI1MTc7ZS55dXNtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODk7ZS55dXlla29yZWFuPTEyNjgzO2UueXV5ZW9rb3JlYW49MTI2ODI7ZS55eWFiZW5nYWxpPTI1Mjc7ZS55eWFkZXZhPTIzOTk7ZS56PTEyMjtlLnphYXJtZW5pYW49MTM4MjtlLnphY3V0ZT0zNzg7ZS56YWRldmE9MjM5NTtlLnphZ3VybXVraGk9MjY1MTtlLnphaGFyYWJpYz0xNTkyO2UuemFoZmluYWxhcmFiaWM9NjUyMjI7ZS56YWhpbml0aWFsYXJhYmljPTY1MjIzO2UuemFoaXJhZ2FuYT0xMjM3NDtlLnphaG1lZGlhbGFyYWJpYz02NTIyNDtlLnphaW5hcmFiaWM9MTU4NjtlLnphaW5maW5hbGFyYWJpYz02NTIwMDtlLnpha2F0YWthbmE9MTI0NzA7ZS56YXFlZmdhZG9saGVicmV3PTE0Mjk7ZS56YXFlZnFhdGFuaGVicmV3PTE0Mjg7ZS56YXJxYWhlYnJldz0xNDMyO2UuemF5aW49MTQ5NDtlLnpheWluZGFnZXNoPTY0MzEwO2UuemF5aW5kYWdlc2hoZWJyZXc9NjQzMTA7ZS56YXlpbmhlYnJldz0xNDk0O2UuemJvcG9tb2ZvPTEyNTY3O2UuemNhcm9uPTM4MjtlLnpjaXJjbGU9OTQ0OTtlLnpjaXJjdW1mbGV4PTc4MjU7ZS56Y3VybD02NTc7ZS56ZG90PTM4MDtlLnpkb3RhY2NlbnQ9MzgwO2UuemRvdGJlbG93PTc4Mjc7ZS56ZWN5cmlsbGljPTEwNzk7ZS56ZWRlc2NlbmRlcmN5cmlsbGljPTExNzc7ZS56ZWRpZXJlc2lzY3lyaWxsaWM9MTI0NztlLnplaGlyYWdhbmE9MTIzODA7ZS56ZWthdGFrYW5hPTEyNDc2O2UuemVybz00ODtlLnplcm9hcmFiaWM9MTYzMjtlLnplcm9iZW5nYWxpPTI1MzQ7ZS56ZXJvZGV2YT0yNDA2O2UuemVyb2d1amFyYXRpPTI3OTA7ZS56ZXJvZ3VybXVraGk9MjY2MjtlLnplcm9oYWNrYXJhYmljPTE2MzI7ZS56ZXJvaW5mZXJpb3I9ODMyMDtlLnplcm9tb25vc3BhY2U9NjUyOTY7ZS56ZXJvb2xkc3R5bGU9NjMyODA7ZS56ZXJvcGVyc2lhbj0xNzc2O2UuemVyb3N1cGVyaW9yPTgzMDQ7ZS56ZXJvdGhhaT0zNjY0O2UuemVyb3dpZHRoam9pbmVyPTY1Mjc5O2UuemVyb3dpZHRobm9uam9pbmVyPTgyMDQ7ZS56ZXJvd2lkdGhzcGFjZT04MjAzO2UuemV0YT05NTA7ZS56aGJvcG9tb2ZvPTEyNTYzO2UuemhlYXJtZW5pYW49MTM4NjtlLnpoZWJyZXZlY3lyaWxsaWM9MTIxODtlLnpoZWN5cmlsbGljPTEwNzg7ZS56aGVkZXNjZW5kZXJjeXJpbGxpYz0xMTc1O2UuemhlZGllcmVzaXNjeXJpbGxpYz0xMjQ1O2UuemloaXJhZ2FuYT0xMjM3NjtlLnppa2F0YWthbmE9MTI0NzI7ZS56aW5vcmhlYnJldz0xNDU0O2UuemxpbmViZWxvdz03ODI5O2Uuem1vbm9zcGFjZT02NTM3MDtlLnpvaGlyYWdhbmE9MTIzODI7ZS56b2thdGFrYW5hPTEyNDc4O2UuenBhcmVuPTkzOTc7ZS56cmV0cm9mbGV4aG9vaz02NTY7ZS56c3Ryb2tlPTQzODtlLnp1aGlyYWdhbmE9MTIzNzg7ZS56dWthdGFrYW5hPTEyNDc0O2VbIi5ub3RkZWYiXT0wO2UuYW5nYnJhY2tldGxlZnRiaWc9OTAwMTtlLmFuZ2JyYWNrZXRsZWZ0QmlnPTkwMDE7ZS5hbmdicmFja2V0bGVmdGJpZ2c9OTAwMTtlLmFuZ2JyYWNrZXRsZWZ0QmlnZz05MDAxO2UuYW5nYnJhY2tldHJpZ2h0QmlnPTkwMDI7ZS5hbmdicmFja2V0cmlnaHRiaWc9OTAwMjtlLmFuZ2JyYWNrZXRyaWdodEJpZ2c9OTAwMjtlLmFuZ2JyYWNrZXRyaWdodGJpZ2c9OTAwMjtlLmFycm93aG9va2xlZnQ9ODYxODtlLmFycm93aG9va3JpZ2h0PTg2MTc7ZS5hcnJvd2xlZnR0b3BoYWxmPTg2MzY7ZS5hcnJvd2xlZnRib3RoYWxmPTg2Mzc7ZS5hcnJvd25vcnRoZWFzdD04NTk5O2UuYXJyb3dub3J0aHdlc3Q9ODU5ODtlLmFycm93cmlnaHR0b3BoYWxmPTg2NDA7ZS5hcnJvd3JpZ2h0Ym90aGFsZj04NjQxO2UuYXJyb3dzb3V0aGVhc3Q9ODYwMDtlLmFycm93c291dGh3ZXN0PTg2MDE7ZS5iYWNrc2xhc2hiaWc9ODcyNjtlLmJhY2tzbGFzaEJpZz04NzI2O2UuYmFja3NsYXNoQmlnZz04NzI2O2UuYmFja3NsYXNoYmlnZz04NzI2O2UuYmFyZGJsPTgyMTQ7ZS5icmFjZWh0aXBkb3dubGVmdD02NTA3OTtlLmJyYWNlaHRpcGRvd25yaWdodD02NTA3OTtlLmJyYWNlaHRpcHVwbGVmdD02NTA4MDtlLmJyYWNlaHRpcHVwcmlnaHQ9NjUwODA7ZS5icmFjZWxlZnRCaWc9MTIzO2UuYnJhY2VsZWZ0YmlnPTEyMztlLmJyYWNlbGVmdGJpZ2c9MTIzO2UuYnJhY2VsZWZ0QmlnZz0xMjM7ZS5icmFjZXJpZ2h0QmlnPTEyNTtlLmJyYWNlcmlnaHRiaWc9MTI1O2UuYnJhY2VyaWdodGJpZ2c9MTI1O2UuYnJhY2VyaWdodEJpZ2c9MTI1O2UuYnJhY2tldGxlZnRiaWc9OTE7ZS5icmFja2V0bGVmdEJpZz05MTtlLmJyYWNrZXRsZWZ0YmlnZz05MTtlLmJyYWNrZXRsZWZ0QmlnZz05MTtlLmJyYWNrZXRyaWdodEJpZz05MztlLmJyYWNrZXRyaWdodGJpZz05MztlLmJyYWNrZXRyaWdodGJpZ2c9OTM7ZS5icmFja2V0cmlnaHRCaWdnPTkzO2UuY2VpbGluZ2xlZnRiaWc9ODk2ODtlLmNlaWxpbmdsZWZ0QmlnPTg5Njg7ZS5jZWlsaW5nbGVmdEJpZ2c9ODk2ODtlLmNlaWxpbmdsZWZ0YmlnZz04OTY4O2UuY2VpbGluZ3JpZ2h0YmlnPTg5Njk7ZS5jZWlsaW5ncmlnaHRCaWc9ODk2OTtlLmNlaWxpbmdyaWdodGJpZ2c9ODk2OTtlLmNlaWxpbmdyaWdodEJpZ2c9ODk2OTtlLmNpcmNsZWRvdGRpc3BsYXk9ODg1NztlLmNpcmNsZWRvdHRleHQ9ODg1NztlLmNpcmNsZW11bHRpcGx5ZGlzcGxheT04ODU1O2UuY2lyY2xlbXVsdGlwbHl0ZXh0PTg4NTU7ZS5jaXJjbGVwbHVzZGlzcGxheT04ODUzO2UuY2lyY2xlcGx1c3RleHQ9ODg1MztlLmNvbnRpbnRlZ3JhbGRpc3BsYXk9ODc1MDtlLmNvbnRpbnRlZ3JhbHRleHQ9ODc1MDtlLmNvcHJvZHVjdGRpc3BsYXk9ODcyMDtlLmNvcHJvZHVjdHRleHQ9ODcyMDtlLmZsb29ybGVmdEJpZz04OTcwO2UuZmxvb3JsZWZ0YmlnPTg5NzA7ZS5mbG9vcmxlZnRiaWdnPTg5NzA7ZS5mbG9vcmxlZnRCaWdnPTg5NzA7ZS5mbG9vcnJpZ2h0YmlnPTg5NzE7ZS5mbG9vcnJpZ2h0QmlnPTg5NzE7ZS5mbG9vcnJpZ2h0QmlnZz04OTcxO2UuZmxvb3JyaWdodGJpZ2c9ODk3MTtlLmhhdHdpZGU9NzcwO2UuaGF0d2lkZXI9NzcwO2UuaGF0d2lkZXN0PTc3MDtlLmludGVyY2FsPTc0ODg7ZS5pbnRlZ3JhbGRpc3BsYXk9ODc0NztlLmludGVncmFsdGV4dD04NzQ3O2UuaW50ZXJzZWN0aW9uZGlzcGxheT04ODk4O2UuaW50ZXJzZWN0aW9udGV4dD04ODk4O2UubG9naWNhbGFuZGRpc3BsYXk9ODc0MztlLmxvZ2ljYWxhbmR0ZXh0PTg3NDM7ZS5sb2dpY2Fsb3JkaXNwbGF5PTg3NDQ7ZS5sb2dpY2Fsb3J0ZXh0PTg3NDQ7ZS5wYXJlbmxlZnRCaWc9NDA7ZS5wYXJlbmxlZnRiaWc9NDA7ZS5wYXJlbmxlZnRCaWdnPTQwO2UucGFyZW5sZWZ0YmlnZz00MDtlLnBhcmVucmlnaHRCaWc9NDE7ZS5wYXJlbnJpZ2h0YmlnPTQxO2UucGFyZW5yaWdodEJpZ2c9NDE7ZS5wYXJlbnJpZ2h0YmlnZz00MTtlLnByaW1lPTgyNDI7ZS5wcm9kdWN0ZGlzcGxheT04NzE5O2UucHJvZHVjdHRleHQ9ODcxOTtlLnJhZGljYWxiaWc9ODczMDtlLnJhZGljYWxCaWc9ODczMDtlLnJhZGljYWxCaWdnPTg3MzA7ZS5yYWRpY2FsYmlnZz04NzMwO2UucmFkaWNhbGJ0PTg3MzA7ZS5yYWRpY2FsdHA9ODczMDtlLnJhZGljYWx2ZXJ0ZXg9ODczMDtlLnNsYXNoYmlnPTQ3O2Uuc2xhc2hCaWc9NDc7ZS5zbGFzaEJpZ2c9NDc7ZS5zbGFzaGJpZ2c9NDc7ZS5zdW1tYXRpb25kaXNwbGF5PTg3MjE7ZS5zdW1tYXRpb250ZXh0PTg3MjE7ZS50aWxkZXdpZGU9NzMyO2UudGlsZGV3aWRlcj03MzI7ZS50aWxkZXdpZGVzdD03MzI7ZS51bmlvbmRpc3BsYXk9ODg5OTtlLnVuaW9ubXVsdGlkaXNwbGF5PTg4NDY7ZS51bmlvbm11bHRpdGV4dD04ODQ2O2UudW5pb25zcWRpc3BsYXk9ODg1MjtlLnVuaW9uc3F0ZXh0PTg4NTI7ZS51bmlvbnRleHQ9ODg5OTtlLnZleHRlbmRkb3VibGU9ODc0MTtlLnZleHRlbmRzaW5nbGU9ODczOX0pKSxocj1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9MzI7ZS5hMT05OTg1O2UuYTI9OTk4NjtlLmEyMDI9OTk4NztlLmEzPTk5ODg7ZS5hND05NzQyO2UuYTU9OTk5MDtlLmExMTk9OTk5MTtlLmExMTg9OTk5MjtlLmExMTc9OTk5MztlLmExMT05NzU1O2UuYTEyPTk3NTg7ZS5hMTM9OTk5NjtlLmExND05OTk3O2UuYTE1PTk5OTg7ZS5hMTY9OTk5OTtlLmExMDU9MWU0O2UuYTE3PTEwMDAxO2UuYTE4PTEwMDAyO2UuYTE5PTEwMDAzO2UuYTIwPTEwMDA0O2UuYTIxPTEwMDA1O2UuYTIyPTEwMDA2O2UuYTIzPTEwMDA3O2UuYTI0PTEwMDA4O2UuYTI1PTEwMDA5O2UuYTI2PTEwMDEwO2UuYTI3PTEwMDExO2UuYTI4PTEwMDEyO2UuYTY9MTAwMTM7ZS5hNz0xMDAxNDtlLmE4PTEwMDE1O2UuYTk9MTAwMTY7ZS5hMTA9MTAwMTc7ZS5hMjk9MTAwMTg7ZS5hMzA9MTAwMTk7ZS5hMzE9MTAwMjA7ZS5hMzI9MTAwMjE7ZS5hMzM9MTAwMjI7ZS5hMzQ9MTAwMjM7ZS5hMzU9OTczMztlLmEzNj0xMDAyNTtlLmEzNz0xMDAyNjtlLmEzOD0xMDAyNztlLmEzOT0xMDAyODtlLmE0MD0xMDAyOTtlLmE0MT0xMDAzMDtlLmE0Mj0xMDAzMTtlLmE0Mz0xMDAzMjtlLmE0ND0xMDAzMztlLmE0NT0xMDAzNDtlLmE0Nj0xMDAzNTtlLmE0Nz0xMDAzNjtlLmE0OD0xMDAzNztlLmE0OT0xMDAzODtlLmE1MD0xMDAzOTtlLmE1MT0xMDA0MDtlLmE1Mj0xMDA0MTtlLmE1Mz0xMDA0MjtlLmE1ND0xMDA0MztlLmE1NT0xMDA0NDtlLmE1Nj0xMDA0NTtlLmE1Nz0xMDA0NjtlLmE1OD0xMDA0NztlLmE1OT0xMDA0ODtlLmE2MD0xMDA0OTtlLmE2MT0xMDA1MDtlLmE2Mj0xMDA1MTtlLmE2Mz0xMDA1MjtlLmE2ND0xMDA1MztlLmE2NT0xMDA1NDtlLmE2Nj0xMDA1NTtlLmE2Nz0xMDA1NjtlLmE2OD0xMDA1NztlLmE2OT0xMDA1ODtlLmE3MD0xMDA1OTtlLmE3MT05Njc5O2UuYTcyPTEwMDYxO2UuYTczPTk2MzI7ZS5hNzQ9MTAwNjM7ZS5hMjAzPTEwMDY0O2UuYTc1PTEwMDY1O2UuYTIwND0xMDA2NjtlLmE3Nj05NjUwO2UuYTc3PTk2NjA7ZS5hNzg9OTY3MDtlLmE3OT0xMDA3MDtlLmE4MT05Njg3O2UuYTgyPTEwMDcyO2UuYTgzPTEwMDczO2UuYTg0PTEwMDc0O2UuYTk3PTEwMDc1O2UuYTk4PTEwMDc2O2UuYTk5PTEwMDc3O2UuYTEwMD0xMDA3ODtlLmExMDE9MTAwODE7ZS5hMTAyPTEwMDgyO2UuYTEwMz0xMDA4MztlLmExMDQ9MTAwODQ7ZS5hMTA2PTEwMDg1O2UuYTEwNz0xMDA4NjtlLmExMDg9MTAwODc7ZS5hMTEyPTk4Mjc7ZS5hMTExPTk4MzA7ZS5hMTEwPTk4Mjk7ZS5hMTA5PTk4MjQ7ZS5hMTIwPTkzMTI7ZS5hMTIxPTkzMTM7ZS5hMTIyPTkzMTQ7ZS5hMTIzPTkzMTU7ZS5hMTI0PTkzMTY7ZS5hMTI1PTkzMTc7ZS5hMTI2PTkzMTg7ZS5hMTI3PTkzMTk7ZS5hMTI4PTkzMjA7ZS5hMTI5PTkzMjE7ZS5hMTMwPTEwMTAyO2UuYTEzMT0xMDEwMztlLmExMzI9MTAxMDQ7ZS5hMTMzPTEwMTA1O2UuYTEzND0xMDEwNjtlLmExMzU9MTAxMDc7ZS5hMTM2PTEwMTA4O2UuYTEzNz0xMDEwOTtlLmExMzg9MTAxMTA7ZS5hMTM5PTEwMTExO2UuYTE0MD0xMDExMjtlLmExNDE9MTAxMTM7ZS5hMTQyPTEwMTE0O2UuYTE0Mz0xMDExNTtlLmExNDQ9MTAxMTY7ZS5hMTQ1PTEwMTE3O2UuYTE0Nj0xMDExODtlLmExNDc9MTAxMTk7ZS5hMTQ4PTEwMTIwO2UuYTE0OT0xMDEyMTtlLmExNTA9MTAxMjI7ZS5hMTUxPTEwMTIzO2UuYTE1Mj0xMDEyNDtlLmExNTM9MTAxMjU7ZS5hMTU0PTEwMTI2O2UuYTE1NT0xMDEyNztlLmExNTY9MTAxMjg7ZS5hMTU3PTEwMTI5O2UuYTE1OD0xMDEzMDtlLmExNTk9MTAxMzE7ZS5hMTYwPTEwMTMyO2UuYTE2MT04NTk0O2UuYTE2Mz04NTk2O2UuYTE2ND04NTk3O2UuYTE5Nj0xMDEzNjtlLmExNjU9MTAxMzc7ZS5hMTkyPTEwMTM4O2UuYTE2Nj0xMDEzOTtlLmExNjc9MTAxNDA7ZS5hMTY4PTEwMTQxO2UuYTE2OT0xMDE0MjtlLmExNzA9MTAxNDM7ZS5hMTcxPTEwMTQ0O2UuYTE3Mj0xMDE0NTtlLmExNzM9MTAxNDY7ZS5hMTYyPTEwMTQ3O2UuYTE3ND0xMDE0ODtlLmExNzU9MTAxNDk7ZS5hMTc2PTEwMTUwO2UuYTE3Nz0xMDE1MTtlLmExNzg9MTAxNTI7ZS5hMTc5PTEwMTUzO2UuYTE5Mz0xMDE1NDtlLmExODA9MTAxNTU7ZS5hMTk5PTEwMTU2O2UuYTE4MT0xMDE1NztlLmEyMDA9MTAxNTg7ZS5hMTgyPTEwMTU5O2UuYTIwMT0xMDE2MTtlLmExODM9MTAxNjI7ZS5hMTg0PTEwMTYzO2UuYTE5Nz0xMDE2NDtlLmExODU9MTAxNjU7ZS5hMTk0PTEwMTY2O2UuYTE5OD0xMDE2NztlLmExODY9MTAxNjg7ZS5hMTk1PTEwMTY5O2UuYTE4Nz0xMDE3MDtlLmExODg9MTAxNzE7ZS5hMTg5PTEwMTcyO2UuYTE5MD0xMDE3MztlLmExOTE9MTAxNzQ7ZS5hODk9MTAwODg7ZS5hOTA9MTAwODk7ZS5hOTM9MTAwOTA7ZS5hOTQ9MTAwOTE7ZS5hOTE9MTAwOTI7ZS5hOTI9MTAwOTM7ZS5hMjA1PTEwMDk0O2UuYTg1PTEwMDk1O2UuYTIwNj0xMDA5NjtlLmE4Nj0xMDA5NztlLmE4Nz0xMDA5ODtlLmE4OD0xMDA5OTtlLmE5NT0xMDEwMDtlLmE5Nj0xMDEwMTtlWyIubm90ZGVmIl09MH0pKSx1cj1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2VbNjM3MjFdPTE2OTtlWzYzMTkzXT0xNjk7ZVs2MzcyMF09MTc0O2VbNjMxOTRdPTE3NDtlWzYzNzIyXT04NDgyO2VbNjMxOTVdPTg0ODI7ZVs2MzcyOV09OTEyNztlWzYzNzMwXT05MTI4O2VbNjM3MzFdPTkxMjk7ZVs2Mzc0MF09OTEzMTtlWzYzNzQxXT05MTMyO2VbNjM3NDJdPTkxMzM7ZVs2MzcyNl09OTEyMTtlWzYzNzI3XT05MTIyO2VbNjM3MjhdPTkxMjM7ZVs2MzczN109OTEyNDtlWzYzNzM4XT05MTI1O2VbNjM3MzldPTkxMjY7ZVs2MzcyM109OTExNTtlWzYzNzI0XT05MTE2O2VbNjM3MjVdPTkxMTc7ZVs2MzczNF09OTExODtlWzYzNzM1XT05MTE5O2VbNjM3MzZdPTkxMjB9KSk7ZnVuY3Rpb24gZ2V0VW5pY29kZUZvckdseXBoKGUsdCl7bGV0IGE9dFtlXTtpZih2b2lkIDAhPT1hKXJldHVybiBhO2lmKCFlKXJldHVybi0xO2lmKCJ1Ij09PWVbMF0pe2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IHI7aWYoNz09PXQmJiJuIj09PWVbMV0mJiJpIj09PWVbMl0pcj1lLnN1YnN0cmluZygzKTtlbHNle2lmKCEodD49NSYmdDw9NykpcmV0dXJuLTE7cj1lLnN1YnN0cmluZygxKX1pZihyPT09ci50b1VwcGVyQ2FzZSgpKXthPXBhcnNlSW50KHIsMTYpO2lmKGE+PTApcmV0dXJuIGF9fXJldHVybi0xfWNvbnN0IGRyPVtbMCwxMjddLFsxMjgsMjU1XSxbMjU2LDM4M10sWzM4NCw1OTFdLFs1OTIsNjg3LDc0MjQsNzU1MSw3NTUyLDc2MTVdLFs2ODgsNzY3LDQyNzUyLDQyNzgzXSxbNzY4LDg3OSw3NjE2LDc2NzldLFs4ODAsMTAyM10sWzExMzkyLDExNTE5XSxbMTAyNCwxMjc5LDEyODAsMTMyNywxMTc0NCwxMTc3NSw0MjU2MCw0MjY1NV0sWzEzMjgsMTQyM10sWzE0MjQsMTUzNV0sWzQyMjQwLDQyNTU5XSxbMTUzNiwxNzkxLDE4NzIsMTkxOV0sWzE5ODQsMjA0N10sWzIzMDQsMjQzMV0sWzI0MzIsMjU1OV0sWzI1NjAsMjY4N10sWzI2ODgsMjgxNV0sWzI4MTYsMjk0M10sWzI5NDQsMzA3MV0sWzMwNzIsMzE5OV0sWzMyMDAsMzMyN10sWzMzMjgsMzQ1NV0sWzM1ODQsMzcxMV0sWzM3MTIsMzgzOV0sWzQyNTYsNDM1MSwxMTUyMCwxMTU2N10sWzY5MTIsNzAzOV0sWzQzNTIsNDYwN10sWzc2ODAsNzkzNSwxMTM2MCwxMTM5MSw0Mjc4NCw0MzAwN10sWzc5MzYsODE5MV0sWzgxOTIsODMwMywxMTc3NiwxMTkwM10sWzgzMDQsODM1MV0sWzgzNTIsODM5OV0sWzg0MDAsODQ0N10sWzg0NDgsODUyN10sWzg1MjgsODU5MV0sWzg1OTIsODcwMywxMDIyNCwxMDIzOSwxMDQ5NiwxMDYyMywxMTAwOCwxMTI2M10sWzg3MDQsODk1OSwxMDc1MiwxMTAwNywxMDE3NiwxMDIyMywxMDYyNCwxMDc1MV0sWzg5NjAsOTIxNV0sWzkyMTYsOTI3OV0sWzkyODAsOTMxMV0sWzkzMTIsOTQ3MV0sWzk0NzIsOTU5OV0sWzk2MDAsOTYzMV0sWzk2MzIsOTcyN10sWzk3MjgsOTk4M10sWzk5ODQsMTAxNzVdLFsxMjI4OCwxMjM1MV0sWzEyMzUyLDEyNDQ3XSxbMTI0NDgsMTI1NDMsMTI3ODQsMTI3OTldLFsxMjU0NCwxMjU5MSwxMjcwNCwxMjczNV0sWzEyNTkyLDEyNjg3XSxbNDMwNzIsNDMxMzVdLFsxMjgwMCwxMzA1NV0sWzEzMDU2LDEzMzExXSxbNDQwMzIsNTUyMTVdLFs1NTI5Niw1NzM0M10sWzY3ODQwLDY3ODcxXSxbMTk5NjgsNDA5NTksMTE5MDQsMTIwMzEsMTIwMzIsMTIyNTUsMTIyNzIsMTIyODcsMTMzMTIsMTk5MDMsMTMxMDcyLDE3Mzc5MSwxMjY4OCwxMjcwM10sWzU3MzQ0LDYzNzQzXSxbMTI3MzYsMTI3ODMsNjM3NDQsNjQyNTUsMTk0NTYwLDE5NTEwM10sWzY0MjU2LDY0MzM1XSxbNjQzMzYsNjUwMjNdLFs2NTA1Niw2NTA3MV0sWzY1MDQwLDY1MDU1XSxbNjUxMDQsNjUxMzVdLFs2NTEzNiw2NTI3OV0sWzY1MjgwLDY1NTE5XSxbNjU1MjAsNjU1MzVdLFszODQwLDQwOTVdLFsxNzkyLDE4NzFdLFsxOTIwLDE5ODNdLFszNDU2LDM1ODNdLFs0MDk2LDQyNTVdLFs0NjA4LDQ5OTEsNDk5Miw1MDIzLDExNjQ4LDExNzQzXSxbNTAyNCw1MTE5XSxbNTEyMCw1NzU5XSxbNTc2MCw1NzkxXSxbNTc5Miw1ODg3XSxbNjAxNiw2MTQzXSxbNjE0NCw2MzE5XSxbMTAyNDAsMTA0OTVdLFs0MDk2MCw0MjEyN10sWzU4ODgsNTkxOSw1OTIwLDU5NTEsNTk1Miw1OTgzLDU5ODQsNjAxNV0sWzY2MzA0LDY2MzUxXSxbNjYzNTIsNjYzODNdLFs2NjU2MCw2NjYzOV0sWzExODc4NCwxMTkwMzksMTE5MDQwLDExOTI5NSwxMTkyOTYsMTE5Mzc1XSxbMTE5ODA4LDEyMDgzMV0sWzEwNDQ0ODAsMTA0ODU3M10sWzY1MDI0LDY1MDM5LDkxNzc2MCw5MTc5OTldLFs5MTc1MDQsOTE3NjMxXSxbNjQwMCw2NDc5XSxbNjQ4MCw2NTI3XSxbNjUyOCw2NjIzXSxbNjY1Niw2Njg3XSxbMTEyNjQsMTEzNTldLFsxMTU2OCwxMTY0N10sWzE5OTA0LDE5OTY3XSxbNDMwMDgsNDMwNTVdLFs2NTUzNiw2NTY2Myw2NTY2NCw2NTc5MSw2NTc5Miw2NTg1NV0sWzY1ODU2LDY1OTM1XSxbNjY0MzIsNjY0NjNdLFs2NjQ2NCw2NjUyN10sWzY2NjQwLDY2Njg3XSxbNjY2ODgsNjY3MzVdLFs2NzU4NCw2NzY0N10sWzY4MDk2LDY4MTkxXSxbMTE5NTUyLDExOTY0N10sWzczNzI4LDc0NzUxLDc0NzUyLDc0ODc5XSxbMTE5NjQ4LDExOTY3OV0sWzcwNDAsNzEwM10sWzcxNjgsNzI0N10sWzcyNDgsNzI5NV0sWzQzMTM2LDQzMjMxXSxbNDMyNjQsNDMzMTFdLFs0MzMxMiw0MzM1OV0sWzQzNTIwLDQzNjE1XSxbNjU5MzYsNjU5OTldLFs2NmUzLDY2MDQ3XSxbNjYyMDgsNjYyNzEsNjYxNzYsNjYyMDcsNjc4NzIsNjc5MDNdLFsxMjcwMjQsMTI3MTM1LDEyNjk3NiwxMjcwMjNdXTtmdW5jdGlvbiBnZXRVbmljb2RlUmFuZ2VGb3IoZSx0PS0xKXtpZigtMSE9PXQpe2NvbnN0IGE9ZHJbdF07Zm9yKGxldCByPTAsaT1hLmxlbmd0aDtyPGk7cis9MilpZihlPj1hW3JdJiZlPD1hW3IrMV0pcmV0dXJuIHR9Zm9yKGxldCB0PTAsYT1kci5sZW5ndGg7dDxhO3QrKyl7Y29uc3QgYT1kclt0XTtmb3IobGV0IHI9MCxpPWEubGVuZ3RoO3I8aTtyKz0yKWlmKGU+PWFbcl0mJmU8PWFbcisxXSlyZXR1cm4gdH1yZXR1cm4tMX1jb25zdCBmcj1uZXcgUmVnRXhwKCJeKFxccyl8KFxccHtNbn0pfChcXHB7Q2Z9KSQiLCJ1IiksZ3I9bmV3IE1hcDtjb25zdCBwcj0hMCxtcj0xLGJyPTIseXI9NCx3cj0zMix4cj1bIi5ub3RkZWYiLCIubnVsbCIsIm5vbm1hcmtpbmdyZXR1cm4iLCJzcGFjZSIsImV4Y2xhbSIsInF1b3RlZGJsIiwibnVtYmVyc2lnbiIsImRvbGxhciIsInBlcmNlbnQiLCJhbXBlcnNhbmQiLCJxdW90ZXNpbmdsZSIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwiZ3JhdmUiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsImJyYWNlbGVmdCIsImJhciIsImJyYWNlcmlnaHQiLCJhc2NpaXRpbGRlIiwiQWRpZXJlc2lzIiwiQXJpbmciLCJDY2VkaWxsYSIsIkVhY3V0ZSIsIk50aWxkZSIsIk9kaWVyZXNpcyIsIlVkaWVyZXNpcyIsImFhY3V0ZSIsImFncmF2ZSIsImFjaXJjdW1mbGV4IiwiYWRpZXJlc2lzIiwiYXRpbGRlIiwiYXJpbmciLCJjY2VkaWxsYSIsImVhY3V0ZSIsImVncmF2ZSIsImVjaXJjdW1mbGV4IiwiZWRpZXJlc2lzIiwiaWFjdXRlIiwiaWdyYXZlIiwiaWNpcmN1bWZsZXgiLCJpZGllcmVzaXMiLCJudGlsZGUiLCJvYWN1dGUiLCJvZ3JhdmUiLCJvY2lyY3VtZmxleCIsIm9kaWVyZXNpcyIsIm90aWxkZSIsInVhY3V0ZSIsInVncmF2ZSIsInVjaXJjdW1mbGV4IiwidWRpZXJlc2lzIiwiZGFnZ2VyIiwiZGVncmVlIiwiY2VudCIsInN0ZXJsaW5nIiwic2VjdGlvbiIsImJ1bGxldCIsInBhcmFncmFwaCIsImdlcm1hbmRibHMiLCJyZWdpc3RlcmVkIiwiY29weXJpZ2h0IiwidHJhZGVtYXJrIiwiYWN1dGUiLCJkaWVyZXNpcyIsIm5vdGVxdWFsIiwiQUUiLCJPc2xhc2giLCJpbmZpbml0eSIsInBsdXNtaW51cyIsImxlc3NlcXVhbCIsImdyZWF0ZXJlcXVhbCIsInllbiIsIm11IiwicGFydGlhbGRpZmYiLCJzdW1tYXRpb24iLCJwcm9kdWN0IiwicGkiLCJpbnRlZ3JhbCIsIm9yZGZlbWluaW5lIiwib3JkbWFzY3VsaW5lIiwiT21lZ2EiLCJhZSIsIm9zbGFzaCIsInF1ZXN0aW9uZG93biIsImV4Y2xhbWRvd24iLCJsb2dpY2Fsbm90IiwicmFkaWNhbCIsImZsb3JpbiIsImFwcHJveGVxdWFsIiwiRGVsdGEiLCJndWlsbGVtb3RsZWZ0IiwiZ3VpbGxlbW90cmlnaHQiLCJlbGxpcHNpcyIsIm5vbmJyZWFraW5nc3BhY2UiLCJBZ3JhdmUiLCJBdGlsZGUiLCJPdGlsZGUiLCJPRSIsIm9lIiwiZW5kYXNoIiwiZW1kYXNoIiwicXVvdGVkYmxsZWZ0IiwicXVvdGVkYmxyaWdodCIsInF1b3RlbGVmdCIsInF1b3RlcmlnaHQiLCJkaXZpZGUiLCJsb3plbmdlIiwieWRpZXJlc2lzIiwiWWRpZXJlc2lzIiwiZnJhY3Rpb24iLCJjdXJyZW5jeSIsImd1aWxzaW5nbGxlZnQiLCJndWlsc2luZ2xyaWdodCIsImZpIiwiZmwiLCJkYWdnZXJkYmwiLCJwZXJpb2RjZW50ZXJlZCIsInF1b3Rlc2luZ2xiYXNlIiwicXVvdGVkYmxiYXNlIiwicGVydGhvdXNhbmQiLCJBY2lyY3VtZmxleCIsIkVjaXJjdW1mbGV4IiwiQWFjdXRlIiwiRWRpZXJlc2lzIiwiRWdyYXZlIiwiSWFjdXRlIiwiSWNpcmN1bWZsZXgiLCJJZGllcmVzaXMiLCJJZ3JhdmUiLCJPYWN1dGUiLCJPY2lyY3VtZmxleCIsImFwcGxlIiwiT2dyYXZlIiwiVWFjdXRlIiwiVWNpcmN1bWZsZXgiLCJVZ3JhdmUiLCJkb3RsZXNzaSIsImNpcmN1bWZsZXgiLCJ0aWxkZSIsIm1hY3JvbiIsImJyZXZlIiwiZG90YWNjZW50IiwicmluZyIsImNlZGlsbGEiLCJodW5nYXJ1bWxhdXQiLCJvZ29uZWsiLCJjYXJvbiIsIkxzbGFzaCIsImxzbGFzaCIsIlNjYXJvbiIsInNjYXJvbiIsIlpjYXJvbiIsInpjYXJvbiIsImJyb2tlbmJhciIsIkV0aCIsImV0aCIsIllhY3V0ZSIsInlhY3V0ZSIsIlRob3JuIiwidGhvcm4iLCJtaW51cyIsIm11bHRpcGx5Iiwib25lc3VwZXJpb3IiLCJ0d29zdXBlcmlvciIsInRocmVlc3VwZXJpb3IiLCJvbmVoYWxmIiwib25lcXVhcnRlciIsInRocmVlcXVhcnRlcnMiLCJmcmFuYyIsIkdicmV2ZSIsImdicmV2ZSIsIklkb3RhY2NlbnQiLCJTY2VkaWxsYSIsInNjZWRpbGxhIiwiQ2FjdXRlIiwiY2FjdXRlIiwiQ2Nhcm9uIiwiY2Nhcm9uIiwiZGNyb2F0Il07ZnVuY3Rpb24gcmVjb3ZlckdseXBoTmFtZShlLHQpe2lmKHZvaWQgMCE9PXRbZV0pcmV0dXJuIGU7Y29uc3QgYT1nZXRVbmljb2RlRm9yR2x5cGgoZSx0KTtpZigtMSE9PWEpZm9yKGNvbnN0IGUgaW4gdClpZih0W2VdPT09YSlyZXR1cm4gZTtpbmZvKCJVbmFibGUgdG8gcmVjb3ZlciBhIHN0YW5kYXJkIGdseXBoIG5hbWUgZm9yOiAiK2UpO3JldHVybiBlfWZ1bmN0aW9uIHR5cGUxRm9udEdseXBoTWFwcGluZyhlLHQsYSl7Y29uc3Qgcj1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBpLG4scztjb25zdCBvPSEhKGUuZmxhZ3MmeXIpO2lmKGUuaXNJbnRlcm5hbEZvbnQpe3M9dDtmb3Iobj0wO248cy5sZW5ndGg7bisrKXtpPWEuaW5kZXhPZihzW25dKTtyW25dPWk+PTA/aTowfX1lbHNlIGlmKGUuYmFzZUVuY29kaW5nTmFtZSl7cz1nZXRFbmNvZGluZyhlLmJhc2VFbmNvZGluZ05hbWUpO2ZvcihuPTA7bjxzLmxlbmd0aDtuKyspe2k9YS5pbmRleE9mKHNbbl0pO3Jbbl09aT49MD9pOjB9fWVsc2UgaWYobylmb3IobiBpbiB0KXJbbl09dFtuXTtlbHNle3M9bnI7Zm9yKG49MDtuPHMubGVuZ3RoO24rKyl7aT1hLmluZGV4T2Yoc1tuXSk7cltuXT1pPj0wP2k6MH19Y29uc3QgYz1lLmRpZmZlcmVuY2VzO2xldCBsO2lmKGMpZm9yKG4gaW4gYyl7Y29uc3QgZT1jW25dO2k9YS5pbmRleE9mKGUpO2lmKC0xPT09aSl7bHx8KGw9bHIoKSk7Y29uc3QgdD1yZWNvdmVyR2x5cGhOYW1lKGUsbCk7dCE9PWUmJihpPWEuaW5kZXhPZih0KSl9cltuXT1pPj0wP2k6MH1yZXR1cm4gcn1mdW5jdGlvbiBub3JtYWxpemVGb250TmFtZShlKXtyZXR1cm4gZS5yZXBsYWNlQWxsKC9bLF9dL2csIi0iKS5yZXBsYWNlQWxsKC9ccy9nLCIiKX1jb25zdCBTcj1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGU9PntlWzgyMTFdPTY1MDc0O2VbODIxMl09NjUwNzM7ZVs4MjI5XT02NTA3MjtlWzgyMzBdPTY1MDQ5O2VbMTIyODldPTY1MDQxO2VbMTIyOTBdPTY1MDQyO2VbMTIyOTZdPTY1MDg3O2VbMTIyOTddPTY1MDg4O2VbMTIyOThdPTY1MDg1O2VbMTIyOTldPTY1MDg2O2VbMTIzMDBdPTY1MDg5O2VbMTIzMDFdPTY1MDkwO2VbMTIzMDJdPTY1MDkxO2VbMTIzMDNdPTY1MDkyO2VbMTIzMDRdPTY1MDgzO2VbMTIzMDVdPTY1MDg0O2VbMTIzMDhdPTY1MDgxO2VbMTIzMDldPTY1MDgyO2VbMTIzMTBdPTY1MDQ3O2VbMTIzMTFdPTY1MDQ4O2VbNjUxMDNdPTY1MDc2O2VbNjUyODFdPTY1MDQ1O2VbNjUyODhdPTY1MDc3O2VbNjUyODldPTY1MDc4O2VbNjUyOTJdPTY1MDQwO2VbNjUzMDZdPTY1MDQzO2VbNjUzMDddPTY1MDQ0O2VbNjUzMTFdPTY1MDQ2O2VbNjUzMzldPTY1MDk1O2VbNjUzNDFdPTY1MDk2O2VbNjUzNDNdPTY1MDc1O2VbNjUzNzFdPTY1MDc5O2VbNjUzNzNdPTY1MDgwfSkpO2NvbnN0IEFyPVsiLm5vdGRlZiIsInNwYWNlIiwiZXhjbGFtIiwicXVvdGVkYmwiLCJudW1iZXJzaWduIiwiZG9sbGFyIiwicGVyY2VudCIsImFtcGVyc2FuZCIsInF1b3RlcmlnaHQiLCJwYXJlbmxlZnQiLCJwYXJlbnJpZ2h0IiwiYXN0ZXJpc2siLCJwbHVzIiwiY29tbWEiLCJoeXBoZW4iLCJwZXJpb2QiLCJzbGFzaCIsInplcm8iLCJvbmUiLCJ0d28iLCJ0aHJlZSIsImZvdXIiLCJmaXZlIiwic2l4Iiwic2V2ZW4iLCJlaWdodCIsIm5pbmUiLCJjb2xvbiIsInNlbWljb2xvbiIsImxlc3MiLCJlcXVhbCIsImdyZWF0ZXIiLCJxdWVzdGlvbiIsImF0IiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiUyIsIlQiLCJVIiwiViIsIlciLCJYIiwiWSIsIloiLCJicmFja2V0bGVmdCIsImJhY2tzbGFzaCIsImJyYWNrZXRyaWdodCIsImFzY2lpY2lyY3VtIiwidW5kZXJzY29yZSIsInF1b3RlbGVmdCIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiYnJhY2VsZWZ0IiwiYmFyIiwiYnJhY2VyaWdodCIsImFzY2lpdGlsZGUiLCJleGNsYW1kb3duIiwiY2VudCIsInN0ZXJsaW5nIiwiZnJhY3Rpb24iLCJ5ZW4iLCJmbG9yaW4iLCJzZWN0aW9uIiwiY3VycmVuY3kiLCJxdW90ZXNpbmdsZSIsInF1b3RlZGJsbGVmdCIsImd1aWxsZW1vdGxlZnQiLCJndWlsc2luZ2xsZWZ0IiwiZ3VpbHNpbmdscmlnaHQiLCJmaSIsImZsIiwiZW5kYXNoIiwiZGFnZ2VyIiwiZGFnZ2VyZGJsIiwicGVyaW9kY2VudGVyZWQiLCJwYXJhZ3JhcGgiLCJidWxsZXQiLCJxdW90ZXNpbmdsYmFzZSIsInF1b3RlZGJsYmFzZSIsInF1b3RlZGJscmlnaHQiLCJndWlsbGVtb3RyaWdodCIsImVsbGlwc2lzIiwicGVydGhvdXNhbmQiLCJxdWVzdGlvbmRvd24iLCJncmF2ZSIsImFjdXRlIiwiY2lyY3VtZmxleCIsInRpbGRlIiwibWFjcm9uIiwiYnJldmUiLCJkb3RhY2NlbnQiLCJkaWVyZXNpcyIsInJpbmciLCJjZWRpbGxhIiwiaHVuZ2FydW1sYXV0Iiwib2dvbmVrIiwiY2Fyb24iLCJlbWRhc2giLCJBRSIsIm9yZGZlbWluaW5lIiwiTHNsYXNoIiwiT3NsYXNoIiwiT0UiLCJvcmRtYXNjdWxpbmUiLCJhZSIsImRvdGxlc3NpIiwibHNsYXNoIiwib3NsYXNoIiwib2UiLCJnZXJtYW5kYmxzIiwib25lc3VwZXJpb3IiLCJsb2dpY2Fsbm90IiwibXUiLCJ0cmFkZW1hcmsiLCJFdGgiLCJvbmVoYWxmIiwicGx1c21pbnVzIiwiVGhvcm4iLCJvbmVxdWFydGVyIiwiZGl2aWRlIiwiYnJva2VuYmFyIiwiZGVncmVlIiwidGhvcm4iLCJ0aHJlZXF1YXJ0ZXJzIiwidHdvc3VwZXJpb3IiLCJyZWdpc3RlcmVkIiwibWludXMiLCJldGgiLCJtdWx0aXBseSIsInRocmVlc3VwZXJpb3IiLCJjb3B5cmlnaHQiLCJBYWN1dGUiLCJBY2lyY3VtZmxleCIsIkFkaWVyZXNpcyIsIkFncmF2ZSIsIkFyaW5nIiwiQXRpbGRlIiwiQ2NlZGlsbGEiLCJFYWN1dGUiLCJFY2lyY3VtZmxleCIsIkVkaWVyZXNpcyIsIkVncmF2ZSIsIklhY3V0ZSIsIkljaXJjdW1mbGV4IiwiSWRpZXJlc2lzIiwiSWdyYXZlIiwiTnRpbGRlIiwiT2FjdXRlIiwiT2NpcmN1bWZsZXgiLCJPZGllcmVzaXMiLCJPZ3JhdmUiLCJPdGlsZGUiLCJTY2Fyb24iLCJVYWN1dGUiLCJVY2lyY3VtZmxleCIsIlVkaWVyZXNpcyIsIlVncmF2ZSIsIllhY3V0ZSIsIllkaWVyZXNpcyIsIlpjYXJvbiIsImFhY3V0ZSIsImFjaXJjdW1mbGV4IiwiYWRpZXJlc2lzIiwiYWdyYXZlIiwiYXJpbmciLCJhdGlsZGUiLCJjY2VkaWxsYSIsImVhY3V0ZSIsImVjaXJjdW1mbGV4IiwiZWRpZXJlc2lzIiwiZWdyYXZlIiwiaWFjdXRlIiwiaWNpcmN1bWZsZXgiLCJpZGllcmVzaXMiLCJpZ3JhdmUiLCJudGlsZGUiLCJvYWN1dGUiLCJvY2lyY3VtZmxleCIsIm9kaWVyZXNpcyIsIm9ncmF2ZSIsIm90aWxkZSIsInNjYXJvbiIsInVhY3V0ZSIsInVjaXJjdW1mbGV4IiwidWRpZXJlc2lzIiwidWdyYXZlIiwieWFjdXRlIiwieWRpZXJlc2lzIiwiemNhcm9uIl0sa3I9WyIubm90ZGVmIiwic3BhY2UiLCJleGNsYW1zbWFsbCIsIkh1bmdhcnVtbGF1dHNtYWxsIiwiZG9sbGFyb2xkc3R5bGUiLCJkb2xsYXJzdXBlcmlvciIsImFtcGVyc2FuZHNtYWxsIiwiQWN1dGVzbWFsbCIsInBhcmVubGVmdHN1cGVyaW9yIiwicGFyZW5yaWdodHN1cGVyaW9yIiwidHdvZG90ZW5sZWFkZXIiLCJvbmVkb3RlbmxlYWRlciIsImNvbW1hIiwiaHlwaGVuIiwicGVyaW9kIiwiZnJhY3Rpb24iLCJ6ZXJvb2xkc3R5bGUiLCJvbmVvbGRzdHlsZSIsInR3b29sZHN0eWxlIiwidGhyZWVvbGRzdHlsZSIsImZvdXJvbGRzdHlsZSIsImZpdmVvbGRzdHlsZSIsInNpeG9sZHN0eWxlIiwic2V2ZW5vbGRzdHlsZSIsImVpZ2h0b2xkc3R5bGUiLCJuaW5lb2xkc3R5bGUiLCJjb2xvbiIsInNlbWljb2xvbiIsImNvbW1hc3VwZXJpb3IiLCJ0aHJlZXF1YXJ0ZXJzZW1kYXNoIiwicGVyaW9kc3VwZXJpb3IiLCJxdWVzdGlvbnNtYWxsIiwiYXN1cGVyaW9yIiwiYnN1cGVyaW9yIiwiY2VudHN1cGVyaW9yIiwiZHN1cGVyaW9yIiwiZXN1cGVyaW9yIiwiaXN1cGVyaW9yIiwibHN1cGVyaW9yIiwibXN1cGVyaW9yIiwibnN1cGVyaW9yIiwib3N1cGVyaW9yIiwicnN1cGVyaW9yIiwic3N1cGVyaW9yIiwidHN1cGVyaW9yIiwiZmYiLCJmaSIsImZsIiwiZmZpIiwiZmZsIiwicGFyZW5sZWZ0aW5mZXJpb3IiLCJwYXJlbnJpZ2h0aW5mZXJpb3IiLCJDaXJjdW1mbGV4c21hbGwiLCJoeXBoZW5zdXBlcmlvciIsIkdyYXZlc21hbGwiLCJBc21hbGwiLCJCc21hbGwiLCJDc21hbGwiLCJEc21hbGwiLCJFc21hbGwiLCJGc21hbGwiLCJHc21hbGwiLCJIc21hbGwiLCJJc21hbGwiLCJKc21hbGwiLCJLc21hbGwiLCJMc21hbGwiLCJNc21hbGwiLCJOc21hbGwiLCJPc21hbGwiLCJQc21hbGwiLCJRc21hbGwiLCJSc21hbGwiLCJTc21hbGwiLCJUc21hbGwiLCJVc21hbGwiLCJWc21hbGwiLCJXc21hbGwiLCJYc21hbGwiLCJZc21hbGwiLCJac21hbGwiLCJjb2xvbm1vbmV0YXJ5Iiwib25lZml0dGVkIiwicnVwaWFoIiwiVGlsZGVzbWFsbCIsImV4Y2xhbWRvd25zbWFsbCIsImNlbnRvbGRzdHlsZSIsIkxzbGFzaHNtYWxsIiwiU2Nhcm9uc21hbGwiLCJaY2Fyb25zbWFsbCIsIkRpZXJlc2lzc21hbGwiLCJCcmV2ZXNtYWxsIiwiQ2Fyb25zbWFsbCIsIkRvdGFjY2VudHNtYWxsIiwiTWFjcm9uc21hbGwiLCJmaWd1cmVkYXNoIiwiaHlwaGVuaW5mZXJpb3IiLCJPZ29uZWtzbWFsbCIsIlJpbmdzbWFsbCIsIkNlZGlsbGFzbWFsbCIsIm9uZXF1YXJ0ZXIiLCJvbmVoYWxmIiwidGhyZWVxdWFydGVycyIsInF1ZXN0aW9uZG93bnNtYWxsIiwib25lZWlnaHRoIiwidGhyZWVlaWdodGhzIiwiZml2ZWVpZ2h0aHMiLCJzZXZlbmVpZ2h0aHMiLCJvbmV0aGlyZCIsInR3b3RoaXJkcyIsInplcm9zdXBlcmlvciIsIm9uZXN1cGVyaW9yIiwidHdvc3VwZXJpb3IiLCJ0aHJlZXN1cGVyaW9yIiwiZm91cnN1cGVyaW9yIiwiZml2ZXN1cGVyaW9yIiwic2l4c3VwZXJpb3IiLCJzZXZlbnN1cGVyaW9yIiwiZWlnaHRzdXBlcmlvciIsIm5pbmVzdXBlcmlvciIsInplcm9pbmZlcmlvciIsIm9uZWluZmVyaW9yIiwidHdvaW5mZXJpb3IiLCJ0aHJlZWluZmVyaW9yIiwiZm91cmluZmVyaW9yIiwiZml2ZWluZmVyaW9yIiwic2l4aW5mZXJpb3IiLCJzZXZlbmluZmVyaW9yIiwiZWlnaHRpbmZlcmlvciIsIm5pbmVpbmZlcmlvciIsImNlbnRpbmZlcmlvciIsImRvbGxhcmluZmVyaW9yIiwicGVyaW9kaW5mZXJpb3IiLCJjb21tYWluZmVyaW9yIiwiQWdyYXZlc21hbGwiLCJBYWN1dGVzbWFsbCIsIkFjaXJjdW1mbGV4c21hbGwiLCJBdGlsZGVzbWFsbCIsIkFkaWVyZXNpc3NtYWxsIiwiQXJpbmdzbWFsbCIsIkFFc21hbGwiLCJDY2VkaWxsYXNtYWxsIiwiRWdyYXZlc21hbGwiLCJFYWN1dGVzbWFsbCIsIkVjaXJjdW1mbGV4c21hbGwiLCJFZGllcmVzaXNzbWFsbCIsIklncmF2ZXNtYWxsIiwiSWFjdXRlc21hbGwiLCJJY2lyY3VtZmxleHNtYWxsIiwiSWRpZXJlc2lzc21hbGwiLCJFdGhzbWFsbCIsIk50aWxkZXNtYWxsIiwiT2dyYXZlc21hbGwiLCJPYWN1dGVzbWFsbCIsIk9jaXJjdW1mbGV4c21hbGwiLCJPdGlsZGVzbWFsbCIsIk9kaWVyZXNpc3NtYWxsIiwiT0VzbWFsbCIsIk9zbGFzaHNtYWxsIiwiVWdyYXZlc21hbGwiLCJVYWN1dGVzbWFsbCIsIlVjaXJjdW1mbGV4c21hbGwiLCJVZGllcmVzaXNzbWFsbCIsIllhY3V0ZXNtYWxsIiwiVGhvcm5zbWFsbCIsIllkaWVyZXNpc3NtYWxsIl0sQ3I9WyIubm90ZGVmIiwic3BhY2UiLCJkb2xsYXJvbGRzdHlsZSIsImRvbGxhcnN1cGVyaW9yIiwicGFyZW5sZWZ0c3VwZXJpb3IiLCJwYXJlbnJpZ2h0c3VwZXJpb3IiLCJ0d29kb3RlbmxlYWRlciIsIm9uZWRvdGVubGVhZGVyIiwiY29tbWEiLCJoeXBoZW4iLCJwZXJpb2QiLCJmcmFjdGlvbiIsInplcm9vbGRzdHlsZSIsIm9uZW9sZHN0eWxlIiwidHdvb2xkc3R5bGUiLCJ0aHJlZW9sZHN0eWxlIiwiZm91cm9sZHN0eWxlIiwiZml2ZW9sZHN0eWxlIiwic2l4b2xkc3R5bGUiLCJzZXZlbm9sZHN0eWxlIiwiZWlnaHRvbGRzdHlsZSIsIm5pbmVvbGRzdHlsZSIsImNvbG9uIiwic2VtaWNvbG9uIiwiY29tbWFzdXBlcmlvciIsInRocmVlcXVhcnRlcnNlbWRhc2giLCJwZXJpb2RzdXBlcmlvciIsImFzdXBlcmlvciIsImJzdXBlcmlvciIsImNlbnRzdXBlcmlvciIsImRzdXBlcmlvciIsImVzdXBlcmlvciIsImlzdXBlcmlvciIsImxzdXBlcmlvciIsIm1zdXBlcmlvciIsIm5zdXBlcmlvciIsIm9zdXBlcmlvciIsInJzdXBlcmlvciIsInNzdXBlcmlvciIsInRzdXBlcmlvciIsImZmIiwiZmkiLCJmbCIsImZmaSIsImZmbCIsInBhcmVubGVmdGluZmVyaW9yIiwicGFyZW5yaWdodGluZmVyaW9yIiwiaHlwaGVuc3VwZXJpb3IiLCJjb2xvbm1vbmV0YXJ5Iiwib25lZml0dGVkIiwicnVwaWFoIiwiY2VudG9sZHN0eWxlIiwiZmlndXJlZGFzaCIsImh5cGhlbmluZmVyaW9yIiwib25lcXVhcnRlciIsIm9uZWhhbGYiLCJ0aHJlZXF1YXJ0ZXJzIiwib25lZWlnaHRoIiwidGhyZWVlaWdodGhzIiwiZml2ZWVpZ2h0aHMiLCJzZXZlbmVpZ2h0aHMiLCJvbmV0aGlyZCIsInR3b3RoaXJkcyIsInplcm9zdXBlcmlvciIsIm9uZXN1cGVyaW9yIiwidHdvc3VwZXJpb3IiLCJ0aHJlZXN1cGVyaW9yIiwiZm91cnN1cGVyaW9yIiwiZml2ZXN1cGVyaW9yIiwic2l4c3VwZXJpb3IiLCJzZXZlbnN1cGVyaW9yIiwiZWlnaHRzdXBlcmlvciIsIm5pbmVzdXBlcmlvciIsInplcm9pbmZlcmlvciIsIm9uZWluZmVyaW9yIiwidHdvaW5mZXJpb3IiLCJ0aHJlZWluZmVyaW9yIiwiZm91cmluZmVyaW9yIiwiZml2ZWluZmVyaW9yIiwic2l4aW5mZXJpb3IiLCJzZXZlbmluZmVyaW9yIiwiZWlnaHRpbmZlcmlvciIsIm5pbmVpbmZlcmlvciIsImNlbnRpbmZlcmlvciIsImRvbGxhcmluZmVyaW9yIiwicGVyaW9kaW5mZXJpb3IiLCJjb21tYWluZmVyaW9yIl0sdnI9WyIubm90ZGVmIiwic3BhY2UiLCJleGNsYW0iLCJxdW90ZWRibCIsIm51bWJlcnNpZ24iLCJkb2xsYXIiLCJwZXJjZW50IiwiYW1wZXJzYW5kIiwicXVvdGVyaWdodCIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwicXVvdGVsZWZ0IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJicmFjZWxlZnQiLCJiYXIiLCJicmFjZXJpZ2h0IiwiYXNjaWl0aWxkZSIsImV4Y2xhbWRvd24iLCJjZW50Iiwic3RlcmxpbmciLCJmcmFjdGlvbiIsInllbiIsImZsb3JpbiIsInNlY3Rpb24iLCJjdXJyZW5jeSIsInF1b3Rlc2luZ2xlIiwicXVvdGVkYmxsZWZ0IiwiZ3VpbGxlbW90bGVmdCIsImd1aWxzaW5nbGxlZnQiLCJndWlsc2luZ2xyaWdodCIsImZpIiwiZmwiLCJlbmRhc2giLCJkYWdnZXIiLCJkYWdnZXJkYmwiLCJwZXJpb2RjZW50ZXJlZCIsInBhcmFncmFwaCIsImJ1bGxldCIsInF1b3Rlc2luZ2xiYXNlIiwicXVvdGVkYmxiYXNlIiwicXVvdGVkYmxyaWdodCIsImd1aWxsZW1vdHJpZ2h0IiwiZWxsaXBzaXMiLCJwZXJ0aG91c2FuZCIsInF1ZXN0aW9uZG93biIsImdyYXZlIiwiYWN1dGUiLCJjaXJjdW1mbGV4IiwidGlsZGUiLCJtYWNyb24iLCJicmV2ZSIsImRvdGFjY2VudCIsImRpZXJlc2lzIiwicmluZyIsImNlZGlsbGEiLCJodW5nYXJ1bWxhdXQiLCJvZ29uZWsiLCJjYXJvbiIsImVtZGFzaCIsIkFFIiwib3JkZmVtaW5pbmUiLCJMc2xhc2giLCJPc2xhc2giLCJPRSIsIm9yZG1hc2N1bGluZSIsImFlIiwiZG90bGVzc2kiLCJsc2xhc2giLCJvc2xhc2giLCJvZSIsImdlcm1hbmRibHMiLCJvbmVzdXBlcmlvciIsImxvZ2ljYWxub3QiLCJtdSIsInRyYWRlbWFyayIsIkV0aCIsIm9uZWhhbGYiLCJwbHVzbWludXMiLCJUaG9ybiIsIm9uZXF1YXJ0ZXIiLCJkaXZpZGUiLCJicm9rZW5iYXIiLCJkZWdyZWUiLCJ0aG9ybiIsInRocmVlcXVhcnRlcnMiLCJ0d29zdXBlcmlvciIsInJlZ2lzdGVyZWQiLCJtaW51cyIsImV0aCIsIm11bHRpcGx5IiwidGhyZWVzdXBlcmlvciIsImNvcHlyaWdodCIsIkFhY3V0ZSIsIkFjaXJjdW1mbGV4IiwiQWRpZXJlc2lzIiwiQWdyYXZlIiwiQXJpbmciLCJBdGlsZGUiLCJDY2VkaWxsYSIsIkVhY3V0ZSIsIkVjaXJjdW1mbGV4IiwiRWRpZXJlc2lzIiwiRWdyYXZlIiwiSWFjdXRlIiwiSWNpcmN1bWZsZXgiLCJJZGllcmVzaXMiLCJJZ3JhdmUiLCJOdGlsZGUiLCJPYWN1dGUiLCJPY2lyY3VtZmxleCIsIk9kaWVyZXNpcyIsIk9ncmF2ZSIsIk90aWxkZSIsIlNjYXJvbiIsIlVhY3V0ZSIsIlVjaXJjdW1mbGV4IiwiVWRpZXJlc2lzIiwiVWdyYXZlIiwiWWFjdXRlIiwiWWRpZXJlc2lzIiwiWmNhcm9uIiwiYWFjdXRlIiwiYWNpcmN1bWZsZXgiLCJhZGllcmVzaXMiLCJhZ3JhdmUiLCJhcmluZyIsImF0aWxkZSIsImNjZWRpbGxhIiwiZWFjdXRlIiwiZWNpcmN1bWZsZXgiLCJlZGllcmVzaXMiLCJlZ3JhdmUiLCJpYWN1dGUiLCJpY2lyY3VtZmxleCIsImlkaWVyZXNpcyIsImlncmF2ZSIsIm50aWxkZSIsIm9hY3V0ZSIsIm9jaXJjdW1mbGV4Iiwib2RpZXJlc2lzIiwib2dyYXZlIiwib3RpbGRlIiwic2Nhcm9uIiwidWFjdXRlIiwidWNpcmN1bWZsZXgiLCJ1ZGllcmVzaXMiLCJ1Z3JhdmUiLCJ5YWN1dGUiLCJ5ZGllcmVzaXMiLCJ6Y2Fyb24iLCJleGNsYW1zbWFsbCIsIkh1bmdhcnVtbGF1dHNtYWxsIiwiZG9sbGFyb2xkc3R5bGUiLCJkb2xsYXJzdXBlcmlvciIsImFtcGVyc2FuZHNtYWxsIiwiQWN1dGVzbWFsbCIsInBhcmVubGVmdHN1cGVyaW9yIiwicGFyZW5yaWdodHN1cGVyaW9yIiwidHdvZG90ZW5sZWFkZXIiLCJvbmVkb3RlbmxlYWRlciIsInplcm9vbGRzdHlsZSIsIm9uZW9sZHN0eWxlIiwidHdvb2xkc3R5bGUiLCJ0aHJlZW9sZHN0eWxlIiwiZm91cm9sZHN0eWxlIiwiZml2ZW9sZHN0eWxlIiwic2l4b2xkc3R5bGUiLCJzZXZlbm9sZHN0eWxlIiwiZWlnaHRvbGRzdHlsZSIsIm5pbmVvbGRzdHlsZSIsImNvbW1hc3VwZXJpb3IiLCJ0aHJlZXF1YXJ0ZXJzZW1kYXNoIiwicGVyaW9kc3VwZXJpb3IiLCJxdWVzdGlvbnNtYWxsIiwiYXN1cGVyaW9yIiwiYnN1cGVyaW9yIiwiY2VudHN1cGVyaW9yIiwiZHN1cGVyaW9yIiwiZXN1cGVyaW9yIiwiaXN1cGVyaW9yIiwibHN1cGVyaW9yIiwibXN1cGVyaW9yIiwibnN1cGVyaW9yIiwib3N1cGVyaW9yIiwicnN1cGVyaW9yIiwic3N1cGVyaW9yIiwidHN1cGVyaW9yIiwiZmYiLCJmZmkiLCJmZmwiLCJwYXJlbmxlZnRpbmZlcmlvciIsInBhcmVucmlnaHRpbmZlcmlvciIsIkNpcmN1bWZsZXhzbWFsbCIsImh5cGhlbnN1cGVyaW9yIiwiR3JhdmVzbWFsbCIsIkFzbWFsbCIsIkJzbWFsbCIsIkNzbWFsbCIsIkRzbWFsbCIsIkVzbWFsbCIsIkZzbWFsbCIsIkdzbWFsbCIsIkhzbWFsbCIsIklzbWFsbCIsIkpzbWFsbCIsIktzbWFsbCIsIkxzbWFsbCIsIk1zbWFsbCIsIk5zbWFsbCIsIk9zbWFsbCIsIlBzbWFsbCIsIlFzbWFsbCIsIlJzbWFsbCIsIlNzbWFsbCIsIlRzbWFsbCIsIlVzbWFsbCIsIlZzbWFsbCIsIldzbWFsbCIsIlhzbWFsbCIsIllzbWFsbCIsIlpzbWFsbCIsImNvbG9ubW9uZXRhcnkiLCJvbmVmaXR0ZWQiLCJydXBpYWgiLCJUaWxkZXNtYWxsIiwiZXhjbGFtZG93bnNtYWxsIiwiY2VudG9sZHN0eWxlIiwiTHNsYXNoc21hbGwiLCJTY2Fyb25zbWFsbCIsIlpjYXJvbnNtYWxsIiwiRGllcmVzaXNzbWFsbCIsIkJyZXZlc21hbGwiLCJDYXJvbnNtYWxsIiwiRG90YWNjZW50c21hbGwiLCJNYWNyb25zbWFsbCIsImZpZ3VyZWRhc2giLCJoeXBoZW5pbmZlcmlvciIsIk9nb25la3NtYWxsIiwiUmluZ3NtYWxsIiwiQ2VkaWxsYXNtYWxsIiwicXVlc3Rpb25kb3duc21hbGwiLCJvbmVlaWdodGgiLCJ0aHJlZWVpZ2h0aHMiLCJmaXZlZWlnaHRocyIsInNldmVuZWlnaHRocyIsIm9uZXRoaXJkIiwidHdvdGhpcmRzIiwiemVyb3N1cGVyaW9yIiwiZm91cnN1cGVyaW9yIiwiZml2ZXN1cGVyaW9yIiwic2l4c3VwZXJpb3IiLCJzZXZlbnN1cGVyaW9yIiwiZWlnaHRzdXBlcmlvciIsIm5pbmVzdXBlcmlvciIsInplcm9pbmZlcmlvciIsIm9uZWluZmVyaW9yIiwidHdvaW5mZXJpb3IiLCJ0aHJlZWluZmVyaW9yIiwiZm91cmluZmVyaW9yIiwiZml2ZWluZmVyaW9yIiwic2l4aW5mZXJpb3IiLCJzZXZlbmluZmVyaW9yIiwiZWlnaHRpbmZlcmlvciIsIm5pbmVpbmZlcmlvciIsImNlbnRpbmZlcmlvciIsImRvbGxhcmluZmVyaW9yIiwicGVyaW9kaW5mZXJpb3IiLCJjb21tYWluZmVyaW9yIiwiQWdyYXZlc21hbGwiLCJBYWN1dGVzbWFsbCIsIkFjaXJjdW1mbGV4c21hbGwiLCJBdGlsZGVzbWFsbCIsIkFkaWVyZXNpc3NtYWxsIiwiQXJpbmdzbWFsbCIsIkFFc21hbGwiLCJDY2VkaWxsYXNtYWxsIiwiRWdyYXZlc21hbGwiLCJFYWN1dGVzbWFsbCIsIkVjaXJjdW1mbGV4c21hbGwiLCJFZGllcmVzaXNzbWFsbCIsIklncmF2ZXNtYWxsIiwiSWFjdXRlc21hbGwiLCJJY2lyY3VtZmxleHNtYWxsIiwiSWRpZXJlc2lzc21hbGwiLCJFdGhzbWFsbCIsIk50aWxkZXNtYWxsIiwiT2dyYXZlc21hbGwiLCJPYWN1dGVzbWFsbCIsIk9jaXJjdW1mbGV4c21hbGwiLCJPdGlsZGVzbWFsbCIsIk9kaWVyZXNpc3NtYWxsIiwiT0VzbWFsbCIsIk9zbGFzaHNtYWxsIiwiVWdyYXZlc21hbGwiLCJVYWN1dGVzbWFsbCIsIlVjaXJjdW1mbGV4c21hbGwiLCJVZGllcmVzaXNzbWFsbCIsIllhY3V0ZXNtYWxsIiwiVGhvcm5zbWFsbCIsIllkaWVyZXNpc3NtYWxsIiwiMDAxLjAwMCIsIjAwMS4wMDEiLCIwMDEuMDAyIiwiMDAxLjAwMyIsIkJsYWNrIiwiQm9sZCIsIkJvb2siLCJMaWdodCIsIk1lZGl1bSIsIlJlZ3VsYXIiLCJSb21hbiIsIlNlbWlib2xkIl0sRnI9MzkxLElyPVtudWxsLHtpZDoiaHN0ZW0iLG1pbjoyLHN0YWNrQ2xlYXJpbmc6ITAsc3RlbTohMH0sbnVsbCx7aWQ6InZzdGVtIixtaW46MixzdGFja0NsZWFyaW5nOiEwLHN0ZW06ITB9LHtpZDoidm1vdmV0byIsbWluOjEsc3RhY2tDbGVhcmluZzohMH0se2lkOiJybGluZXRvIixtaW46MixyZXNldFN0YWNrOiEwfSx7aWQ6ImhsaW5ldG8iLG1pbjoxLHJlc2V0U3RhY2s6ITB9LHtpZDoidmxpbmV0byIsbWluOjEscmVzZXRTdGFjazohMH0se2lkOiJycmN1cnZldG8iLG1pbjo2LHJlc2V0U3RhY2s6ITB9LG51bGwse2lkOiJjYWxsc3ViciIsbWluOjEsdW5kZWZTdGFjazohMH0se2lkOiJyZXR1cm4iLG1pbjowLHVuZGVmU3RhY2s6ITB9LG51bGwsbnVsbCx7aWQ6ImVuZGNoYXIiLG1pbjowLHN0YWNrQ2xlYXJpbmc6ITB9LG51bGwsbnVsbCxudWxsLHtpZDoiaHN0ZW1obSIsbWluOjIsc3RhY2tDbGVhcmluZzohMCxzdGVtOiEwfSx7aWQ6ImhpbnRtYXNrIixtaW46MCxzdGFja0NsZWFyaW5nOiEwfSx7aWQ6ImNudHJtYXNrIixtaW46MCxzdGFja0NsZWFyaW5nOiEwfSx7aWQ6InJtb3ZldG8iLG1pbjoyLHN0YWNrQ2xlYXJpbmc6ITB9LHtpZDoiaG1vdmV0byIsbWluOjEsc3RhY2tDbGVhcmluZzohMH0se2lkOiJ2c3RlbWhtIixtaW46MixzdGFja0NsZWFyaW5nOiEwLHN0ZW06ITB9LHtpZDoicmN1cnZlbGluZSIsbWluOjgscmVzZXRTdGFjazohMH0se2lkOiJybGluZWN1cnZlIixtaW46OCxyZXNldFN0YWNrOiEwfSx7aWQ6InZ2Y3VydmV0byIsbWluOjQscmVzZXRTdGFjazohMH0se2lkOiJoaGN1cnZldG8iLG1pbjo0LHJlc2V0U3RhY2s6ITB9LG51bGwse2lkOiJjYWxsZ3N1YnIiLG1pbjoxLHVuZGVmU3RhY2s6ITB9LHtpZDoidmhjdXJ2ZXRvIixtaW46NCxyZXNldFN0YWNrOiEwfSx7aWQ6Imh2Y3VydmV0byIsbWluOjQscmVzZXRTdGFjazohMH1dLFRyPVtudWxsLG51bGwsbnVsbCx7aWQ6ImFuZCIsbWluOjIsc3RhY2tEZWx0YTotMX0se2lkOiJvciIsbWluOjIsc3RhY2tEZWx0YTotMX0se2lkOiJub3QiLG1pbjoxLHN0YWNrRGVsdGE6MH0sbnVsbCxudWxsLG51bGwse2lkOiJhYnMiLG1pbjoxLHN0YWNrRGVsdGE6MH0se2lkOiJhZGQiLG1pbjoyLHN0YWNrRGVsdGE6LTEsc3RhY2tGbihlLHQpe2VbdC0yXT1lW3QtMl0rZVt0LTFdfX0se2lkOiJzdWIiLG1pbjoyLHN0YWNrRGVsdGE6LTEsc3RhY2tGbihlLHQpe2VbdC0yXT1lW3QtMl0tZVt0LTFdfX0se2lkOiJkaXYiLG1pbjoyLHN0YWNrRGVsdGE6LTEsc3RhY2tGbihlLHQpe2VbdC0yXT1lW3QtMl0vZVt0LTFdfX0sbnVsbCx7aWQ6Im5lZyIsbWluOjEsc3RhY2tEZWx0YTowLHN0YWNrRm4oZSx0KXtlW3QtMV09LWVbdC0xXX19LHtpZDoiZXEiLG1pbjoyLHN0YWNrRGVsdGE6LTF9LG51bGwsbnVsbCx7aWQ6ImRyb3AiLG1pbjoxLHN0YWNrRGVsdGE6LTF9LG51bGwse2lkOiJwdXQiLG1pbjoyLHN0YWNrRGVsdGE6LTJ9LHtpZDoiZ2V0IixtaW46MSxzdGFja0RlbHRhOjB9LHtpZDoiaWZlbHNlIixtaW46NCxzdGFja0RlbHRhOi0zfSx7aWQ6InJhbmRvbSIsbWluOjAsc3RhY2tEZWx0YToxfSx7aWQ6Im11bCIsbWluOjIsc3RhY2tEZWx0YTotMSxzdGFja0ZuKGUsdCl7ZVt0LTJdPWVbdC0yXSplW3QtMV19fSxudWxsLHtpZDoic3FydCIsbWluOjEsc3RhY2tEZWx0YTowfSx7aWQ6ImR1cCIsbWluOjEsc3RhY2tEZWx0YToxfSx7aWQ6ImV4Y2giLG1pbjoyLHN0YWNrRGVsdGE6MH0se2lkOiJpbmRleCIsbWluOjIsc3RhY2tEZWx0YTowfSx7aWQ6InJvbGwiLG1pbjozLHN0YWNrRGVsdGE6LTJ9LG51bGwsbnVsbCxudWxsLHtpZDoiaGZsZXgiLG1pbjo3LHJlc2V0U3RhY2s6ITB9LHtpZDoiZmxleCIsbWluOjEzLHJlc2V0U3RhY2s6ITB9LHtpZDoiaGZsZXgxIixtaW46OSxyZXNldFN0YWNrOiEwfSx7aWQ6ImZsZXgxIixtaW46MTEscmVzZXRTdGFjazohMH1dO2NsYXNzIENGRlBhcnNlcntjb25zdHJ1Y3RvcihlLHQsYSl7dGhpcy5ieXRlcz1lLmdldEJ5dGVzKCk7dGhpcy5wcm9wZXJ0aWVzPXQ7dGhpcy5zZWFjQW5hbHlzaXNFbmFibGVkPSEhYX1wYXJzZSgpe2NvbnN0IGU9dGhpcy5wcm9wZXJ0aWVzLHQ9bmV3IENGRjt0aGlzLmNmZj10O2NvbnN0IGE9dGhpcy5wYXJzZUhlYWRlcigpLHI9dGhpcy5wYXJzZUluZGV4KGEuZW5kUG9zKSxpPXRoaXMucGFyc2VJbmRleChyLmVuZFBvcyksbj10aGlzLnBhcnNlSW5kZXgoaS5lbmRQb3MpLHM9dGhpcy5wYXJzZUluZGV4KG4uZW5kUG9zKSxvPXRoaXMucGFyc2VEaWN0KGkub2JqLmdldCgwKSksYz10aGlzLmNyZWF0ZURpY3QoQ0ZGVG9wRGljdCxvLHQuc3RyaW5ncyk7dC5oZWFkZXI9YS5vYmo7dC5uYW1lcz10aGlzLnBhcnNlTmFtZUluZGV4KHIub2JqKTt0LnN0cmluZ3M9dGhpcy5wYXJzZVN0cmluZ0luZGV4KG4ub2JqKTt0LnRvcERpY3Q9Yzt0Lmdsb2JhbFN1YnJJbmRleD1zLm9iajt0aGlzLnBhcnNlUHJpdmF0ZURpY3QodC50b3BEaWN0KTt0LmlzQ0lERm9udD1jLmhhc05hbWUoIlJPUyIpO2NvbnN0IGw9Yy5nZXRCeU5hbWUoIkNoYXJTdHJpbmdzIiksaD10aGlzLnBhcnNlSW5kZXgobCkub2JqLHU9Yy5nZXRCeU5hbWUoIkZvbnRNYXRyaXgiKTt1JiYoZS5mb250TWF0cml4PXUpO2NvbnN0IGQ9Yy5nZXRCeU5hbWUoIkZvbnRCQm94Iik7aWYoZCl7ZS5hc2NlbnQ9TWF0aC5tYXgoZFszXSxkWzFdKTtlLmRlc2NlbnQ9TWF0aC5taW4oZFsxXSxkWzNdKTtlLmFzY2VudFNjYWxlZD0hMH1sZXQgZixnO2lmKHQuaXNDSURGb250KXtjb25zdCBlPXRoaXMucGFyc2VJbmRleChjLmdldEJ5TmFtZSgiRkRBcnJheSIpKS5vYmo7Zm9yKGxldCBhPTAscj1lLmNvdW50O2E8cjsrK2Epe2NvbnN0IHI9ZS5nZXQoYSksaT10aGlzLmNyZWF0ZURpY3QoQ0ZGVG9wRGljdCx0aGlzLnBhcnNlRGljdChyKSx0LnN0cmluZ3MpO3RoaXMucGFyc2VQcml2YXRlRGljdChpKTt0LmZkQXJyYXkucHVzaChpKX1nPW51bGw7Zj10aGlzLnBhcnNlQ2hhcnNldHMoYy5nZXRCeU5hbWUoImNoYXJzZXQiKSxoLmNvdW50LHQuc3RyaW5ncywhMCk7dC5mZFNlbGVjdD10aGlzLnBhcnNlRkRTZWxlY3QoYy5nZXRCeU5hbWUoIkZEU2VsZWN0IiksaC5jb3VudCl9ZWxzZXtmPXRoaXMucGFyc2VDaGFyc2V0cyhjLmdldEJ5TmFtZSgiY2hhcnNldCIpLGguY291bnQsdC5zdHJpbmdzLCExKTtnPXRoaXMucGFyc2VFbmNvZGluZyhjLmdldEJ5TmFtZSgiRW5jb2RpbmciKSxlLHQuc3RyaW5ncyxmLmNoYXJzZXQpfXQuY2hhcnNldD1mO3QuZW5jb2Rpbmc9Zztjb25zdCBwPXRoaXMucGFyc2VDaGFyU3RyaW5ncyh7Y2hhclN0cmluZ3M6aCxsb2NhbFN1YnJJbmRleDpjLnByaXZhdGVEaWN0LnN1YnJzSW5kZXgsZ2xvYmFsU3VickluZGV4OnMub2JqLGZkU2VsZWN0OnQuZmRTZWxlY3QsZmRBcnJheTp0LmZkQXJyYXkscHJpdmF0ZURpY3Q6Yy5wcml2YXRlRGljdH0pO3QuY2hhclN0cmluZ3M9cC5jaGFyU3RyaW5nczt0LnNlYWNzPXAuc2VhY3M7dC53aWR0aHM9cC53aWR0aHM7cmV0dXJuIHR9cGFyc2VIZWFkZXIoKXtsZXQgZT10aGlzLmJ5dGVzO2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IGE9MDtmb3IoO2E8dCYmMSE9PWVbYV07KSsrYTtpZihhPj10KXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBDRkYgaGVhZGVyIik7aWYoMCE9PWEpe2luZm8oImNmZiBkYXRhIGlzIHNoaWZ0ZWQiKTtlPWUuc3ViYXJyYXkoYSk7dGhpcy5ieXRlcz1lfWNvbnN0IHI9ZVswXSxpPWVbMV0sbj1lWzJdLHM9ZVszXTtyZXR1cm57b2JqOm5ldyBDRkZIZWFkZXIocixpLG4scyksZW5kUG9zOm59fXBhcnNlRGljdChlKXtsZXQgdD0wO2Z1bmN0aW9uIHBhcnNlT3BlcmFuZCgpe2xldCBhPWVbdCsrXTtpZigzMD09PWEpcmV0dXJuIGZ1bmN0aW9uIHBhcnNlRmxvYXRPcGVyYW5kKCl7bGV0IGE9IiI7Y29uc3Qgcj0xNSxpPVsiMCIsIjEiLCIyIiwiMyIsIjQiLCI1IiwiNiIsIjciLCI4IiwiOSIsIi4iLCJFIiwiRS0iLG51bGwsIi0iXSxuPWUubGVuZ3RoO2Zvcig7dDxuOyl7Y29uc3Qgbj1lW3QrK10scz1uPj40LG89MTUmbjtpZihzPT09cilicmVhazthKz1pW3NdO2lmKG89PT1yKWJyZWFrO2ErPWlbb119cmV0dXJuIHBhcnNlRmxvYXQoYSl9KCk7aWYoMjg9PT1hKXthPXJlYWRJbnQxNihlLHQpO3QrPTI7cmV0dXJuIGF9aWYoMjk9PT1hKXthPWVbdCsrXTthPWE8PDh8ZVt0KytdO2E9YTw8OHxlW3QrK107YT1hPDw4fGVbdCsrXTtyZXR1cm4gYX1pZihhPj0zMiYmYTw9MjQ2KXJldHVybiBhLTEzOTtpZihhPj0yNDcmJmE8PTI1MClyZXR1cm4gMjU2KihhLTI0NykrZVt0KytdKzEwODtpZihhPj0yNTEmJmE8PTI1NClyZXR1cm4tMjU2KihhLTI1MSktZVt0KytdLTEwODt3YXJuKCdDRkZQYXJzZXJfcGFyc2VEaWN0OiAiJythKyciIGlzIGEgcmVzZXJ2ZWQgY29tbWFuZC4nKTtyZXR1cm4gTmFOfWxldCBhPVtdO2NvbnN0IHI9W107dD0wO2NvbnN0IGk9ZS5sZW5ndGg7Zm9yKDt0PGk7KXtsZXQgaT1lW3RdO2lmKGk8PTIxKXsxMj09PWkmJihpPWk8PDh8ZVsrK3RdKTtyLnB1c2goW2ksYV0pO2E9W107Kyt0fWVsc2UgYS5wdXNoKHBhcnNlT3BlcmFuZCgpKX1yZXR1cm4gcn1wYXJzZUluZGV4KGUpe2NvbnN0IHQ9bmV3IENGRkluZGV4LGE9dGhpcy5ieXRlcyxyPWFbZSsrXTw8OHxhW2UrK10saT1bXTtsZXQgbixzLG89ZTtpZigwIT09cil7Y29uc3QgdD1hW2UrK10sYz1lKyhyKzEpKnQtMTtmb3Iobj0wLHM9cisxO248czsrK24pe2xldCByPTA7Zm9yKGxldCBpPTA7aTx0OysraSl7cjw8PTg7cis9YVtlKytdfWkucHVzaChjK3IpfW89aVtyXX1mb3Iobj0wLHM9aS5sZW5ndGgtMTtuPHM7KytuKXtjb25zdCBlPWlbbl0scj1pW24rMV07dC5hZGQoYS5zdWJhcnJheShlLHIpKX1yZXR1cm57b2JqOnQsZW5kUG9zOm99fXBhcnNlTmFtZUluZGV4KGUpe2NvbnN0IHQ9W107Zm9yKGxldCBhPTAscj1lLmNvdW50O2E8cjsrK2Epe2NvbnN0IHI9ZS5nZXQoYSk7dC5wdXNoKGJ5dGVzVG9TdHJpbmcocikpfXJldHVybiB0fXBhcnNlU3RyaW5nSW5kZXgoZSl7Y29uc3QgdD1uZXcgQ0ZGU3RyaW5ncztmb3IobGV0IGE9MCxyPWUuY291bnQ7YTxyOysrYSl7Y29uc3Qgcj1lLmdldChhKTt0LmFkZChieXRlc1RvU3RyaW5nKHIpKX1yZXR1cm4gdH1jcmVhdGVEaWN0KGUsdCxhKXtjb25zdCByPW5ldyBlKGEpO2Zvcihjb25zdFtlLGFdb2YgdClyLnNldEJ5S2V5KGUsYSk7cmV0dXJuIHJ9cGFyc2VDaGFyU3RyaW5nKGUsdCxhLHIpe2lmKCF0fHxlLmNhbGxEZXB0aD4xMClyZXR1cm4hMTtsZXQgaT1lLnN0YWNrU2l6ZTtjb25zdCBuPWUuc3RhY2s7bGV0IHM9dC5sZW5ndGg7Zm9yKGxldCBvPTA7bzxzOyl7Y29uc3QgYz10W28rK107bGV0IGw9bnVsbDtpZigxMj09PWMpe2NvbnN0IGU9dFtvKytdO2lmKDA9PT1lKXt0W28tMl09MTM5O3Rbby0xXT0yMjtpPTB9ZWxzZSBsPVRyW2VdfWVsc2UgaWYoMjg9PT1jKXtuW2ldPXJlYWRJbnQxNih0LG8pO28rPTI7aSsrfWVsc2UgaWYoMTQ9PT1jKXtpZihpPj00KXtpLT00O2lmKHRoaXMuc2VhY0FuYWx5c2lzRW5hYmxlZCl7ZS5zZWFjPW4uc2xpY2UoaSxpKzQpO3JldHVybiExfX1sPUlyW2NdfWVsc2UgaWYoYz49MzImJmM8PTI0Nil7bltpXT1jLTEzOTtpKyt9ZWxzZSBpZihjPj0yNDcmJmM8PTI1NCl7bltpXT1jPDI1MT8oYy0yNDc8PDgpK3Rbb10rMTA4Oi0oYy0yNTE8PDgpLXRbb10tMTA4O28rKztpKyt9ZWxzZSBpZigyNTU9PT1jKXtuW2ldPSh0W29dPDwyNHx0W28rMV08PDE2fHRbbysyXTw8OHx0W28rM10pLzY1NTM2O28rPTQ7aSsrfWVsc2UgaWYoMTk9PT1jfHwyMD09PWMpe2UuaGludHMrPWk+PjE7aWYoMD09PWUuaGludHMpe3QuY29weVdpdGhpbihvLTEsbywtMSk7by09MTtzLT0xO2NvbnRpbnVlfW8rPWUuaGludHMrNz4+MztpJT0yO2w9SXJbY119ZWxzZXtpZigxMD09PWN8fDI5PT09Yyl7Y29uc3QgdD0xMD09PWM/YTpyO2lmKCF0KXtsPUlyW2NdO3dhcm4oIk1pc3Npbmcgc3VicnNJbmRleCBmb3IgIitsLmlkKTtyZXR1cm4hMX1sZXQgcz0zMjc2ODt0LmNvdW50PDEyNDA/cz0xMDc6dC5jb3VudDwzMzkwMCYmKHM9MTEzMSk7Y29uc3Qgbz1uWy0taV0rcztpZihvPDB8fG8+PXQuY291bnR8fGlzTmFOKG8pKXtsPUlyW2NdO3dhcm4oIk91dCBvZiBib3VuZHMgc3VickluZGV4IGZvciAiK2wuaWQpO3JldHVybiExfWUuc3RhY2tTaXplPWk7ZS5jYWxsRGVwdGgrKztpZighdGhpcy5wYXJzZUNoYXJTdHJpbmcoZSx0LmdldChvKSxhLHIpKXJldHVybiExO2UuY2FsbERlcHRoLS07aT1lLnN0YWNrU2l6ZTtjb250aW51ZX1pZigxMT09PWMpe2Uuc3RhY2tTaXplPWk7cmV0dXJuITB9aWYoMD09PWMmJm89PT10Lmxlbmd0aCl7dFtvLTFdPTE0O2w9SXJbMTRdfWVsc2V7aWYoOT09PWMpe3QuY29weVdpdGhpbihvLTEsbywtMSk7by09MTtzLT0xO2NvbnRpbnVlfWw9SXJbY119fWlmKGwpe2lmKGwuc3RlbSl7ZS5oaW50cys9aT4+MTtpZigzPT09Y3x8MjM9PT1jKWUuaGFzVlN0ZW1zPSEwO2Vsc2UgaWYoZS5oYXNWU3RlbXMmJigxPT09Y3x8MTg9PT1jKSl7d2FybigiQ0ZGIHN0ZW0gaGludHMgYXJlIGluIHdyb25nIG9yZGVyIik7dFtvLTFdPTE9PT1jPzM6MjN9fWlmKCJtaW4iaW4gbCYmIWUudW5kZWZTdGFjayYmaTxsLm1pbil7d2FybigiTm90IGVub3VnaCBwYXJhbWV0ZXJzIGZvciAiK2wuaWQrIjsgYWN0dWFsOiAiK2krIiwgZXhwZWN0ZWQ6ICIrbC5taW4pO2lmKDA9PT1pKXt0W28tMV09MTQ7cmV0dXJuITB9cmV0dXJuITF9aWYoZS5maXJzdFN0YWNrQ2xlYXJpbmcmJmwuc3RhY2tDbGVhcmluZyl7ZS5maXJzdFN0YWNrQ2xlYXJpbmc9ITE7aS09bC5taW47aT49MiYmbC5zdGVtP2klPTI6aT4xJiZ3YXJuKCJGb3VuZCB0b28gbWFueSBwYXJhbWV0ZXJzIGZvciBzdGFjay1jbGVhcmluZyBjb21tYW5kIik7aT4wJiYoZS53aWR0aD1uW2ktMV0pfWlmKCJzdGFja0RlbHRhImluIGwpeyJzdGFja0ZuImluIGwmJmwuc3RhY2tGbihuLGkpO2krPWwuc3RhY2tEZWx0YX1lbHNlIGlmKGwuc3RhY2tDbGVhcmluZylpPTA7ZWxzZSBpZihsLnJlc2V0U3RhY2spe2k9MDtlLnVuZGVmU3RhY2s9ITF9ZWxzZSBpZihsLnVuZGVmU3RhY2spe2k9MDtlLnVuZGVmU3RhY2s9ITA7ZS5maXJzdFN0YWNrQ2xlYXJpbmc9ITF9fX1zPHQubGVuZ3RoJiZ0LmZpbGwoMTQscyk7ZS5zdGFja1NpemU9aTtyZXR1cm4hMH1wYXJzZUNoYXJTdHJpbmdzKHtjaGFyU3RyaW5nczplLGxvY2FsU3VickluZGV4OnQsZ2xvYmFsU3VickluZGV4OmEsZmRTZWxlY3Q6cixmZEFycmF5OmkscHJpdmF0ZURpY3Q6bn0pe2NvbnN0IHM9W10sbz1bXSxjPWUuY291bnQ7Zm9yKGxldCBsPTA7bDxjO2wrKyl7Y29uc3QgYz1lLmdldChsKSxoPXtjYWxsRGVwdGg6MCxzdGFja1NpemU6MCxzdGFjazpbXSx1bmRlZlN0YWNrOiEwLGhpbnRzOjAsZmlyc3RTdGFja0NsZWFyaW5nOiEwLHNlYWM6bnVsbCx3aWR0aDpudWxsLGhhc1ZTdGVtczohMX07bGV0IHU9ITAsZD1udWxsLGY9bjtpZihyJiZpLmxlbmd0aCl7Y29uc3QgZT1yLmdldEZESW5kZXgobCk7aWYoLTE9PT1lKXt3YXJuKCJHbHlwaCBpbmRleCBpcyBub3QgaW4gZmQgc2VsZWN0LiIpO3U9ITF9aWYoZT49aS5sZW5ndGgpe3dhcm4oIkludmFsaWQgZmQgaW5kZXggZm9yIGdseXBoIGluZGV4LiIpO3U9ITF9aWYodSl7Zj1pW2VdLnByaXZhdGVEaWN0O2Q9Zi5zdWJyc0luZGV4fX1lbHNlIHQmJihkPXQpO3UmJih1PXRoaXMucGFyc2VDaGFyU3RyaW5nKGgsYyxkLGEpKTtpZihudWxsIT09aC53aWR0aCl7Y29uc3QgZT1mLmdldEJ5TmFtZSgibm9taW5hbFdpZHRoWCIpO29bbF09ZStoLndpZHRofWVsc2V7Y29uc3QgZT1mLmdldEJ5TmFtZSgiZGVmYXVsdFdpZHRoWCIpO29bbF09ZX1udWxsIT09aC5zZWFjJiYoc1tsXT1oLnNlYWMpO3V8fGUuc2V0KGwsbmV3IFVpbnQ4QXJyYXkoWzE0XSkpfXJldHVybntjaGFyU3RyaW5nczplLHNlYWNzOnMsd2lkdGhzOm99fWVtcHR5UHJpdmF0ZURpY3Rpb25hcnkoZSl7Y29uc3QgdD10aGlzLmNyZWF0ZURpY3QoQ0ZGUHJpdmF0ZURpY3QsW10sZS5zdHJpbmdzKTtlLnNldEJ5S2V5KDE4LFswLDBdKTtlLnByaXZhdGVEaWN0PXR9cGFyc2VQcml2YXRlRGljdChlKXtpZighZS5oYXNOYW1lKCJQcml2YXRlIikpe3RoaXMuZW1wdHlQcml2YXRlRGljdGlvbmFyeShlKTtyZXR1cm59Y29uc3QgdD1lLmdldEJ5TmFtZSgiUHJpdmF0ZSIpO2lmKCFBcnJheS5pc0FycmF5KHQpfHwyIT09dC5sZW5ndGgpe2UucmVtb3ZlQnlOYW1lKCJQcml2YXRlIik7cmV0dXJufWNvbnN0IGE9dFswXSxyPXRbMV07aWYoMD09PWF8fHI+PXRoaXMuYnl0ZXMubGVuZ3RoKXt0aGlzLmVtcHR5UHJpdmF0ZURpY3Rpb25hcnkoZSk7cmV0dXJufWNvbnN0IGk9cithLG49dGhpcy5ieXRlcy5zdWJhcnJheShyLGkpLHM9dGhpcy5wYXJzZURpY3Qobiksbz10aGlzLmNyZWF0ZURpY3QoQ0ZGUHJpdmF0ZURpY3QscyxlLnN0cmluZ3MpO2UucHJpdmF0ZURpY3Q9bzswPT09by5nZXRCeU5hbWUoIkV4cGFuc2lvbkZhY3RvciIpJiZvLnNldEJ5TmFtZSgiRXhwYW5zaW9uRmFjdG9yIiwuMDYpO2lmKCFvLmdldEJ5TmFtZSgiU3VicnMiKSlyZXR1cm47Y29uc3QgYz1vLmdldEJ5TmFtZSgiU3VicnMiKSxsPXIrYztpZigwPT09Y3x8bD49dGhpcy5ieXRlcy5sZW5ndGgpe3RoaXMuZW1wdHlQcml2YXRlRGljdGlvbmFyeShlKTtyZXR1cm59Y29uc3QgaD10aGlzLnBhcnNlSW5kZXgobCk7by5zdWJyc0luZGV4PWgub2JqfXBhcnNlQ2hhcnNldHMoZSx0LGEscil7aWYoMD09PWUpcmV0dXJuIG5ldyBDRkZDaGFyc2V0KCEwLERyLklTT19BRE9CRSxBcik7aWYoMT09PWUpcmV0dXJuIG5ldyBDRkZDaGFyc2V0KCEwLERyLkVYUEVSVCxrcik7aWYoMj09PWUpcmV0dXJuIG5ldyBDRkZDaGFyc2V0KCEwLERyLkVYUEVSVF9TVUJTRVQsQ3IpO2NvbnN0IGk9dGhpcy5ieXRlcyxuPWUscz1pW2UrK10sbz1bcj8wOiIubm90ZGVmIl07bGV0IGMsbCxoO3QtPTE7c3dpdGNoKHMpe2Nhc2UgMDpmb3IoaD0wO2g8dDtoKyspe2M9aVtlKytdPDw4fGlbZSsrXTtvLnB1c2gocj9jOmEuZ2V0KGMpKX1icmVhaztjYXNlIDE6Zm9yKDtvLmxlbmd0aDw9dDspe2M9aVtlKytdPDw4fGlbZSsrXTtsPWlbZSsrXTtmb3IoaD0wO2g8PWw7aCsrKW8ucHVzaChyP2MrKzphLmdldChjKyspKX1icmVhaztjYXNlIDI6Zm9yKDtvLmxlbmd0aDw9dDspe2M9aVtlKytdPDw4fGlbZSsrXTtsPWlbZSsrXTw8OHxpW2UrK107Zm9yKGg9MDtoPD1sO2grKylvLnB1c2gocj9jKys6YS5nZXQoYysrKSl9YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlVua25vd24gY2hhcnNldCBmb3JtYXQiKX1jb25zdCB1PWUsZD1pLnN1YmFycmF5KG4sdSk7cmV0dXJuIG5ldyBDRkZDaGFyc2V0KCExLHMsbyxkKX1wYXJzZUVuY29kaW5nKGUsdCxhLHIpe2NvbnN0IGk9T2JqZWN0LmNyZWF0ZShudWxsKSxuPXRoaXMuYnl0ZXM7bGV0IHMsbyxjLGw9ITEsaD1udWxsO2lmKDA9PT1lfHwxPT09ZSl7bD0hMDtzPWU7Y29uc3QgdD1lP2FyOm5yO2ZvcihvPTAsYz1yLmxlbmd0aDtvPGM7bysrKXtjb25zdCBlPXQuaW5kZXhPZihyW29dKTstMSE9PWUmJihpW2VdPW8pfX1lbHNle2NvbnN0IHQ9ZTtzPW5bZSsrXTtzd2l0Y2goMTI3JnMpe2Nhc2UgMDpjb25zdCB0PW5bZSsrXTtmb3Iobz0xO288PXQ7bysrKWlbbltlKytdXT1vO2JyZWFrO2Nhc2UgMTpjb25zdCBhPW5bZSsrXTtsZXQgcj0xO2ZvcihvPTA7bzxhO28rKyl7Y29uc3QgdD1uW2UrK10sYT1uW2UrK107Zm9yKGxldCBlPXQ7ZTw9dCthO2UrKylpW2VdPXIrK31icmVhaztkZWZhdWx0OnRocm93IG5ldyBGb3JtYXRFcnJvcihgVW5rbm93biBlbmNvZGluZyBmb3JtYXQ6ICR7c30gaW4gQ0ZGYCl9Y29uc3QgYz1lO2lmKDEyOCZzKXtuW3RdJj0xMjc7IWZ1bmN0aW9uIHJlYWRTdXBwbGVtZW50KCl7Y29uc3QgdD1uW2UrK107Zm9yKG89MDtvPHQ7bysrKXtjb25zdCB0PW5bZSsrXSxzPShuW2UrK108PDgpKygyNTUmbltlKytdKTtpW3RdPXIuaW5kZXhPZihhLmdldChzKSl9fSgpfWg9bi5zdWJhcnJheSh0LGMpfXMmPTEyNztyZXR1cm4gbmV3IENGRkVuY29kaW5nKGwscyxpLGgpfXBhcnNlRkRTZWxlY3QoZSx0KXtjb25zdCBhPXRoaXMuYnl0ZXMscj1hW2UrK10saT1bXTtsZXQgbjtzd2l0Y2gocil7Y2FzZSAwOmZvcihuPTA7bjx0Oysrbil7Y29uc3QgdD1hW2UrK107aS5wdXNoKHQpfWJyZWFrO2Nhc2UgMzpjb25zdCBzPWFbZSsrXTw8OHxhW2UrK107Zm9yKG49MDtuPHM7KytuKXtsZXQgdD1hW2UrK108PDh8YVtlKytdO2lmKDA9PT1uJiYwIT09dCl7d2FybigicGFyc2VGRFNlbGVjdDogVGhlIGZpcnN0IHJhbmdlIG11c3QgaGF2ZSBhIGZpcnN0IEdJRCBvZiAwIC0tIHRyeWluZyB0byByZWNvdmVyLiIpO3Q9MH1jb25zdCByPWFbZSsrXSxzPWFbZV08PDh8YVtlKzFdO2ZvcihsZXQgZT10O2U8czsrK2UpaS5wdXNoKHIpfWUrPTI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYHBhcnNlRkRTZWxlY3Q6IFVua25vd24gZm9ybWF0ICIke3J9Ii5gKX1pZihpLmxlbmd0aCE9PXQpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJwYXJzZUZEU2VsZWN0OiBJbnZhbGlkIGZvbnQgZGF0YS4iKTtyZXR1cm4gbmV3IENGRkZEU2VsZWN0KHIsaSl9fWNsYXNzIENGRntjb25zdHJ1Y3Rvcigpe3RoaXMuaGVhZGVyPW51bGw7dGhpcy5uYW1lcz1bXTt0aGlzLnRvcERpY3Q9bnVsbDt0aGlzLnN0cmluZ3M9bmV3IENGRlN0cmluZ3M7dGhpcy5nbG9iYWxTdWJySW5kZXg9bnVsbDt0aGlzLmVuY29kaW5nPW51bGw7dGhpcy5jaGFyc2V0PW51bGw7dGhpcy5jaGFyU3RyaW5ncz1udWxsO3RoaXMuZmRBcnJheT1bXTt0aGlzLmZkU2VsZWN0PW51bGw7dGhpcy5pc0NJREZvbnQ9ITF9ZHVwbGljYXRlRmlyc3RHbHlwaCgpe2lmKHRoaXMuY2hhclN0cmluZ3MuY291bnQ+PTY1NTM1KXt3YXJuKCJOb3QgZW5vdWdoIHNwYWNlIGluIGNoYXJzdHJpbmdzIHRvIGR1cGxpY2F0ZSBmaXJzdCBnbHlwaC4iKTtyZXR1cm59Y29uc3QgZT10aGlzLmNoYXJTdHJpbmdzLmdldCgwKTt0aGlzLmNoYXJTdHJpbmdzLmFkZChlKTt0aGlzLmlzQ0lERm9udCYmdGhpcy5mZFNlbGVjdC5mZFNlbGVjdC5wdXNoKHRoaXMuZmRTZWxlY3QuZmRTZWxlY3RbMF0pfWhhc0dseXBoSWQoZSl7aWYoZTwwfHxlPj10aGlzLmNoYXJTdHJpbmdzLmNvdW50KXJldHVybiExO3JldHVybiB0aGlzLmNoYXJTdHJpbmdzLmdldChlKS5sZW5ndGg+MH19Y2xhc3MgQ0ZGSGVhZGVye2NvbnN0cnVjdG9yKGUsdCxhLHIpe3RoaXMubWFqb3I9ZTt0aGlzLm1pbm9yPXQ7dGhpcy5oZHJTaXplPWE7dGhpcy5vZmZTaXplPXJ9fWNsYXNzIENGRlN0cmluZ3N7Y29uc3RydWN0b3IoKXt0aGlzLnN0cmluZ3M9W119Z2V0KGUpe3JldHVybiBlPj0wJiZlPD0zOTA/dnJbZV06ZS1Gcjw9dGhpcy5zdHJpbmdzLmxlbmd0aD90aGlzLnN0cmluZ3NbZS1Gcl06dnJbMF19Z2V0U0lEKGUpe2xldCB0PXZyLmluZGV4T2YoZSk7aWYoLTEhPT10KXJldHVybiB0O3Q9dGhpcy5zdHJpbmdzLmluZGV4T2YoZSk7cmV0dXJuLTEhPT10P3QrRnI6LTF9YWRkKGUpe3RoaXMuc3RyaW5ncy5wdXNoKGUpfWdldCBjb3VudCgpe3JldHVybiB0aGlzLnN0cmluZ3MubGVuZ3RofX1jbGFzcyBDRkZJbmRleHtjb25zdHJ1Y3Rvcigpe3RoaXMub2JqZWN0cz1bXTt0aGlzLmxlbmd0aD0wfWFkZChlKXt0aGlzLmxlbmd0aCs9ZS5sZW5ndGg7dGhpcy5vYmplY3RzLnB1c2goZSl9c2V0KGUsdCl7dGhpcy5sZW5ndGgrPXQubGVuZ3RoLXRoaXMub2JqZWN0c1tlXS5sZW5ndGg7dGhpcy5vYmplY3RzW2VdPXR9Z2V0KGUpe3JldHVybiB0aGlzLm9iamVjdHNbZV19Z2V0IGNvdW50KCl7cmV0dXJuIHRoaXMub2JqZWN0cy5sZW5ndGh9fWNsYXNzIENGRkRpY3R7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmtleVRvTmFtZU1hcD1lLmtleVRvTmFtZU1hcDt0aGlzLm5hbWVUb0tleU1hcD1lLm5hbWVUb0tleU1hcDt0aGlzLmRlZmF1bHRzPWUuZGVmYXVsdHM7dGhpcy50eXBlcz1lLnR5cGVzO3RoaXMub3Bjb2Rlcz1lLm9wY29kZXM7dGhpcy5vcmRlcj1lLm9yZGVyO3RoaXMuc3RyaW5ncz10O3RoaXMudmFsdWVzPU9iamVjdC5jcmVhdGUobnVsbCl9c2V0QnlLZXkoZSx0KXtpZighKGUgaW4gdGhpcy5rZXlUb05hbWVNYXApKXJldHVybiExO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4hMDtmb3IoY29uc3QgYSBvZiB0KWlmKGlzTmFOKGEpKXt3YXJuKGBJbnZhbGlkIENGRkRpY3QgdmFsdWU6ICIke3R9IiBmb3Iga2V5ICIke2V9Ii5gKTtyZXR1cm4hMH1jb25zdCBhPXRoaXMudHlwZXNbZV07Im51bSIhPT1hJiYic2lkIiE9PWEmJiJvZmZzZXQiIT09YXx8KHQ9dFswXSk7dGhpcy52YWx1ZXNbZV09dDtyZXR1cm4hMH1zZXRCeU5hbWUoZSx0KXtpZighKGUgaW4gdGhpcy5uYW1lVG9LZXlNYXApKXRocm93IG5ldyBGb3JtYXRFcnJvcihgSW52YWxpZCBkaWN0aW9uYXJ5IG5hbWUgIiR7ZX0iYCk7dGhpcy52YWx1ZXNbdGhpcy5uYW1lVG9LZXlNYXBbZV1dPXR9aGFzTmFtZShlKXtyZXR1cm4gdGhpcy5uYW1lVG9LZXlNYXBbZV1pbiB0aGlzLnZhbHVlc31nZXRCeU5hbWUoZSl7aWYoIShlIGluIHRoaXMubmFtZVRvS2V5TWFwKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgZGljdGlvbmFyeSBuYW1lICR7ZX0iYCk7Y29uc3QgdD10aGlzLm5hbWVUb0tleU1hcFtlXTtyZXR1cm4gdCBpbiB0aGlzLnZhbHVlcz90aGlzLnZhbHVlc1t0XTp0aGlzLmRlZmF1bHRzW3RdfXJlbW92ZUJ5TmFtZShlKXtkZWxldGUgdGhpcy52YWx1ZXNbdGhpcy5uYW1lVG9LZXlNYXBbZV1dfXN0YXRpYyBjcmVhdGVUYWJsZXMoZSl7Y29uc3QgdD17a2V5VG9OYW1lTWFwOnt9LG5hbWVUb0tleU1hcDp7fSxkZWZhdWx0czp7fSx0eXBlczp7fSxvcGNvZGVzOnt9LG9yZGVyOltdfTtmb3IoY29uc3QgYSBvZiBlKXtjb25zdCBlPUFycmF5LmlzQXJyYXkoYVswXSk/KGFbMF1bMF08PDgpK2FbMF1bMV06YVswXTt0LmtleVRvTmFtZU1hcFtlXT1hWzFdO3QubmFtZVRvS2V5TWFwW2FbMV1dPWU7dC50eXBlc1tlXT1hWzJdO3QuZGVmYXVsdHNbZV09YVszXTt0Lm9wY29kZXNbZV09QXJyYXkuaXNBcnJheShhWzBdKT9hWzBdOlthWzBdXTt0Lm9yZGVyLnB1c2goZSl9cmV0dXJuIHR9fWNvbnN0IE9yPVtbWzEyLDMwXSwiUk9TIixbInNpZCIsInNpZCIsIm51bSJdLG51bGxdLFtbMTIsMjBdLCJTeW50aGV0aWNCYXNlIiwibnVtIixudWxsXSxbMCwidmVyc2lvbiIsInNpZCIsbnVsbF0sWzEsIk5vdGljZSIsInNpZCIsbnVsbF0sW1sxMiwwXSwiQ29weXJpZ2h0Iiwic2lkIixudWxsXSxbMiwiRnVsbE5hbWUiLCJzaWQiLG51bGxdLFszLCJGYW1pbHlOYW1lIiwic2lkIixudWxsXSxbNCwiV2VpZ2h0Iiwic2lkIixudWxsXSxbWzEyLDFdLCJpc0ZpeGVkUGl0Y2giLCJudW0iLDBdLFtbMTIsMl0sIkl0YWxpY0FuZ2xlIiwibnVtIiwwXSxbWzEyLDNdLCJVbmRlcmxpbmVQb3NpdGlvbiIsIm51bSIsLTEwMF0sW1sxMiw0XSwiVW5kZXJsaW5lVGhpY2tuZXNzIiwibnVtIiw1MF0sW1sxMiw1XSwiUGFpbnRUeXBlIiwibnVtIiwwXSxbWzEyLDZdLCJDaGFyc3RyaW5nVHlwZSIsIm51bSIsMl0sW1sxMiw3XSwiRm9udE1hdHJpeCIsWyJudW0iLCJudW0iLCJudW0iLCJudW0iLCJudW0iLCJudW0iXSxbLjAwMSwwLDAsLjAwMSwwLDBdXSxbMTMsIlVuaXF1ZUlEIiwibnVtIixudWxsXSxbNSwiRm9udEJCb3giLFsibnVtIiwibnVtIiwibnVtIiwibnVtIl0sWzAsMCwwLDBdXSxbWzEyLDhdLCJTdHJva2VXaWR0aCIsIm51bSIsMF0sWzE0LCJYVUlEIiwiYXJyYXkiLG51bGxdLFsxNSwiY2hhcnNldCIsIm9mZnNldCIsMF0sWzE2LCJFbmNvZGluZyIsIm9mZnNldCIsMF0sWzE3LCJDaGFyU3RyaW5ncyIsIm9mZnNldCIsMF0sWzE4LCJQcml2YXRlIixbIm9mZnNldCIsIm9mZnNldCJdLG51bGxdLFtbMTIsMjFdLCJQb3N0U2NyaXB0Iiwic2lkIixudWxsXSxbWzEyLDIyXSwiQmFzZUZvbnROYW1lIiwic2lkIixudWxsXSxbWzEyLDIzXSwiQmFzZUZvbnRCbGVuZCIsImRlbHRhIixudWxsXSxbWzEyLDMxXSwiQ0lERm9udFZlcnNpb24iLCJudW0iLDBdLFtbMTIsMzJdLCJDSURGb250UmV2aXNpb24iLCJudW0iLDBdLFtbMTIsMzNdLCJDSURGb250VHlwZSIsIm51bSIsMF0sW1sxMiwzNF0sIkNJRENvdW50IiwibnVtIiw4NzIwXSxbWzEyLDM1XSwiVUlEQmFzZSIsIm51bSIsbnVsbF0sW1sxMiwzN10sIkZEU2VsZWN0Iiwib2Zmc2V0IixudWxsXSxbWzEyLDM2XSwiRkRBcnJheSIsIm9mZnNldCIsbnVsbF0sW1sxMiwzOF0sIkZvbnROYW1lIiwic2lkIixudWxsXV07Y2xhc3MgQ0ZGVG9wRGljdCBleHRlbmRzIENGRkRpY3R7c3RhdGljIGdldCB0YWJsZXMoKXtyZXR1cm4gc2hhZG93KHRoaXMsInRhYmxlcyIsdGhpcy5jcmVhdGVUYWJsZXMoT3IpKX1jb25zdHJ1Y3RvcihlKXtzdXBlcihDRkZUb3BEaWN0LnRhYmxlcyxlKTt0aGlzLnByaXZhdGVEaWN0PW51bGx9fWNvbnN0IE1yPVtbNiwiQmx1ZVZhbHVlcyIsImRlbHRhIixudWxsXSxbNywiT3RoZXJCbHVlcyIsImRlbHRhIixudWxsXSxbOCwiRmFtaWx5Qmx1ZXMiLCJkZWx0YSIsbnVsbF0sWzksIkZhbWlseU90aGVyQmx1ZXMiLCJkZWx0YSIsbnVsbF0sW1sxMiw5XSwiQmx1ZVNjYWxlIiwibnVtIiwuMDM5NjI1XSxbWzEyLDEwXSwiQmx1ZVNoaWZ0IiwibnVtIiw3XSxbWzEyLDExXSwiQmx1ZUZ1enoiLCJudW0iLDFdLFsxMCwiU3RkSFciLCJudW0iLG51bGxdLFsxMSwiU3RkVlciLCJudW0iLG51bGxdLFtbMTIsMTJdLCJTdGVtU25hcEgiLCJkZWx0YSIsbnVsbF0sW1sxMiwxM10sIlN0ZW1TbmFwViIsImRlbHRhIixudWxsXSxbWzEyLDE0XSwiRm9yY2VCb2xkIiwibnVtIiwwXSxbWzEyLDE3XSwiTGFuZ3VhZ2VHcm91cCIsIm51bSIsMF0sW1sxMiwxOF0sIkV4cGFuc2lvbkZhY3RvciIsIm51bSIsLjA2XSxbWzEyLDE5XSwiaW5pdGlhbFJhbmRvbVNlZWQiLCJudW0iLDBdLFsyMCwiZGVmYXVsdFdpZHRoWCIsIm51bSIsMF0sWzIxLCJub21pbmFsV2lkdGhYIiwibnVtIiwwXSxbMTksIlN1YnJzIiwib2Zmc2V0IixudWxsXV07Y2xhc3MgQ0ZGUHJpdmF0ZURpY3QgZXh0ZW5kcyBDRkZEaWN0e3N0YXRpYyBnZXQgdGFibGVzKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJ0YWJsZXMiLHRoaXMuY3JlYXRlVGFibGVzKE1yKSl9Y29uc3RydWN0b3IoZSl7c3VwZXIoQ0ZGUHJpdmF0ZURpY3QudGFibGVzLGUpO3RoaXMuc3VicnNJbmRleD1udWxsfX1jb25zdCBEcj17SVNPX0FET0JFOjAsRVhQRVJUOjEsRVhQRVJUX1NVQlNFVDoyfTtjbGFzcyBDRkZDaGFyc2V0e2NvbnN0cnVjdG9yKGUsdCxhLHIpe3RoaXMucHJlZGVmaW5lZD1lO3RoaXMuZm9ybWF0PXQ7dGhpcy5jaGFyc2V0PWE7dGhpcy5yYXc9cn19Y2xhc3MgQ0ZGRW5jb2Rpbmd7Y29uc3RydWN0b3IoZSx0LGEscil7dGhpcy5wcmVkZWZpbmVkPWU7dGhpcy5mb3JtYXQ9dDt0aGlzLmVuY29kaW5nPWE7dGhpcy5yYXc9cn19Y2xhc3MgQ0ZGRkRTZWxlY3R7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmZvcm1hdD1lO3RoaXMuZmRTZWxlY3Q9dH1nZXRGREluZGV4KGUpe3JldHVybiBlPDB8fGU+PXRoaXMuZmRTZWxlY3QubGVuZ3RoPy0xOnRoaXMuZmRTZWxlY3RbZV19fWNsYXNzIENGRk9mZnNldFRyYWNrZXJ7Y29uc3RydWN0b3IoKXt0aGlzLm9mZnNldHM9T2JqZWN0LmNyZWF0ZShudWxsKX1pc1RyYWNraW5nKGUpe3JldHVybiBlIGluIHRoaXMub2Zmc2V0c310cmFjayhlLHQpe2lmKGUgaW4gdGhpcy5vZmZzZXRzKXRocm93IG5ldyBGb3JtYXRFcnJvcihgQWxyZWFkeSB0cmFja2luZyBsb2NhdGlvbiBvZiAke2V9YCk7dGhpcy5vZmZzZXRzW2VdPXR9b2Zmc2V0KGUpe2Zvcihjb25zdCB0IGluIHRoaXMub2Zmc2V0cyl0aGlzLm9mZnNldHNbdF0rPWV9c2V0RW50cnlMb2NhdGlvbihlLHQsYSl7aWYoIShlIGluIHRoaXMub2Zmc2V0cykpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBOb3QgdHJhY2tpbmcgbG9jYXRpb24gb2YgJHtlfWApO2NvbnN0IHI9YS5kYXRhLGk9dGhpcy5vZmZzZXRzW2VdO2ZvcihsZXQgZT0wLGE9dC5sZW5ndGg7ZTxhOysrZSl7Y29uc3QgYT01KmUraSxuPWErMSxzPWErMixvPWErMyxjPWErNDtpZigyOSE9PXJbYV18fDAhPT1yW25dfHwwIT09cltzXXx8MCE9PXJbb118fDAhPT1yW2NdKXRocm93IG5ldyBGb3JtYXRFcnJvcigid3JpdGluZyB0byBhbiBvZmZzZXQgdGhhdCBpcyBub3QgZW1wdHkiKTtjb25zdCBsPXRbZV07clthXT0yOTtyW25dPWw+PjI0JjI1NTtyW3NdPWw+PjE2JjI1NTtyW29dPWw+PjgmMjU1O3JbY109MjU1Jmx9fX1jbGFzcyBDRkZDb21waWxlcntjb25zdHJ1Y3RvcihlKXt0aGlzLmNmZj1lfWNvbXBpbGUoKXtjb25zdCBlPXRoaXMuY2ZmLHQ9e2RhdGE6W10sbGVuZ3RoOjAsYWRkKGUpe3RyeXt0aGlzLmRhdGEucHVzaCguLi5lKX1jYXRjaHt0aGlzLmRhdGE9dGhpcy5kYXRhLmNvbmNhdChlKX10aGlzLmxlbmd0aD10aGlzLmRhdGEubGVuZ3RofX0sYT10aGlzLmNvbXBpbGVIZWFkZXIoZS5oZWFkZXIpO3QuYWRkKGEpO2NvbnN0IHI9dGhpcy5jb21waWxlTmFtZUluZGV4KGUubmFtZXMpO3QuYWRkKHIpO2lmKGUuaXNDSURGb250JiZlLnRvcERpY3QuaGFzTmFtZSgiRm9udE1hdHJpeCIpKXtjb25zdCB0PWUudG9wRGljdC5nZXRCeU5hbWUoIkZvbnRNYXRyaXgiKTtlLnRvcERpY3QucmVtb3ZlQnlOYW1lKCJGb250TWF0cml4Iik7Zm9yKGNvbnN0IGEgb2YgZS5mZEFycmF5KXtsZXQgZT10LnNsaWNlKDApO2EuaGFzTmFtZSgiRm9udE1hdHJpeCIpJiYoZT1VdGlsLnRyYW5zZm9ybShlLGEuZ2V0QnlOYW1lKCJGb250TWF0cml4IikpKTthLnNldEJ5TmFtZSgiRm9udE1hdHJpeCIsZSl9fWNvbnN0IGk9ZS50b3BEaWN0LmdldEJ5TmFtZSgiWFVJRCIpO2k/Lmxlbmd0aD4xNiYmZS50b3BEaWN0LnJlbW92ZUJ5TmFtZSgiWFVJRCIpO2UudG9wRGljdC5zZXRCeU5hbWUoImNoYXJzZXQiLDApO2xldCBuPXRoaXMuY29tcGlsZVRvcERpY3RzKFtlLnRvcERpY3RdLHQubGVuZ3RoLGUuaXNDSURGb250KTt0LmFkZChuLm91dHB1dCk7Y29uc3Qgcz1uLnRyYWNrZXJzWzBdLG89dGhpcy5jb21waWxlU3RyaW5nSW5kZXgoZS5zdHJpbmdzLnN0cmluZ3MpO3QuYWRkKG8pO2NvbnN0IGM9dGhpcy5jb21waWxlSW5kZXgoZS5nbG9iYWxTdWJySW5kZXgpO3QuYWRkKGMpO2lmKGUuZW5jb2RpbmcmJmUudG9wRGljdC5oYXNOYW1lKCJFbmNvZGluZyIpKWlmKGUuZW5jb2RpbmcucHJlZGVmaW5lZClzLnNldEVudHJ5TG9jYXRpb24oIkVuY29kaW5nIixbZS5lbmNvZGluZy5mb3JtYXRdLHQpO2Vsc2V7Y29uc3QgYT10aGlzLmNvbXBpbGVFbmNvZGluZyhlLmVuY29kaW5nKTtzLnNldEVudHJ5TG9jYXRpb24oIkVuY29kaW5nIixbdC5sZW5ndGhdLHQpO3QuYWRkKGEpfWNvbnN0IGw9dGhpcy5jb21waWxlQ2hhcnNldChlLmNoYXJzZXQsZS5jaGFyU3RyaW5ncy5jb3VudCxlLnN0cmluZ3MsZS5pc0NJREZvbnQpO3Muc2V0RW50cnlMb2NhdGlvbigiY2hhcnNldCIsW3QubGVuZ3RoXSx0KTt0LmFkZChsKTtjb25zdCBoPXRoaXMuY29tcGlsZUNoYXJTdHJpbmdzKGUuY2hhclN0cmluZ3MpO3Muc2V0RW50cnlMb2NhdGlvbigiQ2hhclN0cmluZ3MiLFt0Lmxlbmd0aF0sdCk7dC5hZGQoaCk7aWYoZS5pc0NJREZvbnQpe3Muc2V0RW50cnlMb2NhdGlvbigiRkRTZWxlY3QiLFt0Lmxlbmd0aF0sdCk7Y29uc3QgYT10aGlzLmNvbXBpbGVGRFNlbGVjdChlLmZkU2VsZWN0KTt0LmFkZChhKTtuPXRoaXMuY29tcGlsZVRvcERpY3RzKGUuZmRBcnJheSx0Lmxlbmd0aCwhMCk7cy5zZXRFbnRyeUxvY2F0aW9uKCJGREFycmF5IixbdC5sZW5ndGhdLHQpO3QuYWRkKG4ub3V0cHV0KTtjb25zdCByPW4udHJhY2tlcnM7dGhpcy5jb21waWxlUHJpdmF0ZURpY3RzKGUuZmRBcnJheSxyLHQpfXRoaXMuY29tcGlsZVByaXZhdGVEaWN0cyhbZS50b3BEaWN0XSxbc10sdCk7dC5hZGQoWzBdKTtyZXR1cm4gdC5kYXRhfWVuY29kZU51bWJlcihlKXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihlKT90aGlzLmVuY29kZUludGVnZXIoZSk6dGhpcy5lbmNvZGVGbG9hdChlKX1zdGF0aWMgZ2V0IEVuY29kZUZsb2F0UmVnRXhwKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJFbmNvZGVGbG9hdFJlZ0V4cCIsL1wuKFxkKj8pKD86OXs1LDIwfXwwezUsMjB9KVxkezAsMn0oPzplKC4rKXwkKS8pfWVuY29kZUZsb2F0KGUpe2xldCB0PWUudG9TdHJpbmcoKTtjb25zdCBhPUNGRkNvbXBpbGVyLkVuY29kZUZsb2F0UmVnRXhwLmV4ZWModCk7aWYoYSl7Y29uc3Qgcj1wYXJzZUZsb2F0KCIxZSIrKChhWzJdPythWzJdOjApK2FbMV0ubGVuZ3RoKSk7dD0oTWF0aC5yb3VuZChlKnIpL3IpLnRvU3RyaW5nKCl9bGV0IHIsaSxuPSIiO2ZvcihyPTAsaT10Lmxlbmd0aDtyPGk7KytyKXtjb25zdCBlPXRbcl07bis9ImUiPT09ZT8iLSI9PT10Wysrcl0/ImMiOiJiIjoiLiI9PT1lPyJhIjoiLSI9PT1lPyJlIjplfW4rPTEmbi5sZW5ndGg/ImYiOiJmZiI7Y29uc3Qgcz1bMzBdO2ZvcihyPTAsaT1uLmxlbmd0aDtyPGk7cis9MilzLnB1c2gocGFyc2VJbnQobi5zdWJzdHJpbmcocixyKzIpLDE2KSk7cmV0dXJuIHN9ZW5jb2RlSW50ZWdlcihlKXtsZXQgdDt0PWU+PS0xMDcmJmU8PTEwNz9bZSsxMzldOmU+PTEwOCYmZTw9MTEzMT9bMjQ3KygoZS09MTA4KT4+OCksMjU1JmVdOmU+PS0xMTMxJiZlPD0tMTA4P1syNTErKChlPS1lLTEwOCk+PjgpLDI1NSZlXTplPj0tMzI3NjgmJmU8PTMyNzY3P1syOCxlPj44JjI1NSwyNTUmZV06WzI5LGU+PjI0JjI1NSxlPj4xNiYyNTUsZT4+OCYyNTUsMjU1JmVdO3JldHVybiB0fWNvbXBpbGVIZWFkZXIoZSl7cmV0dXJuW2UubWFqb3IsZS5taW5vciw0LGUub2ZmU2l6ZV19Y29tcGlsZU5hbWVJbmRleChlKXtjb25zdCB0PW5ldyBDRkZJbmRleDtmb3IoY29uc3QgYSBvZiBlKXtjb25zdCBlPU1hdGgubWluKGEubGVuZ3RoLDEyNyk7bGV0IHI9bmV3IEFycmF5KGUpO2ZvcihsZXQgdD0wO3Q8ZTt0Kyspe2xldCBlPWFbdF07KGU8IiEifHxlPiJ+Inx8IlsiPT09ZXx8Il0iPT09ZXx8IigiPT09ZXx8IikiPT09ZXx8InsiPT09ZXx8In0iPT09ZXx8IjwiPT09ZXx8Ij4iPT09ZXx8Ii8iPT09ZXx8IiUiPT09ZSkmJihlPSJfIik7clt0XT1lfXI9ci5qb2luKCIiKTsiIj09PXImJihyPSJCYWRfRm9udF9OYW1lIik7dC5hZGQoc3RyaW5nVG9CeXRlcyhyKSl9cmV0dXJuIHRoaXMuY29tcGlsZUluZGV4KHQpfWNvbXBpbGVUb3BEaWN0cyhlLHQsYSl7Y29uc3Qgcj1bXTtsZXQgaT1uZXcgQ0ZGSW5kZXg7Zm9yKGNvbnN0IG4gb2YgZSl7aWYoYSl7bi5yZW1vdmVCeU5hbWUoIkNJREZvbnRWZXJzaW9uIik7bi5yZW1vdmVCeU5hbWUoIkNJREZvbnRSZXZpc2lvbiIpO24ucmVtb3ZlQnlOYW1lKCJDSURGb250VHlwZSIpO24ucmVtb3ZlQnlOYW1lKCJDSURDb3VudCIpO24ucmVtb3ZlQnlOYW1lKCJVSURCYXNlIil9Y29uc3QgZT1uZXcgQ0ZGT2Zmc2V0VHJhY2tlcixzPXRoaXMuY29tcGlsZURpY3QobixlKTtyLnB1c2goZSk7aS5hZGQocyk7ZS5vZmZzZXQodCl9aT10aGlzLmNvbXBpbGVJbmRleChpLHIpO3JldHVybnt0cmFja2VyczpyLG91dHB1dDppfX1jb21waWxlUHJpdmF0ZURpY3RzKGUsdCxhKXtmb3IobGV0IHI9MCxpPWUubGVuZ3RoO3I8aTsrK3Ipe2NvbnN0IGk9ZVtyXSxuPWkucHJpdmF0ZURpY3Q7aWYoIW58fCFpLmhhc05hbWUoIlByaXZhdGUiKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlRoZXJlIG11c3QgYmUgYSBwcml2YXRlIGRpY3Rpb25hcnkuIik7Y29uc3Qgcz1uZXcgQ0ZGT2Zmc2V0VHJhY2tlcixvPXRoaXMuY29tcGlsZURpY3QobixzKTtsZXQgYz1hLmxlbmd0aDtzLm9mZnNldChjKTtvLmxlbmd0aHx8KGM9MCk7dFtyXS5zZXRFbnRyeUxvY2F0aW9uKCJQcml2YXRlIixbby5sZW5ndGgsY10sYSk7YS5hZGQobyk7aWYobi5zdWJyc0luZGV4JiZuLmhhc05hbWUoIlN1YnJzIikpe2NvbnN0IGU9dGhpcy5jb21waWxlSW5kZXgobi5zdWJyc0luZGV4KTtzLnNldEVudHJ5TG9jYXRpb24oIlN1YnJzIixbby5sZW5ndGhdLGEpO2EuYWRkKGUpfX19Y29tcGlsZURpY3QoZSx0KXtjb25zdCBhPVtdO2Zvcihjb25zdCByIG9mIGUub3JkZXIpe2lmKCEociBpbiBlLnZhbHVlcykpY29udGludWU7bGV0IGk9ZS52YWx1ZXNbcl0sbj1lLnR5cGVzW3JdO0FycmF5LmlzQXJyYXkobil8fChuPVtuXSk7QXJyYXkuaXNBcnJheShpKXx8KGk9W2ldKTtpZigwIT09aS5sZW5ndGgpe2ZvcihsZXQgcz0wLG89bi5sZW5ndGg7czxvOysrcyl7Y29uc3Qgbz1uW3NdLGM9aVtzXTtzd2l0Y2gobyl7Y2FzZSJudW0iOmNhc2Uic2lkIjphLnB1c2goLi4udGhpcy5lbmNvZGVOdW1iZXIoYykpO2JyZWFrO2Nhc2Uib2Zmc2V0Ijpjb25zdCBuPWUua2V5VG9OYW1lTWFwW3JdO3QuaXNUcmFja2luZyhuKXx8dC50cmFjayhuLGEubGVuZ3RoKTthLnB1c2goMjksMCwwLDAsMCk7YnJlYWs7Y2FzZSJhcnJheSI6Y2FzZSJkZWx0YSI6YS5wdXNoKC4uLnRoaXMuZW5jb2RlTnVtYmVyKGMpKTtmb3IobGV0IGU9MSx0PWkubGVuZ3RoO2U8dDsrK2UpYS5wdXNoKC4uLnRoaXMuZW5jb2RlTnVtYmVyKGlbZV0pKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBGb3JtYXRFcnJvcihgVW5rbm93biBkYXRhIHR5cGUgb2YgJHtvfWApfX1hLnB1c2goLi4uZS5vcGNvZGVzW3JdKX19cmV0dXJuIGF9Y29tcGlsZVN0cmluZ0luZGV4KGUpe2NvbnN0IHQ9bmV3IENGRkluZGV4O2Zvcihjb25zdCBhIG9mIGUpdC5hZGQoc3RyaW5nVG9CeXRlcyhhKSk7cmV0dXJuIHRoaXMuY29tcGlsZUluZGV4KHQpfWNvbXBpbGVDaGFyU3RyaW5ncyhlKXtjb25zdCB0PW5ldyBDRkZJbmRleDtmb3IobGV0IGE9MDthPGUuY291bnQ7YSsrKXtjb25zdCByPWUuZ2V0KGEpOzAhPT1yLmxlbmd0aD90LmFkZChyKTp0LmFkZChuZXcgVWludDhBcnJheShbMTM5LDE0XSkpfXJldHVybiB0aGlzLmNvbXBpbGVJbmRleCh0KX1jb21waWxlQ2hhcnNldChlLHQsYSxyKXtsZXQgaTtjb25zdCBuPXQtMTtpZihyKXtjb25zdCBlPW4tMTtpPW5ldyBVaW50OEFycmF5KFsyLDAsMSxlPj44JjI1NSwyNTUmZV0pfWVsc2V7aT1uZXcgVWludDhBcnJheSgxKzIqbik7aVswXT0wO2xldCB0PTA7Y29uc3Qgcj1lLmNoYXJzZXQubGVuZ3RoO2xldCBzPSExO2ZvcihsZXQgbj0xO248aS5sZW5ndGg7bis9Mil7bGV0IG89MDtpZih0PHIpe2NvbnN0IHI9ZS5jaGFyc2V0W3QrK107bz1hLmdldFNJRChyKTtpZigtMT09PW8pe289MDtpZighcyl7cz0hMDt3YXJuKGBDb3VsZG4ndCBmaW5kICR7cn0gaW4gQ0ZGIHN0cmluZ3NgKX19fWlbbl09bz4+OCYyNTU7aVtuKzFdPTI1NSZvfX1yZXR1cm4gdGhpcy5jb21waWxlVHlwZWRBcnJheShpKX1jb21waWxlRW5jb2RpbmcoZSl7cmV0dXJuIHRoaXMuY29tcGlsZVR5cGVkQXJyYXkoZS5yYXcpfWNvbXBpbGVGRFNlbGVjdChlKXtjb25zdCB0PWUuZm9ybWF0O2xldCBhLHI7c3dpdGNoKHQpe2Nhc2UgMDphPW5ldyBVaW50OEFycmF5KDErZS5mZFNlbGVjdC5sZW5ndGgpO2FbMF09dDtmb3Iocj0wO3I8ZS5mZFNlbGVjdC5sZW5ndGg7cisrKWFbcisxXT1lLmZkU2VsZWN0W3JdO2JyZWFrO2Nhc2UgMzpjb25zdCBpPTA7bGV0IG49ZS5mZFNlbGVjdFswXTtjb25zdCBzPVt0LDAsMCxpPj44JjI1NSwyNTUmaSxuXTtmb3Iocj0xO3I8ZS5mZFNlbGVjdC5sZW5ndGg7cisrKXtjb25zdCB0PWUuZmRTZWxlY3Rbcl07aWYodCE9PW4pe3MucHVzaChyPj44JjI1NSwyNTUmcix0KTtuPXR9fWNvbnN0IG89KHMubGVuZ3RoLTMpLzM7c1sxXT1vPj44JjI1NTtzWzJdPTI1NSZvO3MucHVzaChyPj44JjI1NSwyNTUmcik7YT1uZXcgVWludDhBcnJheShzKX1yZXR1cm4gdGhpcy5jb21waWxlVHlwZWRBcnJheShhKX1jb21waWxlVHlwZWRBcnJheShlKXtyZXR1cm4gQXJyYXkuZnJvbShlKX1jb21waWxlSW5kZXgoZSx0PVtdKXtjb25zdCBhPWUub2JqZWN0cyxyPWEubGVuZ3RoO2lmKDA9PT1yKXJldHVyblswLDBdO2NvbnN0IGk9W3I+PjgmMjU1LDI1NSZyXTtsZXQgbixzLG89MTtmb3Iobj0wO248cjsrK24pbys9YVtuXS5sZW5ndGg7cz1vPDI1Nj8xOm88NjU1MzY/MjpvPDE2Nzc3MjE2PzM6NDtpLnB1c2gocyk7bGV0IGM9MTtmb3Iobj0wO248cisxO24rKyl7MT09PXM/aS5wdXNoKDI1NSZjKToyPT09cz9pLnB1c2goYz4+OCYyNTUsMjU1JmMpOjM9PT1zP2kucHVzaChjPj4xNiYyNTUsYz4+OCYyNTUsMjU1JmMpOmkucHVzaChjPj4+MjQmMjU1LGM+PjE2JjI1NSxjPj44JjI1NSwyNTUmYyk7YVtuXSYmKGMrPWFbbl0ubGVuZ3RoKX1mb3Iobj0wO248cjtuKyspe3Rbbl0mJnRbbl0ub2Zmc2V0KGkubGVuZ3RoKTtpLnB1c2goLi4uYVtuXSl9cmV0dXJuIGl9fWNvbnN0IFJyPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZVsiVGltZXMtUm9tYW4iXT0iVGltZXMtUm9tYW4iO2UuSGVsdmV0aWNhPSJIZWx2ZXRpY2EiO2UuQ291cmllcj0iQ291cmllciI7ZS5TeW1ib2w9IlN5bWJvbCI7ZVsiVGltZXMtQm9sZCJdPSJUaW1lcy1Cb2xkIjtlWyJIZWx2ZXRpY2EtQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQ291cmllci1Cb2xkIl09IkNvdXJpZXItQm9sZCI7ZS5aYXBmRGluZ2JhdHM9IlphcGZEaW5nYmF0cyI7ZVsiVGltZXMtSXRhbGljIl09IlRpbWVzLUl0YWxpYyI7ZVsiSGVsdmV0aWNhLU9ibGlxdWUiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2VbIkNvdXJpZXItT2JsaXF1ZSJdPSJDb3VyaWVyLU9ibGlxdWUiO2VbIlRpbWVzLUJvbGRJdGFsaWMiXT0iVGltZXMtQm9sZEl0YWxpYyI7ZVsiSGVsdmV0aWNhLUJvbGRPYmxpcXVlIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQ291cmllci1Cb2xkT2JsaXF1ZSJdPSJDb3VyaWVyLUJvbGRPYmxpcXVlIjtlLkFyaWFsTmFycm93PSJIZWx2ZXRpY2EiO2VbIkFyaWFsTmFycm93LUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkFyaWFsTmFycm93LUJvbGRJdGFsaWMiXT0iSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjtlWyJBcmlhbE5hcnJvdy1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuQXJpYWxCbGFjaz0iSGVsdmV0aWNhIjtlWyJBcmlhbEJsYWNrLUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkFyaWFsQmxhY2stQm9sZEl0YWxpYyJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkFyaWFsQmxhY2stSXRhbGljIl09IkhlbHZldGljYS1PYmxpcXVlIjtlWyJBcmlhbC1CbGFjayJdPSJIZWx2ZXRpY2EiO2VbIkFyaWFsLUJsYWNrLUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkFyaWFsLUJsYWNrLUJvbGRJdGFsaWMiXT0iSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjtlWyJBcmlhbC1CbGFjay1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuQXJpYWw9IkhlbHZldGljYSI7ZVsiQXJpYWwtQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQXJpYWwtQm9sZEl0YWxpYyJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkFyaWFsLUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZS5BcmlhbE1UPSJIZWx2ZXRpY2EiO2VbIkFyaWFsLUJvbGRJdGFsaWNNVCJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkFyaWFsLUJvbGRNVCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQXJpYWwtSXRhbGljTVQiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2VbIkFyaWFsLUJvbGRJdGFsaWNNVC1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQXJpYWwtQm9sZE1ULUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkFyaWFsLUl0YWxpY01ULUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZS5BcmlhbFVuaWNvZGVNUz0iSGVsdmV0aWNhIjtlWyJBcmlhbFVuaWNvZGVNUy1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJBcmlhbFVuaWNvZGVNUy1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQXJpYWxVbmljb2RlTVMtSXRhbGljIl09IkhlbHZldGljYS1PYmxpcXVlIjtlWyJDb3VyaWVyLUJvbGRJdGFsaWMiXT0iQ291cmllci1Cb2xkT2JsaXF1ZSI7ZVsiQ291cmllci1JdGFsaWMiXT0iQ291cmllci1PYmxpcXVlIjtlLkNvdXJpZXJOZXc9IkNvdXJpZXIiO2VbIkNvdXJpZXJOZXctQm9sZCJdPSJDb3VyaWVyLUJvbGQiO2VbIkNvdXJpZXJOZXctQm9sZEl0YWxpYyJdPSJDb3VyaWVyLUJvbGRPYmxpcXVlIjtlWyJDb3VyaWVyTmV3LUl0YWxpYyJdPSJDb3VyaWVyLU9ibGlxdWUiO2VbIkNvdXJpZXJOZXdQUy1Cb2xkSXRhbGljTVQiXT0iQ291cmllci1Cb2xkT2JsaXF1ZSI7ZVsiQ291cmllck5ld1BTLUJvbGRNVCJdPSJDb3VyaWVyLUJvbGQiO2VbIkNvdXJpZXJOZXdQUy1JdGFsaWNNVCJdPSJDb3VyaWVyLU9ibGlxdWUiO2UuQ291cmllck5ld1BTTVQ9IkNvdXJpZXIiO2VbIkhlbHZldGljYS1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiSGVsdmV0aWNhLUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZVsiSGVsdmV0aWNhTFRTdGQtQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiU3ltYm9sLUJvbGQiXT0iU3ltYm9sIjtlWyJTeW1ib2wtQm9sZEl0YWxpYyJdPSJTeW1ib2wiO2VbIlN5bWJvbC1JdGFsaWMiXT0iU3ltYm9sIjtlLlRpbWVzTmV3Um9tYW49IlRpbWVzLVJvbWFuIjtlWyJUaW1lc05ld1JvbWFuLUJvbGQiXT0iVGltZXMtQm9sZCI7ZVsiVGltZXNOZXdSb21hbi1Cb2xkSXRhbGljIl09IlRpbWVzLUJvbGRJdGFsaWMiO2VbIlRpbWVzTmV3Um9tYW4tSXRhbGljIl09IlRpbWVzLUl0YWxpYyI7ZS5UaW1lc05ld1JvbWFuUFM9IlRpbWVzLVJvbWFuIjtlWyJUaW1lc05ld1JvbWFuUFMtQm9sZCJdPSJUaW1lcy1Cb2xkIjtlWyJUaW1lc05ld1JvbWFuUFMtQm9sZEl0YWxpYyJdPSJUaW1lcy1Cb2xkSXRhbGljIjtlWyJUaW1lc05ld1JvbWFuUFMtQm9sZEl0YWxpY01UIl09IlRpbWVzLUJvbGRJdGFsaWMiO2VbIlRpbWVzTmV3Um9tYW5QUy1Cb2xkTVQiXT0iVGltZXMtQm9sZCI7ZVsiVGltZXNOZXdSb21hblBTLUl0YWxpYyJdPSJUaW1lcy1JdGFsaWMiO2VbIlRpbWVzTmV3Um9tYW5QUy1JdGFsaWNNVCJdPSJUaW1lcy1JdGFsaWMiO2UuVGltZXNOZXdSb21hblBTTVQ9IlRpbWVzLVJvbWFuIjtlWyJUaW1lc05ld1JvbWFuUFNNVC1Cb2xkIl09IlRpbWVzLUJvbGQiO2VbIlRpbWVzTmV3Um9tYW5QU01ULUJvbGRJdGFsaWMiXT0iVGltZXMtQm9sZEl0YWxpYyI7ZVsiVGltZXNOZXdSb21hblBTTVQtSXRhbGljIl09IlRpbWVzLUl0YWxpYyJ9KSksTnI9Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLkNvdXJpZXI9IkZveGl0Rml4ZWQucGZiIjtlWyJDb3VyaWVyLUJvbGQiXT0iRm94aXRGaXhlZEJvbGQucGZiIjtlWyJDb3VyaWVyLUJvbGRPYmxpcXVlIl09IkZveGl0Rml4ZWRCb2xkSXRhbGljLnBmYiI7ZVsiQ291cmllci1PYmxpcXVlIl09IkZveGl0Rml4ZWRJdGFsaWMucGZiIjtlLkhlbHZldGljYT0iTGliZXJhdGlvblNhbnMtUmVndWxhci50dGYiO2VbIkhlbHZldGljYS1Cb2xkIl09IkxpYmVyYXRpb25TYW5zLUJvbGQudHRmIjtlWyJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiXT0iTGliZXJhdGlvblNhbnMtQm9sZEl0YWxpYy50dGYiO2VbIkhlbHZldGljYS1PYmxpcXVlIl09IkxpYmVyYXRpb25TYW5zLUl0YWxpYy50dGYiO2VbIlRpbWVzLVJvbWFuIl09IkZveGl0U2VyaWYucGZiIjtlWyJUaW1lcy1Cb2xkIl09IkZveGl0U2VyaWZCb2xkLnBmYiI7ZVsiVGltZXMtQm9sZEl0YWxpYyJdPSJGb3hpdFNlcmlmQm9sZEl0YWxpYy5wZmIiO2VbIlRpbWVzLUl0YWxpYyJdPSJGb3hpdFNlcmlmSXRhbGljLnBmYiI7ZS5TeW1ib2w9IkZveGl0U3ltYm9sLnBmYiI7ZS5aYXBmRGluZ2JhdHM9IkZveGl0RGluZ2JhdHMucGZiIjtlWyJMaWJlcmF0aW9uU2Fucy1SZWd1bGFyIl09IkxpYmVyYXRpb25TYW5zLVJlZ3VsYXIudHRmIjtlWyJMaWJlcmF0aW9uU2Fucy1Cb2xkIl09IkxpYmVyYXRpb25TYW5zLUJvbGQudHRmIjtlWyJMaWJlcmF0aW9uU2Fucy1JdGFsaWMiXT0iTGliZXJhdGlvblNhbnMtSXRhbGljLnR0ZiI7ZVsiTGliZXJhdGlvblNhbnMtQm9sZEl0YWxpYyJdPSJMaWJlcmF0aW9uU2Fucy1Cb2xkSXRhbGljLnR0ZiJ9KSksRXI9Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLkNhbGlicmk9IkhlbHZldGljYSI7ZVsiQ2FsaWJyaS1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJDYWxpYnJpLUJvbGRJdGFsaWMiXT0iSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjtlWyJDYWxpYnJpLUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZS5DZW50dXJ5R290aGljPSJIZWx2ZXRpY2EiO2VbIkNlbnR1cnlHb3RoaWMtQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQ2VudHVyeUdvdGhpYy1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQ2VudHVyeUdvdGhpYy1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuQ29taWNTYW5zTVM9IkNvbWljIFNhbnMgTVMiO2VbIkNvbWljU2Fuc01TLUJvbGQiXT0iQ29taWMgU2FucyBNUy1Cb2xkIjtlWyJDb21pY1NhbnNNUy1Cb2xkSXRhbGljIl09IkNvbWljIFNhbnMgTVMtQm9sZEl0YWxpYyI7ZVsiQ29taWNTYW5zTVMtSXRhbGljIl09IkNvbWljIFNhbnMgTVMtSXRhbGljIjtlLkdpbGxTYW5zTVQ9IkhlbHZldGljYSI7ZVsiR2lsbFNhbnNNVC1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJHaWxsU2Fuc01ULUJvbGRJdGFsaWMiXT0iSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjtlWyJHaWxsU2Fuc01ULUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZS5JbXBhY3Q9IkhlbHZldGljYSI7ZVsiSXRjU3ltYm9sLUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkl0Y1N5bWJvbC1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiSXRjU3ltYm9sLUJvb2siXT0iSGVsdmV0aWNhIjtlWyJJdGNTeW1ib2wtQm9va0l0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZVsiSXRjU3ltYm9sLU1lZGl1bSJdPSJIZWx2ZXRpY2EiO2VbIkl0Y1N5bWJvbC1NZWRpdW1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuTHVjaWRhQ29uc29sZT0iQ291cmllciI7ZVsiTHVjaWRhQ29uc29sZS1Cb2xkIl09IkNvdXJpZXItQm9sZCI7ZVsiTHVjaWRhQ29uc29sZS1Cb2xkSXRhbGljIl09IkNvdXJpZXItQm9sZE9ibGlxdWUiO2VbIkx1Y2lkYUNvbnNvbGUtSXRhbGljIl09IkNvdXJpZXItT2JsaXF1ZSI7ZVsiTHVjaWRhU2Fucy1EZW1pIl09IkhlbHZldGljYS1Cb2xkIjtlWyJNUy1Hb3RoaWMiXT0iTVMgR290aGljIjtlWyJNUy1Hb3RoaWMtQm9sZCJdPSJNUyBHb3RoaWMtQm9sZCI7ZVsiTVMtR290aGljLUJvbGRJdGFsaWMiXT0iTVMgR290aGljLUJvbGRJdGFsaWMiO2VbIk1TLUdvdGhpYy1JdGFsaWMiXT0iTVMgR290aGljLUl0YWxpYyI7ZVsiTVMtTWluY2hvIl09Ik1TIE1pbmNobyI7ZVsiTVMtTWluY2hvLUJvbGQiXT0iTVMgTWluY2hvLUJvbGQiO2VbIk1TLU1pbmNoby1Cb2xkSXRhbGljIl09Ik1TIE1pbmNoby1Cb2xkSXRhbGljIjtlWyJNUy1NaW5jaG8tSXRhbGljIl09Ik1TIE1pbmNoby1JdGFsaWMiO2VbIk1TLVBHb3RoaWMiXT0iTVMgUEdvdGhpYyI7ZVsiTVMtUEdvdGhpYy1Cb2xkIl09Ik1TIFBHb3RoaWMtQm9sZCI7ZVsiTVMtUEdvdGhpYy1Cb2xkSXRhbGljIl09Ik1TIFBHb3RoaWMtQm9sZEl0YWxpYyI7ZVsiTVMtUEdvdGhpYy1JdGFsaWMiXT0iTVMgUEdvdGhpYy1JdGFsaWMiO2VbIk1TLVBNaW5jaG8iXT0iTVMgUE1pbmNobyI7ZVsiTVMtUE1pbmNoby1Cb2xkIl09Ik1TIFBNaW5jaG8tQm9sZCI7ZVsiTVMtUE1pbmNoby1Cb2xkSXRhbGljIl09Ik1TIFBNaW5jaG8tQm9sZEl0YWxpYyI7ZVsiTVMtUE1pbmNoby1JdGFsaWMiXT0iTVMgUE1pbmNoby1JdGFsaWMiO2UuTnVwdGlhbFNjcmlwdD0iVGltZXMtSXRhbGljIjtlLlNlZ29lVUlTeW1ib2w9IkhlbHZldGljYSJ9KSksUHI9Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlWyJBZG9iZSBKZW5zb24iXT0hMDtlWyJBZG9iZSBUZXh0Il09ITA7ZS5BbGJlcnR1cz0hMDtlLkFsZHVzPSEwO2UuQWxleGFuZHJpYT0hMDtlLkFsZ2VyaWFuPSEwO2VbIkFtZXJpY2FuIFR5cGV3cml0ZXIiXT0hMDtlLkFudGlxdWE9ITA7ZS5BcGV4PSEwO2UuQXJubz0hMDtlLkFzdGVyPSEwO2UuQXVyb3JhPSEwO2UuQmFza2VydmlsbGU9ITA7ZS5CZWxsPSEwO2UuQmVtYm89ITA7ZVsiQmVtYm8gU2Nob29sYm9vayJdPSEwO2UuQmVuZ3VpYXQ9ITA7ZVsiQmVya2VsZXkgT2xkIFN0eWxlIl09ITA7ZVsiQmVybmhhcmQgTW9kZXJuIl09ITA7ZVsiQmVydGhvbGQgQ2l0eSJdPSEwO2UuQm9kb25pPSEwO2VbIkJhdWVyIEJvZG9uaSJdPSEwO2VbIkJvb2sgQW50aXF1YSJdPSEwO2UuQm9va21hbj0hMDtlWyJCb3JkZWF1eCBSb21hbiJdPSEwO2VbIkNhbGlmb3JuaWFuIEZCIl09ITA7ZS5DYWxpc3RvPSEwO2UuQ2FsdmVydD0hMDtlLkNhcGl0YWxzPSEwO2UuQ2FtYnJpYT0hMDtlLkNhcnRpZXI9ITA7ZS5DYXNsb249ITA7ZS5DYXR1bGw9ITA7ZS5DZW50YXVyPSEwO2VbIkNlbnR1cnkgT2xkIFN0eWxlIl09ITA7ZVsiQ2VudHVyeSBTY2hvb2xib29rIl09ITA7ZS5DaGFwYXJyYWw9ITA7ZVsiQ2hhcmlzIFNJTCJdPSEwO2UuQ2hlbHRlbmhhbT0hMDtlWyJDaG9sbGEgU2xhYiJdPSEwO2UuQ2xhcmVuZG9uPSEwO2UuQ2xlYXJmYWNlPSEwO2UuQ29jaGluPSEwO2UuQ29sb25uYT0hMDtlWyJDb21wdXRlciBNb2Rlcm4iXT0hMDtlWyJDb25jcmV0ZSBSb21hbiJdPSEwO2UuQ29uc3RhbnRpYT0hMDtlWyJDb29wZXIgQmxhY2siXT0hMDtlLkNvcm9uYT0hMDtlLkVjb3R5cGU9ITA7ZS5FZ3lwdGllbm5lPSEwO2UuRWxlcGhhbnQ9ITA7ZS5FeGNlbHNpb3I9ITA7ZS5GYWlyZmllbGQ9ITA7ZVsiRkYgU2NhbGEiXT0hMDtlLkZvbGthcmQ9ITA7ZS5Gb290bGlnaHQ9ITA7ZS5GcmVlU2VyaWY9ITA7ZVsiRnJpeiBRdWFkcmF0YSJdPSEwO2UuR2FyYW1vbmQ9ITA7ZS5HZW50aXVtPSEwO2UuR2VvcmdpYT0hMDtlLkdsb3VjZXN0ZXI9ITA7ZVsiR291ZHkgT2xkIFN0eWxlIl09ITA7ZVsiR291ZHkgU2Nob29sYm9vayJdPSEwO2VbIkdvdWR5IFBybyBGb250Il09ITA7ZS5HcmFuam9uPSEwO2VbIkd1YXJkaWFuIEVneXB0aWFuIl09ITA7ZS5IZWF0aGVyPSEwO2UuSGVyY3VsZXM9ITA7ZVsiSGlnaCBUb3dlciBUZXh0Il09ITA7ZS5IaXJvc2hpZ2U9ITA7ZVsiSG9lZmxlciBUZXh0Il09ITA7ZVsiSHVtYW5hIFNlcmlmIl09ITA7ZS5JbXByaW50PSEwO2VbIklvbmljIE5vLiA1Il09ITA7ZS5KYW5zb249ITA7ZS5Kb2FubmE9ITA7ZS5Lb3Jpbm5hPSEwO2UuTGV4aWNvbj0hMDtlLkxpYmVyYXRpb25TZXJpZj0hMDtlWyJMaWJlcmF0aW9uIFNlcmlmIl09ITA7ZVsiTGludXggTGliZXJ0aW5lIl09ITA7ZS5MaXRlcmF0dXJuYXlhPSEwO2UuTHVjaWRhPSEwO2VbIkx1Y2lkYSBCcmlnaHQiXT0hMDtlLk1lbGlvcj0hMDtlLk1lbXBoaXM9ITA7ZS5NaWxsZXI9ITA7ZS5NaW5pb249ITA7ZS5Nb2Rlcm49ITA7ZVsiTW9uYSBMaXNhIl09ITA7ZVsiTXJzIEVhdmVzIl09ITA7ZVsiTVMgU2VyaWYiXT0hMDtlWyJNdXNlbyBTbGFiIl09ITA7ZVsiTmV3IFlvcmsiXT0hMDtlWyJOaW1idXMgUm9tYW4iXT0hMDtlWyJOUFMgUmF3bGluc29uIFJvYWR3YXkiXT0hMDtlLk51cHRpYWxTY3JpcHQ9ITA7ZS5QYWxhdGlubz0hMDtlLlBlcnBldHVhPSEwO2UuUGxhbnRpbj0hMDtlWyJQbGFudGluIFNjaG9vbGJvb2siXT0hMDtlLlBsYXliaWxsPSEwO2VbIlBvb3IgUmljaGFyZCJdPSEwO2VbIlJhd2xpbnNvbiBSb2Fkd2F5Il09ITA7ZS5SZW5hdWx0PSEwO2UuUmVxdWllbT0hMDtlLlJvY2t3ZWxsPSEwO2UuUm9tYW49ITA7ZVsiUm90aXMgU2VyaWYiXT0hMDtlLlNhYm9uPSEwO2UuU2NhbGE9ITA7ZS5TZWFndWxsPSEwO2UuU2lzdGluYT0hMDtlLlNvdXZlbmlyPSEwO2UuU1RJWD0hMDtlWyJTdG9uZSBJbmZvcm1hbCJdPSEwO2VbIlN0b25lIFNlcmlmIl09ITA7ZS5TeWxmYWVuPSEwO2UuVGltZXM9ITA7ZS5UcmFqYW49ITA7ZVsiVHJpbml0w6kiXT0hMDtlWyJUcnVtcCBNZWRpYWV2YWwiXT0hMDtlLlV0b3BpYT0hMDtlWyJWYWxlIFR5cGUiXT0hMDtlWyJCaXRzdHJlYW0gVmVyYSJdPSEwO2VbIlZlcmEgU2VyaWYiXT0hMDtlLlZlcnNhaWxsZXM9ITA7ZS5XYW50ZWQ9ITA7ZS5XZWlzcz0hMDtlWyJXaWRlIExhdGluIl09ITA7ZS5XaW5kc29yPSEwO2UuWElUUz0hMH0pKSxMcj1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2UuRGluZ2JhdHM9ITA7ZS5TeW1ib2w9ITA7ZS5aYXBmRGluZ2JhdHM9ITA7ZS5XaW5nZGluZ3M9ITA7ZVsiV2luZ2RpbmdzLUJvbGQiXT0hMDtlWyJXaW5nZGluZ3MtUmVndWxhciJdPSEwfSkpLGpyPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZVsyXT0xMDtlWzNdPTMyO2VbNF09MzM7ZVs1XT0zNDtlWzZdPTM1O2VbN109MzY7ZVs4XT0zNztlWzldPTM4O2VbMTBdPTM5O2VbMTFdPTQwO2VbMTJdPTQxO2VbMTNdPTQyO2VbMTRdPTQzO2VbMTVdPTQ0O2VbMTZdPTQ1O2VbMTddPTQ2O2VbMThdPTQ3O2VbMTldPTQ4O2VbMjBdPTQ5O2VbMjFdPTUwO2VbMjJdPTUxO2VbMjNdPTUyO2VbMjRdPTUzO2VbMjVdPTU0O2VbMjZdPTU1O2VbMjddPTU2O2VbMjhdPTU3O2VbMjldPTU4O2VbMzBdPTg5NDtlWzMxXT02MDtlWzMyXT02MTtlWzMzXT02MjtlWzM0XT02MztlWzM1XT02NDtlWzM2XT02NTtlWzM3XT02NjtlWzM4XT02NztlWzM5XT02ODtlWzQwXT02OTtlWzQxXT03MDtlWzQyXT03MTtlWzQzXT03MjtlWzQ0XT03MztlWzQ1XT03NDtlWzQ2XT03NTtlWzQ3XT03NjtlWzQ4XT03NztlWzQ5XT03ODtlWzUwXT03OTtlWzUxXT04MDtlWzUyXT04MTtlWzUzXT04MjtlWzU0XT04MztlWzU1XT04NDtlWzU2XT04NTtlWzU3XT04NjtlWzU4XT04NztlWzU5XT04ODtlWzYwXT04OTtlWzYxXT05MDtlWzYyXT05MTtlWzYzXT05MjtlWzY0XT05MztlWzY1XT05NDtlWzY2XT05NTtlWzY3XT05NjtlWzY4XT05NztlWzY5XT05ODtlWzcwXT05OTtlWzcxXT0xMDA7ZVs3Ml09MTAxO2VbNzNdPTEwMjtlWzc0XT0xMDM7ZVs3NV09MTA0O2VbNzZdPTEwNTtlWzc3XT0xMDY7ZVs3OF09MTA3O2VbNzldPTEwODtlWzgwXT0xMDk7ZVs4MV09MTEwO2VbODJdPTExMTtlWzgzXT0xMTI7ZVs4NF09MTEzO2VbODVdPTExNDtlWzg2XT0xMTU7ZVs4N109MTE2O2VbODhdPTExNztlWzg5XT0xMTg7ZVs5MF09MTE5O2VbOTFdPTEyMDtlWzkyXT0xMjE7ZVs5M109MTIyO2VbOTRdPTEyMztlWzk1XT0xMjQ7ZVs5Nl09MTI1O2VbOTddPTEyNjtlWzk4XT0xOTY7ZVs5OV09MTk3O2VbMTAwXT0xOTk7ZVsxMDFdPTIwMTtlWzEwMl09MjA5O2VbMTAzXT0yMTQ7ZVsxMDRdPTIyMDtlWzEwNV09MjI1O2VbMTA2XT0yMjQ7ZVsxMDddPTIyNjtlWzEwOF09MjI4O2VbMTA5XT0yMjc7ZVsxMTBdPTIyOTtlWzExMV09MjMxO2VbMTEyXT0yMzM7ZVsxMTNdPTIzMjtlWzExNF09MjM0O2VbMTE1XT0yMzU7ZVsxMTZdPTIzNztlWzExN109MjM2O2VbMTE4XT0yMzg7ZVsxMTldPTIzOTtlWzEyMF09MjQxO2VbMTIxXT0yNDM7ZVsxMjJdPTI0MjtlWzEyM109MjQ0O2VbMTI0XT0yNDY7ZVsxMjVdPTI0NTtlWzEyNl09MjUwO2VbMTI3XT0yNDk7ZVsxMjhdPTI1MTtlWzEyOV09MjUyO2VbMTMwXT04MjI0O2VbMTMxXT0xNzY7ZVsxMzJdPTE2MjtlWzEzM109MTYzO2VbMTM0XT0xNjc7ZVsxMzVdPTgyMjY7ZVsxMzZdPTE4MjtlWzEzN109MjIzO2VbMTM4XT0xNzQ7ZVsxMzldPTE2OTtlWzE0MF09ODQ4MjtlWzE0MV09MTgwO2VbMTQyXT0xNjg7ZVsxNDNdPTg4MDA7ZVsxNDRdPTE5ODtlWzE0NV09MjE2O2VbMTQ2XT04NzM0O2VbMTQ3XT0xNzc7ZVsxNDhdPTg4MDQ7ZVsxNDldPTg4MDU7ZVsxNTBdPTE2NTtlWzE1MV09MTgxO2VbMTUyXT04NzA2O2VbMTUzXT04NzIxO2VbMTU0XT04NzE5O2VbMTU2XT04NzQ3O2VbMTU3XT0xNzA7ZVsxNThdPTE4NjtlWzE1OV09ODQ4NjtlWzE2MF09MjMwO2VbMTYxXT0yNDg7ZVsxNjJdPTE5MTtlWzE2M109MTYxO2VbMTY0XT0xNzI7ZVsxNjVdPTg3MzA7ZVsxNjZdPTQwMjtlWzE2N109ODc3NjtlWzE2OF09ODcxMDtlWzE2OV09MTcxO2VbMTcwXT0xODc7ZVsxNzFdPTgyMzA7ZVsxNzldPTgyMjA7ZVsxODBdPTgyMjE7ZVsxODFdPTgyMTY7ZVsxODJdPTgyMTc7ZVsyMDBdPTE5MztlWzIwM109MjA1O2VbMjA3XT0yMTE7ZVsyMTBdPTIxODtlWzIyM109NzExO2VbMjI0XT0zMjE7ZVsyMjVdPTMyMjtlWzIyNl09MzUyO2VbMjI3XT0zNTM7ZVsyMjhdPTM4MTtlWzIyOV09MzgyO2VbMjMzXT0yMjE7ZVsyMzRdPTI1MztlWzI1Ml09MjYzO2VbMjUzXT0yNjg7ZVsyNTRdPTI2OTtlWzI1OF09MjU4O2VbMjYwXT0yNjA7ZVsyNjFdPTI2MTtlWzI2NV09MjgwO2VbMjY2XT0yODE7ZVsyNjddPTI4MjtlWzI2OF09MjgzO2VbMjY5XT0zMTM7ZVsyNzVdPTMyMztlWzI3Nl09MzI0O2VbMjc4XT0zMjg7ZVsyODNdPTM0NDtlWzI4NF09MzQ1O2VbMjg1XT0zNDY7ZVsyODZdPTM0NztlWzI5Ml09MzY3O2VbMjk1XT0zNzc7ZVsyOTZdPTM3ODtlWzI5OF09MzgwO2VbMzA1XT05NjM7ZVszMDZdPTk2NDtlWzMwN109OTY2O2VbMzA4XT04MjE1O2VbMzA5XT04MjUyO2VbMzEwXT04MzE5O2VbMzExXT04MzU5O2VbMzEyXT04NTkyO2VbMzEzXT04NTkzO2VbMzM3XT05NTUyO2VbNDkzXT0xMDM5O2VbNDk0XT0xMDQwO2VbNTcwXT0xMDQwO2VbNTcxXT0xMDQxO2VbNTcyXT0xMDQyO2VbNTczXT0xMDQzO2VbNTc0XT0xMDQ0O2VbNTc1XT0xMDQ1O2VbNTc2XT0xMDQ2O2VbNTc3XT0xMDQ3O2VbNTc4XT0xMDQ4O2VbNTc5XT0xMDQ5O2VbNTgwXT0xMDUwO2VbNTgxXT0xMDUxO2VbNTgyXT0xMDUyO2VbNTgzXT0xMDUzO2VbNTg0XT0xMDU0O2VbNTg1XT0xMDU1O2VbNTg2XT0xMDU2O2VbNTg3XT0xMDU3O2VbNTg4XT0xMDU4O2VbNTg5XT0xMDU5O2VbNTkwXT0xMDYwO2VbNTkxXT0xMDYxO2VbNTkyXT0xMDYyO2VbNTkzXT0xMDYzO2VbNTk0XT0xMDY0O2VbNTk1XT0xMDY1O2VbNTk2XT0xMDY2O2VbNTk3XT0xMDY3O2VbNTk4XT0xMDY4O2VbNTk5XT0xMDY5O2VbNjAwXT0xMDcwO2VbNjcyXT0xNDg4O2VbNjczXT0xNDg5O2VbNjc0XT0xNDkwO2VbNjc1XT0xNDkxO2VbNjc2XT0xNDkyO2VbNjc3XT0xNDkzO2VbNjc4XT0xNDk0O2VbNjc5XT0xNDk1O2VbNjgwXT0xNDk2O2VbNjgxXT0xNDk3O2VbNjgyXT0xNDk4O2VbNjgzXT0xNDk5O2VbNjg0XT0xNTAwO2VbNjg1XT0xNTAxO2VbNjg2XT0xNTAyO2VbNjg3XT0xNTAzO2VbNjg4XT0xNTA0O2VbNjg5XT0xNTA1O2VbNjkwXT0xNTA2O2VbNjkxXT0xNTA3O2VbNjkyXT0xNTA4O2VbNjkzXT0xNTA5O2VbNjk0XT0xNTEwO2VbNjk1XT0xNTExO2VbNjk2XT0xNTEyO2VbNjk3XT0xNTEzO2VbNjk4XT0xNTE0O2VbNzA1XT0xNTI0O2VbNzA2XT04MzYyO2VbNzEwXT02NDI4ODtlWzcxMV09NjQyOTg7ZVs3NTldPTE2MTc7ZVs3NjFdPTE3NzY7ZVs3NjNdPTE3Nzg7ZVs3NzVdPTE2NTI7ZVs3NzddPTE3NjQ7ZVs3NzhdPTE3ODA7ZVs3NzldPTE3ODE7ZVs3ODBdPTE3ODI7ZVs3ODJdPTc3MTtlWzc4M109NjQ3MjY7ZVs3ODZdPTgzNjM7ZVs3ODhdPTg1MzI7ZVs3OTBdPTc2ODtlWzc5MV09NzY5O2VbNzkyXT03Njg7ZVs3OTVdPTgwMztlWzc5N109NjQzMzY7ZVs3OThdPTY0MzM3O2VbNzk5XT02NDM0MjtlWzgwMF09NjQzNDM7ZVs4MDFdPTY0MzQ0O2VbODAyXT02NDM0NTtlWzgwM109NjQzNjI7ZVs4MDRdPTY0MzYzO2VbODA1XT02NDM2NDtlWzI0MjRdPTc4MjE7ZVsyNDI1XT03ODIyO2VbMjQyNl09NzgyMztlWzI0MjddPTc4MjQ7ZVsyNDI4XT03ODI1O2VbMjQyOV09NzgyNjtlWzI0MzBdPTc4Mjc7ZVsyNDMzXT03NjgyO2VbMjY3OF09ODA0NTtlWzI2NzldPTgwNDY7ZVsyODMwXT0xNTUyO2VbMjgzOF09Njg2O2VbMjg0MF09NzUxO2VbMjg0Ml09NzUzO2VbMjg0M109NzU0O2VbMjg0NF09NzU1O2VbMjg0Nl09NzU3O2VbMjg1Nl09NzY3O2VbMjg1N109ODQ4O2VbMjg1OF09ODQ5O2VbMjg2Ml09ODUzO2VbMjg2M109ODU0O2VbMjg2NF09ODU1O2VbMjg2NV09ODYxO2VbMjg2Nl09ODYyO2VbMjkwNl09NzQ2MDtlWzI5MDhdPTc0NjI7ZVsyOTA5XT03NDYzO2VbMjkxMF09NzQ2NDtlWzI5MTJdPTc0NjY7ZVsyOTEzXT03NDY3O2VbMjkxNF09NzQ2ODtlWzI5MTZdPTc0NzA7ZVsyOTE3XT03NDcxO2VbMjkxOF09NzQ3MjtlWzI5MjBdPTc0NzQ7ZVsyOTIxXT03NDc1O2VbMjkyMl09NzQ3NjtlWzI5MjRdPTc0Nzg7ZVsyOTI1XT03NDc5O2VbMjkyNl09NzQ4MDtlWzI5MjhdPTc0ODI7ZVsyOTI5XT03NDgzO2VbMjkzMF09NzQ4NDtlWzI5MzJdPTc0ODY7ZVsyOTMzXT03NDg3O2VbMjkzNF09NzQ4ODtlWzI5MzZdPTc0OTA7ZVsyOTM3XT03NDkxO2VbMjkzOF09NzQ5MjtlWzI5NDBdPTc0OTQ7ZVsyOTQxXT03NDk1O2VbMjk0Ml09NzQ5NjtlWzI5NDRdPTc0OTg7ZVsyOTQ2XT03NTAwO2VbMjk0OF09NzUwMjtlWzI5NTBdPTc1MDQ7ZVsyOTUxXT03NTA1O2VbMjk1Ml09NzUwNjtlWzI5NTRdPTc1MDg7ZVsyOTU1XT03NTA5O2VbMjk1Nl09NzUxMDtlWzI5NThdPTc1MTI7ZVsyOTU5XT03NTEzO2VbMjk2MF09NzUxNDtlWzI5NjJdPTc1MTY7ZVsyOTYzXT03NTE3O2VbMjk2NF09NzUxODtlWzI5NjZdPTc1MjA7ZVsyOTY3XT03NTIxO2VbMjk2OF09NzUyMjtlWzI5NzBdPTc1MjQ7ZVsyOTcxXT03NTI1O2VbMjk3Ml09NzUyNjtlWzI5NzRdPTc1Mjg7ZVsyOTc1XT03NTI5O2VbMjk3Nl09NzUzMDtlWzI5NzhdPTE1Mzc7ZVsyOTc5XT0xNTM4O2VbMjk4MF09MTUzOTtlWzI5ODJdPTE1NDk7ZVsyOTgzXT0xNTUxO2VbMjk4NF09MTU1MjtlWzI5ODZdPTE1NTQ7ZVsyOTg3XT0xNTU1O2VbMjk4OF09MTU1NjtlWzI5OTBdPTE2MjM7ZVsyOTkxXT0xNjI0O2VbMjk5NV09MTc3NTtlWzI5OTldPTE3OTE7ZVszMDAyXT02NDI5MDtlWzMwMDNdPTY0MjkxO2VbMzAwNF09NjQyOTI7ZVszMDA2XT02NDI5NDtlWzMwMDddPTY0Mjk1O2VbMzAwOF09NjQyOTY7ZVszMDExXT0xOTAwO2VbMzAxNF09ODIyMztlWzMwMTVdPTgyNDQ7ZVszMDE3XT03NTMyO2VbMzAxOF09NzUzMztlWzMwMTldPTc1MzQ7ZVszMDc1XT03NTkwO2VbMzA3Nl09NzU5MTtlWzMwNzldPTc1OTQ7ZVszMDgwXT03NTk1O2VbMzA4M109NzU5ODtlWzMwODRdPTc1OTk7ZVszMDg3XT03NjAyO2VbMzA4OF09NzYwMztlWzMwOTFdPTc2MDY7ZVszMDkyXT03NjA3O2VbMzA5NV09NzYxMDtlWzMwOTZdPTc2MTE7ZVszMDk5XT03NjE0O2VbMzEwMF09NzYxNTtlWzMxMDNdPTc2MTg7ZVszMTA0XT03NjE5O2VbMzEwN109ODMzNztlWzMxMDhdPTgzMzg7ZVszMTE2XT0xODg0O2VbMzExOV09MTg4NTtlWzMxMjBdPTE4ODU7ZVszMTIzXT0xODg2O2VbMzEyNF09MTg4NjtlWzMxMjddPTE4ODc7ZVszMTI4XT0xODg3O2VbMzEzMV09MTg4ODtlWzMxMzJdPTE4ODg7ZVszMTM1XT0xODg5O2VbMzEzNl09MTg4OTtlWzMxMzldPTE4OTA7ZVszMTQwXT0xODkwO2VbMzE0M109MTg5MTtlWzMxNDRdPTE4OTE7ZVszMTQ3XT0xODkyO2VbMzE0OF09MTg5MjtlWzMxNTNdPTU4MDtlWzMxNTRdPTU4MTtlWzMxNTddPTU4NDtlWzMxNThdPTU4NTtlWzMxNjFdPTU4ODtlWzMxNjJdPTU4OTtlWzMxNjVdPTg5MTtlWzMxNjZdPTg5MjtlWzMxNjldPTEyNzQ7ZVszMTcwXT0xMjc1O2VbMzE3M109MTI3ODtlWzMxNzRdPTEyNzk7ZVszMTgxXT03NjIyO2VbMzE4Ml09NzYyMztlWzMyODJdPTExNzk5O2VbMzMxNl09NTc4O2VbMzM3OV09NDI3ODU7ZVszMzkzXT0xMTU5O2VbMzQxNl09ODM3N30pKSxfcj1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2VbMjI3XT0zMjI7ZVsyNjRdPTI2MTtlWzI5MV09MzQ2fSkpLFVyPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZVsxXT0zMjtlWzRdPTY1O2VbNV09MTkyO2VbNl09MTkzO2VbOV09MTk2O2VbMTddPTY2O2VbMThdPTY3O2VbMjFdPTI2ODtlWzI0XT02ODtlWzI4XT02OTtlWzI5XT0yMDA7ZVszMF09MjAxO2VbMzJdPTI4MjtlWzM4XT03MDtlWzM5XT03MTtlWzQ0XT03MjtlWzQ3XT03MztlWzQ4XT0yMDQ7ZVs0OV09MjA1O2VbNThdPTc0O2VbNjBdPTc1O2VbNjJdPTc2O2VbNjhdPTc3O2VbNjldPTc4O2VbNzVdPTc5O2VbNzZdPTIxMDtlWzgwXT0yMTQ7ZVs4N109ODA7ZVs4OV09ODE7ZVs5MF09ODI7ZVs5Ml09MzQ0O2VbOTRdPTgzO2VbOTddPTM1MjtlWzEwMF09ODQ7ZVsxMDRdPTg1O2VbMTA5XT0yMjA7ZVsxMTVdPTg2O2VbMTE2XT04NztlWzEyMV09ODg7ZVsxMjJdPTg5O2VbMTI0XT0yMjE7ZVsxMjddPTkwO2VbMTI5XT0zODE7ZVsyNThdPTk3O2VbMjU5XT0yMjQ7ZVsyNjBdPTIyNTtlWzI2M109MjI4O2VbMjY4XT0yNjE7ZVsyNzFdPTk4O2VbMjcyXT05OTtlWzI3M109MjYzO2VbMjc1XT0yNjk7ZVsyODJdPTEwMDtlWzI4Nl09MTAxO2VbMjg3XT0yMzI7ZVsyODhdPTIzMztlWzI5MF09MjgzO2VbMjk1XT0yODE7ZVsyOTZdPTEwMjtlWzMzNl09MTAzO2VbMzQ2XT0xMDQ7ZVszNDldPTEwNTtlWzM1MF09MjM2O2VbMzUxXT0yMzc7ZVszNjFdPTEwNjtlWzM2NF09MTA3O2VbMzY3XT0xMDg7ZVszNzFdPTMyMjtlWzM3M109MTA5O2VbMzc0XT0xMTA7ZVszODFdPTExMTtlWzM4Ml09MjQyO2VbMzgzXT0yNDM7ZVszODZdPTI0NjtlWzM5M109MTEyO2VbMzk1XT0xMTM7ZVszOTZdPTExNDtlWzM5OF09MzQ1O2VbNDAwXT0xMTU7ZVs0MDFdPTM0NztlWzQwM109MzUzO2VbNDEwXT0xMTY7ZVs0MzddPTExNztlWzQ0Ml09MjUyO2VbNDQ4XT0xMTg7ZVs0NDldPTExOTtlWzQ1NF09MTIwO2VbNDU1XT0xMjE7ZVs0NTddPTI1MztlWzQ2MF09MTIyO2VbNDYyXT0zODI7ZVs0NjNdPTM4MDtlWzg1M109NDQ7ZVs4NTVdPTU4O2VbODU2XT00NjtlWzg3Nl09NDc7ZVs4NzhdPTQ1O2VbODgyXT00NTtlWzg5NF09NDA7ZVs4OTVdPTQxO2VbODk2XT05MTtlWzg5N109OTM7ZVs5MjNdPTY0O2VbOTQwXT0xNjM7ZVsxMDA0XT00ODtlWzEwMDVdPTQ5O2VbMTAwNl09NTA7ZVsxMDA3XT01MTtlWzEwMDhdPTUyO2VbMTAwOV09NTM7ZVsxMDEwXT01NDtlWzEwMTFdPTU1O2VbMTAxMl09NTY7ZVsxMDEzXT01NztlWzEwODFdPTM3O2VbMTA4NV09NDM7ZVsxMDg2XT00NX0pKTtmdW5jdGlvbiBnZXRTdGFuZGFyZEZvbnROYW1lKGUpe2NvbnN0IHQ9bm9ybWFsaXplRm9udE5hbWUoZSk7cmV0dXJuIFJyKClbdF19ZnVuY3Rpb24gaXNLbm93bkZvbnROYW1lKGUpe2NvbnN0IHQ9bm9ybWFsaXplRm9udE5hbWUoZSk7cmV0dXJuISEoUnIoKVt0XXx8RXIoKVt0XXx8UHIoKVt0XXx8THIoKVt0XSl9Y2xhc3MgVG9Vbmljb2RlTWFwe2NvbnN0cnVjdG9yKGU9W10pe3RoaXMuX21hcD1lfWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5fbWFwLmxlbmd0aH1mb3JFYWNoKGUpe2Zvcihjb25zdCB0IGluIHRoaXMuX21hcCllKHQsdGhpcy5fbWFwW3RdLmNvZGVQb2ludEF0KDApKX1oYXMoZSl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX21hcFtlXX1nZXQoZSl7cmV0dXJuIHRoaXMuX21hcFtlXX1jaGFyQ29kZU9mKGUpe2NvbnN0IHQ9dGhpcy5fbWFwO2lmKHQubGVuZ3RoPD02NTUzNilyZXR1cm4gdC5pbmRleE9mKGUpO2Zvcihjb25zdCBhIGluIHQpaWYodFthXT09PWUpcmV0dXJuIDB8YTtyZXR1cm4tMX1hbWVuZChlKXtmb3IoY29uc3QgdCBpbiBlKXRoaXMuX21hcFt0XT1lW3RdfX1jbGFzcyBJZGVudGl0eVRvVW5pY29kZU1hcHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuZmlyc3RDaGFyPWU7dGhpcy5sYXN0Q2hhcj10fWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5sYXN0Q2hhcisxLXRoaXMuZmlyc3RDaGFyfWZvckVhY2goZSl7Zm9yKGxldCB0PXRoaXMuZmlyc3RDaGFyLGE9dGhpcy5sYXN0Q2hhcjt0PD1hO3QrKyllKHQsdCl9aGFzKGUpe3JldHVybiB0aGlzLmZpcnN0Q2hhcjw9ZSYmZTw9dGhpcy5sYXN0Q2hhcn1nZXQoZSl7aWYodGhpcy5maXJzdENoYXI8PWUmJmU8PXRoaXMubGFzdENoYXIpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZSl9Y2hhckNvZGVPZihlKXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihlKSYmZT49dGhpcy5maXJzdENoYXImJmU8PXRoaXMubGFzdENoYXI/ZTotMX1hbWVuZChlKXt1bnJlYWNoYWJsZSgiU2hvdWxkIG5vdCBjYWxsIGFtZW5kKCkiKX19Y2xhc3MgQ0ZGRm9udHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMucHJvcGVydGllcz10O2NvbnN0IGE9bmV3IENGRlBhcnNlcihlLHQscHIpO3RoaXMuY2ZmPWEucGFyc2UoKTt0aGlzLmNmZi5kdXBsaWNhdGVGaXJzdEdseXBoKCk7Y29uc3Qgcj1uZXcgQ0ZGQ29tcGlsZXIodGhpcy5jZmYpO3RoaXMuc2VhY3M9dGhpcy5jZmYuc2VhY3M7dHJ5e3RoaXMuZGF0YT1yLmNvbXBpbGUoKX1jYXRjaHt3YXJuKCJGYWlsZWQgdG8gY29tcGlsZSBmb250ICIrdC5sb2FkZWROYW1lKTt0aGlzLmRhdGE9ZX10aGlzLl9jcmVhdGVCdWlsdEluRW5jb2RpbmcoKX1nZXQgbnVtR2x5cGhzKCl7cmV0dXJuIHRoaXMuY2ZmLmNoYXJTdHJpbmdzLmNvdW50fWdldENoYXJzZXQoKXtyZXR1cm4gdGhpcy5jZmYuY2hhcnNldC5jaGFyc2V0fWdldEdseXBoTWFwcGluZygpe2NvbnN0IGU9dGhpcy5jZmYsdD10aGlzLnByb3BlcnRpZXMse2NpZFRvR2lkTWFwOmEsY01hcDpyfT10LGk9ZS5jaGFyc2V0LmNoYXJzZXQ7bGV0IG4scztpZih0LmNvbXBvc2l0ZSl7bGV0IHQsbztpZihhPy5sZW5ndGg+MCl7dD1PYmplY3QuY3JlYXRlKG51bGwpO2ZvcihsZXQgZT0wLHI9YS5sZW5ndGg7ZTxyO2UrKyl7Y29uc3Qgcj1hW2VdO3ZvaWQgMCE9PXImJih0W3JdPWUpfX1uPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoZS5pc0NJREZvbnQpZm9yKHM9MDtzPGkubGVuZ3RoO3MrKyl7Y29uc3QgZT1pW3NdO289ci5jaGFyQ29kZU9mKGUpO3ZvaWQgMCE9PXQ/LltvXSYmKG89dFtvXSk7bltvXT1zfWVsc2UgZm9yKHM9MDtzPGUuY2hhclN0cmluZ3MuY291bnQ7cysrKXtvPXIuY2hhckNvZGVPZihzKTtuW29dPXN9cmV0dXJuIG59bGV0IG89ZS5lbmNvZGluZz9lLmVuY29kaW5nLmVuY29kaW5nOm51bGw7dC5pc0ludGVybmFsRm9udCYmKG89dC5kZWZhdWx0RW5jb2RpbmcpO249dHlwZTFGb250R2x5cGhNYXBwaW5nKHQsbyxpKTtyZXR1cm4gbn1oYXNHbHlwaElkKGUpe3JldHVybiB0aGlzLmNmZi5oYXNHbHlwaElkKGUpfV9jcmVhdGVCdWlsdEluRW5jb2RpbmcoKXtjb25zdHtjaGFyc2V0OmUsZW5jb2Rpbmc6dH09dGhpcy5jZmY7aWYoIWV8fCF0KXJldHVybjtjb25zdCBhPWUuY2hhcnNldCxyPXQuZW5jb2RpbmcsaT1bXTtmb3IoY29uc3QgZSBpbiByKXtjb25zdCB0PXJbZV07aWYodD49MCl7Y29uc3Qgcj1hW3RdO3ImJihpW2VdPXIpfX1pLmxlbmd0aD4wJiYodGhpcy5wcm9wZXJ0aWVzLmJ1aWx0SW5FbmNvZGluZz1pKX19ZnVuY3Rpb24gZ2V0RmxvYXQyMTQoZSx0KXtyZXR1cm4gcmVhZEludDE2KGUsdCkvMTYzODR9ZnVuY3Rpb24gZ2V0U3Vicm91dGluZUJpYXMoZSl7Y29uc3QgdD1lLmxlbmd0aDtsZXQgYT0zMjc2ODt0PDEyNDA/YT0xMDc6dDwzMzkwMCYmKGE9MTEzMSk7cmV0dXJuIGF9ZnVuY3Rpb24gcGFyc2VDbWFwKGUsdCxhKXtjb25zdCByPTE9PT1yZWFkVWludDE2KGUsdCsyKT9yZWFkVWludDMyKGUsdCs4KTpyZWFkVWludDMyKGUsdCsxNiksaT1yZWFkVWludDE2KGUsdCtyKTtsZXQgbixzLG87aWYoND09PWkpe3JlYWRVaW50MTYoZSx0K3IrMik7Y29uc3QgYT1yZWFkVWludDE2KGUsdCtyKzYpPj4xO3M9dCtyKzE0O249W107Zm9yKG89MDtvPGE7bysrLHMrPTIpbltvXT17ZW5kOnJlYWRVaW50MTYoZSxzKX07cys9Mjtmb3Iobz0wO288YTtvKysscys9MiluW29dLnN0YXJ0PXJlYWRVaW50MTYoZSxzKTtmb3Iobz0wO288YTtvKysscys9MiluW29dLmlkRGVsdGE9cmVhZFVpbnQxNihlLHMpO2ZvcihvPTA7bzxhO28rKyxzKz0yKXtsZXQgdD1yZWFkVWludDE2KGUscyk7aWYoMCE9PXQpe25bb10uaWRzPVtdO2ZvcihsZXQgYT0wLHI9bltvXS5lbmQtbltvXS5zdGFydCsxO2E8cjthKyspe25bb10uaWRzW2FdPXJlYWRVaW50MTYoZSxzK3QpO3QrPTJ9fX1yZXR1cm4gbn1pZigxMj09PWkpe2NvbnN0IGE9cmVhZFVpbnQzMihlLHQrcisxMik7cz10K3IrMTY7bj1bXTtmb3Iobz0wO288YTtvKyspe3Q9cmVhZFVpbnQzMihlLHMpO24ucHVzaCh7c3RhcnQ6dCxlbmQ6cmVhZFVpbnQzMihlLHMrNCksaWREZWx0YTpyZWFkVWludDMyKGUscys4KS10fSk7cys9MTJ9cmV0dXJuIG59dGhyb3cgbmV3IEZvcm1hdEVycm9yKGB1bnN1cHBvcnRlZCBjbWFwOiAke2l9YCl9ZnVuY3Rpb24gcGFyc2VDZmYoZSx0LGEscil7Y29uc3QgaT1uZXcgQ0ZGUGFyc2VyKG5ldyBTdHJlYW0oZSx0LGEtdCkse30scikucGFyc2UoKTtyZXR1cm57Z2x5cGhzOmkuY2hhclN0cmluZ3Mub2JqZWN0cyxzdWJyczppLnRvcERpY3QucHJpdmF0ZURpY3Q/LnN1YnJzSW5kZXg/Lm9iamVjdHMsZ3N1YnJzOmkuZ2xvYmFsU3VickluZGV4Py5vYmplY3RzLGlzQ0ZGQ0lERm9udDppLmlzQ0lERm9udCxmZFNlbGVjdDppLmZkU2VsZWN0LGZkQXJyYXk6aS5mZEFycmF5fX1mdW5jdGlvbiBsb29rdXBDbWFwKGUsdCl7Y29uc3QgYT10LmNvZGVQb2ludEF0KDApO2xldCByPTAsaT0wLG49ZS5sZW5ndGgtMTtmb3IoO2k8bjspe2NvbnN0IHQ9aStuKzE+PjE7YTxlW3RdLnN0YXJ0P249dC0xOmk9dH1lW2ldLnN0YXJ0PD1hJiZhPD1lW2ldLmVuZCYmKHI9ZVtpXS5pZERlbHRhKyhlW2ldLmlkcz9lW2ldLmlkc1thLWVbaV0uc3RhcnRdOmEpJjY1NTM1KTtyZXR1cm57Y2hhckNvZGU6YSxnbHlwaElkOnJ9fWZ1bmN0aW9uIGNvbXBpbGVHbHlmKGUsdCxhKXtmdW5jdGlvbiBtb3ZlVG8oZSxhKXtzJiZ0LmFkZCgiTCIscyk7cz1bZSxhXTt0LmFkZCgiTSIsW2UsYV0pfWZ1bmN0aW9uIGxpbmVUbyhlLGEpe3QuYWRkKCJMIixbZSxhXSl9ZnVuY3Rpb24gcXVhZHJhdGljQ3VydmVUbyhlLGEscixpKXt0LmFkZCgiUSIsW2UsYSxyLGldKX1sZXQgcj0wO2NvbnN0IGk9cmVhZEludDE2KGUscik7bGV0IG4scz1udWxsLG89MCxjPTA7cis9MTA7aWYoaTwwKWRve249cmVhZFVpbnQxNihlLHIpO2NvbnN0IGk9cmVhZFVpbnQxNihlLHIrMik7cis9NDtsZXQgcyxsO2lmKDEmbil7aWYoMiZuKXtzPXJlYWRJbnQxNihlLHIpO2w9cmVhZEludDE2KGUscisyKX1lbHNle3M9cmVhZFVpbnQxNihlLHIpO2w9cmVhZFVpbnQxNihlLHIrMil9cis9NH1lbHNlIGlmKDImbil7cz1yZWFkSW50OChlLHIrKyk7bD1yZWFkSW50OChlLHIrKyl9ZWxzZXtzPWVbcisrXTtsPWVbcisrXX1pZigyJm4pe289cztjPWx9ZWxzZXtvPTA7Yz0wfWxldCBoPTEsdT0xLGQ9MCxmPTA7aWYoOCZuKXtoPXU9Z2V0RmxvYXQyMTQoZSxyKTtyKz0yfWVsc2UgaWYoNjQmbil7aD1nZXRGbG9hdDIxNChlLHIpO3U9Z2V0RmxvYXQyMTQoZSxyKzIpO3IrPTR9ZWxzZSBpZigxMjgmbil7aD1nZXRGbG9hdDIxNChlLHIpO2Q9Z2V0RmxvYXQyMTQoZSxyKzIpO2Y9Z2V0RmxvYXQyMTQoZSxyKzQpO3U9Z2V0RmxvYXQyMTQoZSxyKzYpO3IrPTh9Y29uc3QgZz1hLmdseXBoc1tpXTtpZihnKXt0LnNhdmUoKTt0LnRyYW5zZm9ybShbaCxkLGYsdSxvLGNdKTtjb21waWxlR2x5ZihnLHQsYSk7dC5yZXN0b3JlKCl9fXdoaWxlKDMyJm4pO2Vsc2V7Y29uc3QgdD1bXTtsZXQgYSxzO2ZvcihhPTA7YTxpO2ErKyl7dC5wdXNoKHJlYWRVaW50MTYoZSxyKSk7cis9Mn1yKz0yK3JlYWRVaW50MTYoZSxyKTtjb25zdCBsPXQuYXQoLTEpKzEsaD1bXTtmb3IoO2gubGVuZ3RoPGw7KXtuPWVbcisrXTtsZXQgdD0xOzgmbiYmKHQrPWVbcisrXSk7Zm9yKDt0LS0gPjA7KWgucHVzaCh7ZmxhZ3M6bn0pfWZvcihhPTA7YTxsO2ErKyl7c3dpdGNoKDE4JmhbYV0uZmxhZ3Mpe2Nhc2UgMDpvKz1yZWFkSW50MTYoZSxyKTtyKz0yO2JyZWFrO2Nhc2UgMjpvLT1lW3IrK107YnJlYWs7Y2FzZSAxODpvKz1lW3IrK119aFthXS54PW99Zm9yKGE9MDthPGw7YSsrKXtzd2l0Y2goMzYmaFthXS5mbGFncyl7Y2FzZSAwOmMrPXJlYWRJbnQxNihlLHIpO3IrPTI7YnJlYWs7Y2FzZSA0OmMtPWVbcisrXTticmVhaztjYXNlIDM2OmMrPWVbcisrXX1oW2FdLnk9Y31sZXQgdT0wO2ZvcihyPTA7cjxpO3IrKyl7Y29uc3QgZT10W3JdLGk9aC5zbGljZSh1LGUrMSk7aWYoMSZpWzBdLmZsYWdzKWkucHVzaChpWzBdKTtlbHNlIGlmKDEmaS5hdCgtMSkuZmxhZ3MpaS51bnNoaWZ0KGkuYXQoLTEpKTtlbHNle2NvbnN0IGU9e2ZsYWdzOjEseDooaVswXS54K2kuYXQoLTEpLngpLzIseTooaVswXS55K2kuYXQoLTEpLnkpLzJ9O2kudW5zaGlmdChlKTtpLnB1c2goZSl9bW92ZVRvKGlbMF0ueCxpWzBdLnkpO2ZvcihhPTEscz1pLmxlbmd0aDthPHM7YSsrKWlmKDEmaVthXS5mbGFncylsaW5lVG8oaVthXS54LGlbYV0ueSk7ZWxzZSBpZigxJmlbYSsxXS5mbGFncyl7cXVhZHJhdGljQ3VydmVUbyhpW2FdLngsaVthXS55LGlbYSsxXS54LGlbYSsxXS55KTthKyt9ZWxzZSBxdWFkcmF0aWNDdXJ2ZVRvKGlbYV0ueCxpW2FdLnksKGlbYV0ueCtpW2ErMV0ueCkvMiwoaVthXS55K2lbYSsxXS55KS8yKTt1PWUrMX19fWZ1bmN0aW9uIGNvbXBpbGVDaGFyU3RyaW5nKGUsdCxhLHIpe2Z1bmN0aW9uIG1vdmVUbyhlLGEpe2MmJnQuYWRkKCJMIixjKTtjPVtlLGFdO3QuYWRkKCJNIixbZSxhXSl9ZnVuY3Rpb24gbGluZVRvKGUsYSl7dC5hZGQoIkwiLFtlLGFdKX1mdW5jdGlvbiBiZXppZXJDdXJ2ZVRvKGUsYSxyLGksbixzKXt0LmFkZCgiQyIsW2UsYSxyLGksbixzXSl9Y29uc3QgaT1bXTtsZXQgbj0wLHM9MCxvPTAsYz1udWxsOyFmdW5jdGlvbiBwYXJzZShlKXtsZXQgYz0wO2Zvcig7YzxlLmxlbmd0aDspe2xldCBsLGgsdSxkLGYsZyxwLG0sYix5PSExLHc9ZVtjKytdO3N3aXRjaCh3KXtjYXNlIDE6Y2FzZSAzOmNhc2UgMTg6Y2FzZSAyMzpvKz1pLmxlbmd0aD4+MTt5PSEwO2JyZWFrO2Nhc2UgNDpzKz1pLnBvcCgpO21vdmVUbyhuLHMpO3k9ITA7YnJlYWs7Y2FzZSA1OmZvcig7aS5sZW5ndGg+MDspe24rPWkuc2hpZnQoKTtzKz1pLnNoaWZ0KCk7bGluZVRvKG4scyl9YnJlYWs7Y2FzZSA2OmZvcig7aS5sZW5ndGg+MDspe24rPWkuc2hpZnQoKTtsaW5lVG8obixzKTtpZigwPT09aS5sZW5ndGgpYnJlYWs7cys9aS5zaGlmdCgpO2xpbmVUbyhuLHMpfWJyZWFrO2Nhc2UgNzpmb3IoO2kubGVuZ3RoPjA7KXtzKz1pLnNoaWZ0KCk7bGluZVRvKG4scyk7aWYoMD09PWkubGVuZ3RoKWJyZWFrO24rPWkuc2hpZnQoKTtsaW5lVG8obixzKX1icmVhaztjYXNlIDg6Zm9yKDtpLmxlbmd0aD4wOyl7bD1uK2kuc2hpZnQoKTt1PXMraS5zaGlmdCgpO2g9bCtpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtuPWgraS5zaGlmdCgpO3M9ZCtpLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyhsLHUsaCxkLG4scyl9YnJlYWs7Y2FzZSAxMDptPWkucG9wKCk7Yj1udWxsO2lmKGEuaXNDRkZDSURGb250KXtjb25zdCBlPWEuZmRTZWxlY3QuZ2V0RkRJbmRleChyKTtpZihlPj0wJiZlPGEuZmRBcnJheS5sZW5ndGgpe2NvbnN0IHQ9YS5mZEFycmF5W2VdO2xldCByO3QucHJpdmF0ZURpY3Q/LnN1YnJzSW5kZXgmJihyPXQucHJpdmF0ZURpY3Quc3VicnNJbmRleC5vYmplY3RzKTtpZihyKXttKz1nZXRTdWJyb3V0aW5lQmlhcyhyKTtiPXJbbV19fWVsc2Ugd2FybigiSW52YWxpZCBmZCBpbmRleCBmb3IgZ2x5cGggaW5kZXguIil9ZWxzZSBiPWEuc3VicnNbbSthLnN1YnJzQmlhc107YiYmcGFyc2UoYik7YnJlYWs7Y2FzZSAxMTpyZXR1cm47Y2FzZSAxMjp3PWVbYysrXTtzd2l0Y2godyl7Y2FzZSAzNDpsPW4raS5zaGlmdCgpO2g9bCtpLnNoaWZ0KCk7Zj1zK2kuc2hpZnQoKTtuPWgraS5zaGlmdCgpO2JlemllckN1cnZlVG8obCxzLGgsZixuLGYpO2w9bitpLnNoaWZ0KCk7aD1sK2kuc2hpZnQoKTtuPWgraS5zaGlmdCgpO2JlemllckN1cnZlVG8obCxmLGgscyxuLHMpO2JyZWFrO2Nhc2UgMzU6bD1uK2kuc2hpZnQoKTt1PXMraS5zaGlmdCgpO2g9bCtpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtuPWgraS5zaGlmdCgpO3M9ZCtpLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyhsLHUsaCxkLG4scyk7bD1uK2kuc2hpZnQoKTt1PXMraS5zaGlmdCgpO2g9bCtpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtuPWgraS5zaGlmdCgpO3M9ZCtpLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyhsLHUsaCxkLG4scyk7aS5wb3AoKTticmVhaztjYXNlIDM2Omw9bitpLnNoaWZ0KCk7Zj1zK2kuc2hpZnQoKTtoPWwraS5zaGlmdCgpO2c9ZitpLnNoaWZ0KCk7bj1oK2kuc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKGwsZixoLGcsbixnKTtsPW4raS5zaGlmdCgpO2g9bCtpLnNoaWZ0KCk7cD1nK2kuc2hpZnQoKTtuPWgraS5zaGlmdCgpO2JlemllckN1cnZlVG8obCxnLGgscCxuLHMpO2JyZWFrO2Nhc2UgMzc6Y29uc3QgZT1uLHQ9cztsPW4raS5zaGlmdCgpO3U9cytpLnNoaWZ0KCk7aD1sK2kuc2hpZnQoKTtkPXUraS5zaGlmdCgpO249aCtpLnNoaWZ0KCk7cz1kK2kuc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKGwsdSxoLGQsbixzKTtsPW4raS5zaGlmdCgpO3U9cytpLnNoaWZ0KCk7aD1sK2kuc2hpZnQoKTtkPXUraS5zaGlmdCgpO249aDtzPWQ7TWF0aC5hYnMobi1lKT5NYXRoLmFicyhzLXQpP24rPWkuc2hpZnQoKTpzKz1pLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyhsLHUsaCxkLG4scyk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYHVua25vd24gb3BlcmF0b3I6IDEyICR7d31gKX1icmVhaztjYXNlIDE0OmlmKGkubGVuZ3RoPj00KXtjb25zdCBlPWkucG9wKCkscj1pLnBvcCgpO3M9aS5wb3AoKTtuPWkucG9wKCk7dC5zYXZlKCk7dC50cmFuc2xhdGUobixzKTtsZXQgbz1sb29rdXBDbWFwKGEuY21hcCxTdHJpbmcuZnJvbUNoYXJDb2RlKGEuZ2x5cGhOYW1lTWFwW25yW2VdXSkpO2NvbXBpbGVDaGFyU3RyaW5nKGEuZ2x5cGhzW28uZ2x5cGhJZF0sdCxhLG8uZ2x5cGhJZCk7dC5yZXN0b3JlKCk7bz1sb29rdXBDbWFwKGEuY21hcCxTdHJpbmcuZnJvbUNoYXJDb2RlKGEuZ2x5cGhOYW1lTWFwW25yW3JdXSkpO2NvbXBpbGVDaGFyU3RyaW5nKGEuZ2x5cGhzW28uZ2x5cGhJZF0sdCxhLG8uZ2x5cGhJZCl9cmV0dXJuO2Nhc2UgMTk6Y2FzZSAyMDpvKz1pLmxlbmd0aD4+MTtjKz1vKzc+PjM7eT0hMDticmVhaztjYXNlIDIxOnMrPWkucG9wKCk7bis9aS5wb3AoKTttb3ZlVG8obixzKTt5PSEwO2JyZWFrO2Nhc2UgMjI6bis9aS5wb3AoKTttb3ZlVG8obixzKTt5PSEwO2JyZWFrO2Nhc2UgMjQ6Zm9yKDtpLmxlbmd0aD4yOyl7bD1uK2kuc2hpZnQoKTt1PXMraS5zaGlmdCgpO2g9bCtpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtuPWgraS5zaGlmdCgpO3M9ZCtpLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyhsLHUsaCxkLG4scyl9bis9aS5zaGlmdCgpO3MrPWkuc2hpZnQoKTtsaW5lVG8obixzKTticmVhaztjYXNlIDI1OmZvcig7aS5sZW5ndGg+Njspe24rPWkuc2hpZnQoKTtzKz1pLnNoaWZ0KCk7bGluZVRvKG4scyl9bD1uK2kuc2hpZnQoKTt1PXMraS5zaGlmdCgpO2g9bCtpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtuPWgraS5zaGlmdCgpO3M9ZCtpLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyhsLHUsaCxkLG4scyk7YnJlYWs7Y2FzZSAyNjppLmxlbmd0aCUyJiYobis9aS5zaGlmdCgpKTtmb3IoO2kubGVuZ3RoPjA7KXtsPW47dT1zK2kuc2hpZnQoKTtoPWwraS5zaGlmdCgpO2Q9dStpLnNoaWZ0KCk7bj1oO3M9ZCtpLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyhsLHUsaCxkLG4scyl9YnJlYWs7Y2FzZSAyNzppLmxlbmd0aCUyJiYocys9aS5zaGlmdCgpKTtmb3IoO2kubGVuZ3RoPjA7KXtsPW4raS5zaGlmdCgpO3U9cztoPWwraS5zaGlmdCgpO2Q9dStpLnNoaWZ0KCk7bj1oK2kuc2hpZnQoKTtzPWQ7YmV6aWVyQ3VydmVUbyhsLHUsaCxkLG4scyl9YnJlYWs7Y2FzZSAyODppLnB1c2gocmVhZEludDE2KGUsYykpO2MrPTI7YnJlYWs7Y2FzZSAyOTptPWkucG9wKCkrYS5nc3VicnNCaWFzO2I9YS5nc3VicnNbbV07YiYmcGFyc2UoYik7YnJlYWs7Y2FzZSAzMDpmb3IoO2kubGVuZ3RoPjA7KXtsPW47dT1zK2kuc2hpZnQoKTtoPWwraS5zaGlmdCgpO2Q9dStpLnNoaWZ0KCk7bj1oK2kuc2hpZnQoKTtzPWQrKDE9PT1pLmxlbmd0aD9pLnNoaWZ0KCk6MCk7YmV6aWVyQ3VydmVUbyhsLHUsaCxkLG4scyk7aWYoMD09PWkubGVuZ3RoKWJyZWFrO2w9bitpLnNoaWZ0KCk7dT1zO2g9bCtpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtzPWQraS5zaGlmdCgpO249aCsoMT09PWkubGVuZ3RoP2kuc2hpZnQoKTowKTtiZXppZXJDdXJ2ZVRvKGwsdSxoLGQsbixzKX1icmVhaztjYXNlIDMxOmZvcig7aS5sZW5ndGg+MDspe2w9bitpLnNoaWZ0KCk7dT1zO2g9bCtpLnNoaWZ0KCk7ZD11K2kuc2hpZnQoKTtzPWQraS5zaGlmdCgpO249aCsoMT09PWkubGVuZ3RoP2kuc2hpZnQoKTowKTtiZXppZXJDdXJ2ZVRvKGwsdSxoLGQsbixzKTtpZigwPT09aS5sZW5ndGgpYnJlYWs7bD1uO3U9cytpLnNoaWZ0KCk7aD1sK2kuc2hpZnQoKTtkPXUraS5zaGlmdCgpO249aCtpLnNoaWZ0KCk7cz1kKygxPT09aS5sZW5ndGg/aS5zaGlmdCgpOjApO2JlemllckN1cnZlVG8obCx1LGgsZCxuLHMpfWJyZWFrO2RlZmF1bHQ6aWYodzwzMil0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYHVua25vd24gb3BlcmF0b3I6ICR7d31gKTtpZih3PDI0NylpLnB1c2gody0xMzkpO2Vsc2UgaWYodzwyNTEpaS5wdXNoKDI1Nioody0yNDcpK2VbYysrXSsxMDgpO2Vsc2UgaWYodzwyNTUpaS5wdXNoKDI1NiotKHctMjUxKS1lW2MrK10tMTA4KTtlbHNle2kucHVzaCgoZVtjXTw8MjR8ZVtjKzFdPDwxNnxlW2MrMl08PDh8ZVtjKzNdKS82NTUzNik7Yys9NH19eSYmKGkubGVuZ3RoPTApfX0oZSl9Y2xhc3MgQ29tbWFuZHN7Y21kcz1bXTt0cmFuc2Zvcm1TdGFjaz1bXTtjdXJyZW50VHJhbnNmb3JtPVsxLDAsMCwxLDAsMF07YWRkKGUsdCl7aWYodCl7Y29uc3R7Y3VycmVudFRyYW5zZm9ybTphfT10aGlzO2ZvcihsZXQgZT0wLHI9dC5sZW5ndGg7ZTxyO2UrPTIpVXRpbC5hcHBseVRyYW5zZm9ybSh0LGEsZSk7dGhpcy5jbWRzLnB1c2goYCR7ZX0ke3Quam9pbigiICIpfWApfWVsc2UgdGhpcy5jbWRzLnB1c2goZSl9dHJhbnNmb3JtKGUpe3RoaXMuY3VycmVudFRyYW5zZm9ybT1VdGlsLnRyYW5zZm9ybSh0aGlzLmN1cnJlbnRUcmFuc2Zvcm0sZSl9dHJhbnNsYXRlKGUsdCl7dGhpcy50cmFuc2Zvcm0oWzEsMCwwLDEsZSx0XSl9c2F2ZSgpe3RoaXMudHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmN1cnJlbnRUcmFuc2Zvcm0uc2xpY2UoKSl9cmVzdG9yZSgpe3RoaXMuY3VycmVudFRyYW5zZm9ybT10aGlzLnRyYW5zZm9ybVN0YWNrLnBvcCgpfHxbMSwwLDAsMSwwLDBdfWdldFNWRygpe3JldHVybiB0aGlzLmNtZHMuam9pbigiIil9fWNsYXNzIENvbXBpbGVkRm9udHtjb25zdHJ1Y3RvcihlKXt0aGlzLmZvbnRNYXRyaXg9ZTt0aGlzLmNvbXBpbGVkR2x5cGhzPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5jb21waWxlZENoYXJDb2RlVG9HbHlwaElkPU9iamVjdC5jcmVhdGUobnVsbCl9Z2V0UGF0aEpzKGUpe2NvbnN0e2NoYXJDb2RlOnQsZ2x5cGhJZDphfT1sb29rdXBDbWFwKHRoaXMuY21hcCxlKTtsZXQgcixpPXRoaXMuY29tcGlsZWRHbHlwaHNbYV07aWYodm9pZCAwPT09aSl7dHJ5e2k9dGhpcy5jb21waWxlR2x5cGgodGhpcy5nbHlwaHNbYV0sYSl9Y2F0Y2goZSl7aT0iIjtyPWV9dGhpcy5jb21waWxlZEdseXBoc1thXT1pfXRoaXMuY29tcGlsZWRDaGFyQ29kZVRvR2x5cGhJZFt0XT8/PWE7aWYocil0aHJvdyByO3JldHVybiBpfWNvbXBpbGVHbHlwaChlLGEpe2lmKCFlPy5sZW5ndGh8fDE0PT09ZVswXSlyZXR1cm4iIjtsZXQgcj10aGlzLmZvbnRNYXRyaXg7aWYodGhpcy5pc0NGRkNJREZvbnQpe2NvbnN0IGU9dGhpcy5mZFNlbGVjdC5nZXRGREluZGV4KGEpO2lmKGU+PTAmJmU8dGhpcy5mZEFycmF5Lmxlbmd0aCl7cj10aGlzLmZkQXJyYXlbZV0uZ2V0QnlOYW1lKCJGb250TWF0cml4Iil8fHR9ZWxzZSB3YXJuKCJJbnZhbGlkIGZkIGluZGV4IGZvciBnbHlwaCBpbmRleC4iKX1hc3NlcnQoaXNOdW1iZXJBcnJheShyLDYpLCJFeHBlY3RlZCBhIHZhbGlkIGZvbnRNYXRyaXguIik7Y29uc3QgaT1uZXcgQ29tbWFuZHM7aS50cmFuc2Zvcm0oci5zbGljZSgpKTt0aGlzLmNvbXBpbGVHbHlwaEltcGwoZSxpLGEpO2kuYWRkKCJaIik7cmV0dXJuIGkuZ2V0U1ZHKCl9Y29tcGlsZUdseXBoSW1wbCgpe3VucmVhY2hhYmxlKCJDaGlsZHJlbiBjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnQgdGhpcy4iKX1oYXNCdWlsdFBhdGgoZSl7Y29uc3R7Y2hhckNvZGU6dCxnbHlwaElkOmF9PWxvb2t1cENtYXAodGhpcy5jbWFwLGUpO3JldHVybiB2b2lkIDAhPT10aGlzLmNvbXBpbGVkR2x5cGhzW2FdJiZ2b2lkIDAhPT10aGlzLmNvbXBpbGVkQ2hhckNvZGVUb0dseXBoSWRbdF19fWNsYXNzIFRydWVUeXBlQ29tcGlsZWQgZXh0ZW5kcyBDb21waWxlZEZvbnR7Y29uc3RydWN0b3IoZSx0LGEpe3N1cGVyKGF8fFs0ODhlLTYsMCwwLDQ4OGUtNiwwLDBdKTt0aGlzLmdseXBocz1lO3RoaXMuY21hcD10fWNvbXBpbGVHbHlwaEltcGwoZSx0KXtjb21waWxlR2x5ZihlLHQsdGhpcyl9fWNsYXNzIFR5cGUyQ29tcGlsZWQgZXh0ZW5kcyBDb21waWxlZEZvbnR7Y29uc3RydWN0b3IoZSx0LGEpe3N1cGVyKGF8fFsuMDAxLDAsMCwuMDAxLDAsMF0pO3RoaXMuZ2x5cGhzPWUuZ2x5cGhzO3RoaXMuZ3N1YnJzPWUuZ3N1YnJzfHxbXTt0aGlzLnN1YnJzPWUuc3VicnN8fFtdO3RoaXMuY21hcD10O3RoaXMuZ2x5cGhOYW1lTWFwPWxyKCk7dGhpcy5nc3VicnNCaWFzPWdldFN1YnJvdXRpbmVCaWFzKHRoaXMuZ3N1YnJzKTt0aGlzLnN1YnJzQmlhcz1nZXRTdWJyb3V0aW5lQmlhcyh0aGlzLnN1YnJzKTt0aGlzLmlzQ0ZGQ0lERm9udD1lLmlzQ0ZGQ0lERm9udDt0aGlzLmZkU2VsZWN0PWUuZmRTZWxlY3Q7dGhpcy5mZEFycmF5PWUuZmRBcnJheX1jb21waWxlR2x5cGhJbXBsKGUsdCxhKXtjb21waWxlQ2hhclN0cmluZyhlLHQsdGhpcyxhKX19Y2xhc3MgRm9udFJlbmRlcmVyRmFjdG9yeXtzdGF0aWMgY3JlYXRlKGUsdCl7Y29uc3QgYT1uZXcgVWludDhBcnJheShlLmRhdGEpO2xldCByLGksbixzLG8sYztjb25zdCBsPXJlYWRVaW50MTYoYSw0KTtmb3IobGV0IGU9MCxoPTEyO2U8bDtlKyssaCs9MTYpe2NvbnN0IGU9Ynl0ZXNUb1N0cmluZyhhLnN1YmFycmF5KGgsaCs0KSksbD1yZWFkVWludDMyKGEsaCs4KSx1PXJlYWRVaW50MzIoYSxoKzEyKTtzd2l0Y2goZSl7Y2FzZSJjbWFwIjpyPXBhcnNlQ21hcChhLGwpO2JyZWFrO2Nhc2UiZ2x5ZiI6aT1hLnN1YmFycmF5KGwsbCt1KTticmVhaztjYXNlImxvY2EiOm49YS5zdWJhcnJheShsLGwrdSk7YnJlYWs7Y2FzZSJoZWFkIjpjPXJlYWRVaW50MTYoYSxsKzE4KTtvPXJlYWRVaW50MTYoYSxsKzUwKTticmVhaztjYXNlIkNGRiAiOnM9cGFyc2VDZmYoYSxsLGwrdSx0KX19aWYoaSl7Y29uc3QgdD1jP1sxL2MsMCwwLDEvYywwLDBdOmUuZm9udE1hdHJpeDtyZXR1cm4gbmV3IFRydWVUeXBlQ29tcGlsZWQoZnVuY3Rpb24gcGFyc2VHbHlmVGFibGUoZSx0LGEpe2xldCByLGk7aWYoYSl7cj00O2k9cmVhZFVpbnQzMn1lbHNle3I9MjtpPShlLHQpPT4yKnJlYWRVaW50MTYoZSx0KX1jb25zdCBuPVtdO2xldCBzPWkodCwwKTtmb3IobGV0IGE9cjthPHQubGVuZ3RoO2ErPXIpe2NvbnN0IHI9aSh0LGEpO24ucHVzaChlLnN1YmFycmF5KHMscikpO3M9cn1yZXR1cm4gbn0oaSxuLG8pLHIsdCl9cmV0dXJuIG5ldyBUeXBlMkNvbXBpbGVkKHMscixlLmZvbnRNYXRyaXgpfX1jb25zdCBYcj1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2UuQ291cmllcj02MDA7ZVsiQ291cmllci1Cb2xkIl09NjAwO2VbIkNvdXJpZXItQm9sZE9ibGlxdWUiXT02MDA7ZVsiQ291cmllci1PYmxpcXVlIl09NjAwO2UuSGVsdmV0aWNhPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZS5zcGFjZT0yNzg7ZS5leGNsYW09Mjc4O2UucXVvdGVkYmw9MzU1O2UubnVtYmVyc2lnbj01NTY7ZS5kb2xsYXI9NTU2O2UucGVyY2VudD04ODk7ZS5hbXBlcnNhbmQ9NjY3O2UucXVvdGVyaWdodD0yMjI7ZS5wYXJlbmxlZnQ9MzMzO2UucGFyZW5yaWdodD0zMzM7ZS5hc3Rlcmlzaz0zODk7ZS5wbHVzPTU4NDtlLmNvbW1hPTI3ODtlLmh5cGhlbj0zMzM7ZS5wZXJpb2Q9Mjc4O2Uuc2xhc2g9Mjc4O2UuemVybz01NTY7ZS5vbmU9NTU2O2UudHdvPTU1NjtlLnRocmVlPTU1NjtlLmZvdXI9NTU2O2UuZml2ZT01NTY7ZS5zaXg9NTU2O2Uuc2V2ZW49NTU2O2UuZWlnaHQ9NTU2O2UubmluZT01NTY7ZS5jb2xvbj0yNzg7ZS5zZW1pY29sb249Mjc4O2UubGVzcz01ODQ7ZS5lcXVhbD01ODQ7ZS5ncmVhdGVyPTU4NDtlLnF1ZXN0aW9uPTU1NjtlLmF0PTEwMTU7ZS5BPTY2NztlLkI9NjY3O2UuQz03MjI7ZS5EPTcyMjtlLkU9NjY3O2UuRj02MTE7ZS5HPTc3ODtlLkg9NzIyO2UuST0yNzg7ZS5KPTUwMDtlLks9NjY3O2UuTD01NTY7ZS5NPTgzMztlLk49NzIyO2UuTz03Nzg7ZS5QPTY2NztlLlE9Nzc4O2UuUj03MjI7ZS5TPTY2NztlLlQ9NjExO2UuVT03MjI7ZS5WPTY2NztlLlc9OTQ0O2UuWD02Njc7ZS5ZPTY2NztlLlo9NjExO2UuYnJhY2tldGxlZnQ9Mjc4O2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0yNzg7ZS5hc2NpaWNpcmN1bT00Njk7ZS51bmRlcnNjb3JlPTU1NjtlLnF1b3RlbGVmdD0yMjI7ZS5hPTU1NjtlLmI9NTU2O2UuYz01MDA7ZS5kPTU1NjtlLmU9NTU2O2UuZj0yNzg7ZS5nPTU1NjtlLmg9NTU2O2UuaT0yMjI7ZS5qPTIyMjtlLms9NTAwO2UubD0yMjI7ZS5tPTgzMztlLm49NTU2O2Uubz01NTY7ZS5wPTU1NjtlLnE9NTU2O2Uucj0zMzM7ZS5zPTUwMDtlLnQ9Mjc4O2UudT01NTY7ZS52PTUwMDtlLnc9NzIyO2UueD01MDA7ZS55PTUwMDtlLno9NTAwO2UuYnJhY2VsZWZ0PTMzNDtlLmJhcj0yNjA7ZS5icmFjZXJpZ2h0PTMzNDtlLmFzY2lpdGlsZGU9NTg0O2UuZXhjbGFtZG93bj0zMzM7ZS5jZW50PTU1NjtlLnN0ZXJsaW5nPTU1NjtlLmZyYWN0aW9uPTE2NztlLnllbj01NTY7ZS5mbG9yaW49NTU2O2Uuc2VjdGlvbj01NTY7ZS5jdXJyZW5jeT01NTY7ZS5xdW90ZXNpbmdsZT0xOTE7ZS5xdW90ZWRibGxlZnQ9MzMzO2UuZ3VpbGxlbW90bGVmdD01NTY7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTUwMDtlLmZsPTUwMDtlLmVuZGFzaD01NTY7ZS5kYWdnZXI9NTU2O2UuZGFnZ2VyZGJsPTU1NjtlLnBlcmlvZGNlbnRlcmVkPTI3ODtlLnBhcmFncmFwaD01Mzc7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9MjIyO2UucXVvdGVkYmxiYXNlPTMzMztlLnF1b3RlZGJscmlnaHQ9MzMzO2UuZ3VpbGxlbW90cmlnaHQ9NTU2O2UuZWxsaXBzaXM9MWUzO2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTYxMTtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9MWUzO2UuQUU9MWUzO2Uub3JkZmVtaW5pbmU9MzcwO2UuTHNsYXNoPTU1NjtlLk9zbGFzaD03Nzg7ZS5PRT0xZTM7ZS5vcmRtYXNjdWxpbmU9MzY1O2UuYWU9ODg5O2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTIyMjtlLm9zbGFzaD02MTE7ZS5vZT05NDQ7ZS5nZXJtYW5kYmxzPTYxMTtlLklkaWVyZXNpcz0yNzg7ZS5lYWN1dGU9NTU2O2UuYWJyZXZlPTU1NjtlLnVodW5nYXJ1bWxhdXQ9NTU2O2UuZWNhcm9uPTU1NjtlLllkaWVyZXNpcz02Njc7ZS5kaXZpZGU9NTg0O2UuWWFjdXRlPTY2NztlLkFjaXJjdW1mbGV4PTY2NztlLmFhY3V0ZT01NTY7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NTAwO2Uuc2NvbW1hYWNjZW50PTUwMDtlLmVjaXJjdW1mbGV4PTU1NjtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTU1NjtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTU1NjtlLkVkaWVyZXNpcz02Njc7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTczNztlLkVtYWNyb249NjY3O2UuY2Nhcm9uPTUwMDtlLmFyaW5nPTU1NjtlLk5jb21tYWFjY2VudD03MjI7ZS5sYWN1dGU9MjIyO2UuYWdyYXZlPTU1NjtlLlRjb21tYWFjY2VudD02MTE7ZS5DYWN1dGU9NzIyO2UuYXRpbGRlPTU1NjtlLkVkb3RhY2NlbnQ9NjY3O2Uuc2Nhcm9uPTUwMDtlLnNjZWRpbGxhPTUwMDtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ3MTtlLlJjYXJvbj03MjI7ZS5HY29tbWFhY2NlbnQ9Nzc4O2UudWNpcmN1bWZsZXg9NTU2O2UuYWNpcmN1bWZsZXg9NTU2O2UuQW1hY3Jvbj02Njc7ZS5yY2Fyb249MzMzO2UuY2NlZGlsbGE9NTAwO2UuWmRvdGFjY2VudD02MTE7ZS5UaG9ybj02Njc7ZS5PbWFjcm9uPTc3ODtlLlJhY3V0ZT03MjI7ZS5TYWN1dGU9NjY3O2UuZGNhcm9uPTY0MztlLlVtYWNyb249NzIyO2UudXJpbmc9NTU2O2UudGhyZWVzdXBlcmlvcj0zMzM7ZS5PZ3JhdmU9Nzc4O2UuQWdyYXZlPTY2NztlLkFicmV2ZT02Njc7ZS5tdWx0aXBseT01ODQ7ZS51YWN1dGU9NTU2O2UuVGNhcm9uPTYxMTtlLnBhcnRpYWxkaWZmPTQ3NjtlLnlkaWVyZXNpcz01MDA7ZS5OYWN1dGU9NzIyO2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjY3O2UuYWRpZXJlc2lzPTU1NjtlLmVkaWVyZXNpcz01NTY7ZS5jYWN1dGU9NTAwO2UubmFjdXRlPTU1NjtlLnVtYWNyb249NTU2O2UuTmNhcm9uPTcyMjtlLklhY3V0ZT0yNzg7ZS5wbHVzbWludXM9NTg0O2UuYnJva2VuYmFyPTI2MDtlLnJlZ2lzdGVyZWQ9NzM3O2UuR2JyZXZlPTc3ODtlLklkb3RhY2NlbnQ9Mjc4O2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02Njc7ZS5yYWN1dGU9MzMzO2Uub21hY3Jvbj01NTY7ZS5aYWN1dGU9NjExO2UuWmNhcm9uPTYxMTtlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NzIyO2UubGNvbW1hYWNjZW50PTIyMjtlLnRjYXJvbj0zMTc7ZS5lb2dvbmVrPTU1NjtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTY2NztlLkFkaWVyZXNpcz02Njc7ZS5lZ3JhdmU9NTU2O2UuemFjdXRlPTUwMDtlLmlvZ29uZWs9MjIyO2UuT2FjdXRlPTc3ODtlLm9hY3V0ZT01NTY7ZS5hbWFjcm9uPTU1NjtlLnNhY3V0ZT01MDA7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9Nzc4O2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTU1NjtlLnR3b3N1cGVyaW9yPTMzMztlLk9kaWVyZXNpcz03Nzg7ZS5tdT01NTY7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD01NTY7ZS5Fb2dvbmVrPTY2NztlLmRjcm9hdD01NTY7ZS50aHJlZXF1YXJ0ZXJzPTgzNDtlLlNjZWRpbGxhPTY2NztlLmxjYXJvbj0yOTk7ZS5LY29tbWFhY2NlbnQ9NjY3O2UuTGFjdXRlPTU1NjtlLnRyYWRlbWFyaz0xZTM7ZS5lZG90YWNjZW50PTU1NjtlLklncmF2ZT0yNzg7ZS5JbWFjcm9uPTI3ODtlLkxjYXJvbj01NTY7ZS5vbmVoYWxmPTgzNDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD01NTY7ZS5udGlsZGU9NTU2O2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjY3O2UuZW1hY3Jvbj01NTY7ZS5nYnJldmU9NTU2O2Uub25lcXVhcnRlcj04MzQ7ZS5TY2Fyb249NjY3O2UuU2NvbW1hYWNjZW50PTY2NztlLk9odW5nYXJ1bWxhdXQ9Nzc4O2UuZGVncmVlPTQwMDtlLm9ncmF2ZT01NTY7ZS5DY2Fyb249NzIyO2UudWdyYXZlPTU1NjtlLnJhZGljYWw9NDUzO2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD0zMzM7ZS5OdGlsZGU9NzIyO2Uub3RpbGRlPTU1NjtlLlJjb21tYWFjY2VudD03MjI7ZS5MY29tbWFhY2NlbnQ9NTU2O2UuQXRpbGRlPTY2NztlLkFvZ29uZWs9NjY3O2UuQXJpbmc9NjY3O2UuT3RpbGRlPTc3ODtlLnpkb3RhY2NlbnQ9NTAwO2UuRWNhcm9uPTY2NztlLklvZ29uZWs9Mjc4O2Uua2NvbW1hYWNjZW50PTUwMDtlLm1pbnVzPTU4NDtlLkljaXJjdW1mbGV4PTI3ODtlLm5jYXJvbj01NTY7ZS50Y29tbWFhY2NlbnQ9Mjc4O2UubG9naWNhbG5vdD01ODQ7ZS5vZGllcmVzaXM9NTU2O2UudWRpZXJlc2lzPTU1NjtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD01NTY7ZS5ldGg9NTU2O2UuemNhcm9uPTUwMDtlLm5jb21tYWFjY2VudD01NTY7ZS5vbmVzdXBlcmlvcj0zMzM7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTU2fSkpO2VbIkhlbHZldGljYS1Cb2xkIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI3ODtlLmV4Y2xhbT0zMzM7ZS5xdW90ZWRibD00NzQ7ZS5udW1iZXJzaWduPTU1NjtlLmRvbGxhcj01NTY7ZS5wZXJjZW50PTg4OTtlLmFtcGVyc2FuZD03MjI7ZS5xdW90ZXJpZ2h0PTI3ODtlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTM4OTtlLnBsdXM9NTg0O2UuY29tbWE9Mjc4O2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNzg7ZS5zbGFzaD0yNzg7ZS56ZXJvPTU1NjtlLm9uZT01NTY7ZS50d289NTU2O2UudGhyZWU9NTU2O2UuZm91cj01NTY7ZS5maXZlPTU1NjtlLnNpeD01NTY7ZS5zZXZlbj01NTY7ZS5laWdodD01NTY7ZS5uaW5lPTU1NjtlLmNvbG9uPTMzMztlLnNlbWljb2xvbj0zMzM7ZS5sZXNzPTU4NDtlLmVxdWFsPTU4NDtlLmdyZWF0ZXI9NTg0O2UucXVlc3Rpb249NjExO2UuYXQ9OTc1O2UuQT03MjI7ZS5CPTcyMjtlLkM9NzIyO2UuRD03MjI7ZS5FPTY2NztlLkY9NjExO2UuRz03Nzg7ZS5IPTcyMjtlLkk9Mjc4O2UuSj01NTY7ZS5LPTcyMjtlLkw9NjExO2UuTT04MzM7ZS5OPTcyMjtlLk89Nzc4O2UuUD02Njc7ZS5RPTc3ODtlLlI9NzIyO2UuUz02Njc7ZS5UPTYxMTtlLlU9NzIyO2UuVj02Njc7ZS5XPTk0NDtlLlg9NjY3O2UuWT02Njc7ZS5aPTYxMTtlLmJyYWNrZXRsZWZ0PTMzMztlLmJhY2tzbGFzaD0yNzg7ZS5icmFja2V0cmlnaHQ9MzMzO2UuYXNjaWljaXJjdW09NTg0O2UudW5kZXJzY29yZT01NTY7ZS5xdW90ZWxlZnQ9Mjc4O2UuYT01NTY7ZS5iPTYxMTtlLmM9NTU2O2UuZD02MTE7ZS5lPTU1NjtlLmY9MzMzO2UuZz02MTE7ZS5oPTYxMTtlLmk9Mjc4O2Uuaj0yNzg7ZS5rPTU1NjtlLmw9Mjc4O2UubT04ODk7ZS5uPTYxMTtlLm89NjExO2UucD02MTE7ZS5xPTYxMTtlLnI9Mzg5O2Uucz01NTY7ZS50PTMzMztlLnU9NjExO2Uudj01NTY7ZS53PTc3ODtlLng9NTU2O2UueT01NTY7ZS56PTUwMDtlLmJyYWNlbGVmdD0zODk7ZS5iYXI9MjgwO2UuYnJhY2VyaWdodD0zODk7ZS5hc2NpaXRpbGRlPTU4NDtlLmV4Y2xhbWRvd249MzMzO2UuY2VudD01NTY7ZS5zdGVybGluZz01NTY7ZS5mcmFjdGlvbj0xNjc7ZS55ZW49NTU2O2UuZmxvcmluPTU1NjtlLnNlY3Rpb249NTU2O2UuY3VycmVuY3k9NTU2O2UucXVvdGVzaW5nbGU9MjM4O2UucXVvdGVkYmxsZWZ0PTUwMDtlLmd1aWxsZW1vdGxlZnQ9NTU2O2UuZ3VpbHNpbmdsbGVmdD0zMzM7ZS5ndWlsc2luZ2xyaWdodD0zMzM7ZS5maT02MTE7ZS5mbD02MTE7ZS5lbmRhc2g9NTU2O2UuZGFnZ2VyPTU1NjtlLmRhZ2dlcmRibD01NTY7ZS5wZXJpb2RjZW50ZXJlZD0yNzg7ZS5wYXJhZ3JhcGg9NTU2O2UuYnVsbGV0PTM1MDtlLnF1b3Rlc2luZ2xiYXNlPTI3ODtlLnF1b3RlZGJsYmFzZT01MDA7ZS5xdW90ZWRibHJpZ2h0PTUwMDtlLmd1aWxsZW1vdHJpZ2h0PTU1NjtlLmVsbGlwc2lzPTFlMztlLnBlcnRob3VzYW5kPTFlMztlLnF1ZXN0aW9uZG93bj02MTE7ZS5ncmF2ZT0zMzM7ZS5hY3V0ZT0zMzM7ZS5jaXJjdW1mbGV4PTMzMztlLnRpbGRlPTMzMztlLm1hY3Jvbj0zMzM7ZS5icmV2ZT0zMzM7ZS5kb3RhY2NlbnQ9MzMzO2UuZGllcmVzaXM9MzMzO2UucmluZz0zMzM7ZS5jZWRpbGxhPTMzMztlLmh1bmdhcnVtbGF1dD0zMzM7ZS5vZ29uZWs9MzMzO2UuY2Fyb249MzMzO2UuZW1kYXNoPTFlMztlLkFFPTFlMztlLm9yZGZlbWluaW5lPTM3MDtlLkxzbGFzaD02MTE7ZS5Pc2xhc2g9Nzc4O2UuT0U9MWUzO2Uub3JkbWFzY3VsaW5lPTM2NTtlLmFlPTg4OTtlLmRvdGxlc3NpPTI3ODtlLmxzbGFzaD0yNzg7ZS5vc2xhc2g9NjExO2Uub2U9OTQ0O2UuZ2VybWFuZGJscz02MTE7ZS5JZGllcmVzaXM9Mjc4O2UuZWFjdXRlPTU1NjtlLmFicmV2ZT01NTY7ZS51aHVuZ2FydW1sYXV0PTYxMTtlLmVjYXJvbj01NTY7ZS5ZZGllcmVzaXM9NjY3O2UuZGl2aWRlPTU4NDtlLllhY3V0ZT02Njc7ZS5BY2lyY3VtZmxleD03MjI7ZS5hYWN1dGU9NTU2O2UuVWNpcmN1bWZsZXg9NzIyO2UueWFjdXRlPTU1NjtlLnNjb21tYWFjY2VudD01NTY7ZS5lY2lyY3VtZmxleD01NTY7ZS5VcmluZz03MjI7ZS5VZGllcmVzaXM9NzIyO2UuYW9nb25laz01NTY7ZS5VYWN1dGU9NzIyO2UudW9nb25laz02MTE7ZS5FZGllcmVzaXM9NjY3O2UuRGNyb2F0PTcyMjtlLmNvbW1hYWNjZW50PTI1MDtlLmNvcHlyaWdodD03Mzc7ZS5FbWFjcm9uPTY2NztlLmNjYXJvbj01NTY7ZS5hcmluZz01NTY7ZS5OY29tbWFhY2NlbnQ9NzIyO2UubGFjdXRlPTI3ODtlLmFncmF2ZT01NTY7ZS5UY29tbWFhY2NlbnQ9NjExO2UuQ2FjdXRlPTcyMjtlLmF0aWxkZT01NTY7ZS5FZG90YWNjZW50PTY2NztlLnNjYXJvbj01NTY7ZS5zY2VkaWxsYT01NTY7ZS5pYWN1dGU9Mjc4O2UubG96ZW5nZT00OTQ7ZS5SY2Fyb249NzIyO2UuR2NvbW1hYWNjZW50PTc3ODtlLnVjaXJjdW1mbGV4PTYxMTtlLmFjaXJjdW1mbGV4PTU1NjtlLkFtYWNyb249NzIyO2UucmNhcm9uPTM4OTtlLmNjZWRpbGxhPTU1NjtlLlpkb3RhY2NlbnQ9NjExO2UuVGhvcm49NjY3O2UuT21hY3Jvbj03Nzg7ZS5SYWN1dGU9NzIyO2UuU2FjdXRlPTY2NztlLmRjYXJvbj03NDM7ZS5VbWFjcm9uPTcyMjtlLnVyaW5nPTYxMTtlLnRocmVlc3VwZXJpb3I9MzMzO2UuT2dyYXZlPTc3ODtlLkFncmF2ZT03MjI7ZS5BYnJldmU9NzIyO2UubXVsdGlwbHk9NTg0O2UudWFjdXRlPTYxMTtlLlRjYXJvbj02MTE7ZS5wYXJ0aWFsZGlmZj00OTQ7ZS55ZGllcmVzaXM9NTU2O2UuTmFjdXRlPTcyMjtlLmljaXJjdW1mbGV4PTI3ODtlLkVjaXJjdW1mbGV4PTY2NztlLmFkaWVyZXNpcz01NTY7ZS5lZGllcmVzaXM9NTU2O2UuY2FjdXRlPTU1NjtlLm5hY3V0ZT02MTE7ZS51bWFjcm9uPTYxMTtlLk5jYXJvbj03MjI7ZS5JYWN1dGU9Mjc4O2UucGx1c21pbnVzPTU4NDtlLmJyb2tlbmJhcj0yODA7ZS5yZWdpc3RlcmVkPTczNztlLkdicmV2ZT03Nzg7ZS5JZG90YWNjZW50PTI3ODtlLnN1bW1hdGlvbj02MDA7ZS5FZ3JhdmU9NjY3O2UucmFjdXRlPTM4OTtlLm9tYWNyb249NjExO2UuWmFjdXRlPTYxMTtlLlpjYXJvbj02MTE7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UuRXRoPTcyMjtlLkNjZWRpbGxhPTcyMjtlLmxjb21tYWFjY2VudD0yNzg7ZS50Y2Fyb249Mzg5O2UuZW9nb25laz01NTY7ZS5Vb2dvbmVrPTcyMjtlLkFhY3V0ZT03MjI7ZS5BZGllcmVzaXM9NzIyO2UuZWdyYXZlPTU1NjtlLnphY3V0ZT01MDA7ZS5pb2dvbmVrPTI3ODtlLk9hY3V0ZT03Nzg7ZS5vYWN1dGU9NjExO2UuYW1hY3Jvbj01NTY7ZS5zYWN1dGU9NTU2O2UuaWRpZXJlc2lzPTI3ODtlLk9jaXJjdW1mbGV4PTc3ODtlLlVncmF2ZT03MjI7ZS5EZWx0YT02MTI7ZS50aG9ybj02MTE7ZS50d29zdXBlcmlvcj0zMzM7ZS5PZGllcmVzaXM9Nzc4O2UubXU9NjExO2UuaWdyYXZlPTI3ODtlLm9odW5nYXJ1bWxhdXQ9NjExO2UuRW9nb25laz02Njc7ZS5kY3JvYXQ9NjExO2UudGhyZWVxdWFydGVycz04MzQ7ZS5TY2VkaWxsYT02Njc7ZS5sY2Fyb249NDAwO2UuS2NvbW1hYWNjZW50PTcyMjtlLkxhY3V0ZT02MTE7ZS50cmFkZW1hcms9MWUzO2UuZWRvdGFjY2VudD01NTY7ZS5JZ3JhdmU9Mjc4O2UuSW1hY3Jvbj0yNzg7ZS5MY2Fyb249NjExO2Uub25laGFsZj04MzQ7ZS5sZXNzZXF1YWw9NTQ5O2Uub2NpcmN1bWZsZXg9NjExO2UubnRpbGRlPTYxMTtlLlVodW5nYXJ1bWxhdXQ9NzIyO2UuRWFjdXRlPTY2NztlLmVtYWNyb249NTU2O2UuZ2JyZXZlPTYxMTtlLm9uZXF1YXJ0ZXI9ODM0O2UuU2Nhcm9uPTY2NztlLlNjb21tYWFjY2VudD02Njc7ZS5PaHVuZ2FydW1sYXV0PTc3ODtlLmRlZ3JlZT00MDA7ZS5vZ3JhdmU9NjExO2UuQ2Nhcm9uPTcyMjtlLnVncmF2ZT02MTE7ZS5yYWRpY2FsPTU0OTtlLkRjYXJvbj03MjI7ZS5yY29tbWFhY2NlbnQ9Mzg5O2UuTnRpbGRlPTcyMjtlLm90aWxkZT02MTE7ZS5SY29tbWFhY2NlbnQ9NzIyO2UuTGNvbW1hYWNjZW50PTYxMTtlLkF0aWxkZT03MjI7ZS5Bb2dvbmVrPTcyMjtlLkFyaW5nPTcyMjtlLk90aWxkZT03Nzg7ZS56ZG90YWNjZW50PTUwMDtlLkVjYXJvbj02Njc7ZS5Jb2dvbmVrPTI3ODtlLmtjb21tYWFjY2VudD01NTY7ZS5taW51cz01ODQ7ZS5JY2lyY3VtZmxleD0yNzg7ZS5uY2Fyb249NjExO2UudGNvbW1hYWNjZW50PTMzMztlLmxvZ2ljYWxub3Q9NTg0O2Uub2RpZXJlc2lzPTYxMTtlLnVkaWVyZXNpcz02MTE7ZS5ub3RlcXVhbD01NDk7ZS5nY29tbWFhY2NlbnQ9NjExO2UuZXRoPTYxMTtlLnpjYXJvbj01MDA7ZS5uY29tbWFhY2NlbnQ9NjExO2Uub25lc3VwZXJpb3I9MzMzO2UuaW1hY3Jvbj0yNzg7ZS5FdXJvPTU1Nn0pKTtlWyJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiXT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9Mjc4O2UuZXhjbGFtPTMzMztlLnF1b3RlZGJsPTQ3NDtlLm51bWJlcnNpZ249NTU2O2UuZG9sbGFyPTU1NjtlLnBlcmNlbnQ9ODg5O2UuYW1wZXJzYW5kPTcyMjtlLnF1b3RlcmlnaHQ9Mjc4O2UucGFyZW5sZWZ0PTMzMztlLnBhcmVucmlnaHQ9MzMzO2UuYXN0ZXJpc2s9Mzg5O2UucGx1cz01ODQ7ZS5jb21tYT0yNzg7ZS5oeXBoZW49MzMzO2UucGVyaW9kPTI3ODtlLnNsYXNoPTI3ODtlLnplcm89NTU2O2Uub25lPTU1NjtlLnR3bz01NTY7ZS50aHJlZT01NTY7ZS5mb3VyPTU1NjtlLmZpdmU9NTU2O2Uuc2l4PTU1NjtlLnNldmVuPTU1NjtlLmVpZ2h0PTU1NjtlLm5pbmU9NTU2O2UuY29sb249MzMzO2Uuc2VtaWNvbG9uPTMzMztlLmxlc3M9NTg0O2UuZXF1YWw9NTg0O2UuZ3JlYXRlcj01ODQ7ZS5xdWVzdGlvbj02MTE7ZS5hdD05NzU7ZS5BPTcyMjtlLkI9NzIyO2UuQz03MjI7ZS5EPTcyMjtlLkU9NjY3O2UuRj02MTE7ZS5HPTc3ODtlLkg9NzIyO2UuST0yNzg7ZS5KPTU1NjtlLks9NzIyO2UuTD02MTE7ZS5NPTgzMztlLk49NzIyO2UuTz03Nzg7ZS5QPTY2NztlLlE9Nzc4O2UuUj03MjI7ZS5TPTY2NztlLlQ9NjExO2UuVT03MjI7ZS5WPTY2NztlLlc9OTQ0O2UuWD02Njc7ZS5ZPTY2NztlLlo9NjExO2UuYnJhY2tldGxlZnQ9MzMzO2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0zMzM7ZS5hc2NpaWNpcmN1bT01ODQ7ZS51bmRlcnNjb3JlPTU1NjtlLnF1b3RlbGVmdD0yNzg7ZS5hPTU1NjtlLmI9NjExO2UuYz01NTY7ZS5kPTYxMTtlLmU9NTU2O2UuZj0zMzM7ZS5nPTYxMTtlLmg9NjExO2UuaT0yNzg7ZS5qPTI3ODtlLms9NTU2O2UubD0yNzg7ZS5tPTg4OTtlLm49NjExO2Uubz02MTE7ZS5wPTYxMTtlLnE9NjExO2Uucj0zODk7ZS5zPTU1NjtlLnQ9MzMzO2UudT02MTE7ZS52PTU1NjtlLnc9Nzc4O2UueD01NTY7ZS55PTU1NjtlLno9NTAwO2UuYnJhY2VsZWZ0PTM4OTtlLmJhcj0yODA7ZS5icmFjZXJpZ2h0PTM4OTtlLmFzY2lpdGlsZGU9NTg0O2UuZXhjbGFtZG93bj0zMzM7ZS5jZW50PTU1NjtlLnN0ZXJsaW5nPTU1NjtlLmZyYWN0aW9uPTE2NztlLnllbj01NTY7ZS5mbG9yaW49NTU2O2Uuc2VjdGlvbj01NTY7ZS5jdXJyZW5jeT01NTY7ZS5xdW90ZXNpbmdsZT0yMzg7ZS5xdW90ZWRibGxlZnQ9NTAwO2UuZ3VpbGxlbW90bGVmdD01NTY7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTYxMTtlLmZsPTYxMTtlLmVuZGFzaD01NTY7ZS5kYWdnZXI9NTU2O2UuZGFnZ2VyZGJsPTU1NjtlLnBlcmlvZGNlbnRlcmVkPTI3ODtlLnBhcmFncmFwaD01NTY7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9Mjc4O2UucXVvdGVkYmxiYXNlPTUwMDtlLnF1b3RlZGJscmlnaHQ9NTAwO2UuZ3VpbGxlbW90cmlnaHQ9NTU2O2UuZWxsaXBzaXM9MWUzO2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTYxMTtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9MWUzO2UuQUU9MWUzO2Uub3JkZmVtaW5pbmU9MzcwO2UuTHNsYXNoPTYxMTtlLk9zbGFzaD03Nzg7ZS5PRT0xZTM7ZS5vcmRtYXNjdWxpbmU9MzY1O2UuYWU9ODg5O2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTI3ODtlLm9zbGFzaD02MTE7ZS5vZT05NDQ7ZS5nZXJtYW5kYmxzPTYxMTtlLklkaWVyZXNpcz0yNzg7ZS5lYWN1dGU9NTU2O2UuYWJyZXZlPTU1NjtlLnVodW5nYXJ1bWxhdXQ9NjExO2UuZWNhcm9uPTU1NjtlLllkaWVyZXNpcz02Njc7ZS5kaXZpZGU9NTg0O2UuWWFjdXRlPTY2NztlLkFjaXJjdW1mbGV4PTcyMjtlLmFhY3V0ZT01NTY7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NTU2O2Uuc2NvbW1hYWNjZW50PTU1NjtlLmVjaXJjdW1mbGV4PTU1NjtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTU1NjtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTYxMTtlLkVkaWVyZXNpcz02Njc7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTczNztlLkVtYWNyb249NjY3O2UuY2Nhcm9uPTU1NjtlLmFyaW5nPTU1NjtlLk5jb21tYWFjY2VudD03MjI7ZS5sYWN1dGU9Mjc4O2UuYWdyYXZlPTU1NjtlLlRjb21tYWFjY2VudD02MTE7ZS5DYWN1dGU9NzIyO2UuYXRpbGRlPTU1NjtlLkVkb3RhY2NlbnQ9NjY3O2Uuc2Nhcm9uPTU1NjtlLnNjZWRpbGxhPTU1NjtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ5NDtlLlJjYXJvbj03MjI7ZS5HY29tbWFhY2NlbnQ9Nzc4O2UudWNpcmN1bWZsZXg9NjExO2UuYWNpcmN1bWZsZXg9NTU2O2UuQW1hY3Jvbj03MjI7ZS5yY2Fyb249Mzg5O2UuY2NlZGlsbGE9NTU2O2UuWmRvdGFjY2VudD02MTE7ZS5UaG9ybj02Njc7ZS5PbWFjcm9uPTc3ODtlLlJhY3V0ZT03MjI7ZS5TYWN1dGU9NjY3O2UuZGNhcm9uPTc0MztlLlVtYWNyb249NzIyO2UudXJpbmc9NjExO2UudGhyZWVzdXBlcmlvcj0zMzM7ZS5PZ3JhdmU9Nzc4O2UuQWdyYXZlPTcyMjtlLkFicmV2ZT03MjI7ZS5tdWx0aXBseT01ODQ7ZS51YWN1dGU9NjExO2UuVGNhcm9uPTYxMTtlLnBhcnRpYWxkaWZmPTQ5NDtlLnlkaWVyZXNpcz01NTY7ZS5OYWN1dGU9NzIyO2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjY3O2UuYWRpZXJlc2lzPTU1NjtlLmVkaWVyZXNpcz01NTY7ZS5jYWN1dGU9NTU2O2UubmFjdXRlPTYxMTtlLnVtYWNyb249NjExO2UuTmNhcm9uPTcyMjtlLklhY3V0ZT0yNzg7ZS5wbHVzbWludXM9NTg0O2UuYnJva2VuYmFyPTI4MDtlLnJlZ2lzdGVyZWQ9NzM3O2UuR2JyZXZlPTc3ODtlLklkb3RhY2NlbnQ9Mjc4O2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02Njc7ZS5yYWN1dGU9Mzg5O2Uub21hY3Jvbj02MTE7ZS5aYWN1dGU9NjExO2UuWmNhcm9uPTYxMTtlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NzIyO2UubGNvbW1hYWNjZW50PTI3ODtlLnRjYXJvbj0zODk7ZS5lb2dvbmVrPTU1NjtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTcyMjtlLkFkaWVyZXNpcz03MjI7ZS5lZ3JhdmU9NTU2O2UuemFjdXRlPTUwMDtlLmlvZ29uZWs9Mjc4O2UuT2FjdXRlPTc3ODtlLm9hY3V0ZT02MTE7ZS5hbWFjcm9uPTU1NjtlLnNhY3V0ZT01NTY7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9Nzc4O2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTYxMTtlLnR3b3N1cGVyaW9yPTMzMztlLk9kaWVyZXNpcz03Nzg7ZS5tdT02MTE7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD02MTE7ZS5Fb2dvbmVrPTY2NztlLmRjcm9hdD02MTE7ZS50aHJlZXF1YXJ0ZXJzPTgzNDtlLlNjZWRpbGxhPTY2NztlLmxjYXJvbj00MDA7ZS5LY29tbWFhY2NlbnQ9NzIyO2UuTGFjdXRlPTYxMTtlLnRyYWRlbWFyaz0xZTM7ZS5lZG90YWNjZW50PTU1NjtlLklncmF2ZT0yNzg7ZS5JbWFjcm9uPTI3ODtlLkxjYXJvbj02MTE7ZS5vbmVoYWxmPTgzNDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD02MTE7ZS5udGlsZGU9NjExO2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjY3O2UuZW1hY3Jvbj01NTY7ZS5nYnJldmU9NjExO2Uub25lcXVhcnRlcj04MzQ7ZS5TY2Fyb249NjY3O2UuU2NvbW1hYWNjZW50PTY2NztlLk9odW5nYXJ1bWxhdXQ9Nzc4O2UuZGVncmVlPTQwMDtlLm9ncmF2ZT02MTE7ZS5DY2Fyb249NzIyO2UudWdyYXZlPTYxMTtlLnJhZGljYWw9NTQ5O2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD0zODk7ZS5OdGlsZGU9NzIyO2Uub3RpbGRlPTYxMTtlLlJjb21tYWFjY2VudD03MjI7ZS5MY29tbWFhY2NlbnQ9NjExO2UuQXRpbGRlPTcyMjtlLkFvZ29uZWs9NzIyO2UuQXJpbmc9NzIyO2UuT3RpbGRlPTc3ODtlLnpkb3RhY2NlbnQ9NTAwO2UuRWNhcm9uPTY2NztlLklvZ29uZWs9Mjc4O2Uua2NvbW1hYWNjZW50PTU1NjtlLm1pbnVzPTU4NDtlLkljaXJjdW1mbGV4PTI3ODtlLm5jYXJvbj02MTE7ZS50Y29tbWFhY2NlbnQ9MzMzO2UubG9naWNhbG5vdD01ODQ7ZS5vZGllcmVzaXM9NjExO2UudWRpZXJlc2lzPTYxMTtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD02MTE7ZS5ldGg9NjExO2UuemNhcm9uPTUwMDtlLm5jb21tYWFjY2VudD02MTE7ZS5vbmVzdXBlcmlvcj0zMzM7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTU2fSkpO2VbIkhlbHZldGljYS1PYmxpcXVlIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI3ODtlLmV4Y2xhbT0yNzg7ZS5xdW90ZWRibD0zNTU7ZS5udW1iZXJzaWduPTU1NjtlLmRvbGxhcj01NTY7ZS5wZXJjZW50PTg4OTtlLmFtcGVyc2FuZD02Njc7ZS5xdW90ZXJpZ2h0PTIyMjtlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTM4OTtlLnBsdXM9NTg0O2UuY29tbWE9Mjc4O2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNzg7ZS5zbGFzaD0yNzg7ZS56ZXJvPTU1NjtlLm9uZT01NTY7ZS50d289NTU2O2UudGhyZWU9NTU2O2UuZm91cj01NTY7ZS5maXZlPTU1NjtlLnNpeD01NTY7ZS5zZXZlbj01NTY7ZS5laWdodD01NTY7ZS5uaW5lPTU1NjtlLmNvbG9uPTI3ODtlLnNlbWljb2xvbj0yNzg7ZS5sZXNzPTU4NDtlLmVxdWFsPTU4NDtlLmdyZWF0ZXI9NTg0O2UucXVlc3Rpb249NTU2O2UuYXQ9MTAxNTtlLkE9NjY3O2UuQj02Njc7ZS5DPTcyMjtlLkQ9NzIyO2UuRT02Njc7ZS5GPTYxMTtlLkc9Nzc4O2UuSD03MjI7ZS5JPTI3ODtlLko9NTAwO2UuSz02Njc7ZS5MPTU1NjtlLk09ODMzO2UuTj03MjI7ZS5PPTc3ODtlLlA9NjY3O2UuUT03Nzg7ZS5SPTcyMjtlLlM9NjY3O2UuVD02MTE7ZS5VPTcyMjtlLlY9NjY3O2UuVz05NDQ7ZS5YPTY2NztlLlk9NjY3O2UuWj02MTE7ZS5icmFja2V0bGVmdD0yNzg7ZS5iYWNrc2xhc2g9Mjc4O2UuYnJhY2tldHJpZ2h0PTI3ODtlLmFzY2lpY2lyY3VtPTQ2OTtlLnVuZGVyc2NvcmU9NTU2O2UucXVvdGVsZWZ0PTIyMjtlLmE9NTU2O2UuYj01NTY7ZS5jPTUwMDtlLmQ9NTU2O2UuZT01NTY7ZS5mPTI3ODtlLmc9NTU2O2UuaD01NTY7ZS5pPTIyMjtlLmo9MjIyO2Uuaz01MDA7ZS5sPTIyMjtlLm09ODMzO2Uubj01NTY7ZS5vPTU1NjtlLnA9NTU2O2UucT01NTY7ZS5yPTMzMztlLnM9NTAwO2UudD0yNzg7ZS51PTU1NjtlLnY9NTAwO2Uudz03MjI7ZS54PTUwMDtlLnk9NTAwO2Uuej01MDA7ZS5icmFjZWxlZnQ9MzM0O2UuYmFyPTI2MDtlLmJyYWNlcmlnaHQ9MzM0O2UuYXNjaWl0aWxkZT01ODQ7ZS5leGNsYW1kb3duPTMzMztlLmNlbnQ9NTU2O2Uuc3Rlcmxpbmc9NTU2O2UuZnJhY3Rpb249MTY3O2UueWVuPTU1NjtlLmZsb3Jpbj01NTY7ZS5zZWN0aW9uPTU1NjtlLmN1cnJlbmN5PTU1NjtlLnF1b3Rlc2luZ2xlPTE5MTtlLnF1b3RlZGJsbGVmdD0zMzM7ZS5ndWlsbGVtb3RsZWZ0PTU1NjtlLmd1aWxzaW5nbGxlZnQ9MzMzO2UuZ3VpbHNpbmdscmlnaHQ9MzMzO2UuZmk9NTAwO2UuZmw9NTAwO2UuZW5kYXNoPTU1NjtlLmRhZ2dlcj01NTY7ZS5kYWdnZXJkYmw9NTU2O2UucGVyaW9kY2VudGVyZWQ9Mjc4O2UucGFyYWdyYXBoPTUzNztlLmJ1bGxldD0zNTA7ZS5xdW90ZXNpbmdsYmFzZT0yMjI7ZS5xdW90ZWRibGJhc2U9MzMzO2UucXVvdGVkYmxyaWdodD0zMzM7ZS5ndWlsbGVtb3RyaWdodD01NTY7ZS5lbGxpcHNpcz0xZTM7ZS5wZXJ0aG91c2FuZD0xZTM7ZS5xdWVzdGlvbmRvd249NjExO2UuZ3JhdmU9MzMzO2UuYWN1dGU9MzMzO2UuY2lyY3VtZmxleD0zMzM7ZS50aWxkZT0zMzM7ZS5tYWNyb249MzMzO2UuYnJldmU9MzMzO2UuZG90YWNjZW50PTMzMztlLmRpZXJlc2lzPTMzMztlLnJpbmc9MzMzO2UuY2VkaWxsYT0zMzM7ZS5odW5nYXJ1bWxhdXQ9MzMzO2Uub2dvbmVrPTMzMztlLmNhcm9uPTMzMztlLmVtZGFzaD0xZTM7ZS5BRT0xZTM7ZS5vcmRmZW1pbmluZT0zNzA7ZS5Mc2xhc2g9NTU2O2UuT3NsYXNoPTc3ODtlLk9FPTFlMztlLm9yZG1hc2N1bGluZT0zNjU7ZS5hZT04ODk7ZS5kb3RsZXNzaT0yNzg7ZS5sc2xhc2g9MjIyO2Uub3NsYXNoPTYxMTtlLm9lPTk0NDtlLmdlcm1hbmRibHM9NjExO2UuSWRpZXJlc2lzPTI3ODtlLmVhY3V0ZT01NTY7ZS5hYnJldmU9NTU2O2UudWh1bmdhcnVtbGF1dD01NTY7ZS5lY2Fyb249NTU2O2UuWWRpZXJlc2lzPTY2NztlLmRpdmlkZT01ODQ7ZS5ZYWN1dGU9NjY3O2UuQWNpcmN1bWZsZXg9NjY3O2UuYWFjdXRlPTU1NjtlLlVjaXJjdW1mbGV4PTcyMjtlLnlhY3V0ZT01MDA7ZS5zY29tbWFhY2NlbnQ9NTAwO2UuZWNpcmN1bWZsZXg9NTU2O2UuVXJpbmc9NzIyO2UuVWRpZXJlc2lzPTcyMjtlLmFvZ29uZWs9NTU2O2UuVWFjdXRlPTcyMjtlLnVvZ29uZWs9NTU2O2UuRWRpZXJlc2lzPTY2NztlLkRjcm9hdD03MjI7ZS5jb21tYWFjY2VudD0yNTA7ZS5jb3B5cmlnaHQ9NzM3O2UuRW1hY3Jvbj02Njc7ZS5jY2Fyb249NTAwO2UuYXJpbmc9NTU2O2UuTmNvbW1hYWNjZW50PTcyMjtlLmxhY3V0ZT0yMjI7ZS5hZ3JhdmU9NTU2O2UuVGNvbW1hYWNjZW50PTYxMTtlLkNhY3V0ZT03MjI7ZS5hdGlsZGU9NTU2O2UuRWRvdGFjY2VudD02Njc7ZS5zY2Fyb249NTAwO2Uuc2NlZGlsbGE9NTAwO2UuaWFjdXRlPTI3ODtlLmxvemVuZ2U9NDcxO2UuUmNhcm9uPTcyMjtlLkdjb21tYWFjY2VudD03Nzg7ZS51Y2lyY3VtZmxleD01NTY7ZS5hY2lyY3VtZmxleD01NTY7ZS5BbWFjcm9uPTY2NztlLnJjYXJvbj0zMzM7ZS5jY2VkaWxsYT01MDA7ZS5aZG90YWNjZW50PTYxMTtlLlRob3JuPTY2NztlLk9tYWNyb249Nzc4O2UuUmFjdXRlPTcyMjtlLlNhY3V0ZT02Njc7ZS5kY2Fyb249NjQzO2UuVW1hY3Jvbj03MjI7ZS51cmluZz01NTY7ZS50aHJlZXN1cGVyaW9yPTMzMztlLk9ncmF2ZT03Nzg7ZS5BZ3JhdmU9NjY3O2UuQWJyZXZlPTY2NztlLm11bHRpcGx5PTU4NDtlLnVhY3V0ZT01NTY7ZS5UY2Fyb249NjExO2UucGFydGlhbGRpZmY9NDc2O2UueWRpZXJlc2lzPTUwMDtlLk5hY3V0ZT03MjI7ZS5pY2lyY3VtZmxleD0yNzg7ZS5FY2lyY3VtZmxleD02Njc7ZS5hZGllcmVzaXM9NTU2O2UuZWRpZXJlc2lzPTU1NjtlLmNhY3V0ZT01MDA7ZS5uYWN1dGU9NTU2O2UudW1hY3Jvbj01NTY7ZS5OY2Fyb249NzIyO2UuSWFjdXRlPTI3ODtlLnBsdXNtaW51cz01ODQ7ZS5icm9rZW5iYXI9MjYwO2UucmVnaXN0ZXJlZD03Mzc7ZS5HYnJldmU9Nzc4O2UuSWRvdGFjY2VudD0yNzg7ZS5zdW1tYXRpb249NjAwO2UuRWdyYXZlPTY2NztlLnJhY3V0ZT0zMzM7ZS5vbWFjcm9uPTU1NjtlLlphY3V0ZT02MTE7ZS5aY2Fyb249NjExO2UuZ3JlYXRlcmVxdWFsPTU0OTtlLkV0aD03MjI7ZS5DY2VkaWxsYT03MjI7ZS5sY29tbWFhY2NlbnQ9MjIyO2UudGNhcm9uPTMxNztlLmVvZ29uZWs9NTU2O2UuVW9nb25laz03MjI7ZS5BYWN1dGU9NjY3O2UuQWRpZXJlc2lzPTY2NztlLmVncmF2ZT01NTY7ZS56YWN1dGU9NTAwO2UuaW9nb25laz0yMjI7ZS5PYWN1dGU9Nzc4O2Uub2FjdXRlPTU1NjtlLmFtYWNyb249NTU2O2Uuc2FjdXRlPTUwMDtlLmlkaWVyZXNpcz0yNzg7ZS5PY2lyY3VtZmxleD03Nzg7ZS5VZ3JhdmU9NzIyO2UuRGVsdGE9NjEyO2UudGhvcm49NTU2O2UudHdvc3VwZXJpb3I9MzMzO2UuT2RpZXJlc2lzPTc3ODtlLm11PTU1NjtlLmlncmF2ZT0yNzg7ZS5vaHVuZ2FydW1sYXV0PTU1NjtlLkVvZ29uZWs9NjY3O2UuZGNyb2F0PTU1NjtlLnRocmVlcXVhcnRlcnM9ODM0O2UuU2NlZGlsbGE9NjY3O2UubGNhcm9uPTI5OTtlLktjb21tYWFjY2VudD02Njc7ZS5MYWN1dGU9NTU2O2UudHJhZGVtYXJrPTFlMztlLmVkb3RhY2NlbnQ9NTU2O2UuSWdyYXZlPTI3ODtlLkltYWNyb249Mjc4O2UuTGNhcm9uPTU1NjtlLm9uZWhhbGY9ODM0O2UubGVzc2VxdWFsPTU0OTtlLm9jaXJjdW1mbGV4PTU1NjtlLm50aWxkZT01NTY7ZS5VaHVuZ2FydW1sYXV0PTcyMjtlLkVhY3V0ZT02Njc7ZS5lbWFjcm9uPTU1NjtlLmdicmV2ZT01NTY7ZS5vbmVxdWFydGVyPTgzNDtlLlNjYXJvbj02Njc7ZS5TY29tbWFhY2NlbnQ9NjY3O2UuT2h1bmdhcnVtbGF1dD03Nzg7ZS5kZWdyZWU9NDAwO2Uub2dyYXZlPTU1NjtlLkNjYXJvbj03MjI7ZS51Z3JhdmU9NTU2O2UucmFkaWNhbD00NTM7ZS5EY2Fyb249NzIyO2UucmNvbW1hYWNjZW50PTMzMztlLk50aWxkZT03MjI7ZS5vdGlsZGU9NTU2O2UuUmNvbW1hYWNjZW50PTcyMjtlLkxjb21tYWFjY2VudD01NTY7ZS5BdGlsZGU9NjY3O2UuQW9nb25laz02Njc7ZS5BcmluZz02Njc7ZS5PdGlsZGU9Nzc4O2UuemRvdGFjY2VudD01MDA7ZS5FY2Fyb249NjY3O2UuSW9nb25laz0yNzg7ZS5rY29tbWFhY2NlbnQ9NTAwO2UubWludXM9NTg0O2UuSWNpcmN1bWZsZXg9Mjc4O2UubmNhcm9uPTU1NjtlLnRjb21tYWFjY2VudD0yNzg7ZS5sb2dpY2Fsbm90PTU4NDtlLm9kaWVyZXNpcz01NTY7ZS51ZGllcmVzaXM9NTU2O2Uubm90ZXF1YWw9NTQ5O2UuZ2NvbW1hYWNjZW50PTU1NjtlLmV0aD01NTY7ZS56Y2Fyb249NTAwO2UubmNvbW1hYWNjZW50PTU1NjtlLm9uZXN1cGVyaW9yPTMzMztlLmltYWNyb249Mjc4O2UuRXVybz01NTZ9KSk7ZS5TeW1ib2w9Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI1MDtlLmV4Y2xhbT0zMzM7ZS51bml2ZXJzYWw9NzEzO2UubnVtYmVyc2lnbj01MDA7ZS5leGlzdGVudGlhbD01NDk7ZS5wZXJjZW50PTgzMztlLmFtcGVyc2FuZD03Nzg7ZS5zdWNodGhhdD00Mzk7ZS5wYXJlbmxlZnQ9MzMzO2UucGFyZW5yaWdodD0zMzM7ZS5hc3Rlcmlza21hdGg9NTAwO2UucGx1cz01NDk7ZS5jb21tYT0yNTA7ZS5taW51cz01NDk7ZS5wZXJpb2Q9MjUwO2Uuc2xhc2g9Mjc4O2UuemVybz01MDA7ZS5vbmU9NTAwO2UudHdvPTUwMDtlLnRocmVlPTUwMDtlLmZvdXI9NTAwO2UuZml2ZT01MDA7ZS5zaXg9NTAwO2Uuc2V2ZW49NTAwO2UuZWlnaHQ9NTAwO2UubmluZT01MDA7ZS5jb2xvbj0yNzg7ZS5zZW1pY29sb249Mjc4O2UubGVzcz01NDk7ZS5lcXVhbD01NDk7ZS5ncmVhdGVyPTU0OTtlLnF1ZXN0aW9uPTQ0NDtlLmNvbmdydWVudD01NDk7ZS5BbHBoYT03MjI7ZS5CZXRhPTY2NztlLkNoaT03MjI7ZS5EZWx0YT02MTI7ZS5FcHNpbG9uPTYxMTtlLlBoaT03NjM7ZS5HYW1tYT02MDM7ZS5FdGE9NzIyO2UuSW90YT0zMzM7ZS50aGV0YTE9NjMxO2UuS2FwcGE9NzIyO2UuTGFtYmRhPTY4NjtlLk11PTg4OTtlLk51PTcyMjtlLk9taWNyb249NzIyO2UuUGk9NzY4O2UuVGhldGE9NzQxO2UuUmhvPTU1NjtlLlNpZ21hPTU5MjtlLlRhdT02MTE7ZS5VcHNpbG9uPTY5MDtlLnNpZ21hMT00Mzk7ZS5PbWVnYT03Njg7ZS5YaT02NDU7ZS5Qc2k9Nzk1O2UuWmV0YT02MTE7ZS5icmFja2V0bGVmdD0zMzM7ZS50aGVyZWZvcmU9ODYzO2UuYnJhY2tldHJpZ2h0PTMzMztlLnBlcnBlbmRpY3VsYXI9NjU4O2UudW5kZXJzY29yZT01MDA7ZS5yYWRpY2FsZXg9NTAwO2UuYWxwaGE9NjMxO2UuYmV0YT01NDk7ZS5jaGk9NTQ5O2UuZGVsdGE9NDk0O2UuZXBzaWxvbj00Mzk7ZS5waGk9NTIxO2UuZ2FtbWE9NDExO2UuZXRhPTYwMztlLmlvdGE9MzI5O2UucGhpMT02MDM7ZS5rYXBwYT01NDk7ZS5sYW1iZGE9NTQ5O2UubXU9NTc2O2UubnU9NTIxO2Uub21pY3Jvbj01NDk7ZS5waT01NDk7ZS50aGV0YT01MjE7ZS5yaG89NTQ5O2Uuc2lnbWE9NjAzO2UudGF1PTQzOTtlLnVwc2lsb249NTc2O2Uub21lZ2ExPTcxMztlLm9tZWdhPTY4NjtlLnhpPTQ5MztlLnBzaT02ODY7ZS56ZXRhPTQ5NDtlLmJyYWNlbGVmdD00ODA7ZS5iYXI9MjAwO2UuYnJhY2VyaWdodD00ODA7ZS5zaW1pbGFyPTU0OTtlLkV1cm89NzUwO2UuVXBzaWxvbjE9NjIwO2UubWludXRlPTI0NztlLmxlc3NlcXVhbD01NDk7ZS5mcmFjdGlvbj0xNjc7ZS5pbmZpbml0eT03MTM7ZS5mbG9yaW49NTAwO2UuY2x1Yj03NTM7ZS5kaWFtb25kPTc1MztlLmhlYXJ0PTc1MztlLnNwYWRlPTc1MztlLmFycm93Ym90aD0xMDQyO2UuYXJyb3dsZWZ0PTk4NztlLmFycm93dXA9NjAzO2UuYXJyb3dyaWdodD05ODc7ZS5hcnJvd2Rvd249NjAzO2UuZGVncmVlPTQwMDtlLnBsdXNtaW51cz01NDk7ZS5zZWNvbmQ9NDExO2UuZ3JlYXRlcmVxdWFsPTU0OTtlLm11bHRpcGx5PTU0OTtlLnByb3BvcnRpb25hbD03MTM7ZS5wYXJ0aWFsZGlmZj00OTQ7ZS5idWxsZXQ9NDYwO2UuZGl2aWRlPTU0OTtlLm5vdGVxdWFsPTU0OTtlLmVxdWl2YWxlbmNlPTU0OTtlLmFwcHJveGVxdWFsPTU0OTtlLmVsbGlwc2lzPTFlMztlLmFycm93dmVydGV4PTYwMztlLmFycm93aG9yaXpleD0xZTM7ZS5jYXJyaWFnZXJldHVybj02NTg7ZS5hbGVwaD04MjM7ZS5JZnJha3R1cj02ODY7ZS5SZnJha3R1cj03OTU7ZS53ZWllcnN0cmFzcz05ODc7ZS5jaXJjbGVtdWx0aXBseT03Njg7ZS5jaXJjbGVwbHVzPTc2ODtlLmVtcHR5c2V0PTgyMztlLmludGVyc2VjdGlvbj03Njg7ZS51bmlvbj03Njg7ZS5wcm9wZXJzdXBlcnNldD03MTM7ZS5yZWZsZXhzdXBlcnNldD03MTM7ZS5ub3RzdWJzZXQ9NzEzO2UucHJvcGVyc3Vic2V0PTcxMztlLnJlZmxleHN1YnNldD03MTM7ZS5lbGVtZW50PTcxMztlLm5vdGVsZW1lbnQ9NzEzO2UuYW5nbGU9NzY4O2UuZ3JhZGllbnQ9NzEzO2UucmVnaXN0ZXJzZXJpZj03OTA7ZS5jb3B5cmlnaHRzZXJpZj03OTA7ZS50cmFkZW1hcmtzZXJpZj04OTA7ZS5wcm9kdWN0PTgyMztlLnJhZGljYWw9NTQ5O2UuZG90bWF0aD0yNTA7ZS5sb2dpY2Fsbm90PTcxMztlLmxvZ2ljYWxhbmQ9NjAzO2UubG9naWNhbG9yPTYwMztlLmFycm93ZGJsYm90aD0xMDQyO2UuYXJyb3dkYmxsZWZ0PTk4NztlLmFycm93ZGJsdXA9NjAzO2UuYXJyb3dkYmxyaWdodD05ODc7ZS5hcnJvd2RibGRvd249NjAzO2UubG96ZW5nZT00OTQ7ZS5hbmdsZWxlZnQ9MzI5O2UucmVnaXN0ZXJzYW5zPTc5MDtlLmNvcHlyaWdodHNhbnM9NzkwO2UudHJhZGVtYXJrc2Fucz03ODY7ZS5zdW1tYXRpb249NzEzO2UucGFyZW5sZWZ0dHA9Mzg0O2UucGFyZW5sZWZ0ZXg9Mzg0O2UucGFyZW5sZWZ0YnQ9Mzg0O2UuYnJhY2tldGxlZnR0cD0zODQ7ZS5icmFja2V0bGVmdGV4PTM4NDtlLmJyYWNrZXRsZWZ0YnQ9Mzg0O2UuYnJhY2VsZWZ0dHA9NDk0O2UuYnJhY2VsZWZ0bWlkPTQ5NDtlLmJyYWNlbGVmdGJ0PTQ5NDtlLmJyYWNlZXg9NDk0O2UuYW5nbGVyaWdodD0zMjk7ZS5pbnRlZ3JhbD0yNzQ7ZS5pbnRlZ3JhbHRwPTY4NjtlLmludGVncmFsZXg9Njg2O2UuaW50ZWdyYWxidD02ODY7ZS5wYXJlbnJpZ2h0dHA9Mzg0O2UucGFyZW5yaWdodGV4PTM4NDtlLnBhcmVucmlnaHRidD0zODQ7ZS5icmFja2V0cmlnaHR0cD0zODQ7ZS5icmFja2V0cmlnaHRleD0zODQ7ZS5icmFja2V0cmlnaHRidD0zODQ7ZS5icmFjZXJpZ2h0dHA9NDk0O2UuYnJhY2VyaWdodG1pZD00OTQ7ZS5icmFjZXJpZ2h0YnQ9NDk0O2UuYXBwbGU9NzkwfSkpO2VbIlRpbWVzLVJvbWFuIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI1MDtlLmV4Y2xhbT0zMzM7ZS5xdW90ZWRibD00MDg7ZS5udW1iZXJzaWduPTUwMDtlLmRvbGxhcj01MDA7ZS5wZXJjZW50PTgzMztlLmFtcGVyc2FuZD03Nzg7ZS5xdW90ZXJpZ2h0PTMzMztlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTUwMDtlLnBsdXM9NTY0O2UuY29tbWE9MjUwO2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNTA7ZS5zbGFzaD0yNzg7ZS56ZXJvPTUwMDtlLm9uZT01MDA7ZS50d289NTAwO2UudGhyZWU9NTAwO2UuZm91cj01MDA7ZS5maXZlPTUwMDtlLnNpeD01MDA7ZS5zZXZlbj01MDA7ZS5laWdodD01MDA7ZS5uaW5lPTUwMDtlLmNvbG9uPTI3ODtlLnNlbWljb2xvbj0yNzg7ZS5sZXNzPTU2NDtlLmVxdWFsPTU2NDtlLmdyZWF0ZXI9NTY0O2UucXVlc3Rpb249NDQ0O2UuYXQ9OTIxO2UuQT03MjI7ZS5CPTY2NztlLkM9NjY3O2UuRD03MjI7ZS5FPTYxMTtlLkY9NTU2O2UuRz03MjI7ZS5IPTcyMjtlLkk9MzMzO2UuSj0zODk7ZS5LPTcyMjtlLkw9NjExO2UuTT04ODk7ZS5OPTcyMjtlLk89NzIyO2UuUD01NTY7ZS5RPTcyMjtlLlI9NjY3O2UuUz01NTY7ZS5UPTYxMTtlLlU9NzIyO2UuVj03MjI7ZS5XPTk0NDtlLlg9NzIyO2UuWT03MjI7ZS5aPTYxMTtlLmJyYWNrZXRsZWZ0PTMzMztlLmJhY2tzbGFzaD0yNzg7ZS5icmFja2V0cmlnaHQ9MzMzO2UuYXNjaWljaXJjdW09NDY5O2UudW5kZXJzY29yZT01MDA7ZS5xdW90ZWxlZnQ9MzMzO2UuYT00NDQ7ZS5iPTUwMDtlLmM9NDQ0O2UuZD01MDA7ZS5lPTQ0NDtlLmY9MzMzO2UuZz01MDA7ZS5oPTUwMDtlLmk9Mjc4O2Uuaj0yNzg7ZS5rPTUwMDtlLmw9Mjc4O2UubT03Nzg7ZS5uPTUwMDtlLm89NTAwO2UucD01MDA7ZS5xPTUwMDtlLnI9MzMzO2Uucz0zODk7ZS50PTI3ODtlLnU9NTAwO2Uudj01MDA7ZS53PTcyMjtlLng9NTAwO2UueT01MDA7ZS56PTQ0NDtlLmJyYWNlbGVmdD00ODA7ZS5iYXI9MjAwO2UuYnJhY2VyaWdodD00ODA7ZS5hc2NpaXRpbGRlPTU0MTtlLmV4Y2xhbWRvd249MzMzO2UuY2VudD01MDA7ZS5zdGVybGluZz01MDA7ZS5mcmFjdGlvbj0xNjc7ZS55ZW49NTAwO2UuZmxvcmluPTUwMDtlLnNlY3Rpb249NTAwO2UuY3VycmVuY3k9NTAwO2UucXVvdGVzaW5nbGU9MTgwO2UucXVvdGVkYmxsZWZ0PTQ0NDtlLmd1aWxsZW1vdGxlZnQ9NTAwO2UuZ3VpbHNpbmdsbGVmdD0zMzM7ZS5ndWlsc2luZ2xyaWdodD0zMzM7ZS5maT01NTY7ZS5mbD01NTY7ZS5lbmRhc2g9NTAwO2UuZGFnZ2VyPTUwMDtlLmRhZ2dlcmRibD01MDA7ZS5wZXJpb2RjZW50ZXJlZD0yNTA7ZS5wYXJhZ3JhcGg9NDUzO2UuYnVsbGV0PTM1MDtlLnF1b3Rlc2luZ2xiYXNlPTMzMztlLnF1b3RlZGJsYmFzZT00NDQ7ZS5xdW90ZWRibHJpZ2h0PTQ0NDtlLmd1aWxsZW1vdHJpZ2h0PTUwMDtlLmVsbGlwc2lzPTFlMztlLnBlcnRob3VzYW5kPTFlMztlLnF1ZXN0aW9uZG93bj00NDQ7ZS5ncmF2ZT0zMzM7ZS5hY3V0ZT0zMzM7ZS5jaXJjdW1mbGV4PTMzMztlLnRpbGRlPTMzMztlLm1hY3Jvbj0zMzM7ZS5icmV2ZT0zMzM7ZS5kb3RhY2NlbnQ9MzMzO2UuZGllcmVzaXM9MzMzO2UucmluZz0zMzM7ZS5jZWRpbGxhPTMzMztlLmh1bmdhcnVtbGF1dD0zMzM7ZS5vZ29uZWs9MzMzO2UuY2Fyb249MzMzO2UuZW1kYXNoPTFlMztlLkFFPTg4OTtlLm9yZGZlbWluaW5lPTI3NjtlLkxzbGFzaD02MTE7ZS5Pc2xhc2g9NzIyO2UuT0U9ODg5O2Uub3JkbWFzY3VsaW5lPTMxMDtlLmFlPTY2NztlLmRvdGxlc3NpPTI3ODtlLmxzbGFzaD0yNzg7ZS5vc2xhc2g9NTAwO2Uub2U9NzIyO2UuZ2VybWFuZGJscz01MDA7ZS5JZGllcmVzaXM9MzMzO2UuZWFjdXRlPTQ0NDtlLmFicmV2ZT00NDQ7ZS51aHVuZ2FydW1sYXV0PTUwMDtlLmVjYXJvbj00NDQ7ZS5ZZGllcmVzaXM9NzIyO2UuZGl2aWRlPTU2NDtlLllhY3V0ZT03MjI7ZS5BY2lyY3VtZmxleD03MjI7ZS5hYWN1dGU9NDQ0O2UuVWNpcmN1bWZsZXg9NzIyO2UueWFjdXRlPTUwMDtlLnNjb21tYWFjY2VudD0zODk7ZS5lY2lyY3VtZmxleD00NDQ7ZS5VcmluZz03MjI7ZS5VZGllcmVzaXM9NzIyO2UuYW9nb25laz00NDQ7ZS5VYWN1dGU9NzIyO2UudW9nb25laz01MDA7ZS5FZGllcmVzaXM9NjExO2UuRGNyb2F0PTcyMjtlLmNvbW1hYWNjZW50PTI1MDtlLmNvcHlyaWdodD03NjA7ZS5FbWFjcm9uPTYxMTtlLmNjYXJvbj00NDQ7ZS5hcmluZz00NDQ7ZS5OY29tbWFhY2NlbnQ9NzIyO2UubGFjdXRlPTI3ODtlLmFncmF2ZT00NDQ7ZS5UY29tbWFhY2NlbnQ9NjExO2UuQ2FjdXRlPTY2NztlLmF0aWxkZT00NDQ7ZS5FZG90YWNjZW50PTYxMTtlLnNjYXJvbj0zODk7ZS5zY2VkaWxsYT0zODk7ZS5pYWN1dGU9Mjc4O2UubG96ZW5nZT00NzE7ZS5SY2Fyb249NjY3O2UuR2NvbW1hYWNjZW50PTcyMjtlLnVjaXJjdW1mbGV4PTUwMDtlLmFjaXJjdW1mbGV4PTQ0NDtlLkFtYWNyb249NzIyO2UucmNhcm9uPTMzMztlLmNjZWRpbGxhPTQ0NDtlLlpkb3RhY2NlbnQ9NjExO2UuVGhvcm49NTU2O2UuT21hY3Jvbj03MjI7ZS5SYWN1dGU9NjY3O2UuU2FjdXRlPTU1NjtlLmRjYXJvbj01ODg7ZS5VbWFjcm9uPTcyMjtlLnVyaW5nPTUwMDtlLnRocmVlc3VwZXJpb3I9MzAwO2UuT2dyYXZlPTcyMjtlLkFncmF2ZT03MjI7ZS5BYnJldmU9NzIyO2UubXVsdGlwbHk9NTY0O2UudWFjdXRlPTUwMDtlLlRjYXJvbj02MTE7ZS5wYXJ0aWFsZGlmZj00NzY7ZS55ZGllcmVzaXM9NTAwO2UuTmFjdXRlPTcyMjtlLmljaXJjdW1mbGV4PTI3ODtlLkVjaXJjdW1mbGV4PTYxMTtlLmFkaWVyZXNpcz00NDQ7ZS5lZGllcmVzaXM9NDQ0O2UuY2FjdXRlPTQ0NDtlLm5hY3V0ZT01MDA7ZS51bWFjcm9uPTUwMDtlLk5jYXJvbj03MjI7ZS5JYWN1dGU9MzMzO2UucGx1c21pbnVzPTU2NDtlLmJyb2tlbmJhcj0yMDA7ZS5yZWdpc3RlcmVkPTc2MDtlLkdicmV2ZT03MjI7ZS5JZG90YWNjZW50PTMzMztlLnN1bW1hdGlvbj02MDA7ZS5FZ3JhdmU9NjExO2UucmFjdXRlPTMzMztlLm9tYWNyb249NTAwO2UuWmFjdXRlPTYxMTtlLlpjYXJvbj02MTE7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UuRXRoPTcyMjtlLkNjZWRpbGxhPTY2NztlLmxjb21tYWFjY2VudD0yNzg7ZS50Y2Fyb249MzI2O2UuZW9nb25laz00NDQ7ZS5Vb2dvbmVrPTcyMjtlLkFhY3V0ZT03MjI7ZS5BZGllcmVzaXM9NzIyO2UuZWdyYXZlPTQ0NDtlLnphY3V0ZT00NDQ7ZS5pb2dvbmVrPTI3ODtlLk9hY3V0ZT03MjI7ZS5vYWN1dGU9NTAwO2UuYW1hY3Jvbj00NDQ7ZS5zYWN1dGU9Mzg5O2UuaWRpZXJlc2lzPTI3ODtlLk9jaXJjdW1mbGV4PTcyMjtlLlVncmF2ZT03MjI7ZS5EZWx0YT02MTI7ZS50aG9ybj01MDA7ZS50d29zdXBlcmlvcj0zMDA7ZS5PZGllcmVzaXM9NzIyO2UubXU9NTAwO2UuaWdyYXZlPTI3ODtlLm9odW5nYXJ1bWxhdXQ9NTAwO2UuRW9nb25laz02MTE7ZS5kY3JvYXQ9NTAwO2UudGhyZWVxdWFydGVycz03NTA7ZS5TY2VkaWxsYT01NTY7ZS5sY2Fyb249MzQ0O2UuS2NvbW1hYWNjZW50PTcyMjtlLkxhY3V0ZT02MTE7ZS50cmFkZW1hcms9OTgwO2UuZWRvdGFjY2VudD00NDQ7ZS5JZ3JhdmU9MzMzO2UuSW1hY3Jvbj0zMzM7ZS5MY2Fyb249NjExO2Uub25laGFsZj03NTA7ZS5sZXNzZXF1YWw9NTQ5O2Uub2NpcmN1bWZsZXg9NTAwO2UubnRpbGRlPTUwMDtlLlVodW5nYXJ1bWxhdXQ9NzIyO2UuRWFjdXRlPTYxMTtlLmVtYWNyb249NDQ0O2UuZ2JyZXZlPTUwMDtlLm9uZXF1YXJ0ZXI9NzUwO2UuU2Nhcm9uPTU1NjtlLlNjb21tYWFjY2VudD01NTY7ZS5PaHVuZ2FydW1sYXV0PTcyMjtlLmRlZ3JlZT00MDA7ZS5vZ3JhdmU9NTAwO2UuQ2Nhcm9uPTY2NztlLnVncmF2ZT01MDA7ZS5yYWRpY2FsPTQ1MztlLkRjYXJvbj03MjI7ZS5yY29tbWFhY2NlbnQ9MzMzO2UuTnRpbGRlPTcyMjtlLm90aWxkZT01MDA7ZS5SY29tbWFhY2NlbnQ9NjY3O2UuTGNvbW1hYWNjZW50PTYxMTtlLkF0aWxkZT03MjI7ZS5Bb2dvbmVrPTcyMjtlLkFyaW5nPTcyMjtlLk90aWxkZT03MjI7ZS56ZG90YWNjZW50PTQ0NDtlLkVjYXJvbj02MTE7ZS5Jb2dvbmVrPTMzMztlLmtjb21tYWFjY2VudD01MDA7ZS5taW51cz01NjQ7ZS5JY2lyY3VtZmxleD0zMzM7ZS5uY2Fyb249NTAwO2UudGNvbW1hYWNjZW50PTI3ODtlLmxvZ2ljYWxub3Q9NTY0O2Uub2RpZXJlc2lzPTUwMDtlLnVkaWVyZXNpcz01MDA7ZS5ub3RlcXVhbD01NDk7ZS5nY29tbWFhY2NlbnQ9NTAwO2UuZXRoPTUwMDtlLnpjYXJvbj00NDQ7ZS5uY29tbWFhY2NlbnQ9NTAwO2Uub25lc3VwZXJpb3I9MzAwO2UuaW1hY3Jvbj0yNzg7ZS5FdXJvPTUwMH0pKTtlWyJUaW1lcy1Cb2xkIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI1MDtlLmV4Y2xhbT0zMzM7ZS5xdW90ZWRibD01NTU7ZS5udW1iZXJzaWduPTUwMDtlLmRvbGxhcj01MDA7ZS5wZXJjZW50PTFlMztlLmFtcGVyc2FuZD04MzM7ZS5xdW90ZXJpZ2h0PTMzMztlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTUwMDtlLnBsdXM9NTcwO2UuY29tbWE9MjUwO2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNTA7ZS5zbGFzaD0yNzg7ZS56ZXJvPTUwMDtlLm9uZT01MDA7ZS50d289NTAwO2UudGhyZWU9NTAwO2UuZm91cj01MDA7ZS5maXZlPTUwMDtlLnNpeD01MDA7ZS5zZXZlbj01MDA7ZS5laWdodD01MDA7ZS5uaW5lPTUwMDtlLmNvbG9uPTMzMztlLnNlbWljb2xvbj0zMzM7ZS5sZXNzPTU3MDtlLmVxdWFsPTU3MDtlLmdyZWF0ZXI9NTcwO2UucXVlc3Rpb249NTAwO2UuYXQ9OTMwO2UuQT03MjI7ZS5CPTY2NztlLkM9NzIyO2UuRD03MjI7ZS5FPTY2NztlLkY9NjExO2UuRz03Nzg7ZS5IPTc3ODtlLkk9Mzg5O2UuSj01MDA7ZS5LPTc3ODtlLkw9NjY3O2UuTT05NDQ7ZS5OPTcyMjtlLk89Nzc4O2UuUD02MTE7ZS5RPTc3ODtlLlI9NzIyO2UuUz01NTY7ZS5UPTY2NztlLlU9NzIyO2UuVj03MjI7ZS5XPTFlMztlLlg9NzIyO2UuWT03MjI7ZS5aPTY2NztlLmJyYWNrZXRsZWZ0PTMzMztlLmJhY2tzbGFzaD0yNzg7ZS5icmFja2V0cmlnaHQ9MzMzO2UuYXNjaWljaXJjdW09NTgxO2UudW5kZXJzY29yZT01MDA7ZS5xdW90ZWxlZnQ9MzMzO2UuYT01MDA7ZS5iPTU1NjtlLmM9NDQ0O2UuZD01NTY7ZS5lPTQ0NDtlLmY9MzMzO2UuZz01MDA7ZS5oPTU1NjtlLmk9Mjc4O2Uuaj0zMzM7ZS5rPTU1NjtlLmw9Mjc4O2UubT04MzM7ZS5uPTU1NjtlLm89NTAwO2UucD01NTY7ZS5xPTU1NjtlLnI9NDQ0O2Uucz0zODk7ZS50PTMzMztlLnU9NTU2O2Uudj01MDA7ZS53PTcyMjtlLng9NTAwO2UueT01MDA7ZS56PTQ0NDtlLmJyYWNlbGVmdD0zOTQ7ZS5iYXI9MjIwO2UuYnJhY2VyaWdodD0zOTQ7ZS5hc2NpaXRpbGRlPTUyMDtlLmV4Y2xhbWRvd249MzMzO2UuY2VudD01MDA7ZS5zdGVybGluZz01MDA7ZS5mcmFjdGlvbj0xNjc7ZS55ZW49NTAwO2UuZmxvcmluPTUwMDtlLnNlY3Rpb249NTAwO2UuY3VycmVuY3k9NTAwO2UucXVvdGVzaW5nbGU9Mjc4O2UucXVvdGVkYmxsZWZ0PTUwMDtlLmd1aWxsZW1vdGxlZnQ9NTAwO2UuZ3VpbHNpbmdsbGVmdD0zMzM7ZS5ndWlsc2luZ2xyaWdodD0zMzM7ZS5maT01NTY7ZS5mbD01NTY7ZS5lbmRhc2g9NTAwO2UuZGFnZ2VyPTUwMDtlLmRhZ2dlcmRibD01MDA7ZS5wZXJpb2RjZW50ZXJlZD0yNTA7ZS5wYXJhZ3JhcGg9NTQwO2UuYnVsbGV0PTM1MDtlLnF1b3Rlc2luZ2xiYXNlPTMzMztlLnF1b3RlZGJsYmFzZT01MDA7ZS5xdW90ZWRibHJpZ2h0PTUwMDtlLmd1aWxsZW1vdHJpZ2h0PTUwMDtlLmVsbGlwc2lzPTFlMztlLnBlcnRob3VzYW5kPTFlMztlLnF1ZXN0aW9uZG93bj01MDA7ZS5ncmF2ZT0zMzM7ZS5hY3V0ZT0zMzM7ZS5jaXJjdW1mbGV4PTMzMztlLnRpbGRlPTMzMztlLm1hY3Jvbj0zMzM7ZS5icmV2ZT0zMzM7ZS5kb3RhY2NlbnQ9MzMzO2UuZGllcmVzaXM9MzMzO2UucmluZz0zMzM7ZS5jZWRpbGxhPTMzMztlLmh1bmdhcnVtbGF1dD0zMzM7ZS5vZ29uZWs9MzMzO2UuY2Fyb249MzMzO2UuZW1kYXNoPTFlMztlLkFFPTFlMztlLm9yZGZlbWluaW5lPTMwMDtlLkxzbGFzaD02Njc7ZS5Pc2xhc2g9Nzc4O2UuT0U9MWUzO2Uub3JkbWFzY3VsaW5lPTMzMDtlLmFlPTcyMjtlLmRvdGxlc3NpPTI3ODtlLmxzbGFzaD0yNzg7ZS5vc2xhc2g9NTAwO2Uub2U9NzIyO2UuZ2VybWFuZGJscz01NTY7ZS5JZGllcmVzaXM9Mzg5O2UuZWFjdXRlPTQ0NDtlLmFicmV2ZT01MDA7ZS51aHVuZ2FydW1sYXV0PTU1NjtlLmVjYXJvbj00NDQ7ZS5ZZGllcmVzaXM9NzIyO2UuZGl2aWRlPTU3MDtlLllhY3V0ZT03MjI7ZS5BY2lyY3VtZmxleD03MjI7ZS5hYWN1dGU9NTAwO2UuVWNpcmN1bWZsZXg9NzIyO2UueWFjdXRlPTUwMDtlLnNjb21tYWFjY2VudD0zODk7ZS5lY2lyY3VtZmxleD00NDQ7ZS5VcmluZz03MjI7ZS5VZGllcmVzaXM9NzIyO2UuYW9nb25laz01MDA7ZS5VYWN1dGU9NzIyO2UudW9nb25laz01NTY7ZS5FZGllcmVzaXM9NjY3O2UuRGNyb2F0PTcyMjtlLmNvbW1hYWNjZW50PTI1MDtlLmNvcHlyaWdodD03NDc7ZS5FbWFjcm9uPTY2NztlLmNjYXJvbj00NDQ7ZS5hcmluZz01MDA7ZS5OY29tbWFhY2NlbnQ9NzIyO2UubGFjdXRlPTI3ODtlLmFncmF2ZT01MDA7ZS5UY29tbWFhY2NlbnQ9NjY3O2UuQ2FjdXRlPTcyMjtlLmF0aWxkZT01MDA7ZS5FZG90YWNjZW50PTY2NztlLnNjYXJvbj0zODk7ZS5zY2VkaWxsYT0zODk7ZS5pYWN1dGU9Mjc4O2UubG96ZW5nZT00OTQ7ZS5SY2Fyb249NzIyO2UuR2NvbW1hYWNjZW50PTc3ODtlLnVjaXJjdW1mbGV4PTU1NjtlLmFjaXJjdW1mbGV4PTUwMDtlLkFtYWNyb249NzIyO2UucmNhcm9uPTQ0NDtlLmNjZWRpbGxhPTQ0NDtlLlpkb3RhY2NlbnQ9NjY3O2UuVGhvcm49NjExO2UuT21hY3Jvbj03Nzg7ZS5SYWN1dGU9NzIyO2UuU2FjdXRlPTU1NjtlLmRjYXJvbj02NzI7ZS5VbWFjcm9uPTcyMjtlLnVyaW5nPTU1NjtlLnRocmVlc3VwZXJpb3I9MzAwO2UuT2dyYXZlPTc3ODtlLkFncmF2ZT03MjI7ZS5BYnJldmU9NzIyO2UubXVsdGlwbHk9NTcwO2UudWFjdXRlPTU1NjtlLlRjYXJvbj02Njc7ZS5wYXJ0aWFsZGlmZj00OTQ7ZS55ZGllcmVzaXM9NTAwO2UuTmFjdXRlPTcyMjtlLmljaXJjdW1mbGV4PTI3ODtlLkVjaXJjdW1mbGV4PTY2NztlLmFkaWVyZXNpcz01MDA7ZS5lZGllcmVzaXM9NDQ0O2UuY2FjdXRlPTQ0NDtlLm5hY3V0ZT01NTY7ZS51bWFjcm9uPTU1NjtlLk5jYXJvbj03MjI7ZS5JYWN1dGU9Mzg5O2UucGx1c21pbnVzPTU3MDtlLmJyb2tlbmJhcj0yMjA7ZS5yZWdpc3RlcmVkPTc0NztlLkdicmV2ZT03Nzg7ZS5JZG90YWNjZW50PTM4OTtlLnN1bW1hdGlvbj02MDA7ZS5FZ3JhdmU9NjY3O2UucmFjdXRlPTQ0NDtlLm9tYWNyb249NTAwO2UuWmFjdXRlPTY2NztlLlpjYXJvbj02Njc7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UuRXRoPTcyMjtlLkNjZWRpbGxhPTcyMjtlLmxjb21tYWFjY2VudD0yNzg7ZS50Y2Fyb249NDE2O2UuZW9nb25laz00NDQ7ZS5Vb2dvbmVrPTcyMjtlLkFhY3V0ZT03MjI7ZS5BZGllcmVzaXM9NzIyO2UuZWdyYXZlPTQ0NDtlLnphY3V0ZT00NDQ7ZS5pb2dvbmVrPTI3ODtlLk9hY3V0ZT03Nzg7ZS5vYWN1dGU9NTAwO2UuYW1hY3Jvbj01MDA7ZS5zYWN1dGU9Mzg5O2UuaWRpZXJlc2lzPTI3ODtlLk9jaXJjdW1mbGV4PTc3ODtlLlVncmF2ZT03MjI7ZS5EZWx0YT02MTI7ZS50aG9ybj01NTY7ZS50d29zdXBlcmlvcj0zMDA7ZS5PZGllcmVzaXM9Nzc4O2UubXU9NTU2O2UuaWdyYXZlPTI3ODtlLm9odW5nYXJ1bWxhdXQ9NTAwO2UuRW9nb25laz02Njc7ZS5kY3JvYXQ9NTU2O2UudGhyZWVxdWFydGVycz03NTA7ZS5TY2VkaWxsYT01NTY7ZS5sY2Fyb249Mzk0O2UuS2NvbW1hYWNjZW50PTc3ODtlLkxhY3V0ZT02Njc7ZS50cmFkZW1hcms9MWUzO2UuZWRvdGFjY2VudD00NDQ7ZS5JZ3JhdmU9Mzg5O2UuSW1hY3Jvbj0zODk7ZS5MY2Fyb249NjY3O2Uub25laGFsZj03NTA7ZS5sZXNzZXF1YWw9NTQ5O2Uub2NpcmN1bWZsZXg9NTAwO2UubnRpbGRlPTU1NjtlLlVodW5nYXJ1bWxhdXQ9NzIyO2UuRWFjdXRlPTY2NztlLmVtYWNyb249NDQ0O2UuZ2JyZXZlPTUwMDtlLm9uZXF1YXJ0ZXI9NzUwO2UuU2Nhcm9uPTU1NjtlLlNjb21tYWFjY2VudD01NTY7ZS5PaHVuZ2FydW1sYXV0PTc3ODtlLmRlZ3JlZT00MDA7ZS5vZ3JhdmU9NTAwO2UuQ2Nhcm9uPTcyMjtlLnVncmF2ZT01NTY7ZS5yYWRpY2FsPTU0OTtlLkRjYXJvbj03MjI7ZS5yY29tbWFhY2NlbnQ9NDQ0O2UuTnRpbGRlPTcyMjtlLm90aWxkZT01MDA7ZS5SY29tbWFhY2NlbnQ9NzIyO2UuTGNvbW1hYWNjZW50PTY2NztlLkF0aWxkZT03MjI7ZS5Bb2dvbmVrPTcyMjtlLkFyaW5nPTcyMjtlLk90aWxkZT03Nzg7ZS56ZG90YWNjZW50PTQ0NDtlLkVjYXJvbj02Njc7ZS5Jb2dvbmVrPTM4OTtlLmtjb21tYWFjY2VudD01NTY7ZS5taW51cz01NzA7ZS5JY2lyY3VtZmxleD0zODk7ZS5uY2Fyb249NTU2O2UudGNvbW1hYWNjZW50PTMzMztlLmxvZ2ljYWxub3Q9NTcwO2Uub2RpZXJlc2lzPTUwMDtlLnVkaWVyZXNpcz01NTY7ZS5ub3RlcXVhbD01NDk7ZS5nY29tbWFhY2NlbnQ9NTAwO2UuZXRoPTUwMDtlLnpjYXJvbj00NDQ7ZS5uY29tbWFhY2NlbnQ9NTU2O2Uub25lc3VwZXJpb3I9MzAwO2UuaW1hY3Jvbj0yNzg7ZS5FdXJvPTUwMH0pKTtlWyJUaW1lcy1Cb2xkSXRhbGljIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI1MDtlLmV4Y2xhbT0zODk7ZS5xdW90ZWRibD01NTU7ZS5udW1iZXJzaWduPTUwMDtlLmRvbGxhcj01MDA7ZS5wZXJjZW50PTgzMztlLmFtcGVyc2FuZD03Nzg7ZS5xdW90ZXJpZ2h0PTMzMztlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTUwMDtlLnBsdXM9NTcwO2UuY29tbWE9MjUwO2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNTA7ZS5zbGFzaD0yNzg7ZS56ZXJvPTUwMDtlLm9uZT01MDA7ZS50d289NTAwO2UudGhyZWU9NTAwO2UuZm91cj01MDA7ZS5maXZlPTUwMDtlLnNpeD01MDA7ZS5zZXZlbj01MDA7ZS5laWdodD01MDA7ZS5uaW5lPTUwMDtlLmNvbG9uPTMzMztlLnNlbWljb2xvbj0zMzM7ZS5sZXNzPTU3MDtlLmVxdWFsPTU3MDtlLmdyZWF0ZXI9NTcwO2UucXVlc3Rpb249NTAwO2UuYXQ9ODMyO2UuQT02Njc7ZS5CPTY2NztlLkM9NjY3O2UuRD03MjI7ZS5FPTY2NztlLkY9NjY3O2UuRz03MjI7ZS5IPTc3ODtlLkk9Mzg5O2UuSj01MDA7ZS5LPTY2NztlLkw9NjExO2UuTT04ODk7ZS5OPTcyMjtlLk89NzIyO2UuUD02MTE7ZS5RPTcyMjtlLlI9NjY3O2UuUz01NTY7ZS5UPTYxMTtlLlU9NzIyO2UuVj02Njc7ZS5XPTg4OTtlLlg9NjY3O2UuWT02MTE7ZS5aPTYxMTtlLmJyYWNrZXRsZWZ0PTMzMztlLmJhY2tzbGFzaD0yNzg7ZS5icmFja2V0cmlnaHQ9MzMzO2UuYXNjaWljaXJjdW09NTcwO2UudW5kZXJzY29yZT01MDA7ZS5xdW90ZWxlZnQ9MzMzO2UuYT01MDA7ZS5iPTUwMDtlLmM9NDQ0O2UuZD01MDA7ZS5lPTQ0NDtlLmY9MzMzO2UuZz01MDA7ZS5oPTU1NjtlLmk9Mjc4O2Uuaj0yNzg7ZS5rPTUwMDtlLmw9Mjc4O2UubT03Nzg7ZS5uPTU1NjtlLm89NTAwO2UucD01MDA7ZS5xPTUwMDtlLnI9Mzg5O2Uucz0zODk7ZS50PTI3ODtlLnU9NTU2O2Uudj00NDQ7ZS53PTY2NztlLng9NTAwO2UueT00NDQ7ZS56PTM4OTtlLmJyYWNlbGVmdD0zNDg7ZS5iYXI9MjIwO2UuYnJhY2VyaWdodD0zNDg7ZS5hc2NpaXRpbGRlPTU3MDtlLmV4Y2xhbWRvd249Mzg5O2UuY2VudD01MDA7ZS5zdGVybGluZz01MDA7ZS5mcmFjdGlvbj0xNjc7ZS55ZW49NTAwO2UuZmxvcmluPTUwMDtlLnNlY3Rpb249NTAwO2UuY3VycmVuY3k9NTAwO2UucXVvdGVzaW5nbGU9Mjc4O2UucXVvdGVkYmxsZWZ0PTUwMDtlLmd1aWxsZW1vdGxlZnQ9NTAwO2UuZ3VpbHNpbmdsbGVmdD0zMzM7ZS5ndWlsc2luZ2xyaWdodD0zMzM7ZS5maT01NTY7ZS5mbD01NTY7ZS5lbmRhc2g9NTAwO2UuZGFnZ2VyPTUwMDtlLmRhZ2dlcmRibD01MDA7ZS5wZXJpb2RjZW50ZXJlZD0yNTA7ZS5wYXJhZ3JhcGg9NTAwO2UuYnVsbGV0PTM1MDtlLnF1b3Rlc2luZ2xiYXNlPTMzMztlLnF1b3RlZGJsYmFzZT01MDA7ZS5xdW90ZWRibHJpZ2h0PTUwMDtlLmd1aWxsZW1vdHJpZ2h0PTUwMDtlLmVsbGlwc2lzPTFlMztlLnBlcnRob3VzYW5kPTFlMztlLnF1ZXN0aW9uZG93bj01MDA7ZS5ncmF2ZT0zMzM7ZS5hY3V0ZT0zMzM7ZS5jaXJjdW1mbGV4PTMzMztlLnRpbGRlPTMzMztlLm1hY3Jvbj0zMzM7ZS5icmV2ZT0zMzM7ZS5kb3RhY2NlbnQ9MzMzO2UuZGllcmVzaXM9MzMzO2UucmluZz0zMzM7ZS5jZWRpbGxhPTMzMztlLmh1bmdhcnVtbGF1dD0zMzM7ZS5vZ29uZWs9MzMzO2UuY2Fyb249MzMzO2UuZW1kYXNoPTFlMztlLkFFPTk0NDtlLm9yZGZlbWluaW5lPTI2NjtlLkxzbGFzaD02MTE7ZS5Pc2xhc2g9NzIyO2UuT0U9OTQ0O2Uub3JkbWFzY3VsaW5lPTMwMDtlLmFlPTcyMjtlLmRvdGxlc3NpPTI3ODtlLmxzbGFzaD0yNzg7ZS5vc2xhc2g9NTAwO2Uub2U9NzIyO2UuZ2VybWFuZGJscz01MDA7ZS5JZGllcmVzaXM9Mzg5O2UuZWFjdXRlPTQ0NDtlLmFicmV2ZT01MDA7ZS51aHVuZ2FydW1sYXV0PTU1NjtlLmVjYXJvbj00NDQ7ZS5ZZGllcmVzaXM9NjExO2UuZGl2aWRlPTU3MDtlLllhY3V0ZT02MTE7ZS5BY2lyY3VtZmxleD02Njc7ZS5hYWN1dGU9NTAwO2UuVWNpcmN1bWZsZXg9NzIyO2UueWFjdXRlPTQ0NDtlLnNjb21tYWFjY2VudD0zODk7ZS5lY2lyY3VtZmxleD00NDQ7ZS5VcmluZz03MjI7ZS5VZGllcmVzaXM9NzIyO2UuYW9nb25laz01MDA7ZS5VYWN1dGU9NzIyO2UudW9nb25laz01NTY7ZS5FZGllcmVzaXM9NjY3O2UuRGNyb2F0PTcyMjtlLmNvbW1hYWNjZW50PTI1MDtlLmNvcHlyaWdodD03NDc7ZS5FbWFjcm9uPTY2NztlLmNjYXJvbj00NDQ7ZS5hcmluZz01MDA7ZS5OY29tbWFhY2NlbnQ9NzIyO2UubGFjdXRlPTI3ODtlLmFncmF2ZT01MDA7ZS5UY29tbWFhY2NlbnQ9NjExO2UuQ2FjdXRlPTY2NztlLmF0aWxkZT01MDA7ZS5FZG90YWNjZW50PTY2NztlLnNjYXJvbj0zODk7ZS5zY2VkaWxsYT0zODk7ZS5pYWN1dGU9Mjc4O2UubG96ZW5nZT00OTQ7ZS5SY2Fyb249NjY3O2UuR2NvbW1hYWNjZW50PTcyMjtlLnVjaXJjdW1mbGV4PTU1NjtlLmFjaXJjdW1mbGV4PTUwMDtlLkFtYWNyb249NjY3O2UucmNhcm9uPTM4OTtlLmNjZWRpbGxhPTQ0NDtlLlpkb3RhY2NlbnQ9NjExO2UuVGhvcm49NjExO2UuT21hY3Jvbj03MjI7ZS5SYWN1dGU9NjY3O2UuU2FjdXRlPTU1NjtlLmRjYXJvbj02MDg7ZS5VbWFjcm9uPTcyMjtlLnVyaW5nPTU1NjtlLnRocmVlc3VwZXJpb3I9MzAwO2UuT2dyYXZlPTcyMjtlLkFncmF2ZT02Njc7ZS5BYnJldmU9NjY3O2UubXVsdGlwbHk9NTcwO2UudWFjdXRlPTU1NjtlLlRjYXJvbj02MTE7ZS5wYXJ0aWFsZGlmZj00OTQ7ZS55ZGllcmVzaXM9NDQ0O2UuTmFjdXRlPTcyMjtlLmljaXJjdW1mbGV4PTI3ODtlLkVjaXJjdW1mbGV4PTY2NztlLmFkaWVyZXNpcz01MDA7ZS5lZGllcmVzaXM9NDQ0O2UuY2FjdXRlPTQ0NDtlLm5hY3V0ZT01NTY7ZS51bWFjcm9uPTU1NjtlLk5jYXJvbj03MjI7ZS5JYWN1dGU9Mzg5O2UucGx1c21pbnVzPTU3MDtlLmJyb2tlbmJhcj0yMjA7ZS5yZWdpc3RlcmVkPTc0NztlLkdicmV2ZT03MjI7ZS5JZG90YWNjZW50PTM4OTtlLnN1bW1hdGlvbj02MDA7ZS5FZ3JhdmU9NjY3O2UucmFjdXRlPTM4OTtlLm9tYWNyb249NTAwO2UuWmFjdXRlPTYxMTtlLlpjYXJvbj02MTE7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UuRXRoPTcyMjtlLkNjZWRpbGxhPTY2NztlLmxjb21tYWFjY2VudD0yNzg7ZS50Y2Fyb249MzY2O2UuZW9nb25laz00NDQ7ZS5Vb2dvbmVrPTcyMjtlLkFhY3V0ZT02Njc7ZS5BZGllcmVzaXM9NjY3O2UuZWdyYXZlPTQ0NDtlLnphY3V0ZT0zODk7ZS5pb2dvbmVrPTI3ODtlLk9hY3V0ZT03MjI7ZS5vYWN1dGU9NTAwO2UuYW1hY3Jvbj01MDA7ZS5zYWN1dGU9Mzg5O2UuaWRpZXJlc2lzPTI3ODtlLk9jaXJjdW1mbGV4PTcyMjtlLlVncmF2ZT03MjI7ZS5EZWx0YT02MTI7ZS50aG9ybj01MDA7ZS50d29zdXBlcmlvcj0zMDA7ZS5PZGllcmVzaXM9NzIyO2UubXU9NTc2O2UuaWdyYXZlPTI3ODtlLm9odW5nYXJ1bWxhdXQ9NTAwO2UuRW9nb25laz02Njc7ZS5kY3JvYXQ9NTAwO2UudGhyZWVxdWFydGVycz03NTA7ZS5TY2VkaWxsYT01NTY7ZS5sY2Fyb249MzgyO2UuS2NvbW1hYWNjZW50PTY2NztlLkxhY3V0ZT02MTE7ZS50cmFkZW1hcms9MWUzO2UuZWRvdGFjY2VudD00NDQ7ZS5JZ3JhdmU9Mzg5O2UuSW1hY3Jvbj0zODk7ZS5MY2Fyb249NjExO2Uub25laGFsZj03NTA7ZS5sZXNzZXF1YWw9NTQ5O2Uub2NpcmN1bWZsZXg9NTAwO2UubnRpbGRlPTU1NjtlLlVodW5nYXJ1bWxhdXQ9NzIyO2UuRWFjdXRlPTY2NztlLmVtYWNyb249NDQ0O2UuZ2JyZXZlPTUwMDtlLm9uZXF1YXJ0ZXI9NzUwO2UuU2Nhcm9uPTU1NjtlLlNjb21tYWFjY2VudD01NTY7ZS5PaHVuZ2FydW1sYXV0PTcyMjtlLmRlZ3JlZT00MDA7ZS5vZ3JhdmU9NTAwO2UuQ2Nhcm9uPTY2NztlLnVncmF2ZT01NTY7ZS5yYWRpY2FsPTU0OTtlLkRjYXJvbj03MjI7ZS5yY29tbWFhY2NlbnQ9Mzg5O2UuTnRpbGRlPTcyMjtlLm90aWxkZT01MDA7ZS5SY29tbWFhY2NlbnQ9NjY3O2UuTGNvbW1hYWNjZW50PTYxMTtlLkF0aWxkZT02Njc7ZS5Bb2dvbmVrPTY2NztlLkFyaW5nPTY2NztlLk90aWxkZT03MjI7ZS56ZG90YWNjZW50PTM4OTtlLkVjYXJvbj02Njc7ZS5Jb2dvbmVrPTM4OTtlLmtjb21tYWFjY2VudD01MDA7ZS5taW51cz02MDY7ZS5JY2lyY3VtZmxleD0zODk7ZS5uY2Fyb249NTU2O2UudGNvbW1hYWNjZW50PTI3ODtlLmxvZ2ljYWxub3Q9NjA2O2Uub2RpZXJlc2lzPTUwMDtlLnVkaWVyZXNpcz01NTY7ZS5ub3RlcXVhbD01NDk7ZS5nY29tbWFhY2NlbnQ9NTAwO2UuZXRoPTUwMDtlLnpjYXJvbj0zODk7ZS5uY29tbWFhY2NlbnQ9NTU2O2Uub25lc3VwZXJpb3I9MzAwO2UuaW1hY3Jvbj0yNzg7ZS5FdXJvPTUwMH0pKTtlWyJUaW1lcy1JdGFsaWMiXT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9MjUwO2UuZXhjbGFtPTMzMztlLnF1b3RlZGJsPTQyMDtlLm51bWJlcnNpZ249NTAwO2UuZG9sbGFyPTUwMDtlLnBlcmNlbnQ9ODMzO2UuYW1wZXJzYW5kPTc3ODtlLnF1b3RlcmlnaHQ9MzMzO2UucGFyZW5sZWZ0PTMzMztlLnBhcmVucmlnaHQ9MzMzO2UuYXN0ZXJpc2s9NTAwO2UucGx1cz02NzU7ZS5jb21tYT0yNTA7ZS5oeXBoZW49MzMzO2UucGVyaW9kPTI1MDtlLnNsYXNoPTI3ODtlLnplcm89NTAwO2Uub25lPTUwMDtlLnR3bz01MDA7ZS50aHJlZT01MDA7ZS5mb3VyPTUwMDtlLmZpdmU9NTAwO2Uuc2l4PTUwMDtlLnNldmVuPTUwMDtlLmVpZ2h0PTUwMDtlLm5pbmU9NTAwO2UuY29sb249MzMzO2Uuc2VtaWNvbG9uPTMzMztlLmxlc3M9Njc1O2UuZXF1YWw9Njc1O2UuZ3JlYXRlcj02NzU7ZS5xdWVzdGlvbj01MDA7ZS5hdD05MjA7ZS5BPTYxMTtlLkI9NjExO2UuQz02Njc7ZS5EPTcyMjtlLkU9NjExO2UuRj02MTE7ZS5HPTcyMjtlLkg9NzIyO2UuST0zMzM7ZS5KPTQ0NDtlLks9NjY3O2UuTD01NTY7ZS5NPTgzMztlLk49NjY3O2UuTz03MjI7ZS5QPTYxMTtlLlE9NzIyO2UuUj02MTE7ZS5TPTUwMDtlLlQ9NTU2O2UuVT03MjI7ZS5WPTYxMTtlLlc9ODMzO2UuWD02MTE7ZS5ZPTU1NjtlLlo9NTU2O2UuYnJhY2tldGxlZnQ9Mzg5O2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0zODk7ZS5hc2NpaWNpcmN1bT00MjI7ZS51bmRlcnNjb3JlPTUwMDtlLnF1b3RlbGVmdD0zMzM7ZS5hPTUwMDtlLmI9NTAwO2UuYz00NDQ7ZS5kPTUwMDtlLmU9NDQ0O2UuZj0yNzg7ZS5nPTUwMDtlLmg9NTAwO2UuaT0yNzg7ZS5qPTI3ODtlLms9NDQ0O2UubD0yNzg7ZS5tPTcyMjtlLm49NTAwO2Uubz01MDA7ZS5wPTUwMDtlLnE9NTAwO2Uucj0zODk7ZS5zPTM4OTtlLnQ9Mjc4O2UudT01MDA7ZS52PTQ0NDtlLnc9NjY3O2UueD00NDQ7ZS55PTQ0NDtlLno9Mzg5O2UuYnJhY2VsZWZ0PTQwMDtlLmJhcj0yNzU7ZS5icmFjZXJpZ2h0PTQwMDtlLmFzY2lpdGlsZGU9NTQxO2UuZXhjbGFtZG93bj0zODk7ZS5jZW50PTUwMDtlLnN0ZXJsaW5nPTUwMDtlLmZyYWN0aW9uPTE2NztlLnllbj01MDA7ZS5mbG9yaW49NTAwO2Uuc2VjdGlvbj01MDA7ZS5jdXJyZW5jeT01MDA7ZS5xdW90ZXNpbmdsZT0yMTQ7ZS5xdW90ZWRibGxlZnQ9NTU2O2UuZ3VpbGxlbW90bGVmdD01MDA7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTUwMDtlLmZsPTUwMDtlLmVuZGFzaD01MDA7ZS5kYWdnZXI9NTAwO2UuZGFnZ2VyZGJsPTUwMDtlLnBlcmlvZGNlbnRlcmVkPTI1MDtlLnBhcmFncmFwaD01MjM7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9MzMzO2UucXVvdGVkYmxiYXNlPTU1NjtlLnF1b3RlZGJscmlnaHQ9NTU2O2UuZ3VpbGxlbW90cmlnaHQ9NTAwO2UuZWxsaXBzaXM9ODg5O2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTUwMDtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9ODg5O2UuQUU9ODg5O2Uub3JkZmVtaW5pbmU9Mjc2O2UuTHNsYXNoPTU1NjtlLk9zbGFzaD03MjI7ZS5PRT05NDQ7ZS5vcmRtYXNjdWxpbmU9MzEwO2UuYWU9NjY3O2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTI3ODtlLm9zbGFzaD01MDA7ZS5vZT02Njc7ZS5nZXJtYW5kYmxzPTUwMDtlLklkaWVyZXNpcz0zMzM7ZS5lYWN1dGU9NDQ0O2UuYWJyZXZlPTUwMDtlLnVodW5nYXJ1bWxhdXQ9NTAwO2UuZWNhcm9uPTQ0NDtlLllkaWVyZXNpcz01NTY7ZS5kaXZpZGU9Njc1O2UuWWFjdXRlPTU1NjtlLkFjaXJjdW1mbGV4PTYxMTtlLmFhY3V0ZT01MDA7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NDQ0O2Uuc2NvbW1hYWNjZW50PTM4OTtlLmVjaXJjdW1mbGV4PTQ0NDtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTUwMDtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTUwMDtlLkVkaWVyZXNpcz02MTE7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTc2MDtlLkVtYWNyb249NjExO2UuY2Nhcm9uPTQ0NDtlLmFyaW5nPTUwMDtlLk5jb21tYWFjY2VudD02Njc7ZS5sYWN1dGU9Mjc4O2UuYWdyYXZlPTUwMDtlLlRjb21tYWFjY2VudD01NTY7ZS5DYWN1dGU9NjY3O2UuYXRpbGRlPTUwMDtlLkVkb3RhY2NlbnQ9NjExO2Uuc2Nhcm9uPTM4OTtlLnNjZWRpbGxhPTM4OTtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ3MTtlLlJjYXJvbj02MTE7ZS5HY29tbWFhY2NlbnQ9NzIyO2UudWNpcmN1bWZsZXg9NTAwO2UuYWNpcmN1bWZsZXg9NTAwO2UuQW1hY3Jvbj02MTE7ZS5yY2Fyb249Mzg5O2UuY2NlZGlsbGE9NDQ0O2UuWmRvdGFjY2VudD01NTY7ZS5UaG9ybj02MTE7ZS5PbWFjcm9uPTcyMjtlLlJhY3V0ZT02MTE7ZS5TYWN1dGU9NTAwO2UuZGNhcm9uPTU0NDtlLlVtYWNyb249NzIyO2UudXJpbmc9NTAwO2UudGhyZWVzdXBlcmlvcj0zMDA7ZS5PZ3JhdmU9NzIyO2UuQWdyYXZlPTYxMTtlLkFicmV2ZT02MTE7ZS5tdWx0aXBseT02NzU7ZS51YWN1dGU9NTAwO2UuVGNhcm9uPTU1NjtlLnBhcnRpYWxkaWZmPTQ3NjtlLnlkaWVyZXNpcz00NDQ7ZS5OYWN1dGU9NjY3O2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjExO2UuYWRpZXJlc2lzPTUwMDtlLmVkaWVyZXNpcz00NDQ7ZS5jYWN1dGU9NDQ0O2UubmFjdXRlPTUwMDtlLnVtYWNyb249NTAwO2UuTmNhcm9uPTY2NztlLklhY3V0ZT0zMzM7ZS5wbHVzbWludXM9Njc1O2UuYnJva2VuYmFyPTI3NTtlLnJlZ2lzdGVyZWQ9NzYwO2UuR2JyZXZlPTcyMjtlLklkb3RhY2NlbnQ9MzMzO2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02MTE7ZS5yYWN1dGU9Mzg5O2Uub21hY3Jvbj01MDA7ZS5aYWN1dGU9NTU2O2UuWmNhcm9uPTU1NjtlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NjY3O2UubGNvbW1hYWNjZW50PTI3ODtlLnRjYXJvbj0zMDA7ZS5lb2dvbmVrPTQ0NDtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTYxMTtlLkFkaWVyZXNpcz02MTE7ZS5lZ3JhdmU9NDQ0O2UuemFjdXRlPTM4OTtlLmlvZ29uZWs9Mjc4O2UuT2FjdXRlPTcyMjtlLm9hY3V0ZT01MDA7ZS5hbWFjcm9uPTUwMDtlLnNhY3V0ZT0zODk7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9NzIyO2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTUwMDtlLnR3b3N1cGVyaW9yPTMwMDtlLk9kaWVyZXNpcz03MjI7ZS5tdT01MDA7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD01MDA7ZS5Fb2dvbmVrPTYxMTtlLmRjcm9hdD01MDA7ZS50aHJlZXF1YXJ0ZXJzPTc1MDtlLlNjZWRpbGxhPTUwMDtlLmxjYXJvbj0zMDA7ZS5LY29tbWFhY2NlbnQ9NjY3O2UuTGFjdXRlPTU1NjtlLnRyYWRlbWFyaz05ODA7ZS5lZG90YWNjZW50PTQ0NDtlLklncmF2ZT0zMzM7ZS5JbWFjcm9uPTMzMztlLkxjYXJvbj02MTE7ZS5vbmVoYWxmPTc1MDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD01MDA7ZS5udGlsZGU9NTAwO2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjExO2UuZW1hY3Jvbj00NDQ7ZS5nYnJldmU9NTAwO2Uub25lcXVhcnRlcj03NTA7ZS5TY2Fyb249NTAwO2UuU2NvbW1hYWNjZW50PTUwMDtlLk9odW5nYXJ1bWxhdXQ9NzIyO2UuZGVncmVlPTQwMDtlLm9ncmF2ZT01MDA7ZS5DY2Fyb249NjY3O2UudWdyYXZlPTUwMDtlLnJhZGljYWw9NDUzO2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD0zODk7ZS5OdGlsZGU9NjY3O2Uub3RpbGRlPTUwMDtlLlJjb21tYWFjY2VudD02MTE7ZS5MY29tbWFhY2NlbnQ9NTU2O2UuQXRpbGRlPTYxMTtlLkFvZ29uZWs9NjExO2UuQXJpbmc9NjExO2UuT3RpbGRlPTcyMjtlLnpkb3RhY2NlbnQ9Mzg5O2UuRWNhcm9uPTYxMTtlLklvZ29uZWs9MzMzO2Uua2NvbW1hYWNjZW50PTQ0NDtlLm1pbnVzPTY3NTtlLkljaXJjdW1mbGV4PTMzMztlLm5jYXJvbj01MDA7ZS50Y29tbWFhY2NlbnQ9Mjc4O2UubG9naWNhbG5vdD02NzU7ZS5vZGllcmVzaXM9NTAwO2UudWRpZXJlc2lzPTUwMDtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD01MDA7ZS5ldGg9NTAwO2UuemNhcm9uPTM4OTtlLm5jb21tYWFjY2VudD01MDA7ZS5vbmVzdXBlcmlvcj0zMDA7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTAwfSkpO2UuWmFwZkRpbmdiYXRzPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZS5zcGFjZT0yNzg7ZS5hMT05NzQ7ZS5hMj05NjE7ZS5hMjAyPTk3NDtlLmEzPTk4MDtlLmE0PTcxOTtlLmE1PTc4OTtlLmExMTk9NzkwO2UuYTExOD03OTE7ZS5hMTE3PTY5MDtlLmExMT05NjA7ZS5hMTI9OTM5O2UuYTEzPTU0OTtlLmExND04NTU7ZS5hMTU9OTExO2UuYTE2PTkzMztlLmExMDU9OTExO2UuYTE3PTk0NTtlLmExOD05NzQ7ZS5hMTk9NzU1O2UuYTIwPTg0NjtlLmEyMT03NjI7ZS5hMjI9NzYxO2UuYTIzPTU3MTtlLmEyND02Nzc7ZS5hMjU9NzYzO2UuYTI2PTc2MDtlLmEyNz03NTk7ZS5hMjg9NzU0O2UuYTY9NDk0O2UuYTc9NTUyO2UuYTg9NTM3O2UuYTk9NTc3O2UuYTEwPTY5MjtlLmEyOT03ODY7ZS5hMzA9Nzg4O2UuYTMxPTc4ODtlLmEzMj03OTA7ZS5hMzM9NzkzO2UuYTM0PTc5NDtlLmEzNT04MTY7ZS5hMzY9ODIzO2UuYTM3PTc4OTtlLmEzOD04NDE7ZS5hMzk9ODIzO2UuYTQwPTgzMztlLmE0MT04MTY7ZS5hNDI9ODMxO2UuYTQzPTkyMztlLmE0ND03NDQ7ZS5hNDU9NzIzO2UuYTQ2PTc0OTtlLmE0Nz03OTA7ZS5hNDg9NzkyO2UuYTQ5PTY5NTtlLmE1MD03NzY7ZS5hNTE9NzY4O2UuYTUyPTc5MjtlLmE1Mz03NTk7ZS5hNTQ9NzA3O2UuYTU1PTcwODtlLmE1Nj02ODI7ZS5hNTc9NzAxO2UuYTU4PTgyNjtlLmE1OT04MTU7ZS5hNjA9Nzg5O2UuYTYxPTc4OTtlLmE2Mj03MDc7ZS5hNjM9Njg3O2UuYTY0PTY5NjtlLmE2NT02ODk7ZS5hNjY9Nzg2O2UuYTY3PTc4NztlLmE2OD03MTM7ZS5hNjk9NzkxO2UuYTcwPTc4NTtlLmE3MT03OTE7ZS5hNzI9ODczO2UuYTczPTc2MTtlLmE3ND03NjI7ZS5hMjAzPTc2MjtlLmE3NT03NTk7ZS5hMjA0PTc1OTtlLmE3Nj04OTI7ZS5hNzc9ODkyO2UuYTc4PTc4ODtlLmE3OT03ODQ7ZS5hODE9NDM4O2UuYTgyPTEzODtlLmE4Mz0yNzc7ZS5hODQ9NDE1O2UuYTk3PTM5MjtlLmE5OD0zOTI7ZS5hOTk9NjY4O2UuYTEwMD02Njg7ZS5hODk9MzkwO2UuYTkwPTM5MDtlLmE5Mz0zMTc7ZS5hOTQ9MzE3O2UuYTkxPTI3NjtlLmE5Mj0yNzY7ZS5hMjA1PTUwOTtlLmE4NT01MDk7ZS5hMjA2PTQxMDtlLmE4Nj00MTA7ZS5hODc9MjM0O2UuYTg4PTIzNDtlLmE5NT0zMzQ7ZS5hOTY9MzM0O2UuYTEwMT03MzI7ZS5hMTAyPTU0NDtlLmExMDM9NTQ0O2UuYTEwND05MTA7ZS5hMTA2PTY2NztlLmExMDc9NzYwO2UuYTEwOD03NjA7ZS5hMTEyPTc3NjtlLmExMTE9NTk1O2UuYTExMD02OTQ7ZS5hMTA5PTYyNjtlLmExMjA9Nzg4O2UuYTEyMT03ODg7ZS5hMTIyPTc4ODtlLmExMjM9Nzg4O2UuYTEyND03ODg7ZS5hMTI1PTc4ODtlLmExMjY9Nzg4O2UuYTEyNz03ODg7ZS5hMTI4PTc4ODtlLmExMjk9Nzg4O2UuYTEzMD03ODg7ZS5hMTMxPTc4ODtlLmExMzI9Nzg4O2UuYTEzMz03ODg7ZS5hMTM0PTc4ODtlLmExMzU9Nzg4O2UuYTEzNj03ODg7ZS5hMTM3PTc4ODtlLmExMzg9Nzg4O2UuYTEzOT03ODg7ZS5hMTQwPTc4ODtlLmExNDE9Nzg4O2UuYTE0Mj03ODg7ZS5hMTQzPTc4ODtlLmExNDQ9Nzg4O2UuYTE0NT03ODg7ZS5hMTQ2PTc4ODtlLmExNDc9Nzg4O2UuYTE0OD03ODg7ZS5hMTQ5PTc4ODtlLmExNTA9Nzg4O2UuYTE1MT03ODg7ZS5hMTUyPTc4ODtlLmExNTM9Nzg4O2UuYTE1ND03ODg7ZS5hMTU1PTc4ODtlLmExNTY9Nzg4O2UuYTE1Nz03ODg7ZS5hMTU4PTc4ODtlLmExNTk9Nzg4O2UuYTE2MD04OTQ7ZS5hMTYxPTgzODtlLmExNjM9MTAxNjtlLmExNjQ9NDU4O2UuYTE5Nj03NDg7ZS5hMTY1PTkyNDtlLmExOTI9NzQ4O2UuYTE2Nj05MTg7ZS5hMTY3PTkyNztlLmExNjg9OTI4O2UuYTE2OT05Mjg7ZS5hMTcwPTgzNDtlLmExNzE9ODczO2UuYTE3Mj04Mjg7ZS5hMTczPTkyNDtlLmExNjI9OTI0O2UuYTE3ND05MTc7ZS5hMTc1PTkzMDtlLmExNzY9OTMxO2UuYTE3Nz00NjM7ZS5hMTc4PTg4MztlLmExNzk9ODM2O2UuYTE5Mz04MzY7ZS5hMTgwPTg2NztlLmExOTk9ODY3O2UuYTE4MT02OTY7ZS5hMjAwPTY5NjtlLmExODI9ODc0O2UuYTIwMT04NzQ7ZS5hMTgzPTc2MDtlLmExODQ9OTQ2O2UuYTE5Nz03NzE7ZS5hMTg1PTg2NTtlLmExOTQ9NzcxO2UuYTE5OD04ODg7ZS5hMTg2PTk2NztlLmExOTU9ODg4O2UuYTE4Nz04MzE7ZS5hMTg4PTg3MztlLmExODk9OTI3O2UuYTE5MD05NzA7ZS5hMTkxPTkxOH0pKX0pKSxxcj1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2UuQ291cmllcj17YXNjZW50OjYyOSxkZXNjZW50Oi0xNTcsY2FwSGVpZ2h0OjU2Mix4SGVpZ2h0Oi00MjZ9O2VbIkNvdXJpZXItQm9sZCJdPXthc2NlbnQ6NjI5LGRlc2NlbnQ6LTE1NyxjYXBIZWlnaHQ6NTYyLHhIZWlnaHQ6NDM5fTtlWyJDb3VyaWVyLU9ibGlxdWUiXT17YXNjZW50OjYyOSxkZXNjZW50Oi0xNTcsY2FwSGVpZ2h0OjU2Mix4SGVpZ2h0OjQyNn07ZVsiQ291cmllci1Cb2xkT2JsaXF1ZSJdPXthc2NlbnQ6NjI5LGRlc2NlbnQ6LTE1NyxjYXBIZWlnaHQ6NTYyLHhIZWlnaHQ6NDI2fTtlLkhlbHZldGljYT17YXNjZW50OjcxOCxkZXNjZW50Oi0yMDcsY2FwSGVpZ2h0OjcxOCx4SGVpZ2h0OjUyM307ZVsiSGVsdmV0aWNhLUJvbGQiXT17YXNjZW50OjcxOCxkZXNjZW50Oi0yMDcsY2FwSGVpZ2h0OjcxOCx4SGVpZ2h0OjUzMn07ZVsiSGVsdmV0aWNhLU9ibGlxdWUiXT17YXNjZW50OjcxOCxkZXNjZW50Oi0yMDcsY2FwSGVpZ2h0OjcxOCx4SGVpZ2h0OjUyM307ZVsiSGVsdmV0aWNhLUJvbGRPYmxpcXVlIl09e2FzY2VudDo3MTgsZGVzY2VudDotMjA3LGNhcEhlaWdodDo3MTgseEhlaWdodDo1MzJ9O2VbIlRpbWVzLVJvbWFuIl09e2FzY2VudDo2ODMsZGVzY2VudDotMjE3LGNhcEhlaWdodDo2NjIseEhlaWdodDo0NTB9O2VbIlRpbWVzLUJvbGQiXT17YXNjZW50OjY4MyxkZXNjZW50Oi0yMTcsY2FwSGVpZ2h0OjY3Nix4SGVpZ2h0OjQ2MX07ZVsiVGltZXMtSXRhbGljIl09e2FzY2VudDo2ODMsZGVzY2VudDotMjE3LGNhcEhlaWdodDo2NTMseEhlaWdodDo0NDF9O2VbIlRpbWVzLUJvbGRJdGFsaWMiXT17YXNjZW50OjY4MyxkZXNjZW50Oi0yMTcsY2FwSGVpZ2h0OjY2OSx4SGVpZ2h0OjQ2Mn07ZS5TeW1ib2w9e2FzY2VudDpNYXRoLk5hTixkZXNjZW50Ok1hdGguTmFOLGNhcEhlaWdodDpNYXRoLk5hTix4SGVpZ2h0Ok1hdGguTmFOfTtlLlphcGZEaW5nYmF0cz17YXNjZW50Ok1hdGguTmFOLGRlc2NlbnQ6TWF0aC5OYU4sY2FwSGVpZ2h0Ok1hdGguTmFOLHhIZWlnaHQ6TWF0aC5OYU59fSkpO2NsYXNzIEdseWZUYWJsZXtjb25zdHJ1Y3Rvcih7Z2x5ZlRhYmxlOmUsaXNHbHlwaExvY2F0aW9uc0xvbmc6dCxsb2NhVGFibGU6YSxudW1HbHlwaHM6cn0pe3RoaXMuZ2x5cGhzPVtdO2NvbnN0IGk9bmV3IERhdGFWaWV3KGEuYnVmZmVyLGEuYnl0ZU9mZnNldCxhLmJ5dGVMZW5ndGgpLG49bmV3IERhdGFWaWV3KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpLHM9dD80OjI7bGV0IG89dD9pLmdldFVpbnQzMigwKToyKmkuZ2V0VWludDE2KDApLGM9MDtmb3IobGV0IGU9MDtlPHI7ZSsrKXtjKz1zO2NvbnN0IGU9dD9pLmdldFVpbnQzMihjKToyKmkuZ2V0VWludDE2KGMpO2lmKGU9PT1vKXt0aGlzLmdseXBocy5wdXNoKG5ldyBHbHlwaCh7fSkpO2NvbnRpbnVlfWNvbnN0IGE9R2x5cGgucGFyc2UobyxuKTt0aGlzLmdseXBocy5wdXNoKGEpO289ZX19Z2V0U2l6ZSgpe3JldHVybiBNYXRoLnN1bVByZWNpc2UodGhpcy5nbHlwaHMubWFwKChlPT5lLmdldFNpemUoKSszJi00KSkpfXdyaXRlKCl7Y29uc3QgZT10aGlzLmdldFNpemUoKSx0PW5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoZSkpLGE9ZT4xMzEwNzAscj1hPzQ6MixpPW5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoKHRoaXMuZ2x5cGhzLmxlbmd0aCsxKSpyKSk7YT9pLnNldFVpbnQzMigwLDApOmkuc2V0VWludDE2KDAsMCk7bGV0IG49MCxzPTA7Zm9yKGNvbnN0IGUgb2YgdGhpcy5nbHlwaHMpe24rPWUud3JpdGUobix0KTtuPW4rMyYtNDtzKz1yO2E/aS5zZXRVaW50MzIocyxuKTppLnNldFVpbnQxNihzLG4+PjEpfXJldHVybntpc0xvY2F0aW9uTG9uZzphLGxvY2E6bmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIpLGdseWY6bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpfX1zY2FsZShlKXtmb3IobGV0IHQ9MCxhPXRoaXMuZ2x5cGhzLmxlbmd0aDt0PGE7dCsrKXRoaXMuZ2x5cGhzW3RdLnNjYWxlKGVbdF0pfX1jbGFzcyBHbHlwaHtjb25zdHJ1Y3Rvcih7aGVhZGVyOmU9bnVsbCxzaW1wbGU6dD1udWxsLGNvbXBvc2l0ZXM6YT1udWxsfSl7dGhpcy5oZWFkZXI9ZTt0aGlzLnNpbXBsZT10O3RoaXMuY29tcG9zaXRlcz1hfXN0YXRpYyBwYXJzZShlLHQpe2NvbnN0W2Escl09R2x5cGhIZWFkZXIucGFyc2UoZSx0KTtlKz1hO2lmKHIubnVtYmVyT2ZDb250b3VyczwwKXtjb25zdCBhPVtdO2Zvcig7Oyl7Y29uc3RbcixpXT1Db21wb3NpdGVHbHlwaC5wYXJzZShlLHQpO2UrPXI7YS5wdXNoKGkpO2lmKCEoMzImaS5mbGFncykpYnJlYWt9cmV0dXJuIG5ldyBHbHlwaCh7aGVhZGVyOnIsY29tcG9zaXRlczphfSl9Y29uc3QgaT1TaW1wbGVHbHlwaC5wYXJzZShlLHQsci5udW1iZXJPZkNvbnRvdXJzKTtyZXR1cm4gbmV3IEdseXBoKHtoZWFkZXI6cixzaW1wbGU6aX0pfWdldFNpemUoKXtpZighdGhpcy5oZWFkZXIpcmV0dXJuIDA7Y29uc3QgZT10aGlzLnNpbXBsZT90aGlzLnNpbXBsZS5nZXRTaXplKCk6TWF0aC5zdW1QcmVjaXNlKHRoaXMuY29tcG9zaXRlcy5tYXAoKGU9PmUuZ2V0U2l6ZSgpKSkpO3JldHVybiB0aGlzLmhlYWRlci5nZXRTaXplKCkrZX13cml0ZShlLHQpe2lmKCF0aGlzLmhlYWRlcilyZXR1cm4gMDtjb25zdCBhPWU7ZSs9dGhpcy5oZWFkZXIud3JpdGUoZSx0KTtpZih0aGlzLnNpbXBsZSllKz10aGlzLnNpbXBsZS53cml0ZShlLHQpO2Vsc2UgZm9yKGNvbnN0IGEgb2YgdGhpcy5jb21wb3NpdGVzKWUrPWEud3JpdGUoZSx0KTtyZXR1cm4gZS1hfXNjYWxlKGUpe2lmKCF0aGlzLmhlYWRlcilyZXR1cm47Y29uc3QgdD0odGhpcy5oZWFkZXIueE1pbit0aGlzLmhlYWRlci54TWF4KS8yO3RoaXMuaGVhZGVyLnNjYWxlKHQsZSk7aWYodGhpcy5zaW1wbGUpdGhpcy5zaW1wbGUuc2NhbGUodCxlKTtlbHNlIGZvcihjb25zdCBhIG9mIHRoaXMuY29tcG9zaXRlcylhLnNjYWxlKHQsZSl9fWNsYXNzIEdseXBoSGVhZGVye2NvbnN0cnVjdG9yKHtudW1iZXJPZkNvbnRvdXJzOmUseE1pbjp0LHlNaW46YSx4TWF4OnIseU1heDppfSl7dGhpcy5udW1iZXJPZkNvbnRvdXJzPWU7dGhpcy54TWluPXQ7dGhpcy55TWluPWE7dGhpcy54TWF4PXI7dGhpcy55TWF4PWl9c3RhdGljIHBhcnNlKGUsdCl7cmV0dXJuWzEwLG5ldyBHbHlwaEhlYWRlcih7bnVtYmVyT2ZDb250b3Vyczp0LmdldEludDE2KGUpLHhNaW46dC5nZXRJbnQxNihlKzIpLHlNaW46dC5nZXRJbnQxNihlKzQpLHhNYXg6dC5nZXRJbnQxNihlKzYpLHlNYXg6dC5nZXRJbnQxNihlKzgpfSldfWdldFNpemUoKXtyZXR1cm4gMTB9d3JpdGUoZSx0KXt0LnNldEludDE2KGUsdGhpcy5udW1iZXJPZkNvbnRvdXJzKTt0LnNldEludDE2KGUrMix0aGlzLnhNaW4pO3Quc2V0SW50MTYoZSs0LHRoaXMueU1pbik7dC5zZXRJbnQxNihlKzYsdGhpcy54TWF4KTt0LnNldEludDE2KGUrOCx0aGlzLnlNYXgpO3JldHVybiAxMH1zY2FsZShlLHQpe3RoaXMueE1pbj1NYXRoLnJvdW5kKGUrKHRoaXMueE1pbi1lKSp0KTt0aGlzLnhNYXg9TWF0aC5yb3VuZChlKyh0aGlzLnhNYXgtZSkqdCl9fWNsYXNzIENvbnRvdXJ7Y29uc3RydWN0b3Ioe2ZsYWdzOmUseENvb3JkaW5hdGVzOnQseUNvb3JkaW5hdGVzOmF9KXt0aGlzLnhDb29yZGluYXRlcz10O3RoaXMueUNvb3JkaW5hdGVzPWE7dGhpcy5mbGFncz1lfX1jbGFzcyBTaW1wbGVHbHlwaHtjb25zdHJ1Y3Rvcih7Y29udG91cnM6ZSxpbnN0cnVjdGlvbnM6dH0pe3RoaXMuY29udG91cnM9ZTt0aGlzLmluc3RydWN0aW9ucz10fXN0YXRpYyBwYXJzZShlLHQsYSl7Y29uc3Qgcj1bXTtmb3IobGV0IGk9MDtpPGE7aSsrKXtjb25zdCBhPXQuZ2V0VWludDE2KGUpO2UrPTI7ci5wdXNoKGEpfWNvbnN0IGk9clthLTFdKzEsbj10LmdldFVpbnQxNihlKTtlKz0yO2NvbnN0IHM9bmV3IFVpbnQ4QXJyYXkodCkuc2xpY2UoZSxlK24pO2UrPW47Y29uc3Qgbz1bXTtmb3IobGV0IGE9MDthPGk7ZSsrLGErKyl7bGV0IHI9dC5nZXRVaW50OChlKTtvLnB1c2gocik7aWYoOCZyKXtjb25zdCBpPXQuZ2V0VWludDgoKytlKTtyXj04O2ZvcihsZXQgZT0wO2U8aTtlKyspby5wdXNoKHIpO2ErPWl9fWNvbnN0IGM9W107bGV0IGw9W10saD1bXSx1PVtdO2NvbnN0IGQ9W107bGV0IGY9MCxnPTA7Zm9yKGxldCBhPTA7YTxpO2ErKyl7Y29uc3QgaT1vW2FdO2lmKDImaSl7Y29uc3QgYT10LmdldFVpbnQ4KGUrKyk7Zys9MTYmaT9hOi1hO2wucHVzaChnKX1lbHNlIGlmKDE2JmkpbC5wdXNoKGcpO2Vsc2V7Zys9dC5nZXRJbnQxNihlKTtlKz0yO2wucHVzaChnKX1pZihyW2ZdPT09YSl7ZisrO2MucHVzaChsKTtsPVtdfX1nPTA7Zj0wO2ZvcihsZXQgYT0wO2E8aTthKyspe2NvbnN0IGk9b1thXTtpZig0Jmkpe2NvbnN0IGE9dC5nZXRVaW50OChlKyspO2crPTMyJmk/YTotYTtoLnB1c2goZyl9ZWxzZSBpZigzMiZpKWgucHVzaChnKTtlbHNle2crPXQuZ2V0SW50MTYoZSk7ZSs9MjtoLnB1c2goZyl9dS5wdXNoKDEmaXw2NCZpKTtpZihyW2ZdPT09YSl7bD1jW2ZdO2YrKztkLnB1c2gobmV3IENvbnRvdXIoe2ZsYWdzOnUseENvb3JkaW5hdGVzOmwseUNvb3JkaW5hdGVzOmh9KSk7aD1bXTt1PVtdfX1yZXR1cm4gbmV3IFNpbXBsZUdseXBoKHtjb250b3VyczpkLGluc3RydWN0aW9uczpzfSl9Z2V0U2l6ZSgpe2xldCBlPTIqdGhpcy5jb250b3Vycy5sZW5ndGgrMit0aGlzLmluc3RydWN0aW9ucy5sZW5ndGgsdD0wLGE9MDtmb3IoY29uc3QgciBvZiB0aGlzLmNvbnRvdXJzKXtlKz1yLmZsYWdzLmxlbmd0aDtmb3IobGV0IGk9MCxuPXIueENvb3JkaW5hdGVzLmxlbmd0aDtpPG47aSsrKXtjb25zdCBuPXIueENvb3JkaW5hdGVzW2ldLHM9ci55Q29vcmRpbmF0ZXNbaV07bGV0IG89TWF0aC5hYnMobi10KTtvPjI1NT9lKz0yOm8+MCYmKGUrPTEpO3Q9bjtvPU1hdGguYWJzKHMtYSk7bz4yNTU/ZSs9MjpvPjAmJihlKz0xKTthPXN9fXJldHVybiBlfXdyaXRlKGUsdCl7Y29uc3QgYT1lLHI9W10saT1bXSxuPVtdO2xldCBzPTAsbz0wO2Zvcihjb25zdCBhIG9mIHRoaXMuY29udG91cnMpe2ZvcihsZXQgZT0wLHQ9YS54Q29vcmRpbmF0ZXMubGVuZ3RoO2U8dDtlKyspe2xldCB0PWEuZmxhZ3NbZV07Y29uc3QgYz1hLnhDb29yZGluYXRlc1tlXTtsZXQgbD1jLXM7aWYoMD09PWwpe3R8PTE2O3IucHVzaCgwKX1lbHNle2NvbnN0IGU9TWF0aC5hYnMobCk7aWYoZTw9MjU1KXt0fD1sPj0wPzE4OjI7ci5wdXNoKGUpfWVsc2Ugci5wdXNoKGwpfXM9Yztjb25zdCBoPWEueUNvb3JkaW5hdGVzW2VdO2w9aC1vO2lmKDA9PT1sKXt0fD0zMjtpLnB1c2goMCl9ZWxzZXtjb25zdCBlPU1hdGguYWJzKGwpO2lmKGU8PTI1NSl7dHw9bD49MD8zNjo0O2kucHVzaChlKX1lbHNlIGkucHVzaChsKX1vPWg7bi5wdXNoKHQpfXQuc2V0VWludDE2KGUsci5sZW5ndGgtMSk7ZSs9Mn10LnNldFVpbnQxNihlLHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCk7ZSs9MjtpZih0aGlzLmluc3RydWN0aW9ucy5sZW5ndGgpe25ldyBVaW50OEFycmF5KHQuYnVmZmVyLDAsdC5idWZmZXIuYnl0ZUxlbmd0aCkuc2V0KHRoaXMuaW5zdHJ1Y3Rpb25zLGUpO2UrPXRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aH1mb3IoY29uc3QgYSBvZiBuKXQuc2V0VWludDgoZSsrLGEpO2ZvcihsZXQgYT0wLGk9ci5sZW5ndGg7YTxpO2ErKyl7Y29uc3QgaT1yW2FdLHM9blthXTtpZigyJnMpdC5zZXRVaW50OChlKyssaSk7ZWxzZSBpZighKDE2JnMpKXt0LnNldEludDE2KGUsaSk7ZSs9Mn19Zm9yKGxldCBhPTAscj1pLmxlbmd0aDthPHI7YSsrKXtjb25zdCByPWlbYV0scz1uW2FdO2lmKDQmcyl0LnNldFVpbnQ4KGUrKyxyKTtlbHNlIGlmKCEoMzImcykpe3Quc2V0SW50MTYoZSxyKTtlKz0yfX1yZXR1cm4gZS1hfXNjYWxlKGUsdCl7Zm9yKGNvbnN0IGEgb2YgdGhpcy5jb250b3VycylpZigwIT09YS54Q29vcmRpbmF0ZXMubGVuZ3RoKWZvcihsZXQgcj0wLGk9YS54Q29vcmRpbmF0ZXMubGVuZ3RoO3I8aTtyKyspYS54Q29vcmRpbmF0ZXNbcl09TWF0aC5yb3VuZChlKyhhLnhDb29yZGluYXRlc1tyXS1lKSp0KX19Y2xhc3MgQ29tcG9zaXRlR2x5cGh7Y29uc3RydWN0b3Ioe2ZsYWdzOmUsZ2x5cGhJbmRleDp0LGFyZ3VtZW50MTphLGFyZ3VtZW50MjpyLHRyYW5zZjppLGluc3RydWN0aW9uczpufSl7dGhpcy5mbGFncz1lO3RoaXMuZ2x5cGhJbmRleD10O3RoaXMuYXJndW1lbnQxPWE7dGhpcy5hcmd1bWVudDI9cjt0aGlzLnRyYW5zZj1pO3RoaXMuaW5zdHJ1Y3Rpb25zPW59c3RhdGljIHBhcnNlKGUsdCl7Y29uc3QgYT1lLHI9W107bGV0IGk9dC5nZXRVaW50MTYoZSk7Y29uc3Qgbj10LmdldFVpbnQxNihlKzIpO2UrPTQ7bGV0IHMsbztpZigxJmkpe2lmKDImaSl7cz10LmdldEludDE2KGUpO289dC5nZXRJbnQxNihlKzIpfWVsc2V7cz10LmdldFVpbnQxNihlKTtvPXQuZ2V0VWludDE2KGUrMil9ZSs9NDtpXj0xfWVsc2V7aWYoMiZpKXtzPXQuZ2V0SW50OChlKTtvPXQuZ2V0SW50OChlKzEpfWVsc2V7cz10LmdldFVpbnQ4KGUpO289dC5nZXRVaW50OChlKzEpfWUrPTJ9aWYoOCZpKXtyLnB1c2godC5nZXRVaW50MTYoZSkpO2UrPTJ9ZWxzZSBpZig2NCZpKXtyLnB1c2godC5nZXRVaW50MTYoZSksdC5nZXRVaW50MTYoZSsyKSk7ZSs9NH1lbHNlIGlmKDEyOCZpKXtyLnB1c2godC5nZXRVaW50MTYoZSksdC5nZXRVaW50MTYoZSsyKSx0LmdldFVpbnQxNihlKzQpLHQuZ2V0VWludDE2KGUrNikpO2UrPTh9bGV0IGM9bnVsbDtpZigyNTYmaSl7Y29uc3QgYT10LmdldFVpbnQxNihlKTtlKz0yO2M9bmV3IFVpbnQ4QXJyYXkodCkuc2xpY2UoZSxlK2EpO2UrPWF9cmV0dXJuW2UtYSxuZXcgQ29tcG9zaXRlR2x5cGgoe2ZsYWdzOmksZ2x5cGhJbmRleDpuLGFyZ3VtZW50MTpzLGFyZ3VtZW50MjpvLHRyYW5zZjpyLGluc3RydWN0aW9uczpjfSldfWdldFNpemUoKXtsZXQgZT00KzIqdGhpcy50cmFuc2YubGVuZ3RoOzI1NiZ0aGlzLmZsYWdzJiYoZSs9Mit0aGlzLmluc3RydWN0aW9ucy5sZW5ndGgpO2UrPTI7MiZ0aGlzLmZsYWdzP3RoaXMuYXJndW1lbnQxPj0tMTI4JiZ0aGlzLmFyZ3VtZW50MTw9MTI3JiZ0aGlzLmFyZ3VtZW50Mj49LTEyOCYmdGhpcy5hcmd1bWVudDI8PTEyN3x8KGUrPTIpOnRoaXMuYXJndW1lbnQxPj0wJiZ0aGlzLmFyZ3VtZW50MTw9MjU1JiZ0aGlzLmFyZ3VtZW50Mj49MCYmdGhpcy5hcmd1bWVudDI8PTI1NXx8KGUrPTIpO3JldHVybiBlfXdyaXRlKGUsdCl7Y29uc3QgYT1lOzImdGhpcy5mbGFncz90aGlzLmFyZ3VtZW50MT49LTEyOCYmdGhpcy5hcmd1bWVudDE8PTEyNyYmdGhpcy5hcmd1bWVudDI+PS0xMjgmJnRoaXMuYXJndW1lbnQyPD0xMjd8fCh0aGlzLmZsYWdzfD0xKTp0aGlzLmFyZ3VtZW50MT49MCYmdGhpcy5hcmd1bWVudDE8PTI1NSYmdGhpcy5hcmd1bWVudDI+PTAmJnRoaXMuYXJndW1lbnQyPD0yNTV8fCh0aGlzLmZsYWdzfD0xKTt0LnNldFVpbnQxNihlLHRoaXMuZmxhZ3MpO3Quc2V0VWludDE2KGUrMix0aGlzLmdseXBoSW5kZXgpO2UrPTQ7aWYoMSZ0aGlzLmZsYWdzKXtpZigyJnRoaXMuZmxhZ3Mpe3Quc2V0SW50MTYoZSx0aGlzLmFyZ3VtZW50MSk7dC5zZXRJbnQxNihlKzIsdGhpcy5hcmd1bWVudDIpfWVsc2V7dC5zZXRVaW50MTYoZSx0aGlzLmFyZ3VtZW50MSk7dC5zZXRVaW50MTYoZSsyLHRoaXMuYXJndW1lbnQyKX1lKz00fWVsc2V7dC5zZXRVaW50OChlLHRoaXMuYXJndW1lbnQxKTt0LnNldFVpbnQ4KGUrMSx0aGlzLmFyZ3VtZW50Mik7ZSs9Mn1pZigyNTYmdGhpcy5mbGFncyl7dC5zZXRVaW50MTYoZSx0aGlzLmluc3RydWN0aW9ucy5sZW5ndGgpO2UrPTI7aWYodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoKXtuZXcgVWludDhBcnJheSh0LmJ1ZmZlciwwLHQuYnVmZmVyLmJ5dGVMZW5ndGgpLnNldCh0aGlzLmluc3RydWN0aW9ucyxlKTtlKz10aGlzLmluc3RydWN0aW9ucy5sZW5ndGh9fXJldHVybiBlLWF9c2NhbGUoZSx0KXt9fWZ1bmN0aW9uIHdyaXRlSW50MTYoZSx0LGEpe2VbdF09YT4+OCYyNTU7ZVt0KzFdPTI1NSZhfWZ1bmN0aW9uIHdyaXRlSW50MzIoZSx0LGEpe2VbdF09YT4+MjQmMjU1O2VbdCsxXT1hPj4xNiYyNTU7ZVt0KzJdPWE+PjgmMjU1O2VbdCszXT0yNTUmYX1mdW5jdGlvbiB3cml0ZURhdGEoZSx0LGEpe2lmKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KWUuc2V0KGEsdCk7ZWxzZSBpZigic3RyaW5nIj09dHlwZW9mIGEpZm9yKGxldCByPTAsaT1hLmxlbmd0aDtyPGk7cisrKWVbdCsrXT0yNTUmYS5jaGFyQ29kZUF0KHIpO2Vsc2UgZm9yKGNvbnN0IHIgb2YgYSllW3QrK109MjU1JnJ9Y2xhc3MgT3BlblR5cGVGaWxlQnVpbGRlcntjb25zdHJ1Y3RvcihlKXt0aGlzLnNmbnQ9ZTt0aGlzLnRhYmxlcz1PYmplY3QuY3JlYXRlKG51bGwpfXN0YXRpYyBnZXRTZWFyY2hQYXJhbXMoZSx0KXtsZXQgYT0xLHI9MDtmb3IoOyhhXmUpPmE7KXthPDw9MTtyKyt9Y29uc3QgaT1hKnQ7cmV0dXJue3JhbmdlOmksZW50cnk6cixyYW5nZVNoaWZ0OnQqZS1pfX10b0FycmF5KCl7bGV0IGU9dGhpcy5zZm50O2NvbnN0IHQ9dGhpcy50YWJsZXMsYT1PYmplY3Qua2V5cyh0KTthLnNvcnQoKTtjb25zdCByPWEubGVuZ3RoO2xldCBpLG4scyxvLGMsbD0xMisxNipyO2NvbnN0IGg9W2xdO2ZvcihpPTA7aTxyO2krKyl7bz10W2FbaV1dO2wrPShvLmxlbmd0aCszJi00KT4+PjA7aC5wdXNoKGwpfWNvbnN0IHU9bmV3IFVpbnQ4QXJyYXkobCk7Zm9yKGk9MDtpPHI7aSsrKXtvPXRbYVtpXV07d3JpdGVEYXRhKHUsaFtpXSxvKX0idHJ1ZSI9PT1lJiYoZT1zdHJpbmczMig2NTUzNikpO3VbMF09MjU1JmUuY2hhckNvZGVBdCgwKTt1WzFdPTI1NSZlLmNoYXJDb2RlQXQoMSk7dVsyXT0yNTUmZS5jaGFyQ29kZUF0KDIpO3VbM109MjU1JmUuY2hhckNvZGVBdCgzKTt3cml0ZUludDE2KHUsNCxyKTtjb25zdCBkPU9wZW5UeXBlRmlsZUJ1aWxkZXIuZ2V0U2VhcmNoUGFyYW1zKHIsMTYpO3dyaXRlSW50MTYodSw2LGQucmFuZ2UpO3dyaXRlSW50MTYodSw4LGQuZW50cnkpO3dyaXRlSW50MTYodSwxMCxkLnJhbmdlU2hpZnQpO2w9MTI7Zm9yKGk9MDtpPHI7aSsrKXtjPWFbaV07dVtsXT0yNTUmYy5jaGFyQ29kZUF0KDApO3VbbCsxXT0yNTUmYy5jaGFyQ29kZUF0KDEpO3VbbCsyXT0yNTUmYy5jaGFyQ29kZUF0KDIpO3VbbCszXT0yNTUmYy5jaGFyQ29kZUF0KDMpO2xldCBlPTA7Zm9yKG49aFtpXSxzPWhbaSsxXTtuPHM7bis9NCl7ZT1lK3JlYWRVaW50MzIodSxuKT4+PjB9d3JpdGVJbnQzMih1LGwrNCxlKTt3cml0ZUludDMyKHUsbCs4LGhbaV0pO3dyaXRlSW50MzIodSxsKzEyLHRbY10ubGVuZ3RoKTtsKz0xNn1yZXR1cm4gdX1hZGRUYWJsZShlLHQpe2lmKGUgaW4gdGhpcy50YWJsZXMpdGhyb3cgbmV3IEVycm9yKCJUYWJsZSAiK2UrIiBhbHJlYWR5IGV4aXN0cyIpO3RoaXMudGFibGVzW2VdPXR9fWNvbnN0IEhyPVs0XSxXcj1bNV0senI9WzZdLCRyPVs3XSxHcj1bOF0sVnI9WzEyLDM1XSxLcj1bMTRdLEpyPVsyMV0sWXI9WzIyXSxacj1bMzBdLFFyPVszMV07Y2xhc3MgVHlwZTFDaGFyU3RyaW5ne2NvbnN0cnVjdG9yKCl7dGhpcy53aWR0aD0wO3RoaXMubHNiPTA7dGhpcy5mbGV4aW5nPSExO3RoaXMub3V0cHV0PVtdO3RoaXMuc3RhY2s9W119Y29udmVydChlLHQsYSl7Y29uc3Qgcj1lLmxlbmd0aDtsZXQgaSxuLHMsbz0hMTtmb3IobGV0IGM9MDtjPHI7YysrKXtsZXQgcj1lW2NdO2lmKHI8MzIpezEyPT09ciYmKHI9KHI8PDgpK2VbKytjXSk7c3dpdGNoKHIpe2Nhc2UgMTpjYXNlIDM6Y2FzZSA5OmNhc2UgMzA3MjpjYXNlIDMwNzM6Y2FzZSAzMDc0OmNhc2UgMzEwNTp0aGlzLnN0YWNrPVtdO2JyZWFrO2Nhc2UgNDppZih0aGlzLmZsZXhpbmcpe2lmKHRoaXMuc3RhY2subGVuZ3RoPDEpe289ITA7YnJlYWt9Y29uc3QgZT10aGlzLnN0YWNrLnBvcCgpO3RoaXMuc3RhY2sucHVzaCgwLGUpO2JyZWFrfW89dGhpcy5leGVjdXRlQ29tbWFuZCgxLEhyKTticmVhaztjYXNlIDU6bz10aGlzLmV4ZWN1dGVDb21tYW5kKDIsV3IpO2JyZWFrO2Nhc2UgNjpvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoMSx6cik7YnJlYWs7Y2FzZSA3Om89dGhpcy5leGVjdXRlQ29tbWFuZCgxLCRyKTticmVhaztjYXNlIDg6bz10aGlzLmV4ZWN1dGVDb21tYW5kKDYsR3IpO2JyZWFrO2Nhc2UgMTA6aWYodGhpcy5zdGFjay5sZW5ndGg8MSl7bz0hMDticmVha31zPXRoaXMuc3RhY2sucG9wKCk7aWYoIXRbc10pe289ITA7YnJlYWt9bz10aGlzLmNvbnZlcnQodFtzXSx0LGEpO2JyZWFrO2Nhc2UgMTE6cmV0dXJuIG87Y2FzZSAxMzppZih0aGlzLnN0YWNrLmxlbmd0aDwyKXtvPSEwO2JyZWFrfWk9dGhpcy5zdGFjay5wb3AoKTtuPXRoaXMuc3RhY2sucG9wKCk7dGhpcy5sc2I9bjt0aGlzLndpZHRoPWk7dGhpcy5zdGFjay5wdXNoKGksbik7bz10aGlzLmV4ZWN1dGVDb21tYW5kKDIsWXIpO2JyZWFrO2Nhc2UgMTQ6dGhpcy5vdXRwdXQucHVzaChLclswXSk7YnJlYWs7Y2FzZSAyMTppZih0aGlzLmZsZXhpbmcpYnJlYWs7bz10aGlzLmV4ZWN1dGVDb21tYW5kKDIsSnIpO2JyZWFrO2Nhc2UgMjI6aWYodGhpcy5mbGV4aW5nKXt0aGlzLnN0YWNrLnB1c2goMCk7YnJlYWt9bz10aGlzLmV4ZWN1dGVDb21tYW5kKDEsWXIpO2JyZWFrO2Nhc2UgMzA6bz10aGlzLmV4ZWN1dGVDb21tYW5kKDQsWnIpO2JyZWFrO2Nhc2UgMzE6bz10aGlzLmV4ZWN1dGVDb21tYW5kKDQsUXIpO2JyZWFrO2Nhc2UgMzA3ODppZihhKXtjb25zdCBlPXRoaXMuc3RhY2suYXQoLTUpO3RoaXMuc2VhYz10aGlzLnN0YWNrLnNwbGljZSgtNCw0KTt0aGlzLnNlYWNbMF0rPXRoaXMubHNiLWU7bz10aGlzLmV4ZWN1dGVDb21tYW5kKDAsS3IpfWVsc2Ugbz10aGlzLmV4ZWN1dGVDb21tYW5kKDQsS3IpO2JyZWFrO2Nhc2UgMzA3OTppZih0aGlzLnN0YWNrLmxlbmd0aDw0KXtvPSEwO2JyZWFrfXRoaXMuc3RhY2sucG9wKCk7aT10aGlzLnN0YWNrLnBvcCgpO2NvbnN0IGU9dGhpcy5zdGFjay5wb3AoKTtuPXRoaXMuc3RhY2sucG9wKCk7dGhpcy5sc2I9bjt0aGlzLndpZHRoPWk7dGhpcy5zdGFjay5wdXNoKGksbixlKTtvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoMyxKcik7YnJlYWs7Y2FzZSAzMDg0OmlmKHRoaXMuc3RhY2subGVuZ3RoPDIpe289ITA7YnJlYWt9Y29uc3QgYz10aGlzLnN0YWNrLnBvcCgpLGw9dGhpcy5zdGFjay5wb3AoKTt0aGlzLnN0YWNrLnB1c2gobC9jKTticmVhaztjYXNlIDMwODg6aWYodGhpcy5zdGFjay5sZW5ndGg8Mil7bz0hMDticmVha31zPXRoaXMuc3RhY2sucG9wKCk7Y29uc3QgaD10aGlzLnN0YWNrLnBvcCgpO2lmKDA9PT1zJiYzPT09aCl7Y29uc3QgZT10aGlzLnN0YWNrLnNwbGljZSgtMTcsMTcpO3RoaXMuc3RhY2sucHVzaChlWzJdK2VbMF0sZVszXStlWzFdLGVbNF0sZVs1XSxlWzZdLGVbN10sZVs4XSxlWzldLGVbMTBdLGVbMTFdLGVbMTJdLGVbMTNdLGVbMTRdKTtvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoMTMsVnIsITApO3RoaXMuZmxleGluZz0hMTt0aGlzLnN0YWNrLnB1c2goZVsxNV0sZVsxNl0pfWVsc2UgMT09PXMmJjA9PT1oJiYodGhpcy5mbGV4aW5nPSEwKTticmVhaztjYXNlIDMwODk6YnJlYWs7ZGVmYXVsdDp3YXJuKCdVbmtub3duIHR5cGUgMSBjaGFyc3RyaW5nIGNvbW1hbmQgb2YgIicrcisnIicpfWlmKG8pYnJlYWt9ZWxzZXtyPD0yNDY/ci09MTM5OnI9cjw9MjUwPzI1Niooci0yNDcpK2VbKytjXSsxMDg6cjw9MjU0Py0yNTYqKHItMjUxKS1lWysrY10tMTA4OigyNTUmZVsrK2NdKTw8MjR8KDI1NSZlWysrY10pPDwxNnwoMjU1JmVbKytjXSk8PDh8MjU1JmVbKytjXTt0aGlzLnN0YWNrLnB1c2gocil9fXJldHVybiBvfWV4ZWN1dGVDb21tYW5kKGUsdCxhKXtjb25zdCByPXRoaXMuc3RhY2subGVuZ3RoO2lmKGU+cilyZXR1cm4hMDtjb25zdCBpPXItZTtmb3IobGV0IGU9aTtlPHI7ZSsrKXtsZXQgdD10aGlzLnN0YWNrW2VdO2lmKE51bWJlci5pc0ludGVnZXIodCkpdGhpcy5vdXRwdXQucHVzaCgyOCx0Pj44JjI1NSwyNTUmdCk7ZWxzZXt0PTY1NTM2KnR8MDt0aGlzLm91dHB1dC5wdXNoKDI1NSx0Pj4yNCYyNTUsdD4+MTYmMjU1LHQ+PjgmMjU1LDI1NSZ0KX19dGhpcy5vdXRwdXQucHVzaCguLi50KTthP3RoaXMuc3RhY2suc3BsaWNlKGksZSk6dGhpcy5zdGFjay5sZW5ndGg9MDtyZXR1cm4hMX19ZnVuY3Rpb24gaXNIZXhEaWdpdChlKXtyZXR1cm4gZT49NDgmJmU8PTU3fHxlPj02NSYmZTw9NzB8fGU+PTk3JiZlPD0xMDJ9ZnVuY3Rpb24gZGVjcnlwdChlLHQsYSl7aWYoYT49ZS5sZW5ndGgpcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO2xldCByLGksbj0wfHQ7Zm9yKHI9MDtyPGE7cisrKW49NTI4NDUqKGVbcl0rbikrMjI3MTkmNjU1MzU7Y29uc3Qgcz1lLmxlbmd0aC1hLG89bmV3IFVpbnQ4QXJyYXkocyk7Zm9yKHI9YSxpPTA7aTxzO3IrKyxpKyspe2NvbnN0IHQ9ZVtyXTtvW2ldPXRebj4+ODtuPTUyODQ1Kih0K24pKzIyNzE5JjY1NTM1fXJldHVybiBvfWZ1bmN0aW9uIGlzU3BlY2lhbChlKXtyZXR1cm4gNDc9PT1lfHw5MT09PWV8fDkzPT09ZXx8MTIzPT09ZXx8MTI1PT09ZXx8NDA9PT1lfHw0MT09PWV9Y2xhc3MgVHlwZTFQYXJzZXJ7Y29uc3RydWN0b3IoZSx0LGEpe2lmKHQpe2NvbnN0IHQ9ZS5nZXRCeXRlcygpLGE9ISgoaXNIZXhEaWdpdCh0WzBdKXx8aXNXaGl0ZVNwYWNlKHRbMF0pKSYmaXNIZXhEaWdpdCh0WzFdKSYmaXNIZXhEaWdpdCh0WzJdKSYmaXNIZXhEaWdpdCh0WzNdKSYmaXNIZXhEaWdpdCh0WzRdKSYmaXNIZXhEaWdpdCh0WzVdKSYmaXNIZXhEaWdpdCh0WzZdKSYmaXNIZXhEaWdpdCh0WzddKSk7ZT1uZXcgU3RyZWFtKGE/ZGVjcnlwdCh0LDU1NjY1LDQpOmZ1bmN0aW9uIGRlY3J5cHRBc2NpaShlLHQsYSl7bGV0IHI9MHx0O2NvbnN0IGk9ZS5sZW5ndGgsbj1uZXcgVWludDhBcnJheShpPj4+MSk7bGV0IHMsbztmb3Iocz0wLG89MDtzPGk7cysrKXtjb25zdCB0PWVbc107aWYoIWlzSGV4RGlnaXQodCkpY29udGludWU7cysrO2xldCBhO2Zvcig7czxpJiYhaXNIZXhEaWdpdChhPWVbc10pOylzKys7aWYoczxpKXtjb25zdCBlPXBhcnNlSW50KFN0cmluZy5mcm9tQ2hhckNvZGUodCxhKSwxNik7bltvKytdPWVecj4+ODtyPTUyODQ1KihlK3IpKzIyNzE5JjY1NTM1fX1yZXR1cm4gbi5zbGljZShhLG8pfSh0LDU1NjY1LDQpKX10aGlzLnNlYWNBbmFseXNpc0VuYWJsZWQ9ISFhO3RoaXMuc3RyZWFtPWU7dGhpcy5uZXh0Q2hhcigpfXJlYWROdW1iZXJBcnJheSgpe3RoaXMuZ2V0VG9rZW4oKTtjb25zdCBlPVtdO2Zvcig7Oyl7Y29uc3QgdD10aGlzLmdldFRva2VuKCk7aWYobnVsbD09PXR8fCJdIj09PXR8fCJ9Ij09PXQpYnJlYWs7ZS5wdXNoKHBhcnNlRmxvYXQodHx8MCkpfXJldHVybiBlfXJlYWROdW1iZXIoKXtjb25zdCBlPXRoaXMuZ2V0VG9rZW4oKTtyZXR1cm4gcGFyc2VGbG9hdChlfHwwKX1yZWFkSW50KCl7Y29uc3QgZT10aGlzLmdldFRva2VuKCk7cmV0dXJuIDB8cGFyc2VJbnQoZXx8MCwxMCl9cmVhZEJvb2xlYW4oKXtyZXR1cm4idHJ1ZSI9PT10aGlzLmdldFRva2VuKCk/MTowfW5leHRDaGFyKCl7cmV0dXJuIHRoaXMuY3VycmVudENoYXI9dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpfXByZXZDaGFyKCl7dGhpcy5zdHJlYW0uc2tpcCgtMik7cmV0dXJuIHRoaXMuY3VycmVudENoYXI9dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpfWdldFRva2VuKCl7bGV0IGU9ITEsdD10aGlzLmN1cnJlbnRDaGFyO2Zvcig7Oyl7aWYoLTE9PT10KXJldHVybiBudWxsO2lmKGUpMTAhPT10JiYxMyE9PXR8fChlPSExKTtlbHNlIGlmKDM3PT09dCllPSEwO2Vsc2UgaWYoIWlzV2hpdGVTcGFjZSh0KSlicmVhazt0PXRoaXMubmV4dENoYXIoKX1pZihpc1NwZWNpYWwodCkpe3RoaXMubmV4dENoYXIoKTtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0KX1sZXQgYT0iIjtkb3thKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO3Q9dGhpcy5uZXh0Q2hhcigpfXdoaWxlKHQ+PTAmJiFpc1doaXRlU3BhY2UodCkmJiFpc1NwZWNpYWwodCkpO3JldHVybiBhfXJlYWRDaGFyU3RyaW5ncyhlLHQpe3JldHVybi0xPT09dD9lOmRlY3J5cHQoZSw0MzMwLHQpfWV4dHJhY3RGb250UHJvZ3JhbShlKXtjb25zdCB0PXRoaXMuc3RyZWFtLGE9W10scj1bXSxpPU9iamVjdC5jcmVhdGUobnVsbCk7aS5sZW5JVj00O2NvbnN0IG49e3N1YnJzOltdLGNoYXJzdHJpbmdzOltdLHByb3BlcnRpZXM6e3ByaXZhdGVEYXRhOml9fTtsZXQgcyxvLGMsbDtmb3IoO251bGwhPT0ocz10aGlzLmdldFRva2VuKCkpOylpZigiLyI9PT1zKXtzPXRoaXMuZ2V0VG9rZW4oKTtzd2l0Y2gocyl7Y2FzZSJDaGFyU3RyaW5ncyI6dGhpcy5nZXRUb2tlbigpO3RoaXMuZ2V0VG9rZW4oKTt0aGlzLmdldFRva2VuKCk7dGhpcy5nZXRUb2tlbigpO2Zvcig7Oyl7cz10aGlzLmdldFRva2VuKCk7aWYobnVsbD09PXN8fCJlbmQiPT09cylicmVhaztpZigiLyIhPT1zKWNvbnRpbnVlO2NvbnN0IGU9dGhpcy5nZXRUb2tlbigpO289dGhpcy5yZWFkSW50KCk7dGhpcy5nZXRUb2tlbigpO2M9bz4wP3QuZ2V0Qnl0ZXMobyk6bmV3IFVpbnQ4QXJyYXkoMCk7bD1uLnByb3BlcnRpZXMucHJpdmF0ZURhdGEubGVuSVY7Y29uc3QgYT10aGlzLnJlYWRDaGFyU3RyaW5ncyhjLGwpO3RoaXMubmV4dENoYXIoKTtzPXRoaXMuZ2V0VG9rZW4oKTsibm9hY2Nlc3MiPT09cz90aGlzLmdldFRva2VuKCk6Ii8iPT09cyYmdGhpcy5wcmV2Q2hhcigpO3IucHVzaCh7Z2x5cGg6ZSxlbmNvZGVkOmF9KX1icmVhaztjYXNlIlN1YnJzIjp0aGlzLnJlYWRJbnQoKTt0aGlzLmdldFRva2VuKCk7Zm9yKDsiZHVwIj09PXRoaXMuZ2V0VG9rZW4oKTspe2NvbnN0IGU9dGhpcy5yZWFkSW50KCk7bz10aGlzLnJlYWRJbnQoKTt0aGlzLmdldFRva2VuKCk7Yz1vPjA/dC5nZXRCeXRlcyhvKTpuZXcgVWludDhBcnJheSgwKTtsPW4ucHJvcGVydGllcy5wcml2YXRlRGF0YS5sZW5JVjtjb25zdCByPXRoaXMucmVhZENoYXJTdHJpbmdzKGMsbCk7dGhpcy5uZXh0Q2hhcigpO3M9dGhpcy5nZXRUb2tlbigpOyJub2FjY2VzcyI9PT1zJiZ0aGlzLmdldFRva2VuKCk7YVtlXT1yfWJyZWFrO2Nhc2UiQmx1ZVZhbHVlcyI6Y2FzZSJPdGhlckJsdWVzIjpjYXNlIkZhbWlseUJsdWVzIjpjYXNlIkZhbWlseU90aGVyQmx1ZXMiOmNvbnN0IGU9dGhpcy5yZWFkTnVtYmVyQXJyYXkoKTtlLmxlbmd0aD4wJiZlLmxlbmd0aCwwO2JyZWFrO2Nhc2UiU3RlbVNuYXBIIjpjYXNlIlN0ZW1TbmFwViI6bi5wcm9wZXJ0aWVzLnByaXZhdGVEYXRhW3NdPXRoaXMucmVhZE51bWJlckFycmF5KCk7YnJlYWs7Y2FzZSJTdGRIVyI6Y2FzZSJTdGRWVyI6bi5wcm9wZXJ0aWVzLnByaXZhdGVEYXRhW3NdPXRoaXMucmVhZE51bWJlckFycmF5KClbMF07YnJlYWs7Y2FzZSJCbHVlU2hpZnQiOmNhc2UibGVuSVYiOmNhc2UiQmx1ZUZ1enoiOmNhc2UiQmx1ZVNjYWxlIjpjYXNlIkxhbmd1YWdlR3JvdXAiOm4ucHJvcGVydGllcy5wcml2YXRlRGF0YVtzXT10aGlzLnJlYWROdW1iZXIoKTticmVhaztjYXNlIkV4cGFuc2lvbkZhY3RvciI6bi5wcm9wZXJ0aWVzLnByaXZhdGVEYXRhW3NdPXRoaXMucmVhZE51bWJlcigpfHwuMDY7YnJlYWs7Y2FzZSJGb3JjZUJvbGQiOm4ucHJvcGVydGllcy5wcml2YXRlRGF0YVtzXT10aGlzLnJlYWRCb29sZWFuKCl9fWZvcihjb25zdHtlbmNvZGVkOnQsZ2x5cGg6aX1vZiByKXtjb25zdCByPW5ldyBUeXBlMUNoYXJTdHJpbmcscz1yLmNvbnZlcnQodCxhLHRoaXMuc2VhY0FuYWx5c2lzRW5hYmxlZCk7bGV0IG89ci5vdXRwdXQ7cyYmKG89WzE0XSk7Y29uc3QgYz17Z2x5cGhOYW1lOmksY2hhcnN0cmluZzpvLHdpZHRoOnIud2lkdGgsbHNiOnIubHNiLHNlYWM6ci5zZWFjfTsiLm5vdGRlZiI9PT1pP24uY2hhcnN0cmluZ3MudW5zaGlmdChjKTpuLmNoYXJzdHJpbmdzLnB1c2goYyk7aWYoZS5idWlsdEluRW5jb2Rpbmcpe2NvbnN0IHQ9ZS5idWlsdEluRW5jb2RpbmcuaW5kZXhPZihpKTt0Pi0xJiZ2b2lkIDA9PT1lLndpZHRoc1t0XSYmdD49ZS5maXJzdENoYXImJnQ8PWUubGFzdENoYXImJihlLndpZHRoc1t0XT1yLndpZHRoKX19cmV0dXJuIG59ZXh0cmFjdEZvbnRIZWFkZXIoZSl7bGV0IHQ7Zm9yKDtudWxsIT09KHQ9dGhpcy5nZXRUb2tlbigpKTspaWYoIi8iPT09dCl7dD10aGlzLmdldFRva2VuKCk7c3dpdGNoKHQpe2Nhc2UiRm9udE1hdHJpeCI6Y29uc3QgYT10aGlzLnJlYWROdW1iZXJBcnJheSgpO2UuZm9udE1hdHJpeD1hO2JyZWFrO2Nhc2UiRW5jb2RpbmciOmNvbnN0IHI9dGhpcy5nZXRUb2tlbigpO2xldCBpO2lmKC9eXGQrJC8udGVzdChyKSl7aT1bXTtjb25zdCBlPTB8cGFyc2VJbnQociwxMCk7dGhpcy5nZXRUb2tlbigpO2ZvcihsZXQgYT0wO2E8ZTthKyspe3Q9dGhpcy5nZXRUb2tlbigpO2Zvcig7ImR1cCIhPT10JiYiZGVmIiE9PXQ7KXt0PXRoaXMuZ2V0VG9rZW4oKTtpZihudWxsPT09dClyZXR1cm59aWYoImRlZiI9PT10KWJyZWFrO2NvbnN0IGU9dGhpcy5yZWFkSW50KCk7dGhpcy5nZXRUb2tlbigpO2NvbnN0IGE9dGhpcy5nZXRUb2tlbigpO2lbZV09YTt0aGlzLmdldFRva2VuKCl9fWVsc2UgaT1nZXRFbmNvZGluZyhyKTtlLmJ1aWx0SW5FbmNvZGluZz1pO2JyZWFrO2Nhc2UiRm9udEJCb3giOmNvbnN0IG49dGhpcy5yZWFkTnVtYmVyQXJyYXkoKTtlLmFzY2VudD1NYXRoLm1heChuWzNdLG5bMV0pO2UuZGVzY2VudD1NYXRoLm1pbihuWzFdLG5bM10pO2UuYXNjZW50U2NhbGVkPSEwfX19fWZ1bmN0aW9uIGZpbmRCbG9jayhlLHQsYSl7Y29uc3Qgcj1lLmxlbmd0aCxpPXQubGVuZ3RoLG49ci1pO2xldCBzPWEsbz0hMTtmb3IoO3M8bjspe2xldCBhPTA7Zm9yKDthPGkmJmVbcythXT09PXRbYV07KWErKztpZihhPj1pKXtzKz1hO2Zvcig7czxyJiZpc1doaXRlU3BhY2UoZVtzXSk7KXMrKztvPSEwO2JyZWFrfXMrK31yZXR1cm57Zm91bmQ6byxsZW5ndGg6c319Y2xhc3MgVHlwZTFGb250e2NvbnN0cnVjdG9yKGUsdCxhKXtsZXQgcj1hLmxlbmd0aDEsaT1hLmxlbmd0aDIsbj10LnBlZWtCeXRlcyg2KTtjb25zdCBzPTEyOD09PW5bMF0mJjE9PT1uWzFdO2lmKHMpe3Quc2tpcCg2KTtyPW5bNV08PDI0fG5bNF08PDE2fG5bM108PDh8blsyXX1jb25zdCBvPWZ1bmN0aW9uIGdldEhlYWRlckJsb2NrKGUsdCl7Y29uc3QgYT1bMTAxLDEwMSwxMjAsMTAxLDk5XSxyPWUucG9zO2xldCBpLG4scyxvO3RyeXtpPWUuZ2V0Qnl0ZXModCk7bj1pLmxlbmd0aH1jYXRjaHt9aWYobj09PXQpe3M9ZmluZEJsb2NrKGksYSx0LTIqYS5sZW5ndGgpO2lmKHMuZm91bmQmJnMubGVuZ3RoPT09dClyZXR1cm57c3RyZWFtOm5ldyBTdHJlYW0oaSksbGVuZ3RoOnR9fXdhcm4oJ0ludmFsaWQgIkxlbmd0aDEiIHByb3BlcnR5IGluIFR5cGUxIGZvbnQgLS0gdHJ5aW5nIHRvIHJlY292ZXIuJyk7ZS5wb3M9cjtmb3IoOzspe3M9ZmluZEJsb2NrKGUucGVla0J5dGVzKDIwNDgpLGEsMCk7aWYoMD09PXMubGVuZ3RoKWJyZWFrO2UucG9zKz1zLmxlbmd0aDtpZihzLmZvdW5kKXtvPWUucG9zLXI7YnJlYWt9fWUucG9zPXI7aWYobylyZXR1cm57c3RyZWFtOm5ldyBTdHJlYW0oZS5nZXRCeXRlcyhvKSksbGVuZ3RoOm99O3dhcm4oJ1VuYWJsZSB0byByZWNvdmVyICJMZW5ndGgxIiBwcm9wZXJ0eSBpbiBUeXBlMSBmb250IC0tIHVzaW5nIGFzIGlzLicpO3JldHVybntzdHJlYW06bmV3IFN0cmVhbShlLmdldEJ5dGVzKHQpKSxsZW5ndGg6dH19KHQscik7bmV3IFR5cGUxUGFyc2VyKG8uc3RyZWFtLCExLHByKS5leHRyYWN0Rm9udEhlYWRlcihhKTtpZihzKXtuPXQuZ2V0Qnl0ZXMoNik7aT1uWzVdPDwyNHxuWzRdPDwxNnxuWzNdPDw4fG5bMl19Y29uc3QgYz1mdW5jdGlvbiBnZXRFZXhlY0Jsb2NrKGUsdCl7Y29uc3QgYT1lLmdldEJ5dGVzKCk7aWYoMD09PWEubGVuZ3RoKXRocm93IG5ldyBGb3JtYXRFcnJvcigiZ2V0RWV4ZWNCbG9jayAtIG5vIGZvbnQgcHJvZ3JhbSBmb3VuZC4iKTtyZXR1cm57c3RyZWFtOm5ldyBTdHJlYW0oYSksbGVuZ3RoOmEubGVuZ3RofX0odCksbD1uZXcgVHlwZTFQYXJzZXIoYy5zdHJlYW0sITAscHIpLmV4dHJhY3RGb250UHJvZ3JhbShhKTtmb3IoY29uc3QgZSBpbiBsLnByb3BlcnRpZXMpYVtlXT1sLnByb3BlcnRpZXNbZV07Y29uc3QgaD1sLmNoYXJzdHJpbmdzLHU9dGhpcy5nZXRUeXBlMkNoYXJzdHJpbmdzKGgpLGQ9dGhpcy5nZXRUeXBlMlN1YnJzKGwuc3VicnMpO3RoaXMuY2hhcnN0cmluZ3M9aDt0aGlzLmRhdGE9dGhpcy53cmFwKGUsdSx0aGlzLmNoYXJzdHJpbmdzLGQsYSk7dGhpcy5zZWFjcz10aGlzLmdldFNlYWNzKGwuY2hhcnN0cmluZ3MpfWdldCBudW1HbHlwaHMoKXtyZXR1cm4gdGhpcy5jaGFyc3RyaW5ncy5sZW5ndGgrMX1nZXRDaGFyc2V0KCl7Y29uc3QgZT1bIi5ub3RkZWYiXTtmb3IoY29uc3R7Z2x5cGhOYW1lOnR9b2YgdGhpcy5jaGFyc3RyaW5ncyllLnB1c2godCk7cmV0dXJuIGV9Z2V0R2x5cGhNYXBwaW5nKGUpe2NvbnN0IHQ9dGhpcy5jaGFyc3RyaW5ncztpZihlLmNvbXBvc2l0ZSl7Y29uc3QgYT1PYmplY3QuY3JlYXRlKG51bGwpO2ZvcihsZXQgcj0wLGk9dC5sZW5ndGg7cjxpO3IrKyl7YVtlLmNNYXAuY2hhckNvZGVPZihyKV09cisxfXJldHVybiBhfWNvbnN0IGE9WyIubm90ZGVmIl07bGV0IHIsaTtmb3IoaT0wO2k8dC5sZW5ndGg7aSsrKWEucHVzaCh0W2ldLmdseXBoTmFtZSk7Y29uc3Qgbj1lLmJ1aWx0SW5FbmNvZGluZztpZihuKXtyPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGNvbnN0IGUgaW4gbil7aT1hLmluZGV4T2YobltlXSk7aT49MCYmKHJbZV09aSl9fXJldHVybiB0eXBlMUZvbnRHbHlwaE1hcHBpbmcoZSxyLGEpfWhhc0dseXBoSWQoZSl7aWYoZTwwfHxlPj10aGlzLm51bUdseXBocylyZXR1cm4hMTtpZigwPT09ZSlyZXR1cm4hMDtyZXR1cm4gdGhpcy5jaGFyc3RyaW5nc1tlLTFdLmNoYXJzdHJpbmcubGVuZ3RoPjB9Z2V0U2VhY3MoZSl7Y29uc3QgdD1bXTtmb3IobGV0IGE9MCxyPWUubGVuZ3RoO2E8cjthKyspe2NvbnN0IHI9ZVthXTtyLnNlYWMmJih0W2ErMV09ci5zZWFjKX1yZXR1cm4gdH1nZXRUeXBlMkNoYXJzdHJpbmdzKGUpe2NvbnN0IHQ9W107Zm9yKGNvbnN0IGEgb2YgZSl0LnB1c2goYS5jaGFyc3RyaW5nKTtyZXR1cm4gdH1nZXRUeXBlMlN1YnJzKGUpe2xldCB0PTA7Y29uc3QgYT1lLmxlbmd0aDt0PWE8MTEzMz8xMDc6YTwzMzc2OT8xMTMxOjMyNzY4O2NvbnN0IHI9W107bGV0IGk7Zm9yKGk9MDtpPHQ7aSsrKXIucHVzaChbMTFdKTtmb3IoaT0wO2k8YTtpKyspci5wdXNoKGVbaV0pO3JldHVybiByfXdyYXAoZSx0LGEscixpKXtjb25zdCBuPW5ldyBDRkY7bi5oZWFkZXI9bmV3IENGRkhlYWRlcigxLDAsNCw0KTtuLm5hbWVzPVtlXTtjb25zdCBzPW5ldyBDRkZUb3BEaWN0O3Muc2V0QnlOYW1lKCJ2ZXJzaW9uIiwzOTEpO3Muc2V0QnlOYW1lKCJOb3RpY2UiLDM5Mik7cy5zZXRCeU5hbWUoIkZ1bGxOYW1lIiwzOTMpO3Muc2V0QnlOYW1lKCJGYW1pbHlOYW1lIiwzOTQpO3Muc2V0QnlOYW1lKCJXZWlnaHQiLDM5NSk7cy5zZXRCeU5hbWUoIkVuY29kaW5nIixudWxsKTtzLnNldEJ5TmFtZSgiRm9udE1hdHJpeCIsaS5mb250TWF0cml4KTtzLnNldEJ5TmFtZSgiRm9udEJCb3giLGkuYmJveCk7cy5zZXRCeU5hbWUoImNoYXJzZXQiLG51bGwpO3Muc2V0QnlOYW1lKCJDaGFyU3RyaW5ncyIsbnVsbCk7cy5zZXRCeU5hbWUoIlByaXZhdGUiLG51bGwpO24udG9wRGljdD1zO2NvbnN0IG89bmV3IENGRlN0cmluZ3M7by5hZGQoIlZlcnNpb24gMC4xMSIpO28uYWRkKCJTZWUgb3JpZ2luYWwgbm90aWNlIik7by5hZGQoZSk7by5hZGQoZSk7by5hZGQoIk1lZGl1bSIpO24uc3RyaW5ncz1vO24uZ2xvYmFsU3VickluZGV4PW5ldyBDRkZJbmRleDtjb25zdCBjPXQubGVuZ3RoLGw9WyIubm90ZGVmIl07bGV0IGgsdTtmb3IoaD0wO2g8YztoKyspe2NvbnN0IGU9YVtoXS5nbHlwaE5hbWU7LTE9PT12ci5pbmRleE9mKGUpJiZvLmFkZChlKTtsLnB1c2goZSl9bi5jaGFyc2V0PW5ldyBDRkZDaGFyc2V0KCExLDAsbCk7Y29uc3QgZD1uZXcgQ0ZGSW5kZXg7ZC5hZGQoWzEzOSwxNF0pO2ZvcihoPTA7aDxjO2grKylkLmFkZCh0W2hdKTtuLmNoYXJTdHJpbmdzPWQ7Y29uc3QgZj1uZXcgQ0ZGUHJpdmF0ZURpY3Q7Zi5zZXRCeU5hbWUoIlN1YnJzIixudWxsKTtjb25zdCBnPVsiQmx1ZVZhbHVlcyIsIk90aGVyQmx1ZXMiLCJGYW1pbHlCbHVlcyIsIkZhbWlseU90aGVyQmx1ZXMiLCJTdGVtU25hcEgiLCJTdGVtU25hcFYiLCJCbHVlU2hpZnQiLCJCbHVlRnV6eiIsIkJsdWVTY2FsZSIsIkxhbmd1YWdlR3JvdXAiLCJFeHBhbnNpb25GYWN0b3IiLCJGb3JjZUJvbGQiLCJTdGRIVyIsIlN0ZFZXIl07Zm9yKGg9MCx1PWcubGVuZ3RoO2g8dTtoKyspe2NvbnN0IGU9Z1toXTtpZighKGUgaW4gaS5wcml2YXRlRGF0YSkpY29udGludWU7Y29uc3QgdD1pLnByaXZhdGVEYXRhW2VdO2lmKEFycmF5LmlzQXJyYXkodCkpZm9yKGxldCBlPXQubGVuZ3RoLTE7ZT4wO2UtLSl0W2VdLT10W2UtMV07Zi5zZXRCeU5hbWUoZSx0KX1uLnRvcERpY3QucHJpdmF0ZURpY3Q9Zjtjb25zdCBwPW5ldyBDRkZJbmRleDtmb3IoaD0wLHU9ci5sZW5ndGg7aDx1O2grKylwLmFkZChyW2hdKTtmLnN1YnJzSW5kZXg9cDtyZXR1cm4gbmV3IENGRkNvbXBpbGVyKG4pLmNvbXBpbGUoKX19Y29uc3QgZWk9W1s1NzM0NCw2Mzc0M10sWzEwNDg1NzYsMTExNDEwOV1dLHRpPTFlMyxhaT1bImFzY2VudCIsImJib3giLCJibGFjayIsImJvbGQiLCJjaGFyUHJvY09wZXJhdG9yTGlzdCIsImNzc0ZvbnRJbmZvIiwiZGF0YSIsImRlZmF1bHRWTWV0cmljcyIsImRlZmF1bHRXaWR0aCIsImRlc2NlbnQiLCJkaXNhYmxlRm9udEZhY2UiLCJmYWxsYmFja05hbWUiLCJmb250RXh0cmFQcm9wZXJ0aWVzIiwiZm9udE1hdHJpeCIsImlzSW52YWxpZFBERmpzRm9udCIsImlzVHlwZTNGb250IiwiaXRhbGljIiwibG9hZGVkTmFtZSIsIm1pbWV0eXBlIiwibWlzc2luZ0ZpbGUiLCJuYW1lIiwicmVtZWFzdXJlIiwic3lzdGVtRm9udEluZm8iLCJ2ZXJ0aWNhbCJdLHJpPVsiY01hcCIsImNvbXBvc2l0ZSIsImRlZmF1bHRFbmNvZGluZyIsImRpZmZlcmVuY2VzIiwiaXNNb25vc3BhY2UiLCJpc1NlcmlmRm9udCIsImlzU3ltYm9saWNGb250Iiwic2VhY01hcCIsInN1YnR5cGUiLCJ0b0ZvbnRDaGFyIiwidG9Vbmljb2RlIiwidHlwZSIsInZtZXRyaWNzIiwid2lkdGhzIl07ZnVuY3Rpb24gYWRqdXN0V2lkdGhzKGUpe2lmKCFlLmZvbnRNYXRyaXgpcmV0dXJuO2lmKGUuZm9udE1hdHJpeFswXT09PXRbMF0pcmV0dXJuO2NvbnN0IGE9LjAwMS9lLmZvbnRNYXRyaXhbMF0scj1lLndpZHRocztmb3IoY29uc3QgZSBpbiByKXJbZV0qPWE7ZS5kZWZhdWx0V2lkdGgqPWF9ZnVuY3Rpb24gYW1lbmRGYWxsYmFja1RvVW5pY29kZShlKXtpZighZS5mYWxsYmFja1RvVW5pY29kZSlyZXR1cm47aWYoZS50b1VuaWNvZGUgaW5zdGFuY2VvZiBJZGVudGl0eVRvVW5pY29kZU1hcClyZXR1cm47Y29uc3QgdD1bXTtmb3IoY29uc3QgYSBpbiBlLmZhbGxiYWNrVG9Vbmljb2RlKWUudG9Vbmljb2RlLmhhcyhhKXx8KHRbYV09ZS5mYWxsYmFja1RvVW5pY29kZVthXSk7dC5sZW5ndGg+MCYmZS50b1VuaWNvZGUuYW1lbmQodCl9Y2xhc3MgZm9udHNfR2x5cGh7Y29uc3RydWN0b3IoZSx0LGEscixpLG4scyxvLGMpe3RoaXMub3JpZ2luYWxDaGFyQ29kZT1lO3RoaXMuZm9udENoYXI9dDt0aGlzLnVuaWNvZGU9YTt0aGlzLmFjY2VudD1yO3RoaXMud2lkdGg9aTt0aGlzLnZtZXRyaWM9bjt0aGlzLm9wZXJhdG9yTGlzdElkPXM7dGhpcy5pc1NwYWNlPW87dGhpcy5pc0luRm9udD1jfWdldCBjYXRlZ29yeSgpe3JldHVybiBzaGFkb3codGhpcywiY2F0ZWdvcnkiLGZ1bmN0aW9uIGdldENoYXJVbmljb2RlQ2F0ZWdvcnkoZSl7Y29uc3QgdD1nci5nZXQoZSk7aWYodClyZXR1cm4gdDtjb25zdCBhPWUubWF0Y2goZnIpLHI9e2lzV2hpdGVzcGFjZTohIWE/LlsxXSxpc1plcm9XaWR0aERpYWNyaXRpYzohIWE/LlsyXSxpc0ludmlzaWJsZUZvcm1hdE1hcms6ISFhPy5bM119O2dyLnNldChlLHIpO3JldHVybiByfSh0aGlzLnVuaWNvZGUpLCEwKX19ZnVuY3Rpb24gaW50MTYoZSx0KXtyZXR1cm4oZTw8OCkrdH1mdW5jdGlvbiB3cml0ZVNpZ25lZEludDE2KGUsdCxhKXtlW3QrMV09YTtlW3RdPWE+Pj44fWZ1bmN0aW9uIHNpZ25lZEludDE2KGUsdCl7Y29uc3QgYT0oZTw8OCkrdDtyZXR1cm4gMzI3NjgmYT9hLTY1NTM2OmF9ZnVuY3Rpb24gc3RyaW5nMTYoZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZT4+OCYyNTUsMjU1JmUpfWZ1bmN0aW9uIHNhZmVTdHJpbmcxNihlKXtlPjMyNzY3P2U9MzI3Njc6ZTwtMzI3NjgmJihlPS0zMjc2OCk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZT4+OCYyNTUsMjU1JmUpfWZ1bmN0aW9uIGlzVHJ1ZVR5cGVDb2xsZWN0aW9uRmlsZShlKXtyZXR1cm4idHRjZiI9PT1ieXRlc1RvU3RyaW5nKGUucGVla0J5dGVzKDQpKX1mdW5jdGlvbiBnZXRGb250RmlsZVR5cGUoZSx7dHlwZTp0LHN1YnR5cGU6YSxjb21wb3NpdGU6cn0pe2xldCBpLG47aWYoZnVuY3Rpb24gaXNUcnVlVHlwZUZpbGUoZSl7Y29uc3QgdD1lLnBlZWtCeXRlcyg0KTtyZXR1cm4gNjU1MzY9PT1yZWFkVWludDMyKHQsMCl8fCJ0cnVlIj09PWJ5dGVzVG9TdHJpbmcodCl9KGUpfHxpc1RydWVUeXBlQ29sbGVjdGlvbkZpbGUoZSkpaT1yPyJDSURGb250VHlwZTIiOiJUcnVlVHlwZSI7ZWxzZSBpZihmdW5jdGlvbiBpc09wZW5UeXBlRmlsZShlKXtyZXR1cm4iT1RUTyI9PT1ieXRlc1RvU3RyaW5nKGUucGVla0J5dGVzKDQpKX0oZSkpaT1yPyJDSURGb250VHlwZTIiOiJPcGVuVHlwZSI7ZWxzZSBpZihmdW5jdGlvbiBpc1R5cGUxRmlsZShlKXtjb25zdCB0PWUucGVla0J5dGVzKDIpO3JldHVybiAzNz09PXRbMF0mJjMzPT09dFsxXXx8MTI4PT09dFswXSYmMT09PXRbMV19KGUpKWk9cj8iQ0lERm9udFR5cGUwIjoiTU1UeXBlMSI9PT10PyJNTVR5cGUxIjoiVHlwZTEiO2Vsc2UgaWYoZnVuY3Rpb24gaXNDRkZGaWxlKGUpe2NvbnN0IHQ9ZS5wZWVrQnl0ZXMoNCk7cmV0dXJuIHRbMF0+PTEmJnRbM10+PTEmJnRbM108PTR9KGUpKWlmKHIpe2k9IkNJREZvbnRUeXBlMCI7bj0iQ0lERm9udFR5cGUwQyJ9ZWxzZXtpPSJNTVR5cGUxIj09PXQ/Ik1NVHlwZTEiOiJUeXBlMSI7bj0iVHlwZTFDIn1lbHNle3dhcm4oImdldEZvbnRGaWxlVHlwZTogVW5hYmxlIHRvIGRldGVjdCBjb3JyZWN0IGZvbnQgZmlsZSBUeXBlL1N1YnR5cGUuIik7aT10O249YX1yZXR1cm5baSxuXX1mdW5jdGlvbiBhcHBseVN0YW5kYXJkRm9udEdseXBoTWFwKGUsdCl7Zm9yKGNvbnN0IGEgaW4gdCllWythXT10W2FdfWZ1bmN0aW9uIGJ1aWxkVG9Gb250Q2hhcihlLHQsYSl7Y29uc3Qgcj1bXTtsZXQgaTtmb3IobGV0IGE9MCxuPWUubGVuZ3RoO2E8bjthKyspe2k9Z2V0VW5pY29kZUZvckdseXBoKGVbYV0sdCk7LTEhPT1pJiYoclthXT1pKX1mb3IoY29uc3QgZSBpbiBhKXtpPWdldFVuaWNvZGVGb3JHbHlwaChhW2VdLHQpOy0xIT09aSYmKHJbK2VdPWkpfXJldHVybiByfWZ1bmN0aW9uIGlzTWFjTmFtZVJlY29yZChlKXtyZXR1cm4gMT09PWUucGxhdGZvcm0mJjA9PT1lLmVuY29kaW5nJiYwPT09ZS5sYW5ndWFnZX1mdW5jdGlvbiBpc1dpbk5hbWVSZWNvcmQoZSl7cmV0dXJuIDM9PT1lLnBsYXRmb3JtJiYxPT09ZS5lbmNvZGluZyYmMTAzMz09PWUubGFuZ3VhZ2V9ZnVuY3Rpb24gY29udmVydENpZFN0cmluZyhlLHQsYT0hMSl7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDE6cmV0dXJuIHQuY2hhckNvZGVBdCgwKTtjYXNlIDI6cmV0dXJuIHQuY2hhckNvZGVBdCgwKTw8OHx0LmNoYXJDb2RlQXQoMSl9Y29uc3Qgcj1gVW5zdXBwb3J0ZWQgQ0lEIHN0cmluZyAoY2hhckNvZGUgJHtlfSk6ICIke3R9Ii5gO2lmKGEpdGhyb3cgbmV3IEZvcm1hdEVycm9yKHIpO3dhcm4ocik7cmV0dXJuIHR9ZnVuY3Rpb24gYWRqdXN0TWFwcGluZyhlLHQsYSxyKXtjb25zdCBpPU9iamVjdC5jcmVhdGUobnVsbCksbj1uZXcgTWFwLHM9W10sbz1uZXcgU2V0O2xldCBjPTA7bGV0IGw9ZWlbY11bMF0saD1laVtjXVsxXTtsZXQgdT1udWxsO2Zvcihjb25zdCBmIGluIGUpe2xldCBnPWVbZl07aWYoIXQoZykpY29udGludWU7aWYobD5oKXtjKys7aWYoYz49ZWkubGVuZ3RoKXt3YXJuKCJSYW4gb3V0IG9mIHNwYWNlIGluIGZvbnQgcHJpdmF0ZSB1c2UgYXJlYS4iKTticmVha31sPWVpW2NdWzBdO2g9ZWlbY11bMV19Y29uc3QgcD1sKys7MD09PWcmJihnPWEpO2xldCBtPXIuZ2V0KGYpO2lmKCJzdHJpbmciPT10eXBlb2YgbSlpZigxPT09bS5sZW5ndGgpbT1tLmNvZGVQb2ludEF0KDApO2Vsc2V7aWYoIXUpe3U9bmV3IE1hcDtmb3IobGV0IGU9NjQyNTY7ZTw9NjQzMzU7ZSsrKXtjb25zdCB0PVN0cmluZy5mcm9tQ2hhckNvZGUoZSkubm9ybWFsaXplKCJORktEIik7dC5sZW5ndGg+MSYmdS5zZXQodCxlKX19bT11LmdldChtKXx8bS5jb2RlUG9pbnRBdCgwKX1pZihtJiYhKGQ9bSxlaVswXVswXTw9ZCYmZDw9ZWlbMF1bMV18fGVpWzFdWzBdPD1kJiZkPD1laVsxXVsxXSkmJiFvLmhhcyhnKSl7bi5zZXQobSxnKTtvLmFkZChnKX1pW3BdPWc7c1tmXT1wfXZhciBkO3JldHVybnt0b0ZvbnRDaGFyOnMsY2hhckNvZGVUb0dseXBoSWQ6aSx0b1VuaWNvZGVFeHRyYU1hcDpuLG5leHRBdmFpbGFibGVGb250Q2hhckNvZGU6bH19ZnVuY3Rpb24gY3JlYXRlQ21hcFRhYmxlKGUsdCxhKXtjb25zdCByPWZ1bmN0aW9uIGdldFJhbmdlcyhlLHQsYSl7Y29uc3Qgcj1bXTtmb3IoY29uc3QgdCBpbiBlKWVbdF0+PWF8fHIucHVzaCh7Zm9udENoYXJDb2RlOjB8dCxnbHlwaElkOmVbdF19KTtpZih0KWZvcihjb25zdFtlLGldb2YgdClpPj1hfHxyLnB1c2goe2ZvbnRDaGFyQ29kZTplLGdseXBoSWQ6aX0pOzA9PT1yLmxlbmd0aCYmci5wdXNoKHtmb250Q2hhckNvZGU6MCxnbHlwaElkOjB9KTtyLnNvcnQoKChlLHQpPT5lLmZvbnRDaGFyQ29kZS10LmZvbnRDaGFyQ29kZSkpO2NvbnN0IGk9W10sbj1yLmxlbmd0aDtmb3IobGV0IGU9MDtlPG47KXtjb25zdCB0PXJbZV0uZm9udENoYXJDb2RlLGE9W3JbZV0uZ2x5cGhJZF07KytlO2xldCBzPXQ7Zm9yKDtlPG4mJnMrMT09PXJbZV0uZm9udENoYXJDb2RlOyl7YS5wdXNoKHJbZV0uZ2x5cGhJZCk7KytzOysrZTtpZig2NTUzNT09PXMpYnJlYWt9aS5wdXNoKFt0LHMsYV0pfXJldHVybiBpfShlLHQsYSksaT1yLmF0KC0xKVsxXT42NTUzNT8yOjE7bGV0IG4scyxvLGMsbD0iXDBcMCIrc3RyaW5nMTYoaSkrIlwwA1wwASIrc3RyaW5nMzIoNCs4KmkpO2ZvcihuPXIubGVuZ3RoLTE7bj49MCYmIShyW25dWzBdPD02NTUzNSk7LS1uKTtjb25zdCBoPW4rMTtyW25dWzBdPDY1NTM1JiY2NTUzNT09PXJbbl1bMV0mJihyW25dWzFdPTY1NTM0KTtjb25zdCB1PXJbbl1bMV08NjU1MzU/MTowLGQ9aCt1LGY9T3BlblR5cGVGaWxlQnVpbGRlci5nZXRTZWFyY2hQYXJhbXMoZCwyKTtsZXQgZyxwLG0sYix5PSIiLHc9IiIseD0iIixTPSIiLGs9IiIsQz0wO2ZvcihuPTAscz1oO248cztuKyspe2c9cltuXTtwPWdbMF07bT1nWzFdO3krPXN0cmluZzE2KHApO3crPXN0cmluZzE2KG0pO2I9Z1syXTtsZXQgZT0hMDtmb3Iobz0xLGM9Yi5sZW5ndGg7bzxjOysrbylpZihiW29dIT09YltvLTFdKzEpe2U9ITE7YnJlYWt9aWYoZSl7eCs9c3RyaW5nMTYoYlswXS1wJjY1NTM1KTtTKz1zdHJpbmcxNigwKX1lbHNle2NvbnN0IGU9MiooZC1uKSsyKkM7Qys9bS1wKzE7eCs9c3RyaW5nMTYoMCk7Uys9c3RyaW5nMTYoZSk7Zm9yKG89MCxjPWIubGVuZ3RoO288YzsrK28pays9c3RyaW5nMTYoYltvXSl9fWlmKHU+MCl7dys9IsO/w78iO3krPSLDv8O/Ijt4Kz0iXDABIjtTKz0iXDBcMCJ9Y29uc3Qgdj0iXDBcMCIrc3RyaW5nMTYoMipkKStzdHJpbmcxNihmLnJhbmdlKStzdHJpbmcxNihmLmVudHJ5KStzdHJpbmcxNihmLnJhbmdlU2hpZnQpK3crIlwwXDAiK3kreCtTK2s7bGV0IEY9IiIsVD0iIjtpZihpPjEpe2wrPSJcMANcMFxuIitzdHJpbmczMig0KzgqaSs0K3YubGVuZ3RoKTtGPSIiO2ZvcihuPTAscz1yLmxlbmd0aDtuPHM7bisrKXtnPXJbbl07cD1nWzBdO2I9Z1syXTtsZXQgZT1iWzBdO2ZvcihvPTEsYz1iLmxlbmd0aDtvPGM7KytvKWlmKGJbb10hPT1iW28tMV0rMSl7bT1nWzBdK28tMTtGKz1zdHJpbmczMihwKStzdHJpbmczMihtKStzdHJpbmczMihlKTtwPW0rMTtlPWJbb119Ris9c3RyaW5nMzIocCkrc3RyaW5nMzIoZ1sxXSkrc3RyaW5nMzIoZSl9VD0iXDBcZlwwXDAiK3N0cmluZzMyKEYubGVuZ3RoKzE2KSsiXDBcMFwwXDAiK3N0cmluZzMyKEYubGVuZ3RoLzEyKX1yZXR1cm4gbCsiXDAEIitzdHJpbmcxNih2Lmxlbmd0aCs0KSt2K1QrRn1mdW5jdGlvbiBjcmVhdGVPUzJUYWJsZShlLHQsYSl7YXx8PXt1bml0c1BlckVtOjAseU1heDowLHlNaW46MCxhc2NlbnQ6MCxkZXNjZW50OjB9O2xldCByPTAsaT0wLG49MCxzPTAsbz1udWxsLGM9MCxsPS0xO2lmKHQpe2ZvcihsZXQgZSBpbiB0KXtlfD0wOyhvPmV8fCFvKSYmKG89ZSk7YzxlJiYoYz1lKTtsPWdldFVuaWNvZGVSYW5nZUZvcihlLGwpO2lmKGw8MzIpcnw9MTw8bDtlbHNlIGlmKGw8NjQpaXw9MTw8bC0zMjtlbHNlIGlmKGw8OTYpbnw9MTw8bC02NDtlbHNle2lmKCEobDwxMjMpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiVW5pY29kZSByYW5nZXMgQml0cyA+IDEyMyBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlIik7c3w9MTw8bC05Nn19Yz42NTUzNSYmKGM9NjU1MzUpfWVsc2V7bz0wO2M9MjU1fWNvbnN0IGg9ZS5iYm94fHxbMCwwLDAsMF0sdT1hLnVuaXRzUGVyRW18fChlLmZvbnRNYXRyaXg/MS9NYXRoLm1heCguLi5lLmZvbnRNYXRyaXguc2xpY2UoMCw0KS5tYXAoTWF0aC5hYnMpKToxZTMpLGQ9ZS5hc2NlbnRTY2FsZWQ/MTp1L3RpLGY9YS5hc2NlbnR8fE1hdGgucm91bmQoZCooZS5hc2NlbnR8fGhbM10pKTtsZXQgZz1hLmRlc2NlbnR8fE1hdGgucm91bmQoZCooZS5kZXNjZW50fHxoWzFdKSk7Zz4wJiZlLmRlc2NlbnQ+MCYmaFsxXTwwJiYoZz0tZyk7Y29uc3QgcD1hLnlNYXh8fGYsbT0tYS55TWlufHwtZztyZXR1cm4iXDADAiQBw7RcMAVcMFwwAsKKAsK7XDBcMFwwwowCwooCwrtcMFwwAcOfXHgwMDEBAlwwXDBcMFwwBiIrU3RyaW5nLmZyb21DaGFyQ29kZShlLmZpeGVkUGl0Y2g/OTowKSsiXDBcMFwwXDBcMFwwIitzdHJpbmczMihyKStzdHJpbmczMihpKStzdHJpbmczMihuKStzdHJpbmczMihzKSsiKjIxKiIrc3RyaW5nMTYoZS5pdGFsaWNBbmdsZT8xOjApK3N0cmluZzE2KG98fGUuZmlyc3RDaGFyKStzdHJpbmcxNihjfHxlLmxhc3RDaGFyKStzdHJpbmcxNihmKStzdHJpbmcxNihnKSsiXDBkIitzdHJpbmcxNihwKStzdHJpbmcxNihtKSsiXDBcMFwwXDBcMFwwXDBcMCIrc3RyaW5nMTYoZS54SGVpZ2h0KStzdHJpbmcxNihlLmNhcEhlaWdodCkrc3RyaW5nMTYoMCkrc3RyaW5nMTYob3x8ZS5maXJzdENoYXIpKyJcMAMifWZ1bmN0aW9uIGNyZWF0ZVBvc3RUYWJsZShlKXtyZXR1cm4iXDADXDBcMCIrc3RyaW5nMzIoTWF0aC5mbG9vcig2NTUzNiplLml0YWxpY0FuZ2xlKSkrIlwwXDBcMFwwIitzdHJpbmczMihlLmZpeGVkUGl0Y2g/MTowKSsiXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwXDAifWZ1bmN0aW9uIGNyZWF0ZVBvc3RzY3JpcHROYW1lKGUpe3JldHVybiBlLnJlcGxhY2VBbGwoL1teXHgyMS1ceDdFXXxbW1xdKCl7fTw+LyVdL2csIiIpLnNsaWNlKDAsNjMpfWZ1bmN0aW9uIGNyZWF0ZU5hbWVUYWJsZShlLHQpe3R8fCh0PVtbXSxbXV0pO2NvbnN0IGE9W3RbMF1bMF18fCJPcmlnaW5hbCBsaWNlbmNlIix0WzBdWzFdfHxlLHRbMF1bMl18fCJVbmtub3duIix0WzBdWzNdfHwidW5pcXVlSUQiLHRbMF1bNF18fGUsdFswXVs1XXx8IlZlcnNpb24gMC4xMSIsdFswXVs2XXx8Y3JlYXRlUG9zdHNjcmlwdE5hbWUoZSksdFswXVs3XXx8IlVua25vd24iLHRbMF1bOF18fCJVbmtub3duIix0WzBdWzldfHwiVW5rbm93biJdLHI9W107bGV0IGksbixzLG8sYztmb3IoaT0wLG49YS5sZW5ndGg7aTxuO2krKyl7Yz10WzFdW2ldfHxhW2ldO2NvbnN0IGU9W107Zm9yKHM9MCxvPWMubGVuZ3RoO3M8bztzKyspZS5wdXNoKHN0cmluZzE2KGMuY2hhckNvZGVBdChzKSkpO3IucHVzaChlLmpvaW4oIiIpKX1jb25zdCBsPVthLHJdLGg9WyJcMAEiLCJcMAMiXSx1PVsiXDBcMCIsIlwwASJdLGQ9WyJcMFwwIiwiBFx0Il0sZj1hLmxlbmd0aCpoLmxlbmd0aDtsZXQgZz0iXDBcMCIrc3RyaW5nMTYoZikrc3RyaW5nMTYoMTIqZis2KSxwPTA7Zm9yKGk9MCxuPWgubGVuZ3RoO2k8bjtpKyspe2NvbnN0IGU9bFtpXTtmb3Iocz0wLG89ZS5sZW5ndGg7czxvO3MrKyl7Yz1lW3NdO2crPWhbaV0rdVtpXStkW2ldK3N0cmluZzE2KHMpK3N0cmluZzE2KGMubGVuZ3RoKStzdHJpbmcxNihwKTtwKz1jLmxlbmd0aH19Zys9YS5qb2luKCIiKStyLmpvaW4oIiIpO3JldHVybiBnfWNsYXNzIEZvbnR7Y29uc3RydWN0b3IoZSx0LGEscil7dGhpcy5uYW1lPWU7dGhpcy5wc05hbWU9bnVsbDt0aGlzLm1pbWV0eXBlPW51bGw7dGhpcy5kaXNhYmxlRm9udEZhY2U9ci5kaXNhYmxlRm9udEZhY2U7dGhpcy5mb250RXh0cmFQcm9wZXJ0aWVzPXIuZm9udEV4dHJhUHJvcGVydGllczt0aGlzLmxvYWRlZE5hbWU9YS5sb2FkZWROYW1lO3RoaXMuaXNUeXBlM0ZvbnQ9YS5pc1R5cGUzRm9udDt0aGlzLm1pc3NpbmdGaWxlPSExO3RoaXMuY3NzRm9udEluZm89YS5jc3NGb250SW5mbzt0aGlzLl9jaGFyc0NhY2hlPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5fZ2x5cGhDYWNoZT1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBpPSEhKGEuZmxhZ3MmYnIpO2lmKCFpJiYhYS5pc1NpbXVsYXRlZEZsYWdzKXtjb25zdCB0PWUucmVwbGFjZUFsbCgvWyxfXS9nLCItIikuc3BsaXQoIi0iLDEpWzBdLGE9UHIoKTtmb3IoY29uc3QgZSBvZiB0LnNwbGl0KCIrIikpaWYoYVtlXSl7aT0hMDticmVha319dGhpcy5pc1NlcmlmRm9udD1pO3RoaXMuaXNTeW1ib2xpY0ZvbnQ9ISEoYS5mbGFncyZ5cik7dGhpcy5pc01vbm9zcGFjZT0hIShhLmZsYWdzJm1yKTtsZXR7dHlwZTpuLHN1YnR5cGU6c309YTt0aGlzLnR5cGU9bjt0aGlzLnN1YnR5cGU9czt0aGlzLnN5c3RlbUZvbnRJbmZvPWEuc3lzdGVtRm9udEluZm87Y29uc3Qgbz1lLm1hdGNoKC9eSW52YWxpZFBERmpzRm9udF8oLiopX1xkKyQvKTt0aGlzLmlzSW52YWxpZFBERmpzRm9udD0hIW87dGhpcy5pc0ludmFsaWRQREZqc0ZvbnQ/dGhpcy5mYWxsYmFja05hbWU9b1sxXTp0aGlzLmlzTW9ub3NwYWNlP3RoaXMuZmFsbGJhY2tOYW1lPSJtb25vc3BhY2UiOnRoaXMuaXNTZXJpZkZvbnQ/dGhpcy5mYWxsYmFja05hbWU9InNlcmlmIjp0aGlzLmZhbGxiYWNrTmFtZT0ic2Fucy1zZXJpZiI7aWYodGhpcy5zeXN0ZW1Gb250SW5mbz8uZ3Vlc3NGYWxsYmFjayl7dGhpcy5zeXN0ZW1Gb250SW5mby5ndWVzc0ZhbGxiYWNrPSExO3RoaXMuc3lzdGVtRm9udEluZm8uY3NzKz1gLCR7dGhpcy5mYWxsYmFja05hbWV9YH10aGlzLmRpZmZlcmVuY2VzPWEuZGlmZmVyZW5jZXM7dGhpcy53aWR0aHM9YS53aWR0aHM7dGhpcy5kZWZhdWx0V2lkdGg9YS5kZWZhdWx0V2lkdGg7dGhpcy5jb21wb3NpdGU9YS5jb21wb3NpdGU7dGhpcy5jTWFwPWEuY01hcDt0aGlzLmNhcEhlaWdodD1hLmNhcEhlaWdodC90aTt0aGlzLmFzY2VudD1hLmFzY2VudC90aTt0aGlzLmRlc2NlbnQ9YS5kZXNjZW50L3RpO3RoaXMubGluZUhlaWdodD10aGlzLmFzY2VudC10aGlzLmRlc2NlbnQ7dGhpcy5mb250TWF0cml4PWEuZm9udE1hdHJpeDt0aGlzLmJib3g9YS5iYm94O3RoaXMuZGVmYXVsdEVuY29kaW5nPWEuZGVmYXVsdEVuY29kaW5nO3RoaXMudG9Vbmljb2RlPWEudG9Vbmljb2RlO3RoaXMudG9Gb250Q2hhcj1bXTtpZigiVHlwZTMiPT09YS50eXBlKXtmb3IobGV0IGU9MDtlPDI1NjtlKyspdGhpcy50b0ZvbnRDaGFyW2VdPXRoaXMuZGlmZmVyZW5jZXNbZV18fGEuZGVmYXVsdEVuY29kaW5nW2VdO3JldHVybn10aGlzLmNpZEVuY29kaW5nPWEuY2lkRW5jb2Rpbmd8fCIiO3RoaXMudmVydGljYWw9ISFhLnZlcnRpY2FsO2lmKHRoaXMudmVydGljYWwpe3RoaXMudm1ldHJpY3M9YS52bWV0cmljczt0aGlzLmRlZmF1bHRWTWV0cmljcz1hLmRlZmF1bHRWTWV0cmljc31pZighdHx8dC5pc0VtcHR5KXt0JiZ3YXJuKCdGb250IGZpbGUgaXMgZW1wdHkgaW4gIicrZSsnIiAoJyt0aGlzLmxvYWRlZE5hbWUrIikiKTt0aGlzLmZhbGxiYWNrVG9TeXN0ZW1Gb250KGEpO3JldHVybn1bbixzXT1nZXRGb250RmlsZVR5cGUodCxhKTtuPT09dGhpcy50eXBlJiZzPT09dGhpcy5zdWJ0eXBlfHxpbmZvKGBJbmNvbnNpc3RlbnQgZm9udCBmaWxlIFR5cGUvU3ViVHlwZSwgZXhwZWN0ZWQ6ICR7dGhpcy50eXBlfS8ke3RoaXMuc3VidHlwZX0gYnV0IGZvdW5kOiAke259LyR7c30uYCk7bGV0IGM7dHJ5e3N3aXRjaChuKXtjYXNlIk1NVHlwZTEiOmluZm8oIk1NVHlwZTEgZm9udCAoIitlKyIpLCBmYWxsaW5nIGJhY2sgdG8gVHlwZTEuIik7Y2FzZSJUeXBlMSI6Y2FzZSJDSURGb250VHlwZTAiOnRoaXMubWltZXR5cGU9ImZvbnQvb3BlbnR5cGUiO2NvbnN0IHI9IlR5cGUxQyI9PT1zfHwiQ0lERm9udFR5cGUwQyI9PT1zP25ldyBDRkZGb250KHQsYSk6bmV3IFR5cGUxRm9udChlLHQsYSk7YWRqdXN0V2lkdGhzKGEpO2M9dGhpcy5jb252ZXJ0KGUscixhKTticmVhaztjYXNlIk9wZW5UeXBlIjpjYXNlIlRydWVUeXBlIjpjYXNlIkNJREZvbnRUeXBlMiI6dGhpcy5taW1ldHlwZT0iZm9udC9vcGVudHlwZSI7Yz10aGlzLmNoZWNrQW5kUmVwYWlyKGUsdCxhKTthZGp1c3RXaWR0aHMoYSk7dGhpcy5pc09wZW5UeXBlJiYobj0iT3BlblR5cGUiKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBGb3JtYXRFcnJvcihgRm9udCAke259IGlzIG5vdCBzdXBwb3J0ZWRgKX19Y2F0Y2goZSl7d2FybihlKTt0aGlzLmZhbGxiYWNrVG9TeXN0ZW1Gb250KGEpO3JldHVybn1hbWVuZEZhbGxiYWNrVG9Vbmljb2RlKGEpO3RoaXMuZGF0YT1jO3RoaXMudHlwZT1uO3RoaXMuc3VidHlwZT1zO3RoaXMuZm9udE1hdHJpeD1hLmZvbnRNYXRyaXg7dGhpcy53aWR0aHM9YS53aWR0aHM7dGhpcy5kZWZhdWx0V2lkdGg9YS5kZWZhdWx0V2lkdGg7dGhpcy50b1VuaWNvZGU9YS50b1VuaWNvZGU7dGhpcy5zZWFjTWFwPWEuc2VhY01hcH1nZXQgcmVuZGVyZXIoKXtyZXR1cm4gc2hhZG93KHRoaXMsInJlbmRlcmVyIixGb250UmVuZGVyZXJGYWN0b3J5LmNyZWF0ZSh0aGlzLHByKSl9ZXhwb3J0RGF0YSgpe2NvbnN0IGU9dGhpcy5mb250RXh0cmFQcm9wZXJ0aWVzP1suLi5haSwuLi5yaV06YWksdD1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdCBhIG9mIGUpe2NvbnN0IGU9dGhpc1thXTt2b2lkIDAhPT1lJiYodFthXT1lKX1yZXR1cm4gdH1mYWxsYmFja1RvU3lzdGVtRm9udChlKXt0aGlzLm1pc3NpbmdGaWxlPSEwO2NvbnN0e25hbWU6dCx0eXBlOmF9PXRoaXM7bGV0IHI9bm9ybWFsaXplRm9udE5hbWUodCk7Y29uc3QgaT1ScigpLG49RXIoKSxzPSEhaVtyXSxvPSEoIW5bcl18fCFpW25bcl1dKTtyPWlbcl18fG5bcl18fHI7Y29uc3QgYz1xcigpW3JdO2lmKGMpe2lzTmFOKHRoaXMuYXNjZW50KSYmKHRoaXMuYXNjZW50PWMuYXNjZW50L3RpKTtpc05hTih0aGlzLmRlc2NlbnQpJiYodGhpcy5kZXNjZW50PWMuZGVzY2VudC90aSk7aXNOYU4odGhpcy5jYXBIZWlnaHQpJiYodGhpcy5jYXBIZWlnaHQ9Yy5jYXBIZWlnaHQvdGkpfXRoaXMuYm9sZD0vYm9sZC9naS50ZXN0KHIpO3RoaXMuaXRhbGljPS9vYmxpcXVlfGl0YWxpYy9naS50ZXN0KHIpO3RoaXMuYmxhY2s9L0JsYWNrL2cudGVzdCh0KTtjb25zdCBsPS9OYXJyb3cvZy50ZXN0KHQpO3RoaXMucmVtZWFzdXJlPSghc3x8bCkmJk9iamVjdC5rZXlzKHRoaXMud2lkdGhzKS5sZW5ndGg+MDtpZigoc3x8bykmJiJDSURGb250VHlwZTIiPT09YSYmdGhpcy5jaWRFbmNvZGluZy5zdGFydHNXaXRoKCJJZGVudGl0eS0iKSl7Y29uc3QgYT1lLmNpZFRvR2lkTWFwLHI9W107YXBwbHlTdGFuZGFyZEZvbnRHbHlwaE1hcChyLGpyKCkpOy9BcmlhbC0/QmxhY2svaS50ZXN0KHQpP2FwcGx5U3RhbmRhcmRGb250R2x5cGhNYXAocixfcigpKTovQ2FsaWJyaS9pLnRlc3QodCkmJmFwcGx5U3RhbmRhcmRGb250R2x5cGhNYXAocixVcigpKTtpZihhKXtmb3IoY29uc3QgZSBpbiByKXtjb25zdCB0PXJbZV07dm9pZCAwIT09YVt0XSYmKHJbK2VdPWFbdF0pfWEubGVuZ3RoIT09dGhpcy50b1VuaWNvZGUubGVuZ3RoJiZlLmhhc0luY2x1ZGVkVG9Vbmljb2RlTWFwJiZ0aGlzLnRvVW5pY29kZSBpbnN0YW5jZW9mIElkZW50aXR5VG9Vbmljb2RlTWFwJiZ0aGlzLnRvVW5pY29kZS5mb3JFYWNoKChmdW5jdGlvbihlLHQpe2NvbnN0IGk9cltlXTt2b2lkIDA9PT1hW2ldJiYoclsrZV09dCl9KSl9dGhpcy50b1VuaWNvZGUgaW5zdGFuY2VvZiBJZGVudGl0eVRvVW5pY29kZU1hcHx8dGhpcy50b1VuaWNvZGUuZm9yRWFjaCgoZnVuY3Rpb24oZSx0KXtyWytlXT10fSkpO3RoaXMudG9Gb250Q2hhcj1yO3RoaXMudG9Vbmljb2RlPW5ldyBUb1VuaWNvZGVNYXAocil9ZWxzZSBpZigvU3ltYm9sL2kudGVzdChyKSl0aGlzLnRvRm9udENoYXI9YnVpbGRUb0ZvbnRDaGFyKG9yLGxyKCksdGhpcy5kaWZmZXJlbmNlcyk7ZWxzZSBpZigvRGluZ2JhdHMvaS50ZXN0KHIpKXRoaXMudG9Gb250Q2hhcj1idWlsZFRvRm9udENoYXIoY3IsaHIoKSx0aGlzLmRpZmZlcmVuY2VzKTtlbHNlIGlmKHN8fG8pe2NvbnN0IGU9YnVpbGRUb0ZvbnRDaGFyKHRoaXMuZGVmYXVsdEVuY29kaW5nLGxyKCksdGhpcy5kaWZmZXJlbmNlcyk7IkNJREZvbnRUeXBlMiIhPT1hfHx0aGlzLmNpZEVuY29kaW5nLnN0YXJ0c1dpdGgoIklkZW50aXR5LSIpfHx0aGlzLnRvVW5pY29kZSBpbnN0YW5jZW9mIElkZW50aXR5VG9Vbmljb2RlTWFwfHx0aGlzLnRvVW5pY29kZS5mb3JFYWNoKChmdW5jdGlvbih0LGEpe2VbK3RdPWF9KSk7dGhpcy50b0ZvbnRDaGFyPWV9ZWxzZXtjb25zdCBlPWxyKCksYT1bXTt0aGlzLnRvVW5pY29kZS5mb3JFYWNoKCgodCxyKT0+e2lmKCF0aGlzLmNvbXBvc2l0ZSl7Y29uc3QgYT1nZXRVbmljb2RlRm9yR2x5cGgodGhpcy5kaWZmZXJlbmNlc1t0XXx8dGhpcy5kZWZhdWx0RW5jb2RpbmdbdF0sZSk7LTEhPT1hJiYocj1hKX1hWyt0XT1yfSkpO3RoaXMuY29tcG9zaXRlJiZ0aGlzLnRvVW5pY29kZSBpbnN0YW5jZW9mIElkZW50aXR5VG9Vbmljb2RlTWFwJiYvVGFob21hfFZlcmRhbmEvaS50ZXN0KHQpJiZhcHBseVN0YW5kYXJkRm9udEdseXBoTWFwKGEsanIoKSk7dGhpcy50b0ZvbnRDaGFyPWF9YW1lbmRGYWxsYmFja1RvVW5pY29kZShlKTt0aGlzLmxvYWRlZE5hbWU9ci5zcGxpdCgiLSIsMSlbMF19Y2hlY2tBbmRSZXBhaXIoZSx0LGEpe2NvbnN0IHI9WyJPUy8yIiwiY21hcCIsImhlYWQiLCJoaGVhIiwiaG10eCIsIm1heHAiLCJuYW1lIiwicG9zdCIsImxvY2EiLCJnbHlmIiwiZnBnbSIsInByZXAiLCJjdnQgIiwiQ0ZGICJdO2Z1bmN0aW9uIHJlYWRUYWJsZXMoZSx0KXtjb25zdCBhPU9iamVjdC5jcmVhdGUobnVsbCk7YVsiT1MvMiJdPW51bGw7YS5jbWFwPW51bGw7YS5oZWFkPW51bGw7YS5oaGVhPW51bGw7YS5obXR4PW51bGw7YS5tYXhwPW51bGw7YS5uYW1lPW51bGw7YS5wb3N0PW51bGw7Zm9yKGxldCBpPTA7aTx0O2krKyl7Y29uc3QgdD1yZWFkVGFibGVFbnRyeShlKTtyLmluY2x1ZGVzKHQudGFnKSYmKDAhPT10Lmxlbmd0aCYmKGFbdC50YWddPXQpKX1yZXR1cm4gYX1mdW5jdGlvbiByZWFkVGFibGVFbnRyeShlKXtjb25zdCB0PWUuZ2V0U3RyaW5nKDQpLGE9ZS5nZXRJbnQzMigpPj4+MCxyPWUuZ2V0SW50MzIoKT4+PjAsaT1lLmdldEludDMyKCk+Pj4wLG49ZS5wb3M7ZS5wb3M9ZS5zdGFydHx8MDtlLnNraXAocik7Y29uc3Qgcz1lLmdldEJ5dGVzKGkpO2UucG9zPW47aWYoImhlYWQiPT09dCl7c1s4XT1zWzldPXNbMTBdPXNbMTFdPTA7c1sxN118PTMyfXJldHVybnt0YWc6dCxjaGVja3N1bTphLGxlbmd0aDppLG9mZnNldDpyLGRhdGE6c319ZnVuY3Rpb24gcmVhZE9wZW5UeXBlSGVhZGVyKGUpe3JldHVybnt2ZXJzaW9uOmUuZ2V0U3RyaW5nKDQpLG51bVRhYmxlczplLmdldFVpbnQxNigpLHNlYXJjaFJhbmdlOmUuZ2V0VWludDE2KCksZW50cnlTZWxlY3RvcjplLmdldFVpbnQxNigpLHJhbmdlU2hpZnQ6ZS5nZXRVaW50MTYoKX19ZnVuY3Rpb24gc2FuaXRpemVHbHlwaChlLHQsYSxyLGksbil7Y29uc3Qgcz17bGVuZ3RoOjAsc2l6ZU9mSW5zdHJ1Y3Rpb25zOjB9O2lmKHQ8MHx8dD49ZS5sZW5ndGh8fGE+ZS5sZW5ndGh8fGEtdDw9MTIpcmV0dXJuIHM7Y29uc3Qgbz1lLnN1YmFycmF5KHQsYSksYz1zaWduZWRJbnQxNihvWzJdLG9bM10pLGw9c2lnbmVkSW50MTYob1s0XSxvWzVdKSxoPXNpZ25lZEludDE2KG9bNl0sb1s3XSksdT1zaWduZWRJbnQxNihvWzhdLG9bOV0pO2lmKGM+aCl7d3JpdGVTaWduZWRJbnQxNihvLDIsaCk7d3JpdGVTaWduZWRJbnQxNihvLDYsYyl9aWYobD51KXt3cml0ZVNpZ25lZEludDE2KG8sNCx1KTt3cml0ZVNpZ25lZEludDE2KG8sOCxsKX1jb25zdCBkPXNpZ25lZEludDE2KG9bMF0sb1sxXSk7aWYoZDwwKXtpZihkPC0xKXJldHVybiBzO3Iuc2V0KG8saSk7cy5sZW5ndGg9by5sZW5ndGg7cmV0dXJuIHN9bGV0IGYsZz0xMCxwPTA7Zm9yKGY9MDtmPGQ7ZisrKXtwPShvW2ddPDw4fG9bZysxXSkrMTtnKz0yfWNvbnN0IG09ZyxiPW9bZ108PDh8b1tnKzFdO3Muc2l6ZU9mSW5zdHJ1Y3Rpb25zPWI7Zys9MitiO2NvbnN0IHk9ZztsZXQgdz0wO2ZvcihmPTA7ZjxwO2YrKyl7Y29uc3QgZT1vW2crK107MTkyJmUmJihvW2ctMV09NjMmZSk7bGV0IHQ9MjsyJmU/dD0xOjE2JmUmJih0PTApO2xldCBhPTI7NCZlP2E9MTozMiZlJiYoYT0wKTtjb25zdCByPXQrYTt3Kz1yO2lmKDgmZSl7Y29uc3QgZT1vW2crK107MD09PWUmJihvW2ctMV1ePTgpO2YrPWU7dys9ZSpyfX1pZigwPT09dylyZXR1cm4gcztsZXQgeD1nK3c7aWYoeD5vLmxlbmd0aClyZXR1cm4gcztpZighbiYmYj4wKXtyLnNldChvLnN1YmFycmF5KDAsbSksaSk7ci5zZXQoWzAsMF0saSttKTtyLnNldChvLnN1YmFycmF5KHkseCksaSttKzIpO3gtPWI7by5sZW5ndGgteD4zJiYoeD14KzMmLTQpO3MubGVuZ3RoPXg7cmV0dXJuIHN9aWYoby5sZW5ndGgteD4zKXt4PXgrMyYtNDtyLnNldChvLnN1YmFycmF5KDAseCksaSk7cy5sZW5ndGg9eDtyZXR1cm4gc31yLnNldChvLGkpO3MubGVuZ3RoPW8ubGVuZ3RoO3JldHVybiBzfWZ1bmN0aW9uIHJlYWROYW1lVGFibGUoZSl7Y29uc3QgYT0odC5zdGFydHx8MCkrZS5vZmZzZXQ7dC5wb3M9YTtjb25zdCByPVtbXSxbXV0saT1bXSxuPWUubGVuZ3RoLHM9YStuO2lmKDAhPT10LmdldFVpbnQxNigpfHxuPDYpcmV0dXJuW3IsaV07Y29uc3Qgbz10LmdldFVpbnQxNigpLGM9dC5nZXRVaW50MTYoKTtsZXQgbCxoO2ZvcihsPTA7bDxvJiZ0LnBvcysxMjw9cztsKyspe2NvbnN0IGU9e3BsYXRmb3JtOnQuZ2V0VWludDE2KCksZW5jb2Rpbmc6dC5nZXRVaW50MTYoKSxsYW5ndWFnZTp0LmdldFVpbnQxNigpLG5hbWU6dC5nZXRVaW50MTYoKSxsZW5ndGg6dC5nZXRVaW50MTYoKSxvZmZzZXQ6dC5nZXRVaW50MTYoKX07KGlzTWFjTmFtZVJlY29yZChlKXx8aXNXaW5OYW1lUmVjb3JkKGUpKSYmaS5wdXNoKGUpfWZvcihsPTAsaD1pLmxlbmd0aDtsPGg7bCsrKXtjb25zdCBlPWlbbF07aWYoZS5sZW5ndGg8PTApY29udGludWU7Y29uc3Qgbj1hK2MrZS5vZmZzZXQ7aWYobitlLmxlbmd0aD5zKWNvbnRpbnVlO3QucG9zPW47Y29uc3Qgbz1lLm5hbWU7aWYoZS5lbmNvZGluZyl7bGV0IGE9IiI7Zm9yKGxldCByPTAsaT1lLmxlbmd0aDtyPGk7cis9MilhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQuZ2V0VWludDE2KCkpO3JbMV1bb109YX1lbHNlIHJbMF1bb109dC5nZXRTdHJpbmcoZS5sZW5ndGgpfXJldHVybltyLGldfWNvbnN0IGk9WzAsMCwwLDAsMCwwLDAsMCwtMiwtMiwtMiwtMiwwLDAsLTIsLTUsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsMCwwLC0xLDAsLTEsLTEsLTEsLTEsMSwtMSwtOTk5LDAsMSwwLC0xLC0yLDAsLTEsLTIsLTEsLTEsMCwtMSwtMSwwLDAsLTk5OSwtOTk5LC0xLC0xLC0xLC0xLC0yLC05OTksLTIsLTIsLTk5OSwwLC0yLC0yLDAsMCwtMiwwLC0yLDAsMCwwLC0yLC0xLC0xLDEsMSwwLDAsLTEsLTEsLTEsLTEsLTEsLTEsLTEsMCwwLC0xLDAsLTEsLTEsMCwtOTk5LC0xLC0xLC0xLC0xLC0xLC0xLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLC0yLC05OTksLTk5OSwtOTk5LC05OTksLTk5OSwtMSwtMSwtMiwtMiwwLDAsMCwwLC0xLC0xLC05OTksLTIsLTIsMCwwLC0xLC0yLC0yLDAsMCwwLC0xLC0xLC0xLC0yXTtmdW5jdGlvbiBzYW5pdGl6ZVRUUHJvZ3JhbShlLHQpe2xldCBhLHIsbixzLG8sYz1lLmRhdGEsbD0wLGg9MCx1PTA7Y29uc3QgZD1bXSxmPVtdLGc9W107bGV0IHA9dC50b29Db21wbGV4VG9Gb2xsb3dGdW5jdGlvbnMsbT0hMSxiPTAseT0wO2ZvcihsZXQgZT1jLmxlbmd0aDtsPGU7KXtjb25zdCBlPWNbbCsrXTtpZig2ND09PWUpe3I9Y1tsKytdO2lmKG18fHkpbCs9cjtlbHNlIGZvcihhPTA7YTxyO2ErKylkLnB1c2goY1tsKytdKX1lbHNlIGlmKDY1PT09ZSl7cj1jW2wrK107aWYobXx8eSlsKz0yKnI7ZWxzZSBmb3IoYT0wO2E8cjthKyspe249Y1tsKytdO2QucHVzaChuPDw4fGNbbCsrXSl9fWVsc2UgaWYoMTc2PT0oMjQ4JmUpKXtyPWUtMTc2KzE7aWYobXx8eSlsKz1yO2Vsc2UgZm9yKGE9MDthPHI7YSsrKWQucHVzaChjW2wrK10pfWVsc2UgaWYoMTg0PT0oMjQ4JmUpKXtyPWUtMTg0KzE7aWYobXx8eSlsKz0yKnI7ZWxzZSBmb3IoYT0wO2E8cjthKyspe249Y1tsKytdO2QucHVzaChzaWduZWRJbnQxNihuLGNbbCsrXSkpfX1lbHNlIGlmKDQzIT09ZXx8cClpZig0NCE9PWV8fHApe2lmKDQ1PT09ZSlpZihtKXttPSExO2g9bH1lbHNle289Zi5wb3AoKTtpZighbyl7d2FybigiVFQ6IEVOREYgYmFkIHN0YWNrIik7dC5oaW50c1ZhbGlkPSExO3JldHVybn1zPWcucG9wKCk7Yz1vLmRhdGE7bD1vLmk7dC5mdW5jdGlvbnNTdGFja0RlbHRhc1tzXT1kLmxlbmd0aC1vLnN0YWNrVG9wfWVsc2UgaWYoMTM3PT09ZSl7aWYobXx8eSl7d2FybigiVFQ6IG5lc3RlZCBJREVGcyBub3QgYWxsb3dlZCIpO3A9ITB9bT0hMDt1PWx9ZWxzZSBpZig4OD09PWUpKytiO2Vsc2UgaWYoMjc9PT1lKXk9YjtlbHNlIGlmKDg5PT09ZSl7eT09PWImJih5PTApOy0tYn1lbHNlIGlmKDI4PT09ZSYmIW0mJiF5KXtjb25zdCBlPWQuYXQoLTEpO2U+MCYmKGwrPWUtMSl9fWVsc2V7aWYobXx8eSl7d2FybigiVFQ6IG5lc3RlZCBGREVGcyBub3QgYWxsb3dlZCIpO3A9ITB9bT0hMDt1PWw7cz1kLnBvcCgpO3QuZnVuY3Rpb25zRGVmaW5lZFtzXT17ZGF0YTpjLGk6bH19ZWxzZSBpZighbSYmIXkpe3M9ZC5hdCgtMSk7aWYoaXNOYU4ocykpaW5mbygiVFQ6IENBTEwgZW1wdHkgc3RhY2sgKG9yIGludmFsaWQgZW50cnkpLiIpO2Vsc2V7dC5mdW5jdGlvbnNVc2VkW3NdPSEwO2lmKHMgaW4gdC5mdW5jdGlvbnNTdGFja0RlbHRhcyl7Y29uc3QgZT1kLmxlbmd0aCt0LmZ1bmN0aW9uc1N0YWNrRGVsdGFzW3NdO2lmKGU8MCl7d2FybigiVFQ6IENBTEwgaW52YWxpZCBmdW5jdGlvbnMgc3RhY2sgZGVsdGEuIik7dC5oaW50c1ZhbGlkPSExO3JldHVybn1kLmxlbmd0aD1lfWVsc2UgaWYocyBpbiB0LmZ1bmN0aW9uc0RlZmluZWQmJiFnLmluY2x1ZGVzKHMpKXtmLnB1c2goe2RhdGE6YyxpOmwsc3RhY2tUb3A6ZC5sZW5ndGgtMX0pO2cucHVzaChzKTtvPXQuZnVuY3Rpb25zRGVmaW5lZFtzXTtpZighbyl7d2FybigiVFQ6IENBTEwgbm9uLWV4aXN0ZW50IGZ1bmN0aW9uIik7dC5oaW50c1ZhbGlkPSExO3JldHVybn1jPW8uZGF0YTtsPW8uaX19fWlmKCFtJiYheSl7bGV0IHQ9MDtlPD0xNDI/dD1pW2VdOmU+PTE5MiYmZTw9MjIzP3Q9LTE6ZT49MjI0JiYodD0tMik7aWYoZT49MTEzJiZlPD0xMTcpe3I9ZC5wb3AoKTtpc05hTihyKXx8KHQ9Miotcil9Zm9yKDt0PDAmJmQubGVuZ3RoPjA7KXtkLnBvcCgpO3QrK31mb3IoO3Q+MDspe2QucHVzaChOYU4pO3QtLX19fXQudG9vQ29tcGxleFRvRm9sbG93RnVuY3Rpb25zPXA7Y29uc3Qgdz1bY107bD5jLmxlbmd0aCYmdy5wdXNoKG5ldyBVaW50OEFycmF5KGwtYy5sZW5ndGgpKTtpZih1Pmgpe3dhcm4oIlRUOiBjb21wbGVtZW50aW5nIGEgbWlzc2luZyBmdW5jdGlvbiB0YWlsIik7dy5wdXNoKG5ldyBVaW50OEFycmF5KFszNCw0NV0pKX0hZnVuY3Rpb24gZm9sZFRUVGFibGUoZSx0KXtpZih0Lmxlbmd0aD4xKXtsZXQgYSxyLGk9MDtmb3IoYT0wLHI9dC5sZW5ndGg7YTxyO2ErKylpKz10W2FdLmxlbmd0aDtpPWkrMyYtNDtjb25zdCBuPW5ldyBVaW50OEFycmF5KGkpO2xldCBzPTA7Zm9yKGE9MCxyPXQubGVuZ3RoO2E8cjthKyspe24uc2V0KHRbYV0scyk7cys9dFthXS5sZW5ndGh9ZS5kYXRhPW47ZS5sZW5ndGg9aX19KGUsdyl9bGV0IG4scyxvLGM7aWYoaXNUcnVlVHlwZUNvbGxlY3Rpb25GaWxlKHQ9bmV3IFN0cmVhbShuZXcgVWludDhBcnJheSh0LmdldEJ5dGVzKCkpKSkpe2NvbnN0IGU9ZnVuY3Rpb24gcmVhZFRydWVUeXBlQ29sbGVjdGlvbkRhdGEoZSx0KXtjb25zdHtudW1Gb250czphLG9mZnNldFRhYmxlOnJ9PWZ1bmN0aW9uIHJlYWRUcnVlVHlwZUNvbGxlY3Rpb25IZWFkZXIoZSl7Y29uc3QgdD1lLmdldFN0cmluZyg0KTthc3NlcnQoInR0Y2YiPT09dCwiTXVzdCBiZSBhIFRydWVUeXBlIENvbGxlY3Rpb24gZm9udC4iKTtjb25zdCBhPWUuZ2V0VWludDE2KCkscj1lLmdldFVpbnQxNigpLGk9ZS5nZXRJbnQzMigpPj4+MCxuPVtdO2ZvcihsZXQgdD0wO3Q8aTt0Kyspbi5wdXNoKGUuZ2V0SW50MzIoKT4+PjApO2NvbnN0IHM9e3R0Y1RhZzp0LG1ham9yVmVyc2lvbjphLG1pbm9yVmVyc2lvbjpyLG51bUZvbnRzOmksb2Zmc2V0VGFibGU6bn07c3dpdGNoKGEpe2Nhc2UgMTpyZXR1cm4gcztjYXNlIDI6cy5kc2lnVGFnPWUuZ2V0SW50MzIoKT4+PjA7cy5kc2lnTGVuZ3RoPWUuZ2V0SW50MzIoKT4+PjA7cy5kc2lnT2Zmc2V0PWUuZ2V0SW50MzIoKT4+PjA7cmV0dXJuIHN9dGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIFRydWVUeXBlIENvbGxlY3Rpb24gbWFqb3JWZXJzaW9uOiAke2F9LmApfShlKSxpPXQuc3BsaXQoIisiKTtsZXQgbjtmb3IobGV0IHM9MDtzPGE7cysrKXtlLnBvcz0oZS5zdGFydHx8MCkrcltzXTtjb25zdCBhPXJlYWRPcGVuVHlwZUhlYWRlcihlKSxvPXJlYWRUYWJsZXMoZSxhLm51bVRhYmxlcyk7aWYoIW8ubmFtZSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoJ1RydWVUeXBlIENvbGxlY3Rpb24gZm9udCBtdXN0IGNvbnRhaW4gYSAibmFtZSIgdGFibGUuJyk7Y29uc3RbY109cmVhZE5hbWVUYWJsZShvLm5hbWUpO2ZvcihsZXQgZT0wLHI9Yy5sZW5ndGg7ZTxyO2UrKylmb3IobGV0IHI9MCxzPWNbZV0ubGVuZ3RoO3I8cztyKyspe2NvbnN0IHM9Y1tlXVtyXT8ucmVwbGFjZUFsbCgvXHMvZywiIik7aWYocyl7aWYocz09PXQpcmV0dXJue2hlYWRlcjphLHRhYmxlczpvfTtpZighKGkubGVuZ3RoPDIpKWZvcihjb25zdCBlIG9mIGkpcz09PWUmJihuPXtuYW1lOmUsaGVhZGVyOmEsdGFibGVzOm99KX19fWlmKG4pe3dhcm4oYFRydWVUeXBlIENvbGxlY3Rpb24gZG9lcyBub3QgY29udGFpbiAiJHt0fSIgZm9udCwgZmFsbGluZyBiYWNrIHRvICIke24ubmFtZX0iIGZvbnQgaW5zdGVhZC5gKTtyZXR1cm57aGVhZGVyOm4uaGVhZGVyLHRhYmxlczpuLnRhYmxlc319dGhyb3cgbmV3IEZvcm1hdEVycm9yKGBUcnVlVHlwZSBDb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gIiR7dH0iIGZvbnQuYCl9KHQsdGhpcy5uYW1lKTtuPWUuaGVhZGVyO3M9ZS50YWJsZXN9ZWxzZXtuPXJlYWRPcGVuVHlwZUhlYWRlcih0KTtzPXJlYWRUYWJsZXModCxuLm51bVRhYmxlcyl9Y29uc3QgbD0hc1siQ0ZGICJdO2lmKGwpe2lmKCFzLmxvY2EpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCdSZXF1aXJlZCAibG9jYSIgdGFibGUgaXMgbm90IGZvdW5kJyk7aWYoIXMuZ2x5Zil7d2FybignUmVxdWlyZWQgImdseWYiIHRhYmxlIGlzIG5vdCBmb3VuZCAtLSB0cnlpbmcgdG8gcmVjb3Zlci4nKTtzLmdseWY9e3RhZzoiZ2x5ZiIsZGF0YTpuZXcgVWludDhBcnJheSgwKX19dGhpcy5pc09wZW5UeXBlPSExfWVsc2V7Y29uc3QgdD1hLmNvbXBvc2l0ZSYmKGEuY2lkVG9HaWRNYXA/Lmxlbmd0aD4wfHwhKGEuY01hcCBpbnN0YW5jZW9mIElkZW50aXR5Q01hcCkpO2lmKCJPVFRPIj09PW4udmVyc2lvbiYmIXR8fCFzLmhlYWR8fCFzLmhoZWF8fCFzLm1heHB8fCFzLnBvc3Qpe2M9bmV3IFN0cmVhbShzWyJDRkYgIl0uZGF0YSk7bz1uZXcgQ0ZGRm9udChjLGEpO3JldHVybiB0aGlzLmNvbnZlcnQoZSxvLGEpfWRlbGV0ZSBzLmdseWY7ZGVsZXRlIHMubG9jYTtkZWxldGUgcy5mcGdtO2RlbGV0ZSBzLnByZXA7ZGVsZXRlIHNbImN2dCAiXTt0aGlzLmlzT3BlblR5cGU9ITB9aWYoIXMubWF4cCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoJ1JlcXVpcmVkICJtYXhwIiB0YWJsZSBpcyBub3QgZm91bmQnKTt0LnBvcz0odC5zdGFydHx8MCkrcy5tYXhwLm9mZnNldDtsZXQgaD10LmdldEludDMyKCk7Y29uc3QgdT10LmdldFVpbnQxNigpO2lmKDY1NTM2IT09aCYmMjA0ODAhPT1oKXtpZig2PT09cy5tYXhwLmxlbmd0aCloPTIwNDgwO2Vsc2V7aWYoIShzLm1heHAubGVuZ3RoPj0zMikpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCcibWF4cCIgdGFibGUgaGFzIGEgd3JvbmcgdmVyc2lvbiBudW1iZXInKTtoPTY1NTM2fSFmdW5jdGlvbiB3cml0ZVVpbnQzMihlLHQsYSl7ZVt0KzNdPTI1NSZhO2VbdCsyXT1hPj4+ODtlW3QrMV09YT4+PjE2O2VbdF09YT4+PjI0fShzLm1heHAuZGF0YSwwLGgpfWlmKGEuc2NhbGVGYWN0b3JzPy5sZW5ndGg9PT11JiZsKXtjb25zdHtzY2FsZUZhY3RvcnM6ZX09YSx0PWludDE2KHMuaGVhZC5kYXRhWzUwXSxzLmhlYWQuZGF0YVs1MV0pLHI9bmV3IEdseWZUYWJsZSh7Z2x5ZlRhYmxlOnMuZ2x5Zi5kYXRhLGlzR2x5cGhMb2NhdGlvbnNMb25nOnQsbG9jYVRhYmxlOnMubG9jYS5kYXRhLG51bUdseXBoczp1fSk7ci5zY2FsZShlKTtjb25zdHtnbHlmOmksbG9jYTpuLGlzTG9jYXRpb25Mb25nOm99PXIud3JpdGUoKTtzLmdseWYuZGF0YT1pO3MubG9jYS5kYXRhPW47aWYobyE9PSEhdCl7cy5oZWFkLmRhdGFbNTBdPTA7cy5oZWFkLmRhdGFbNTFdPW8/MTowfWNvbnN0IGM9cy5obXR4LmRhdGE7Zm9yKGxldCB0PTA7dDx1O3QrKyl7Y29uc3QgYT00KnQscj1NYXRoLnJvdW5kKGVbdF0qaW50MTYoY1thXSxjW2ErMV0pKTtjW2FdPXI+PjgmMjU1O2NbYSsxXT0yNTUmcjt3cml0ZVNpZ25lZEludDE2KGMsYSsyLE1hdGgucm91bmQoZVt0XSpzaWduZWRJbnQxNihjW2ErMl0sY1thKzNdKSkpfX1sZXQgZD11KzEsZj0hMDtpZihkPjY1NTM1KXtmPSExO2Q9dTt3YXJuKCJOb3QgZW5vdWdoIHNwYWNlIGluIGdseWZzIHRvIGR1cGxpY2F0ZSBmaXJzdCBnbHlwaC4iKX1sZXQgZz0wLHA9MDtpZihoPj02NTUzNiYmcy5tYXhwLmxlbmd0aD49MzIpe3QucG9zKz04O2lmKHQuZ2V0VWludDE2KCk+Mil7cy5tYXhwLmRhdGFbMTRdPTA7cy5tYXhwLmRhdGFbMTVdPTJ9dC5wb3MrPTQ7Zz10LmdldFVpbnQxNigpO3QucG9zKz00O3A9dC5nZXRVaW50MTYoKX1zLm1heHAuZGF0YVs0XT1kPj44O3MubWF4cC5kYXRhWzVdPTI1NSZkO2NvbnN0IG09ZnVuY3Rpb24gc2FuaXRpemVUVFByb2dyYW1zKGUsdCxhLHIpe2NvbnN0IGk9e2Z1bmN0aW9uc0RlZmluZWQ6W10sZnVuY3Rpb25zVXNlZDpbXSxmdW5jdGlvbnNTdGFja0RlbHRhczpbXSx0b29Db21wbGV4VG9Gb2xsb3dGdW5jdGlvbnM6ITEsaGludHNWYWxpZDohMH07ZSYmc2FuaXRpemVUVFByb2dyYW0oZSxpKTt0JiZzYW5pdGl6ZVRUUHJvZ3JhbSh0LGkpO2UmJmZ1bmN0aW9uIGNoZWNrSW52YWxpZEZ1bmN0aW9ucyhlLHQpe2lmKCFlLnRvb0NvbXBsZXhUb0ZvbGxvd0Z1bmN0aW9ucylpZihlLmZ1bmN0aW9uc0RlZmluZWQubGVuZ3RoPnQpe3dhcm4oIlRUOiBtb3JlIGZ1bmN0aW9ucyBkZWZpbmVkIHRoYW4gZXhwZWN0ZWQiKTtlLmhpbnRzVmFsaWQ9ITF9ZWxzZSBmb3IobGV0IGE9MCxyPWUuZnVuY3Rpb25zVXNlZC5sZW5ndGg7YTxyO2ErKyl7aWYoYT50KXt3YXJuKCJUVDogaW52YWxpZCBmdW5jdGlvbiBpZDogIithKTtlLmhpbnRzVmFsaWQ9ITE7cmV0dXJufWlmKGUuZnVuY3Rpb25zVXNlZFthXSYmIWUuZnVuY3Rpb25zRGVmaW5lZFthXSl7d2FybigiVFQ6IHVuZGVmaW5lZCBmdW5jdGlvbjogIithKTtlLmhpbnRzVmFsaWQ9ITE7cmV0dXJufX19KGkscik7aWYoYSYmMSZhLmxlbmd0aCl7Y29uc3QgZT1uZXcgVWludDhBcnJheShhLmxlbmd0aCsxKTtlLnNldChhLmRhdGEpO2EuZGF0YT1lfXJldHVybiBpLmhpbnRzVmFsaWR9KHMuZnBnbSxzLnByZXAsc1siY3Z0ICJdLGcpO2lmKCFtKXtkZWxldGUgcy5mcGdtO2RlbGV0ZSBzLnByZXA7ZGVsZXRlIHNbImN2dCAiXX0hZnVuY3Rpb24gc2FuaXRpemVNZXRyaWNzKGUsdCxhLHIsaSxuKXtpZighdCl7YSYmKGEuZGF0YT1udWxsKTtyZXR1cm59ZS5wb3M9KGUuc3RhcnR8fDApK3Qub2Zmc2V0O2UucG9zKz00O2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2UucG9zKz0yO2NvbnN0IHM9ZS5nZXRVaW50MTYoKTtlLnBvcys9ODtlLnBvcys9MjtsZXQgbz1lLmdldFVpbnQxNigpO2lmKDAhPT1zKXtpZighKDImaW50MTYoci5kYXRhWzQ0XSxyLmRhdGFbNDVdKSkpe3QuZGF0YVsyMl09MDt0LmRhdGFbMjNdPTB9fWlmKG8+aSl7aW5mbyhgVGhlIG51bU9mTWV0cmljcyAoJHtvfSkgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bUdseXBocyAoJHtpfSkuYCk7bz1pO3QuZGF0YVszNF09KDY1MjgwJm8pPj44O3QuZGF0YVszNV09MjU1Jm99Y29uc3QgYz1pLW8tKGEubGVuZ3RoLTQqbz4+MSk7aWYoYz4wKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KGEubGVuZ3RoKzIqYyk7ZS5zZXQoYS5kYXRhKTtpZihuKXtlW2EubGVuZ3RoXT1hLmRhdGFbMl07ZVthLmxlbmd0aCsxXT1hLmRhdGFbM119YS5kYXRhPWV9fSh0LHMuaGhlYSxzLmhtdHgscy5oZWFkLGQsZik7aWYoIXMuaGVhZCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoJ1JlcXVpcmVkICJoZWFkIiB0YWJsZSBpcyBub3QgZm91bmQnKTshZnVuY3Rpb24gc2FuaXRpemVIZWFkKGUsdCxhKXtjb25zdCByPWUuZGF0YSxpPWZ1bmN0aW9uIGludDMyKGUsdCxhLHIpe3JldHVybihlPDwyNCkrKHQ8PDE2KSsoYTw8OCkrcn0oclswXSxyWzFdLHJbMl0sclszXSk7aWYoaT4+MTYhPTEpe2luZm8oIkF0dGVtcHRpbmcgdG8gZml4IGludmFsaWQgdmVyc2lvbiBpbiBoZWFkIHRhYmxlOiAiK2kpO3JbMF09MDtyWzFdPTE7clsyXT0wO3JbM109MH1jb25zdCBuPWludDE2KHJbNTBdLHJbNTFdKTtpZihuPDB8fG4+MSl7aW5mbygiQXR0ZW1wdGluZyB0byBmaXggaW52YWxpZCBpbmRleFRvTG9jRm9ybWF0IGluIGhlYWQgdGFibGU6ICIrbik7Y29uc3QgZT10KzE7aWYoYT09PWU8PDEpe3JbNTBdPTA7cls1MV09MH1lbHNle2lmKGEhPT1lPDwyKXRocm93IG5ldyBGb3JtYXRFcnJvcigiQ291bGQgbm90IGZpeCBpbmRleFRvTG9jRm9ybWF0OiAiK24pO3JbNTBdPTA7cls1MV09MX19fShzLmhlYWQsdSxsP3MubG9jYS5sZW5ndGg6MCk7bGV0IGI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihsKXtjb25zdCBlPWludDE2KHMuaGVhZC5kYXRhWzUwXSxzLmhlYWQuZGF0YVs1MV0pLHQ9ZnVuY3Rpb24gc2FuaXRpemVHbHlwaExvY2F0aW9ucyhlLHQsYSxyLGksbixzKXtsZXQgbyxjLGw7aWYocil7bz00O2M9ZnVuY3Rpb24gZm9udEl0ZW1EZWNvZGVMb25nKGUsdCl7cmV0dXJuIGVbdF08PDI0fGVbdCsxXTw8MTZ8ZVt0KzJdPDw4fGVbdCszXX07bD1mdW5jdGlvbiBmb250SXRlbUVuY29kZUxvbmcoZSx0LGEpe2VbdF09YT4+PjI0JjI1NTtlW3QrMV09YT4+MTYmMjU1O2VbdCsyXT1hPj44JjI1NTtlW3QrM109MjU1JmF9fWVsc2V7bz0yO2M9ZnVuY3Rpb24gZm9udEl0ZW1EZWNvZGUoZSx0KXtyZXR1cm4gZVt0XTw8OXxlW3QrMV08PDF9O2w9ZnVuY3Rpb24gZm9udEl0ZW1FbmNvZGUoZSx0LGEpe2VbdF09YT4+OSYyNTU7ZVt0KzFdPWE+PjEmMjU1fX1jb25zdCBoPW4/YSsxOmEsdT1vKigxK2gpLGQ9bmV3IFVpbnQ4QXJyYXkodSk7ZC5zZXQoZS5kYXRhLnN1YmFycmF5KDAsdSkpO2UuZGF0YT1kO2NvbnN0IGY9dC5kYXRhLGc9Zi5sZW5ndGgscD1uZXcgVWludDhBcnJheShnKTtsZXQgbSxiO2NvbnN0IHk9W107Zm9yKG09MCxiPTA7bTxhKzE7bSsrLGIrPW8pe2xldCBlPWMoZCxiKTtlPmcmJihlPWcpO3kucHVzaCh7aW5kZXg6bSxvZmZzZXQ6ZSxlbmRPZmZzZXQ6MH0pfXkuc29ydCgoKGUsdCk9PmUub2Zmc2V0LXQub2Zmc2V0KSk7Zm9yKG09MDttPGE7bSsrKXlbbV0uZW5kT2Zmc2V0PXlbbSsxXS5vZmZzZXQ7eS5zb3J0KCgoZSx0KT0+ZS5pbmRleC10LmluZGV4KSk7Zm9yKG09MDttPGE7bSsrKXtjb25zdHtvZmZzZXQ6ZSxlbmRPZmZzZXQ6dH09eVttXTtpZigwIT09ZXx8MCE9PXQpYnJlYWs7Y29uc3QgYT15W20rMV0ub2Zmc2V0O2lmKDAhPT1hKXt5W21dLmVuZE9mZnNldD1hO2JyZWFrfX1jb25zdCB3PXkuYXQoLTIpOzAhPT13Lm9mZnNldCYmMD09PXcuZW5kT2Zmc2V0JiYody5lbmRPZmZzZXQ9Zyk7Y29uc3QgeD1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBTPTA7bChkLDAsUyk7Zm9yKG09MCxiPW87bTxhO20rKyxiKz1vKXtjb25zdCBlPXNhbml0aXplR2x5cGgoZix5W21dLm9mZnNldCx5W21dLmVuZE9mZnNldCxwLFMsaSksdD1lLmxlbmd0aDswPT09dCYmKHhbbV09ITApO2Uuc2l6ZU9mSW5zdHJ1Y3Rpb25zPnMmJihzPWUuc2l6ZU9mSW5zdHJ1Y3Rpb25zKTtTKz10O2woZCxiLFMpfWlmKDA9PT1TKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KFswLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsNDksMF0pO2ZvcihtPTAsYj1vO208aDttKyssYis9bylsKGQsYixlLmxlbmd0aCk7dC5kYXRhPWV9ZWxzZSBpZihuKXtjb25zdCBhPWMoZCxvKTtpZihwLmxlbmd0aD5hK1MpdC5kYXRhPXAuc3ViYXJyYXkoMCxhK1MpO2Vsc2V7dC5kYXRhPW5ldyBVaW50OEFycmF5KGErUyk7dC5kYXRhLnNldChwLnN1YmFycmF5KDAsUykpfXQuZGF0YS5zZXQocC5zdWJhcnJheSgwLGEpLFMpO2woZS5kYXRhLGQubGVuZ3RoLW8sUythKX1lbHNlIHQuZGF0YT1wLnN1YmFycmF5KDAsUyk7cmV0dXJue21pc3NpbmdHbHlwaHM6eCxtYXhTaXplT2ZJbnN0cnVjdGlvbnM6c319KHMubG9jYSxzLmdseWYsdSxlLG0sZixwKTtiPXQubWlzc2luZ0dseXBocztpZihoPj02NTUzNiYmcy5tYXhwLmxlbmd0aD49MzIpe3MubWF4cC5kYXRhWzI2XT10Lm1heFNpemVPZkluc3RydWN0aW9ucz4+ODtzLm1heHAuZGF0YVsyN109MjU1JnQubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zfX1pZighcy5oaGVhKXRocm93IG5ldyBGb3JtYXRFcnJvcignUmVxdWlyZWQgImhoZWEiIHRhYmxlIGlzIG5vdCBmb3VuZCcpO2lmKDA9PT1zLmhoZWEuZGF0YVsxMF0mJjA9PT1zLmhoZWEuZGF0YVsxMV0pe3MuaGhlYS5kYXRhWzEwXT0yNTU7cy5oaGVhLmRhdGFbMTFdPTI1NX1jb25zdCB5PXt1bml0c1BlckVtOmludDE2KHMuaGVhZC5kYXRhWzE4XSxzLmhlYWQuZGF0YVsxOV0pLHlNYXg6c2lnbmVkSW50MTYocy5oZWFkLmRhdGFbNDJdLHMuaGVhZC5kYXRhWzQzXSkseU1pbjpzaWduZWRJbnQxNihzLmhlYWQuZGF0YVszOF0scy5oZWFkLmRhdGFbMzldKSxhc2NlbnQ6c2lnbmVkSW50MTYocy5oaGVhLmRhdGFbNF0scy5oaGVhLmRhdGFbNV0pLGRlc2NlbnQ6c2lnbmVkSW50MTYocy5oaGVhLmRhdGFbNl0scy5oaGVhLmRhdGFbN10pLGxpbmVHYXA6c2lnbmVkSW50MTYocy5oaGVhLmRhdGFbOF0scy5oaGVhLmRhdGFbOV0pfTt0aGlzLmFzY2VudD15LmFzY2VudC95LnVuaXRzUGVyRW07dGhpcy5kZXNjZW50PXkuZGVzY2VudC95LnVuaXRzUGVyRW07dGhpcy5saW5lR2FwPXkubGluZUdhcC95LnVuaXRzUGVyRW07aWYodGhpcy5jc3NGb250SW5mbz8ubGluZUhlaWdodCl7dGhpcy5saW5lSGVpZ2h0PXRoaXMuY3NzRm9udEluZm8ubWV0cmljcy5saW5lSGVpZ2h0O3RoaXMubGluZUdhcD10aGlzLmNzc0ZvbnRJbmZvLm1ldHJpY3MubGluZUdhcH1lbHNlIHRoaXMubGluZUhlaWdodD10aGlzLmFzY2VudC10aGlzLmRlc2NlbnQrdGhpcy5saW5lR2FwO3MucG9zdCYmZnVuY3Rpb24gcmVhZFBvc3RTY3JpcHRUYWJsZShlLGEscil7Y29uc3QgaT0odC5zdGFydHx8MCkrZS5vZmZzZXQ7dC5wb3M9aTtjb25zdCBuPWkrZS5sZW5ndGgscz10LmdldEludDMyKCk7dC5za2lwKDI4KTtsZXQgbyxjLGw9ITA7c3dpdGNoKHMpe2Nhc2UgNjU1MzY6bz14cjticmVhaztjYXNlIDEzMTA3Mjpjb25zdCBlPXQuZ2V0VWludDE2KCk7aWYoZSE9PXIpe2w9ITE7YnJlYWt9Y29uc3QgaT1bXTtmb3IoYz0wO2M8ZTsrK2Mpe2NvbnN0IGU9dC5nZXRVaW50MTYoKTtpZihlPj0zMjc2OCl7bD0hMTticmVha31pLnB1c2goZSl9aWYoIWwpYnJlYWs7Y29uc3QgaD1bXSx1PVtdO2Zvcig7dC5wb3M8bjspe2NvbnN0IGU9dC5nZXRCeXRlKCk7dS5sZW5ndGg9ZTtmb3IoYz0wO2M8ZTsrK2MpdVtjXT1TdHJpbmcuZnJvbUNoYXJDb2RlKHQuZ2V0Qnl0ZSgpKTtoLnB1c2godS5qb2luKCIiKSl9bz1bXTtmb3IoYz0wO2M8ZTsrK2Mpe2NvbnN0IGU9aVtjXTtlPDI1OD9vLnB1c2goeHJbZV0pOm8ucHVzaChoW2UtMjU4XSl9YnJlYWs7Y2FzZSAxOTY2MDg6YnJlYWs7ZGVmYXVsdDp3YXJuKCJVbmtub3duL3Vuc3VwcG9ydGVkIHBvc3QgdGFibGUgdmVyc2lvbiAiK3MpO2w9ITE7YS5kZWZhdWx0RW5jb2RpbmcmJihvPWEuZGVmYXVsdEVuY29kaW5nKX1hLmdseXBoTmFtZXM9bztyZXR1cm4gbH0ocy5wb3N0LGEsdSk7cy5wb3N0PXt0YWc6InBvc3QiLGRhdGE6Y3JlYXRlUG9zdFRhYmxlKGEpfTtjb25zdCB3PU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gaGFzR2x5cGgoZSl7cmV0dXJuIWJbZV19aWYoYS5jb21wb3NpdGUpe2NvbnN0IGU9YS5jaWRUb0dpZE1hcHx8W10sdD0wPT09ZS5sZW5ndGg7YS5jTWFwLmZvckVhY2goKGZ1bmN0aW9uKGEscil7InN0cmluZyI9PXR5cGVvZiByJiYocj1jb252ZXJ0Q2lkU3RyaW5nKGEsciwhMCkpO2lmKHI+NjU1MzUpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJNYXggc2l6ZSBvZiBDSUQgaXMgNjUsNTM1Iik7bGV0IGk9LTE7dD9pPXI6dm9pZCAwIT09ZVtyXSYmKGk9ZVtyXSk7aT49MCYmaTx1JiZoYXNHbHlwaChpKSYmKHdbYV09aSl9KSl9ZWxzZXtjb25zdCBlPWZ1bmN0aW9uIHJlYWRDbWFwVGFibGUoZSx0LGEscil7aWYoIWUpe3dhcm4oIk5vIGNtYXAgdGFibGUgYXZhaWxhYmxlLiIpO3JldHVybntwbGF0Zm9ybUlkOi0xLGVuY29kaW5nSWQ6LTEsbWFwcGluZ3M6W10saGFzU2hvcnRDbWFwOiExfX1sZXQgaSxuPSh0LnN0YXJ0fHwwKStlLm9mZnNldDt0LnBvcz1uO3Quc2tpcCgyKTtjb25zdCBzPXQuZ2V0VWludDE2KCk7bGV0IG8sYz0hMTtmb3IobGV0IGU9MDtlPHM7ZSsrKXtjb25zdCBpPXQuZ2V0VWludDE2KCksbj10LmdldFVpbnQxNigpLGw9dC5nZXRJbnQzMigpPj4+MDtsZXQgaD0hMTtpZihvPy5wbGF0Zm9ybUlkIT09aXx8bz8uZW5jb2RpbmdJZCE9PW4pe2lmKDAhPT1pfHwwIT09biYmMSE9PW4mJjMhPT1uKWlmKDE9PT1pJiYwPT09biloPSEwO2Vsc2UgaWYoMyE9PWl8fDEhPT1ufHwhciYmbyl7aWYoYSYmMz09PWkmJjA9PT1uKXtoPSEwO2xldCBhPSEwO2lmKGU8cy0xKXtjb25zdCBlPXQucGVla0J5dGVzKDIpO2ludDE2KGVbMF0sZVsxXSk8aSYmKGE9ITEpfWEmJihjPSEwKX19ZWxzZXtoPSEwO2F8fChjPSEwKX1lbHNlIGg9ITA7aCYmKG89e3BsYXRmb3JtSWQ6aSxlbmNvZGluZ0lkOm4sb2Zmc2V0Omx9KTtpZihjKWJyZWFrfX1vJiYodC5wb3M9bitvLm9mZnNldCk7aWYoIW98fC0xPT09dC5wZWVrQnl0ZSgpKXt3YXJuKCJDb3VsZCBub3QgZmluZCBhIHByZWZlcnJlZCBjbWFwIHRhYmxlLiIpO3JldHVybntwbGF0Zm9ybUlkOi0xLGVuY29kaW5nSWQ6LTEsbWFwcGluZ3M6W10saGFzU2hvcnRDbWFwOiExfX1jb25zdCBsPXQuZ2V0VWludDE2KCk7bGV0IGg9ITE7Y29uc3QgdT1bXTtsZXQgZCxmO2lmKDA9PT1sKXt0LnNraXAoNCk7Zm9yKGQ9MDtkPDI1NjtkKyspe2NvbnN0IGU9dC5nZXRCeXRlKCk7ZSYmdS5wdXNoKHtjaGFyQ29kZTpkLGdseXBoSWQ6ZX0pfWg9ITB9ZWxzZSBpZigyPT09bCl7dC5za2lwKDQpO2NvbnN0IGU9W107bGV0IGE9MDtmb3IobGV0IHI9MDtyPDI1NjtyKyspe2NvbnN0IHI9dC5nZXRVaW50MTYoKT4+MztlLnB1c2gocik7YT1NYXRoLm1heChyLGEpfWNvbnN0IHI9W107Zm9yKGxldCBlPTA7ZTw9YTtlKyspci5wdXNoKHtmaXJzdENvZGU6dC5nZXRVaW50MTYoKSxlbnRyeUNvdW50OnQuZ2V0VWludDE2KCksaWREZWx0YTpzaWduZWRJbnQxNih0LmdldEJ5dGUoKSx0LmdldEJ5dGUoKSksaWRSYW5nZVBvczp0LnBvcyt0LmdldFVpbnQxNigpfSk7Zm9yKGxldCBhPTA7YTwyNTY7YSsrKWlmKDA9PT1lW2FdKXt0LnBvcz1yWzBdLmlkUmFuZ2VQb3MrMiphO2Y9dC5nZXRVaW50MTYoKTt1LnB1c2goe2NoYXJDb2RlOmEsZ2x5cGhJZDpmfSl9ZWxzZXtjb25zdCBpPXJbZVthXV07Zm9yKGQ9MDtkPGkuZW50cnlDb3VudDtkKyspe2NvbnN0IGU9KGE8PDgpK2QraS5maXJzdENvZGU7dC5wb3M9aS5pZFJhbmdlUG9zKzIqZDtmPXQuZ2V0VWludDE2KCk7MCE9PWYmJihmPShmK2kuaWREZWx0YSklNjU1MzYpO3UucHVzaCh7Y2hhckNvZGU6ZSxnbHlwaElkOmZ9KX19fWVsc2UgaWYoND09PWwpe3Quc2tpcCg0KTtjb25zdCBlPXQuZ2V0VWludDE2KCk+PjE7dC5za2lwKDYpO2NvbnN0IGE9W107bGV0IHI7Zm9yKHI9MDtyPGU7cisrKWEucHVzaCh7ZW5kOnQuZ2V0VWludDE2KCl9KTt0LnNraXAoMik7Zm9yKHI9MDtyPGU7cisrKWFbcl0uc3RhcnQ9dC5nZXRVaW50MTYoKTtmb3Iocj0wO3I8ZTtyKyspYVtyXS5kZWx0YT10LmdldFVpbnQxNigpO2xldCBzLG89MDtmb3Iocj0wO3I8ZTtyKyspe2k9YVtyXTtjb25zdCBuPXQuZ2V0VWludDE2KCk7aWYobil7cz0obj4+MSktKGUtcik7aS5vZmZzZXRJbmRleD1zO289TWF0aC5tYXgobyxzK2kuZW5kLWkuc3RhcnQrMSl9ZWxzZSBpLm9mZnNldEluZGV4PS0xfWNvbnN0IGM9W107Zm9yKGQ9MDtkPG87ZCsrKWMucHVzaCh0LmdldFVpbnQxNigpKTtmb3Iocj0wO3I8ZTtyKyspe2k9YVtyXTtuPWkuc3RhcnQ7Y29uc3QgZT1pLmVuZCx0PWkuZGVsdGE7cz1pLm9mZnNldEluZGV4O2ZvcihkPW47ZDw9ZTtkKyspaWYoNjU1MzUhPT1kKXtmPXM8MD9kOmNbcytkLW5dO2Y9Zit0JjY1NTM1O3UucHVzaCh7Y2hhckNvZGU6ZCxnbHlwaElkOmZ9KX19fWVsc2UgaWYoNj09PWwpe3Quc2tpcCg0KTtjb25zdCBlPXQuZ2V0VWludDE2KCksYT10LmdldFVpbnQxNigpO2ZvcihkPTA7ZDxhO2QrKyl7Zj10LmdldFVpbnQxNigpO2NvbnN0IGE9ZStkO3UucHVzaCh7Y2hhckNvZGU6YSxnbHlwaElkOmZ9KX19ZWxzZXtpZigxMiE9PWwpe3dhcm4oImNtYXAgdGFibGUgaGFzIHVuc3VwcG9ydGVkIGZvcm1hdDogIitsKTtyZXR1cm57cGxhdGZvcm1JZDotMSxlbmNvZGluZ0lkOi0xLG1hcHBpbmdzOltdLGhhc1Nob3J0Q21hcDohMX19e3Quc2tpcCgxMCk7Y29uc3QgZT10LmdldEludDMyKCk+Pj4wO2ZvcihkPTA7ZDxlO2QrKyl7Y29uc3QgZT10LmdldEludDMyKCk+Pj4wLGE9dC5nZXRJbnQzMigpPj4+MDtsZXQgcj10LmdldEludDMyKCk+Pj4wO2ZvcihsZXQgdD1lO3Q8PWE7dCsrKXUucHVzaCh7Y2hhckNvZGU6dCxnbHlwaElkOnIrK30pfX19dS5zb3J0KCgoZSx0KT0+ZS5jaGFyQ29kZS10LmNoYXJDb2RlKSk7Y29uc3QgZz1bXSxwPW5ldyBTZXQ7Zm9yKGNvbnN0IGUgb2YgdSl7Y29uc3R7Y2hhckNvZGU6dH09ZTtpZighcC5oYXModCkpe3AuYWRkKHQpO2cucHVzaChlKX19cmV0dXJue3BsYXRmb3JtSWQ6by5wbGF0Zm9ybUlkLGVuY29kaW5nSWQ6by5lbmNvZGluZ0lkLG1hcHBpbmdzOmcsaGFzU2hvcnRDbWFwOmh9fShzLmNtYXAsdCx0aGlzLmlzU3ltYm9saWNGb250LGEuaGFzRW5jb2RpbmcpLHI9ZS5wbGF0Zm9ybUlkLGk9ZS5lbmNvZGluZ0lkLG49ZS5tYXBwaW5ncztsZXQgbz1bXSxjPSExOyFhLmhhc0VuY29kaW5nfHwiTWFjUm9tYW5FbmNvZGluZyIhPT1hLmJhc2VFbmNvZGluZ05hbWUmJiJXaW5BbnNpRW5jb2RpbmciIT09YS5iYXNlRW5jb2RpbmdOYW1lfHwobz1nZXRFbmNvZGluZyhhLmJhc2VFbmNvZGluZ05hbWUpKTtpZihhLmhhc0VuY29kaW5nJiYhdGhpcy5pc1N5bWJvbGljRm9udCYmKDM9PT1yJiYxPT09aXx8MT09PXImJjA9PT1pKSl7Y29uc3QgZT1scigpO2ZvcihsZXQgdD0wO3Q8MjU2O3QrKyl7bGV0IHM7cz12b2lkIDAhPT10aGlzLmRpZmZlcmVuY2VzW3RdP3RoaXMuZGlmZmVyZW5jZXNbdF06by5sZW5ndGgmJiIiIT09b1t0XT9vW3RdOm5yW3RdO2lmKCFzKWNvbnRpbnVlO2NvbnN0IGM9cmVjb3ZlckdseXBoTmFtZShzLGUpO2xldCBsOzM9PT1yJiYxPT09aT9sPWVbY106MT09PXImJjA9PT1pJiYobD1pci5pbmRleE9mKGMpKTtpZih2b2lkIDA9PT1sKXtpZighYS5nbHlwaE5hbWVzJiZhLmhhc0luY2x1ZGVkVG9Vbmljb2RlTWFwJiYhKHRoaXMudG9Vbmljb2RlIGluc3RhbmNlb2YgSWRlbnRpdHlUb1VuaWNvZGVNYXApKXtjb25zdCBlPXRoaXMudG9Vbmljb2RlLmdldCh0KTtlJiYobD1lLmNvZGVQb2ludEF0KDApKX1pZih2b2lkIDA9PT1sKWNvbnRpbnVlfWZvcihjb25zdCBlIG9mIG4paWYoZS5jaGFyQ29kZT09PWwpe3dbdF09ZS5nbHlwaElkO2JyZWFrfX19ZWxzZSBpZigwPT09cil7Zm9yKGNvbnN0IGUgb2Ygbil3W2UuY2hhckNvZGVdPWUuZ2x5cGhJZDtjPSEwfWVsc2UgaWYoMz09PXImJjA9PT1pKWZvcihjb25zdCBlIG9mIG4pe2xldCB0PWUuY2hhckNvZGU7dD49NjE0NDAmJnQ8PTYxNjk1JiYodCY9MjU1KTt3W3RdPWUuZ2x5cGhJZH1lbHNlIGZvcihjb25zdCBlIG9mIG4pd1tlLmNoYXJDb2RlXT1lLmdseXBoSWQ7aWYoYS5nbHlwaE5hbWVzJiYoby5sZW5ndGh8fHRoaXMuZGlmZmVyZW5jZXMubGVuZ3RoKSlmb3IobGV0IGU9MDtlPDI1NjsrK2Upe2lmKCFjJiZ2b2lkIDAhPT13W2VdKWNvbnRpbnVlO2NvbnN0IHQ9dGhpcy5kaWZmZXJlbmNlc1tlXXx8b1tlXTtpZighdCljb250aW51ZTtjb25zdCByPWEuZ2x5cGhOYW1lcy5pbmRleE9mKHQpO3I+MCYmaGFzR2x5cGgocikmJih3W2VdPXIpfX0wPT09dy5sZW5ndGgmJih3WzBdPTApO2xldCB4PWQtMTtmfHwoeD0wKTtpZighYS5jc3NGb250SW5mbyl7Y29uc3QgZT1hZGp1c3RNYXBwaW5nKHcsaGFzR2x5cGgseCx0aGlzLnRvVW5pY29kZSk7dGhpcy50b0ZvbnRDaGFyPWUudG9Gb250Q2hhcjtzLmNtYXA9e3RhZzoiY21hcCIsZGF0YTpjcmVhdGVDbWFwVGFibGUoZS5jaGFyQ29kZVRvR2x5cGhJZCxlLnRvVW5pY29kZUV4dHJhTWFwLGQpfTtzWyJPUy8yIl0mJmZ1bmN0aW9uIHZhbGlkYXRlT1MyVGFibGUoZSx0KXt0LnBvcz0odC5zdGFydHx8MCkrZS5vZmZzZXQ7Y29uc3QgYT10LmdldFVpbnQxNigpO3Quc2tpcCg2MCk7Y29uc3Qgcj10LmdldFVpbnQxNigpO2lmKGE8NCYmNzY4JnIpcmV0dXJuITE7aWYodC5nZXRVaW50MTYoKT50LmdldFVpbnQxNigpKXJldHVybiExO3Quc2tpcCg2KTtpZigwPT09dC5nZXRVaW50MTYoKSlyZXR1cm4hMTtlLmRhdGFbOF09ZS5kYXRhWzldPTA7cmV0dXJuITB9KHNbIk9TLzIiXSx0KXx8KHNbIk9TLzIiXT17dGFnOiJPUy8yIixkYXRhOmNyZWF0ZU9TMlRhYmxlKGEsZS5jaGFyQ29kZVRvR2x5cGhJZCx5KX0pfWlmKCFsKXRyeXtjPW5ldyBTdHJlYW0oc1siQ0ZGICJdLmRhdGEpO289bmV3IENGRlBhcnNlcihjLGEscHIpLnBhcnNlKCk7by5kdXBsaWNhdGVGaXJzdEdseXBoKCk7Y29uc3QgZT1uZXcgQ0ZGQ29tcGlsZXIobyk7c1siQ0ZGICJdLmRhdGE9ZS5jb21waWxlKCl9Y2F0Y2h7d2FybigiRmFpbGVkIHRvIGNvbXBpbGUgZm9udCAiK2EubG9hZGVkTmFtZSl9aWYocy5uYW1lKXtjb25zdFt0LHJdPXJlYWROYW1lVGFibGUocy5uYW1lKTtzLm5hbWUuZGF0YT1jcmVhdGVOYW1lVGFibGUoZSx0KTt0aGlzLnBzTmFtZT10WzBdWzZdfHxudWxsO2EuY29tcG9zaXRlfHxmdW5jdGlvbiBhZGp1c3RUcnVlVHlwZVRvVW5pY29kZShlLHQsYSl7aWYoZS5pc0ludGVybmFsRm9udClyZXR1cm47aWYoZS5oYXNJbmNsdWRlZFRvVW5pY29kZU1hcClyZXR1cm47aWYoZS5oYXNFbmNvZGluZylyZXR1cm47aWYoZS50b1VuaWNvZGUgaW5zdGFuY2VvZiBJZGVudGl0eVRvVW5pY29kZU1hcClyZXR1cm47aWYoIXQpcmV0dXJuO2lmKDA9PT1hLmxlbmd0aClyZXR1cm47aWYoZS5kZWZhdWx0RW5jb2Rpbmc9PT1zcilyZXR1cm47Zm9yKGNvbnN0IGUgb2YgYSlpZighaXNXaW5OYW1lUmVjb3JkKGUpKXJldHVybjtjb25zdCByPXNyLGk9W10sbj1scigpO2Zvcihjb25zdCBlIGluIHIpe2NvbnN0IHQ9cltlXTtpZigiIj09PXQpY29udGludWU7Y29uc3QgYT1uW3RdO3ZvaWQgMCE9PWEmJihpW2VdPVN0cmluZy5mcm9tQ2hhckNvZGUoYSkpfWkubGVuZ3RoPjAmJmUudG9Vbmljb2RlLmFtZW5kKGkpfShhLHRoaXMuaXNTeW1ib2xpY0ZvbnQscil9ZWxzZSBzLm5hbWU9e3RhZzoibmFtZSIsZGF0YTpjcmVhdGVOYW1lVGFibGUodGhpcy5uYW1lKX07Y29uc3QgUz1uZXcgT3BlblR5cGVGaWxlQnVpbGRlcihuLnZlcnNpb24pO2Zvcihjb25zdCBlIGluIHMpUy5hZGRUYWJsZShlLHNbZV0uZGF0YSk7cmV0dXJuIFMudG9BcnJheSgpfWNvbnZlcnQoZSxhLHIpe3IuZml4ZWRQaXRjaD0hMTtyLmJ1aWx0SW5FbmNvZGluZyYmZnVuY3Rpb24gYWRqdXN0VHlwZTFUb1VuaWNvZGUoZSx0KXtpZihlLmlzSW50ZXJuYWxGb250KXJldHVybjtpZihlLmhhc0luY2x1ZGVkVG9Vbmljb2RlTWFwKXJldHVybjtpZih0PT09ZS5kZWZhdWx0RW5jb2RpbmcpcmV0dXJuO2lmKGUudG9Vbmljb2RlIGluc3RhbmNlb2YgSWRlbnRpdHlUb1VuaWNvZGVNYXApcmV0dXJuO2NvbnN0IGE9W10scj1scigpO2Zvcihjb25zdCBpIGluIHQpe2lmKGUuaGFzRW5jb2RpbmcmJihlLmJhc2VFbmNvZGluZ05hbWV8fHZvaWQgMCE9PWUuZGlmZmVyZW5jZXNbaV0pKWNvbnRpbnVlO2NvbnN0IG49Z2V0VW5pY29kZUZvckdseXBoKHRbaV0scik7LTEhPT1uJiYoYVtpXT1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pKX1hLmxlbmd0aD4wJiZlLnRvVW5pY29kZS5hbWVuZChhKX0ocixyLmJ1aWx0SW5FbmNvZGluZyk7bGV0IGk9MTthIGluc3RhbmNlb2YgQ0ZGRm9udCYmKGk9YS5udW1HbHlwaHMtMSk7Y29uc3Qgbj1hLmdldEdseXBoTWFwcGluZyhyKTtsZXQgcz1udWxsLG89bixjPW51bGw7aWYoIXIuY3NzRm9udEluZm8pe3M9YWRqdXN0TWFwcGluZyhuLGEuaGFzR2x5cGhJZC5iaW5kKGEpLGksdGhpcy50b1VuaWNvZGUpO3RoaXMudG9Gb250Q2hhcj1zLnRvRm9udENoYXI7bz1zLmNoYXJDb2RlVG9HbHlwaElkO2M9cy50b1VuaWNvZGVFeHRyYU1hcH1jb25zdCBsPWEubnVtR2x5cGhzO2Z1bmN0aW9uIGdldENoYXJDb2RlcyhlLHQpe2xldCBhPW51bGw7Zm9yKGNvbnN0IHIgaW4gZSl0PT09ZVtyXSYmKGF8fD1bXSkucHVzaCgwfHIpO3JldHVybiBhfWZ1bmN0aW9uIGNyZWF0ZUNoYXJDb2RlKGUsdCl7Zm9yKGNvbnN0IGEgaW4gZSlpZih0PT09ZVthXSlyZXR1cm4gMHxhO3MuY2hhckNvZGVUb0dseXBoSWRbcy5uZXh0QXZhaWxhYmxlRm9udENoYXJDb2RlXT10O3JldHVybiBzLm5leHRBdmFpbGFibGVGb250Q2hhckNvZGUrK31jb25zdCBoPWEuc2VhY3M7aWYocyYmaD8ubGVuZ3RoKXtjb25zdCBlPXIuZm9udE1hdHJpeHx8dCxpPWEuZ2V0Q2hhcnNldCgpLG89T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IobGV0IHQgaW4gaCl7dHw9MDtjb25zdCBhPWhbdF0scj1uclthWzJdXSxjPW5yW2FbM11dLGw9aS5pbmRleE9mKHIpLHU9aS5pbmRleE9mKGMpO2lmKGw8MHx8dTwwKWNvbnRpbnVlO2NvbnN0IGQ9e3g6YVswXSplWzBdK2FbMV0qZVsyXStlWzRdLHk6YVswXSplWzFdK2FbMV0qZVszXStlWzVdfSxmPWdldENoYXJDb2RlcyhuLHQpO2lmKGYpZm9yKGNvbnN0IGUgb2YgZil7Y29uc3QgdD1zLmNoYXJDb2RlVG9HbHlwaElkLGE9Y3JlYXRlQ2hhckNvZGUodCxsKSxyPWNyZWF0ZUNoYXJDb2RlKHQsdSk7b1tlXT17YmFzZUZvbnRDaGFyQ29kZTphLGFjY2VudEZvbnRDaGFyQ29kZTpyLGFjY2VudE9mZnNldDpkfX19ci5zZWFjTWFwPW99Y29uc3QgdT1yLmZvbnRNYXRyaXg/MS9NYXRoLm1heCguLi5yLmZvbnRNYXRyaXguc2xpY2UoMCw0KS5tYXAoTWF0aC5hYnMpKToxZTMsZD1uZXcgT3BlblR5cGVGaWxlQnVpbGRlcigiT1RUTyIpO2QuYWRkVGFibGUoIkNGRiAiLGEuZGF0YSk7ZC5hZGRUYWJsZSgiT1MvMiIsY3JlYXRlT1MyVGFibGUocixvKSk7ZC5hZGRUYWJsZSgiY21hcCIsY3JlYXRlQ21hcFRhYmxlKG8sYyxsKSk7ZC5hZGRUYWJsZSgiaGVhZCIsIlwwAVwwXDBcMFwwEFwwXDBcMFwwXDBfDzzDtVwwXDAiK3NhZmVTdHJpbmcxNih1KSsiXDBcMFwwXDDCnlx2fidcMFwwXDBcMMKeXHZ+J1wwXDAiK3NhZmVTdHJpbmcxNihyLmRlc2NlbnQpKyIPw78iK3NhZmVTdHJpbmcxNihyLmFzY2VudCkrc3RyaW5nMTYoci5pdGFsaWNBbmdsZT8yOjApKyJcMBFcMFwwXDBcMFwwXDAiKTtkLmFkZFRhYmxlKCJoaGVhIiwiXDABXDBcMCIrc2FmZVN0cmluZzE2KHIuYXNjZW50KStzYWZlU3RyaW5nMTYoci5kZXNjZW50KSsiXDBcMMO/w79cMFwwXDBcMFwwXDAiK3NhZmVTdHJpbmcxNihyLmNhcEhlaWdodCkrc2FmZVN0cmluZzE2KE1hdGgudGFuKHIuaXRhbGljQW5nbGUpKnIueEhlaWdodCkrIlwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMCIrc3RyaW5nMTYobCkpO2QuYWRkVGFibGUoImhtdHgiLGZ1bmN0aW9uIGZvbnRGaWVsZHNIbXR4KCl7Y29uc3QgZT1hLmNoYXJzdHJpbmdzLHQ9YS5jZmY/YS5jZmYud2lkdGhzOm51bGw7bGV0IHI9IlwwXDBcMFwwIjtmb3IobGV0IGE9MSxpPWw7YTxpO2ErKyl7bGV0IGk9MDtpZihlKXtjb25zdCB0PWVbYS0xXTtpPSJ3aWR0aCJpbiB0P3Qud2lkdGg6MH1lbHNlIHQmJihpPU1hdGguY2VpbCh0W2FdfHwwKSk7cis9c3RyaW5nMTYoaSkrc3RyaW5nMTYoMCl9cmV0dXJuIHJ9KCkpO2QuYWRkVGFibGUoIm1heHAiLCJcMFwwUFwwIitzdHJpbmcxNihsKSk7ZC5hZGRUYWJsZSgibmFtZSIsY3JlYXRlTmFtZVRhYmxlKGUpKTtkLmFkZFRhYmxlKCJwb3N0IixjcmVhdGVQb3N0VGFibGUocikpO3JldHVybiBkLnRvQXJyYXkoKX1nZXQgX3NwYWNlV2lkdGgoKXtjb25zdCBlPVsic3BhY2UiLCJtaW51cyIsIm9uZSIsImkiLCJJIl07bGV0IHQ7Zm9yKGNvbnN0IGEgb2YgZSl7aWYoYSBpbiB0aGlzLndpZHRocyl7dD10aGlzLndpZHRoc1thXTticmVha31jb25zdCBlPWxyKClbYV07bGV0IHI9MDtpZih0aGlzLmNvbXBvc2l0ZSYmdGhpcy5jTWFwLmNvbnRhaW5zKGUpKXtyPXRoaXMuY01hcC5sb29rdXAoZSk7InN0cmluZyI9PXR5cGVvZiByJiYocj1jb252ZXJ0Q2lkU3RyaW5nKGUscikpfSFyJiZ0aGlzLnRvVW5pY29kZSYmKHI9dGhpcy50b1VuaWNvZGUuY2hhckNvZGVPZihlKSk7cjw9MCYmKHI9ZSk7dD10aGlzLndpZHRoc1tyXTtpZih0KWJyZWFrfXJldHVybiBzaGFkb3codGhpcywiX3NwYWNlV2lkdGgiLHR8fHRoaXMuZGVmYXVsdFdpZHRoKX1fY2hhclRvR2x5cGgoZSx0PSExKXtsZXQgYSxyLGksbj10aGlzLl9nbHlwaENhY2hlW2VdO2lmKG4/LmlzU3BhY2U9PT10KXJldHVybiBuO2xldCBzPWU7aWYodGhpcy5jTWFwPy5jb250YWlucyhlKSl7cz10aGlzLmNNYXAubG9va3VwKGUpOyJzdHJpbmciPT10eXBlb2YgcyYmKHM9Y29udmVydENpZFN0cmluZyhlLHMpKX1yPXRoaXMud2lkdGhzW3NdOyJudW1iZXIiIT10eXBlb2YgciYmKHI9dGhpcy5kZWZhdWx0V2lkdGgpO2NvbnN0IG89dGhpcy52bWV0cmljcz8uW3NdO2xldCBjPXRoaXMudG9Vbmljb2RlLmdldChlKXx8ZTsibnVtYmVyIj09dHlwZW9mIGMmJihjPVN0cmluZy5mcm9tQ2hhckNvZGUoYykpO2xldCBsPXZvaWQgMCE9PXRoaXMudG9Gb250Q2hhcltlXTthPXRoaXMudG9Gb250Q2hhcltlXXx8ZTtpZih0aGlzLm1pc3NpbmdGaWxlKXtjb25zdCB0PXRoaXMuZGlmZmVyZW5jZXNbZV18fHRoaXMuZGVmYXVsdEVuY29kaW5nW2VdO2lmKCgiLm5vdGRlZiI9PT10fHwiIj09PXQpJiYiVHlwZTEiPT09dGhpcy50eXBlKXthPTMyO2lmKCIiPT09dCl7cnx8PXRoaXMuX3NwYWNlV2lkdGg7Yz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfX1hPWZ1bmN0aW9uIG1hcFNwZWNpYWxVbmljb2RlVmFsdWVzKGUpe3JldHVybiBlPj02NTUyMCYmZTw9NjU1MzU/MDplPj02Mjk3NiYmZTw9NjM3NDM/dXIoKVtlXXx8ZToxNzM9PT1lPzQ1OmV9KGEpfXRoaXMuaXNUeXBlM0ZvbnQmJihpPWEpO2xldCBoPW51bGw7aWYodGhpcy5zZWFjTWFwPy5bZV0pe2w9ITA7Y29uc3QgdD10aGlzLnNlYWNNYXBbZV07YT10LmJhc2VGb250Q2hhckNvZGU7aD17Zm9udENoYXI6U3RyaW5nLmZyb21Db2RlUG9pbnQodC5hY2NlbnRGb250Q2hhckNvZGUpLG9mZnNldDp0LmFjY2VudE9mZnNldH19bGV0IHU9IiI7Im51bWJlciI9PXR5cGVvZiBhJiYoYTw9MTExNDExMT91PVN0cmluZy5mcm9tQ29kZVBvaW50KGEpOndhcm4oYGNoYXJUb0dseXBoIC0gaW52YWxpZCBmb250Q2hhckNvZGU6ICR7YX1gKSk7aWYodGhpcy5taXNzaW5nRmlsZSYmdGhpcy52ZXJ0aWNhbCYmMT09PXUubGVuZ3RoKXtjb25zdCBlPVNyKClbdS5jaGFyQ29kZUF0KDApXTtlJiYodT1jPVN0cmluZy5mcm9tQ2hhckNvZGUoZSkpfW49bmV3IGZvbnRzX0dseXBoKGUsdSxjLGgscixvLGksdCxsKTtyZXR1cm4gdGhpcy5fZ2x5cGhDYWNoZVtlXT1ufWNoYXJzVG9HbHlwaHMoZSl7bGV0IHQ9dGhpcy5fY2hhcnNDYWNoZVtlXTtpZih0KXJldHVybiB0O3Q9W107aWYodGhpcy5jTWFwKXtjb25zdCBhPU9iamVjdC5jcmVhdGUobnVsbCkscj1lLmxlbmd0aDtsZXQgaT0wO2Zvcig7aTxyOyl7dGhpcy5jTWFwLnJlYWRDaGFyQ29kZShlLGksYSk7Y29uc3R7Y2hhcmNvZGU6cixsZW5ndGg6bn09YTtpKz1uO2NvbnN0IHM9dGhpcy5fY2hhclRvR2x5cGgociwxPT09biYmMzI9PT1lLmNoYXJDb2RlQXQoaS0xKSk7dC5wdXNoKHMpfX1lbHNlIGZvcihsZXQgYT0wLHI9ZS5sZW5ndGg7YTxyOysrYSl7Y29uc3Qgcj1lLmNoYXJDb2RlQXQoYSksaT10aGlzLl9jaGFyVG9HbHlwaChyLDMyPT09cik7dC5wdXNoKGkpfXJldHVybiB0aGlzLl9jaGFyc0NhY2hlW2VdPXR9Z2V0Q2hhclBvc2l0aW9ucyhlKXtjb25zdCB0PVtdO2lmKHRoaXMuY01hcCl7Y29uc3QgYT1PYmplY3QuY3JlYXRlKG51bGwpO2xldCByPTA7Zm9yKDtyPGUubGVuZ3RoOyl7dGhpcy5jTWFwLnJlYWRDaGFyQ29kZShlLHIsYSk7Y29uc3QgaT1hLmxlbmd0aDt0LnB1c2goW3IscitpXSk7cis9aX19ZWxzZSBmb3IobGV0IGE9MCxyPWUubGVuZ3RoO2E8cjsrK2EpdC5wdXNoKFthLGErMV0pO3JldHVybiB0fWdldCBnbHlwaENhY2hlVmFsdWVzKCl7cmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fZ2x5cGhDYWNoZSl9ZW5jb2RlU3RyaW5nKGUpe2NvbnN0IHQ9W10sYT1bXSxoYXNDdXJyZW50QnVmRXJyb3JzPSgpPT50Lmxlbmd0aCUyPT0xLHI9dGhpcy50b1VuaWNvZGUgaW5zdGFuY2VvZiBJZGVudGl0eVRvVW5pY29kZU1hcD9lPT50aGlzLnRvVW5pY29kZS5jaGFyQ29kZU9mKGUpOmU9PnRoaXMudG9Vbmljb2RlLmNoYXJDb2RlT2YoU3RyaW5nLmZyb21Db2RlUG9pbnQoZSkpO2ZvcihsZXQgaT0wLG49ZS5sZW5ndGg7aTxuO2krKyl7Y29uc3Qgbj1lLmNvZGVQb2ludEF0KGkpO24+NTUyOTUmJihuPDU3MzQ0fHxuPjY1NTMzKSYmaSsrO2lmKHRoaXMudG9Vbmljb2RlKXtjb25zdCBlPXIobik7aWYoLTEhPT1lKXtpZihoYXNDdXJyZW50QnVmRXJyb3JzKCkpe3QucHVzaChhLmpvaW4oIiIpKTthLmxlbmd0aD0wfWZvcihsZXQgdD0odGhpcy5jTWFwP3RoaXMuY01hcC5nZXRDaGFyQ29kZUxlbmd0aChlKToxKS0xO3Q+PTA7dC0tKWEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGU+PjgqdCYyNTUpKTtjb250aW51ZX19aWYoIWhhc0N1cnJlbnRCdWZFcnJvcnMoKSl7dC5wdXNoKGEuam9pbigiIikpO2EubGVuZ3RoPTB9YS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KG4pKX10LnB1c2goYS5qb2luKCIiKSk7cmV0dXJuIHR9fWNsYXNzIEVycm9yRm9udHtjb25zdHJ1Y3RvcihlKXt0aGlzLmVycm9yPWU7dGhpcy5sb2FkZWROYW1lPSJnX2ZvbnRfZXJyb3IiO3RoaXMubWlzc2luZ0ZpbGU9ITB9Y2hhcnNUb0dseXBocygpe3JldHVybltdfWVuY29kZVN0cmluZyhlKXtyZXR1cm5bZV19ZXhwb3J0RGF0YSgpe3JldHVybntlcnJvcjp0aGlzLmVycm9yfX19Y29uc3QgaWk9MixuaT0zLHNpPTQsb2k9NSxjaT02LGxpPTc7Y2xhc3MgUGF0dGVybntjb25zdHJ1Y3Rvcigpe3VucmVhY2hhYmxlKCJDYW5ub3QgaW5pdGlhbGl6ZSBQYXR0ZXJuLiIpfXN0YXRpYyBwYXJzZVNoYWRpbmcoZSx0LGEscixpLG4pe2NvbnN0IHM9ZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0/ZS5kaWN0OmUsbz1zLmdldCgiU2hhZGluZ1R5cGUiKTt0cnl7c3dpdGNoKG8pe2Nhc2UgaWk6Y2FzZSBuaTpyZXR1cm4gbmV3IFJhZGlhbEF4aWFsU2hhZGluZyhzLHQsYSxyLGksbik7Y2FzZSBzaTpjYXNlIG9pOmNhc2UgY2k6Y2FzZSBsaTpyZXR1cm4gbmV3IE1lc2hTaGFkaW5nKGUsdCxhLHIsaSxuKTtkZWZhdWx0OnRocm93IG5ldyBGb3JtYXRFcnJvcigiVW5zdXBwb3J0ZWQgU2hhZGluZ1R5cGU6ICIrbyl9fWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlO3dhcm4oZSk7cmV0dXJuIG5ldyBEdW1teVNoYWRpbmd9fX1jbGFzcyBCYXNlU2hhZGluZ3tzdGF0aWMgU01BTExfTlVNQkVSPTFlLTY7Z2V0SVIoKXt1bnJlYWNoYWJsZSgiQWJzdHJhY3QgbWV0aG9kIGBnZXRJUmAgY2FsbGVkLiIpfX1jbGFzcyBSYWRpYWxBeGlhbFNoYWRpbmcgZXh0ZW5kcyBCYXNlU2hhZGluZ3tjb25zdHJ1Y3RvcihlLHQsYSxyLGksbil7c3VwZXIoKTt0aGlzLnNoYWRpbmdUeXBlPWUuZ2V0KCJTaGFkaW5nVHlwZSIpO2xldCBzPTA7dGhpcy5zaGFkaW5nVHlwZT09PWlpP3M9NDp0aGlzLnNoYWRpbmdUeXBlPT09bmkmJihzPTYpO3RoaXMuY29vcmRzQXJyPWUuZ2V0QXJyYXkoIkNvb3JkcyIpO2lmKCFpc051bWJlckFycmF5KHRoaXMuY29vcmRzQXJyLHMpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiUmFkaWFsQXhpYWxTaGFkaW5nOiBJbnZhbGlkIC9Db29yZHMgYXJyYXkuIik7Y29uc3Qgbz1Db2xvclNwYWNlVXRpbHMucGFyc2Uoe2NzOmUuZ2V0UmF3KCJDUyIpfHxlLmdldFJhdygiQ29sb3JTcGFjZSIpLHhyZWY6dCxyZXNvdXJjZXM6YSxwZGZGdW5jdGlvbkZhY3Rvcnk6cixnbG9iYWxDb2xvclNwYWNlQ2FjaGU6aSxsb2NhbENvbG9yU3BhY2VDYWNoZTpufSk7dGhpcy5iYm94PWxvb2t1cE5vcm1hbFJlY3QoZS5nZXRBcnJheSgiQkJveCIpLG51bGwpO2xldCBjPTAsbD0xO2NvbnN0IGg9ZS5nZXRBcnJheSgiRG9tYWluIik7aXNOdW1iZXJBcnJheShoLDIpJiYoW2MsbF09aCk7bGV0IHU9ITEsZD0hMTtjb25zdCBmPWUuZ2V0QXJyYXkoIkV4dGVuZCIpOyhmdW5jdGlvbiBpc0Jvb2xlYW5BcnJheShlLHQpe3JldHVybiBBcnJheS5pc0FycmF5KGUpJiYobnVsbD09PXR8fGUubGVuZ3RoPT09dCkmJmUuZXZlcnkoKGU9PiJib29sZWFuIj09dHlwZW9mIGUpKX0pKGYsMikmJihbdSxkXT1mKTtpZighKHRoaXMuc2hhZGluZ1R5cGUhPT1uaXx8dSYmZCkpe2NvbnN0W2UsdCxhLHIsaSxuXT10aGlzLmNvb3Jkc0FycixzPU1hdGguaHlwb3QoZS1yLHQtaSk7YTw9bitzJiZuPD1hK3MmJndhcm4oIlVuc3VwcG9ydGVkIHJhZGlhbCBncmFkaWVudC4iKX10aGlzLmV4dGVuZFN0YXJ0PXU7dGhpcy5leHRlbmRFbmQ9ZDtjb25zdCBnPWUuZ2V0UmF3KCJGdW5jdGlvbiIpLHA9ci5jcmVhdGUoZywhMCksbT0obC1jKS84NDAsYj10aGlzLmNvbG9yU3RvcHM9W107aWYoYz49bHx8bTw9MCl7aW5mbygiQmFkIHNoYWRpbmcgZG9tYWluLiIpO3JldHVybn1jb25zdCB5PW5ldyBGbG9hdDMyQXJyYXkoby5udW1Db21wcyksdz1uZXcgRmxvYXQzMkFycmF5KDEpO2xldCB4PTA7d1swXT1jO3AodywwLHksMCk7Y29uc3QgUz1uZXcgVWludDhDbGFtcGVkQXJyYXkoMyk7by5nZXRSZ2IoeSwwLFMpO2xldFtrLEMsdl09UztiLnB1c2goWzAsVXRpbC5tYWtlSGV4Q29sb3IoayxDLHYpXSk7bGV0IEY9MTt3WzBdPWMrbTtwKHcsMCx5LDApO28uZ2V0UmdiKHksMCxTKTtsZXRbVCxPLE1dPVMsRD1ULWsrMSxSPU8tQysxLE49TS12KzEsRT1ULWstMSxMPU8tQy0xLGo9TS12LTE7Zm9yKGxldCBlPTI7ZTw4NDA7ZSsrKXt3WzBdPWMrZSptO3AodywwLHksMCk7by5nZXRSZ2IoeSwwLFMpO2NvbnN0W3QsYSxyXT1TLGk9ZS14O0Q9TWF0aC5taW4oRCwodC1rKzEpL2kpO1I9TWF0aC5taW4oUiwoYS1DKzEpL2kpO049TWF0aC5taW4oTiwoci12KzEpL2kpO0U9TWF0aC5tYXgoRSwodC1rLTEpL2kpO0w9TWF0aC5tYXgoTCwoYS1DLTEpL2kpO2o9TWF0aC5tYXgoaiwoci12LTEpL2kpO2lmKCEoRTw9RCYmTDw9UiYmajw9Tikpe2NvbnN0IGU9VXRpbC5tYWtlSGV4Q29sb3IoVCxPLE0pO2IucHVzaChbRi84NDAsZV0pO0Q9dC1UKzE7Uj1hLU8rMTtOPXItTSsxO0U9dC1ULTE7TD1hLU8tMTtqPXItTS0xO3g9RjtrPVQ7Qz1PO3Y9TX1GPWU7VD10O089YTtNPXJ9Yi5wdXNoKFsxLFV0aWwubWFrZUhleENvbG9yKFQsTyxNKV0pO2xldCBfPSJ0cmFuc3BhcmVudCI7ZS5oYXMoIkJhY2tncm91bmQiKSYmKF89by5nZXRSZ2JIZXgoZS5nZXQoIkJhY2tncm91bmQiKSwwKSk7aWYoIXUpe2IudW5zaGlmdChbMCxfXSk7YlsxXVswXSs9QmFzZVNoYWRpbmcuU01BTExfTlVNQkVSfWlmKCFkKXtiLmF0KC0xKVswXS09QmFzZVNoYWRpbmcuU01BTExfTlVNQkVSO2IucHVzaChbMSxfXSl9dGhpcy5jb2xvclN0b3BzPWJ9Z2V0SVIoKXtjb25zdHtjb29yZHNBcnI6ZSxzaGFkaW5nVHlwZTp0fT10aGlzO2xldCBhLHIsaSxuLHM7aWYodD09PWlpKXtyPVtlWzBdLGVbMV1dO2k9W2VbMl0sZVszXV07bj1udWxsO3M9bnVsbDthPSJheGlhbCJ9ZWxzZSBpZih0PT09bmkpe3I9W2VbMF0sZVsxXV07aT1bZVszXSxlWzRdXTtuPWVbMl07cz1lWzVdO2E9InJhZGlhbCJ9ZWxzZSB1bnJlYWNoYWJsZShgZ2V0UGF0dGVybiB0eXBlIHVua25vd246ICR7dH1gKTtyZXR1cm5bIlJhZGlhbEF4aWFsIixhLHRoaXMuYmJveCx0aGlzLmNvbG9yU3RvcHMscixpLG4sc119fWNsYXNzIE1lc2hTdHJlYW1SZWFkZXJ7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnN0cmVhbT1lO3RoaXMuY29udGV4dD10O3RoaXMuYnVmZmVyPTA7dGhpcy5idWZmZXJMZW5ndGg9MDtjb25zdCBhPXQubnVtQ29tcHM7dGhpcy50bXBDb21wc0J1Zj1uZXcgRmxvYXQzMkFycmF5KGEpO2NvbnN0IHI9dC5jb2xvclNwYWNlLm51bUNvbXBzO3RoaXMudG1wQ3NDb21wc0J1Zj10LmNvbG9yRm4/bmV3IEZsb2F0MzJBcnJheShyKTp0aGlzLnRtcENvbXBzQnVmfWdldCBoYXNEYXRhKCl7aWYodGhpcy5zdHJlYW0uZW5kKXJldHVybiB0aGlzLnN0cmVhbS5wb3M8dGhpcy5zdHJlYW0uZW5kO2lmKHRoaXMuYnVmZmVyTGVuZ3RoPjApcmV0dXJuITA7Y29uc3QgZT10aGlzLnN0cmVhbS5nZXRCeXRlKCk7aWYoZTwwKXJldHVybiExO3RoaXMuYnVmZmVyPWU7dGhpcy5idWZmZXJMZW5ndGg9ODtyZXR1cm4hMH1yZWFkQml0cyhlKXtjb25zdHtzdHJlYW06dH09dGhpcztsZXR7YnVmZmVyOmEsYnVmZmVyTGVuZ3RoOnJ9PXRoaXM7aWYoMzI9PT1lKXtpZigwPT09cilyZXR1cm4gdC5nZXRJbnQzMigpPj4+MDthPWE8PDI0fHQuZ2V0Qnl0ZSgpPDwxNnx0LmdldEJ5dGUoKTw8OHx0LmdldEJ5dGUoKTtjb25zdCBlPXQuZ2V0Qnl0ZSgpO3RoaXMuYnVmZmVyPWUmKDE8PHIpLTE7cmV0dXJuKGE8PDgtcnwoMjU1JmUpPj5yKT4+PjB9aWYoOD09PWUmJjA9PT1yKXJldHVybiB0LmdldEJ5dGUoKTtmb3IoO3I8ZTspe2E9YTw8OHx0LmdldEJ5dGUoKTtyKz04fXItPWU7dGhpcy5idWZmZXJMZW5ndGg9cjt0aGlzLmJ1ZmZlcj1hJigxPDxyKS0xO3JldHVybiBhPj5yfWFsaWduKCl7dGhpcy5idWZmZXI9MDt0aGlzLmJ1ZmZlckxlbmd0aD0wfXJlYWRGbGFnKCl7cmV0dXJuIHRoaXMucmVhZEJpdHModGhpcy5jb250ZXh0LmJpdHNQZXJGbGFnKX1yZWFkQ29vcmRpbmF0ZSgpe2NvbnN0e2JpdHNQZXJDb29yZGluYXRlOmUsZGVjb2RlOnR9PXRoaXMuY29udGV4dCxhPXRoaXMucmVhZEJpdHMoZSkscj10aGlzLnJlYWRCaXRzKGUpLGk9ZTwzMj8xLygoMTw8ZSktMSk6Mi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDtyZXR1cm5bYSppKih0WzFdLXRbMF0pK3RbMF0scippKih0WzNdLXRbMl0pK3RbMl1dfXJlYWRDb21wb25lbnRzKCl7Y29uc3R7Yml0c1BlckNvbXBvbmVudDplLGNvbG9yRm46dCxjb2xvclNwYWNlOmEsZGVjb2RlOnIsbnVtQ29tcHM6aX09dGhpcy5jb250ZXh0LG49ZTwzMj8xLygoMTw8ZSktMSk6Mi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCxzPXRoaXMudG1wQ29tcHNCdWY7Zm9yKGxldCB0PTAsYT00O3Q8aTt0KyssYSs9Mil7Y29uc3QgaT10aGlzLnJlYWRCaXRzKGUpO3NbdF09aSpuKihyW2ErMV0tclthXSkrclthXX1jb25zdCBvPXRoaXMudG1wQ3NDb21wc0J1Zjt0Py4ocywwLG8sMCk7cmV0dXJuIGEuZ2V0UmdiKG8sMCl9fWxldCBoaT1PYmplY3QuY3JlYXRlKG51bGwpO2Z1bmN0aW9uIGdldEIoZSl7cmV0dXJuIGhpW2VdfHw9ZnVuY3Rpb24gYnVpbGRCKGUpe2NvbnN0IHQ9W107Zm9yKGxldCBhPTA7YTw9ZTthKyspe2NvbnN0IHI9YS9lLGk9MS1yO3QucHVzaChuZXcgRmxvYXQzMkFycmF5KFtpKiozLDMqcippKioyLDMqcioqMippLHIqKjNdKSl9cmV0dXJuIHR9KGUpfWNsYXNzIE1lc2hTaGFkaW5nIGV4dGVuZHMgQmFzZVNoYWRpbmd7c3RhdGljIE1JTl9TUExJVF9QQVRDSF9DSFVOS1NfQU1PVU5UPTM7c3RhdGljIE1BWF9TUExJVF9QQVRDSF9DSFVOS1NfQU1PVU5UPTIwO3N0YXRpYyBUUklBTkdMRV9ERU5TSVRZPTIwO2NvbnN0cnVjdG9yKGUsdCxhLHIsaSxuKXtzdXBlcigpO2lmKCEoZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pKXRocm93IG5ldyBGb3JtYXRFcnJvcigiTWVzaCBkYXRhIGlzIG5vdCBhIHN0cmVhbSIpO2NvbnN0IHM9ZS5kaWN0O3RoaXMuc2hhZGluZ1R5cGU9cy5nZXQoIlNoYWRpbmdUeXBlIik7dGhpcy5iYm94PWxvb2t1cE5vcm1hbFJlY3Qocy5nZXRBcnJheSgiQkJveCIpLG51bGwpO2NvbnN0IG89Q29sb3JTcGFjZVV0aWxzLnBhcnNlKHtjczpzLmdldFJhdygiQ1MiKXx8cy5nZXRSYXcoIkNvbG9yU3BhY2UiKSx4cmVmOnQscmVzb3VyY2VzOmEscGRmRnVuY3Rpb25GYWN0b3J5OnIsZ2xvYmFsQ29sb3JTcGFjZUNhY2hlOmksbG9jYWxDb2xvclNwYWNlQ2FjaGU6bn0pO3RoaXMuYmFja2dyb3VuZD1zLmhhcygiQmFja2dyb3VuZCIpP28uZ2V0UmdiKHMuZ2V0KCJCYWNrZ3JvdW5kIiksMCk6bnVsbDtjb25zdCBjPXMuZ2V0UmF3KCJGdW5jdGlvbiIpLGw9Yz9yLmNyZWF0ZShjLCEwKTpudWxsO3RoaXMuY29vcmRzPVtdO3RoaXMuY29sb3JzPVtdO3RoaXMuZmlndXJlcz1bXTtjb25zdCBoPXtiaXRzUGVyQ29vcmRpbmF0ZTpzLmdldCgiQml0c1BlckNvb3JkaW5hdGUiKSxiaXRzUGVyQ29tcG9uZW50OnMuZ2V0KCJCaXRzUGVyQ29tcG9uZW50IiksYml0c1BlckZsYWc6cy5nZXQoIkJpdHNQZXJGbGFnIiksZGVjb2RlOnMuZ2V0QXJyYXkoIkRlY29kZSIpLGNvbG9yRm46bCxjb2xvclNwYWNlOm8sbnVtQ29tcHM6bD8xOm8ubnVtQ29tcHN9LHU9bmV3IE1lc2hTdHJlYW1SZWFkZXIoZSxoKTtsZXQgZD0hMTtzd2l0Y2godGhpcy5zaGFkaW5nVHlwZSl7Y2FzZSBzaTp0aGlzLl9kZWNvZGVUeXBlNFNoYWRpbmcodSk7YnJlYWs7Y2FzZSBvaTpjb25zdCBlPTB8cy5nZXQoIlZlcnRpY2VzUGVyUm93Iik7aWYoZTwyKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBWZXJ0aWNlc1BlclJvdyIpO3RoaXMuX2RlY29kZVR5cGU1U2hhZGluZyh1LGUpO2JyZWFrO2Nhc2UgY2k6dGhpcy5fZGVjb2RlVHlwZTZTaGFkaW5nKHUpO2Q9ITA7YnJlYWs7Y2FzZSBsaTp0aGlzLl9kZWNvZGVUeXBlN1NoYWRpbmcodSk7ZD0hMDticmVhaztkZWZhdWx0OnVucmVhY2hhYmxlKCJVbnN1cHBvcnRlZCBtZXNoIHR5cGUuIil9aWYoZCl7dGhpcy5fdXBkYXRlQm91bmRzKCk7Zm9yKGxldCBlPTAsdD10aGlzLmZpZ3VyZXMubGVuZ3RoO2U8dDtlKyspdGhpcy5fYnVpbGRGaWd1cmVGcm9tUGF0Y2goZSl9dGhpcy5fdXBkYXRlQm91bmRzKCk7dGhpcy5fcGFja0RhdGEoKX1fZGVjb2RlVHlwZTRTaGFkaW5nKGUpe2NvbnN0IHQ9dGhpcy5jb29yZHMsYT10aGlzLmNvbG9ycyxyPVtdLGk9W107bGV0IG49MDtmb3IoO2UuaGFzRGF0YTspe2NvbnN0IHM9ZS5yZWFkRmxhZygpLG89ZS5yZWFkQ29vcmRpbmF0ZSgpLGM9ZS5yZWFkQ29tcG9uZW50cygpO2lmKDA9PT1uKXtpZighKDA8PXMmJnM8PTIpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiVW5rbm93biB0eXBlNCBmbGFnIik7c3dpdGNoKHMpe2Nhc2UgMDpuPTM7YnJlYWs7Y2FzZSAxOmkucHVzaChpLmF0KC0yKSxpLmF0KC0xKSk7bj0xO2JyZWFrO2Nhc2UgMjppLnB1c2goaS5hdCgtMyksaS5hdCgtMSkpO249MX1yLnB1c2gocyl9aS5wdXNoKHQubGVuZ3RoKTt0LnB1c2gobyk7YS5wdXNoKGMpO24tLTtlLmFsaWduKCl9dGhpcy5maWd1cmVzLnB1c2goe3R5cGU6InRyaWFuZ2xlcyIsY29vcmRzOm5ldyBJbnQzMkFycmF5KGkpLGNvbG9yczpuZXcgSW50MzJBcnJheShpKX0pfV9kZWNvZGVUeXBlNVNoYWRpbmcoZSx0KXtjb25zdCBhPXRoaXMuY29vcmRzLHI9dGhpcy5jb2xvcnMsaT1bXTtmb3IoO2UuaGFzRGF0YTspe2NvbnN0IHQ9ZS5yZWFkQ29vcmRpbmF0ZSgpLG49ZS5yZWFkQ29tcG9uZW50cygpO2kucHVzaChhLmxlbmd0aCk7YS5wdXNoKHQpO3IucHVzaChuKX10aGlzLmZpZ3VyZXMucHVzaCh7dHlwZToibGF0dGljZSIsY29vcmRzOm5ldyBJbnQzMkFycmF5KGkpLGNvbG9yczpuZXcgSW50MzJBcnJheShpKSx2ZXJ0aWNlc1BlclJvdzp0fSl9X2RlY29kZVR5cGU2U2hhZGluZyhlKXtjb25zdCB0PXRoaXMuY29vcmRzLGE9dGhpcy5jb2xvcnMscj1uZXcgSW50MzJBcnJheSgxNiksaT1uZXcgSW50MzJBcnJheSg0KTtmb3IoO2UuaGFzRGF0YTspe2NvbnN0IG49ZS5yZWFkRmxhZygpO2lmKCEoMDw9biYmbjw9MykpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJVbmtub3duIHR5cGU2IGZsYWciKTtjb25zdCBzPXQubGVuZ3RoO2ZvcihsZXQgYT0wLHI9MCE9PW4/ODoxMjthPHI7YSsrKXQucHVzaChlLnJlYWRDb29yZGluYXRlKCkpO2NvbnN0IG89YS5sZW5ndGg7Zm9yKGxldCB0PTAscj0wIT09bj8yOjQ7dDxyO3QrKylhLnB1c2goZS5yZWFkQ29tcG9uZW50cygpKTtsZXQgYyxsLGgsdTtzd2l0Y2gobil7Y2FzZSAwOnJbMTJdPXMrMztyWzEzXT1zKzQ7clsxNF09cys1O3JbMTVdPXMrNjtyWzhdPXMrMjtyWzExXT1zKzc7cls0XT1zKzE7cls3XT1zKzg7clswXT1zO3JbMV09cysxMTtyWzJdPXMrMTA7clszXT1zKzk7aVsyXT1vKzE7aVszXT1vKzI7aVswXT1vO2lbMV09byszO2JyZWFrO2Nhc2UgMTpjPXJbMTJdO2w9clsxM107aD1yWzE0XTt1PXJbMTVdO3JbMTJdPXU7clsxM109cyswO3JbMTRdPXMrMTtyWzE1XT1zKzI7cls4XT1oO3JbMTFdPXMrMztyWzRdPWw7cls3XT1zKzQ7clswXT1jO3JbMV09cys3O3JbMl09cys2O3JbM109cys1O2M9aVsyXTtsPWlbM107aVsyXT1sO2lbM109bztpWzBdPWM7aVsxXT1vKzE7YnJlYWs7Y2FzZSAyOmM9clsxNV07bD1yWzExXTtyWzEyXT1yWzNdO3JbMTNdPXMrMDtyWzE0XT1zKzE7clsxNV09cysyO3JbOF09cls3XTtyWzExXT1zKzM7cls0XT1sO3JbN109cys0O3JbMF09YztyWzFdPXMrNztyWzJdPXMrNjtyWzNdPXMrNTtjPWlbM107aVsyXT1pWzFdO2lbM109bztpWzBdPWM7aVsxXT1vKzE7YnJlYWs7Y2FzZSAzOnJbMTJdPXJbMF07clsxM109cyswO3JbMTRdPXMrMTtyWzE1XT1zKzI7cls4XT1yWzFdO3JbMTFdPXMrMztyWzRdPXJbMl07cls3XT1zKzQ7clswXT1yWzNdO3JbMV09cys3O3JbMl09cys2O3JbM109cys1O2lbMl09aVswXTtpWzNdPW87aVswXT1pWzFdO2lbMV09bysxfXJbNV09dC5sZW5ndGg7dC5wdXNoKFsoLTQqdFtyWzBdXVswXS10W3JbMTVdXVswXSs2Kih0W3JbNF1dWzBdK3RbclsxXV1bMF0pLTIqKHRbclsxMl1dWzBdK3RbclszXV1bMF0pKzMqKHRbclsxM11dWzBdK3Rbcls3XV1bMF0pKS85LCgtNCp0W3JbMF1dWzFdLXRbclsxNV1dWzFdKzYqKHRbcls0XV1bMV0rdFtyWzFdXVsxXSktMioodFtyWzEyXV1bMV0rdFtyWzNdXVsxXSkrMyoodFtyWzEzXV1bMV0rdFtyWzddXVsxXSkpLzldKTtyWzZdPXQubGVuZ3RoO3QucHVzaChbKC00KnRbclszXV1bMF0tdFtyWzEyXV1bMF0rNioodFtyWzJdXVswXSt0W3JbN11dWzBdKS0yKih0W3JbMF1dWzBdK3RbclsxNV1dWzBdKSszKih0W3JbNF1dWzBdK3RbclsxNF1dWzBdKSkvOSwoLTQqdFtyWzNdXVsxXS10W3JbMTJdXVsxXSs2Kih0W3JbMl1dWzFdK3Rbcls3XV1bMV0pLTIqKHRbclswXV1bMV0rdFtyWzE1XV1bMV0pKzMqKHRbcls0XV1bMV0rdFtyWzE0XV1bMV0pKS85XSk7cls5XT10Lmxlbmd0aDt0LnB1c2goWygtNCp0W3JbMTJdXVswXS10W3JbM11dWzBdKzYqKHRbcls4XV1bMF0rdFtyWzEzXV1bMF0pLTIqKHRbclswXV1bMF0rdFtyWzE1XV1bMF0pKzMqKHRbclsxMV1dWzBdK3RbclsxXV1bMF0pKS85LCgtNCp0W3JbMTJdXVsxXS10W3JbM11dWzFdKzYqKHRbcls4XV1bMV0rdFtyWzEzXV1bMV0pLTIqKHRbclswXV1bMV0rdFtyWzE1XV1bMV0pKzMqKHRbclsxMV1dWzFdK3RbclsxXV1bMV0pKS85XSk7clsxMF09dC5sZW5ndGg7dC5wdXNoKFsoLTQqdFtyWzE1XV1bMF0tdFtyWzBdXVswXSs2Kih0W3JbMTFdXVswXSt0W3JbMTRdXVswXSktMioodFtyWzEyXV1bMF0rdFtyWzNdXVswXSkrMyoodFtyWzJdXVswXSt0W3JbOF1dWzBdKSkvOSwoLTQqdFtyWzE1XV1bMV0tdFtyWzBdXVsxXSs2Kih0W3JbMTFdXVsxXSt0W3JbMTRdXVsxXSktMioodFtyWzEyXV1bMV0rdFtyWzNdXVsxXSkrMyoodFtyWzJdXVsxXSt0W3JbOF1dWzFdKSkvOV0pO3RoaXMuZmlndXJlcy5wdXNoKHt0eXBlOiJwYXRjaCIsY29vcmRzOm5ldyBJbnQzMkFycmF5KHIpLGNvbG9yczpuZXcgSW50MzJBcnJheShpKX0pfX1fZGVjb2RlVHlwZTdTaGFkaW5nKGUpe2NvbnN0IHQ9dGhpcy5jb29yZHMsYT10aGlzLmNvbG9ycyxyPW5ldyBJbnQzMkFycmF5KDE2KSxpPW5ldyBJbnQzMkFycmF5KDQpO2Zvcig7ZS5oYXNEYXRhOyl7Y29uc3Qgbj1lLnJlYWRGbGFnKCk7aWYoISgwPD1uJiZuPD0zKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlVua25vd24gdHlwZTcgZmxhZyIpO2NvbnN0IHM9dC5sZW5ndGg7Zm9yKGxldCBhPTAscj0wIT09bj8xMjoxNjthPHI7YSsrKXQucHVzaChlLnJlYWRDb29yZGluYXRlKCkpO2NvbnN0IG89YS5sZW5ndGg7Zm9yKGxldCB0PTAscj0wIT09bj8yOjQ7dDxyO3QrKylhLnB1c2goZS5yZWFkQ29tcG9uZW50cygpKTtsZXQgYyxsLGgsdTtzd2l0Y2gobil7Y2FzZSAwOnJbMTJdPXMrMztyWzEzXT1zKzQ7clsxNF09cys1O3JbMTVdPXMrNjtyWzhdPXMrMjtyWzldPXMrMTM7clsxMF09cysxNDtyWzExXT1zKzc7cls0XT1zKzE7cls1XT1zKzEyO3JbNl09cysxNTtyWzddPXMrODtyWzBdPXM7clsxXT1zKzExO3JbMl09cysxMDtyWzNdPXMrOTtpWzJdPW8rMTtpWzNdPW8rMjtpWzBdPW87aVsxXT1vKzM7YnJlYWs7Y2FzZSAxOmM9clsxMl07bD1yWzEzXTtoPXJbMTRdO3U9clsxNV07clsxMl09dTtyWzEzXT1zKzA7clsxNF09cysxO3JbMTVdPXMrMjtyWzhdPWg7cls5XT1zKzk7clsxMF09cysxMDtyWzExXT1zKzM7cls0XT1sO3JbNV09cys4O3JbNl09cysxMTtyWzddPXMrNDtyWzBdPWM7clsxXT1zKzc7clsyXT1zKzY7clszXT1zKzU7Yz1pWzJdO2w9aVszXTtpWzJdPWw7aVszXT1vO2lbMF09YztpWzFdPW8rMTticmVhaztjYXNlIDI6Yz1yWzE1XTtsPXJbMTFdO3JbMTJdPXJbM107clsxM109cyswO3JbMTRdPXMrMTtyWzE1XT1zKzI7cls4XT1yWzddO3JbOV09cys5O3JbMTBdPXMrMTA7clsxMV09cyszO3JbNF09bDtyWzVdPXMrODtyWzZdPXMrMTE7cls3XT1zKzQ7clswXT1jO3JbMV09cys3O3JbMl09cys2O3JbM109cys1O2M9aVszXTtpWzJdPWlbMV07aVszXT1vO2lbMF09YztpWzFdPW8rMTticmVhaztjYXNlIDM6clsxMl09clswXTtyWzEzXT1zKzA7clsxNF09cysxO3JbMTVdPXMrMjtyWzhdPXJbMV07cls5XT1zKzk7clsxMF09cysxMDtyWzExXT1zKzM7cls0XT1yWzJdO3JbNV09cys4O3JbNl09cysxMTtyWzddPXMrNDtyWzBdPXJbM107clsxXT1zKzc7clsyXT1zKzY7clszXT1zKzU7aVsyXT1pWzBdO2lbM109bztpWzBdPWlbMV07aVsxXT1vKzF9dGhpcy5maWd1cmVzLnB1c2goe3R5cGU6InBhdGNoIixjb29yZHM6bmV3IEludDMyQXJyYXkociksY29sb3JzOm5ldyBJbnQzMkFycmF5KGkpfSl9fV9idWlsZEZpZ3VyZUZyb21QYXRjaChlKXtjb25zdCB0PXRoaXMuZmlndXJlc1tlXTthc3NlcnQoInBhdGNoIj09PXQudHlwZSwiVW5leHBlY3RlZCBwYXRjaCBtZXNoIGZpZ3VyZSIpO2NvbnN0IGE9dGhpcy5jb29yZHMscj10aGlzLmNvbG9ycyxpPXQuY29vcmRzLG49dC5jb2xvcnMscz1NYXRoLm1pbihhW2lbMF1dWzBdLGFbaVszXV1bMF0sYVtpWzEyXV1bMF0sYVtpWzE1XV1bMF0pLG89TWF0aC5taW4oYVtpWzBdXVsxXSxhW2lbM11dWzFdLGFbaVsxMl1dWzFdLGFbaVsxNV1dWzFdKSxjPU1hdGgubWF4KGFbaVswXV1bMF0sYVtpWzNdXVswXSxhW2lbMTJdXVswXSxhW2lbMTVdXVswXSksbD1NYXRoLm1heChhW2lbMF1dWzFdLGFbaVszXV1bMV0sYVtpWzEyXV1bMV0sYVtpWzE1XV1bMV0pO2xldCBoPU1hdGguY2VpbCgoYy1zKSpNZXNoU2hhZGluZy5UUklBTkdMRV9ERU5TSVRZLyh0aGlzLmJvdW5kc1syXS10aGlzLmJvdW5kc1swXSkpO2g9TWF0aENsYW1wKGgsTWVzaFNoYWRpbmcuTUlOX1NQTElUX1BBVENIX0NIVU5LU19BTU9VTlQsTWVzaFNoYWRpbmcuTUFYX1NQTElUX1BBVENIX0NIVU5LU19BTU9VTlQpO2xldCB1PU1hdGguY2VpbCgobC1vKSpNZXNoU2hhZGluZy5UUklBTkdMRV9ERU5TSVRZLyh0aGlzLmJvdW5kc1szXS10aGlzLmJvdW5kc1sxXSkpO3U9TWF0aENsYW1wKHUsTWVzaFNoYWRpbmcuTUlOX1NQTElUX1BBVENIX0NIVU5LU19BTU9VTlQsTWVzaFNoYWRpbmcuTUFYX1NQTElUX1BBVENIX0NIVU5LU19BTU9VTlQpO2NvbnN0IGQ9aCsxLGY9bmV3IEludDMyQXJyYXkoKHUrMSkqZCksZz1uZXcgSW50MzJBcnJheSgodSsxKSpkKTtsZXQgcD0wO2NvbnN0IG09bmV3IFVpbnQ4QXJyYXkoMyksYj1uZXcgVWludDhBcnJheSgzKSx5PXJbblswXV0sdz1yW25bMV1dLHg9cltuWzJdXSxTPXJbblszXV0saz1nZXRCKHUpLEM9Z2V0QihoKTtmb3IobGV0IGU9MDtlPD11O2UrKyl7bVswXT0oeVswXSoodS1lKSt4WzBdKmUpL3V8MDttWzFdPSh5WzFdKih1LWUpK3hbMV0qZSkvdXwwO21bMl09KHlbMl0qKHUtZSkreFsyXSplKS91fDA7YlswXT0od1swXSoodS1lKStTWzBdKmUpL3V8MDtiWzFdPSh3WzFdKih1LWUpK1NbMV0qZSkvdXwwO2JbMl09KHdbMl0qKHUtZSkrU1syXSplKS91fDA7Zm9yKGxldCB0PTA7dDw9aDt0KysscCsrKXtpZighKDAhPT1lJiZlIT09dXx8MCE9PXQmJnQhPT1oKSljb250aW51ZTtsZXQgbj0wLHM9MCxvPTA7Zm9yKGxldCByPTA7cjw9MztyKyspZm9yKGxldCBjPTA7Yzw9MztjKyssbysrKXtjb25zdCBsPWtbZV1bcl0qQ1t0XVtjXTtuKz1hW2lbb11dWzBdKmw7cys9YVtpW29dXVsxXSpsfWZbcF09YS5sZW5ndGg7YS5wdXNoKFtuLHNdKTtnW3BdPXIubGVuZ3RoO2NvbnN0IGM9bmV3IFVpbnQ4QXJyYXkoMyk7Y1swXT0obVswXSooaC10KStiWzBdKnQpL2h8MDtjWzFdPShtWzFdKihoLXQpK2JbMV0qdCkvaHwwO2NbMl09KG1bMl0qKGgtdCkrYlsyXSp0KS9ofDA7ci5wdXNoKGMpfX1mWzBdPWlbMF07Z1swXT1uWzBdO2ZbaF09aVszXTtnW2hdPW5bMV07ZltkKnVdPWlbMTJdO2dbZCp1XT1uWzJdO2ZbZCp1K2hdPWlbMTVdO2dbZCp1K2hdPW5bM107dGhpcy5maWd1cmVzW2VdPXt0eXBlOiJsYXR0aWNlIixjb29yZHM6Zixjb2xvcnM6Zyx2ZXJ0aWNlc1BlclJvdzpkfX1fdXBkYXRlQm91bmRzKCl7bGV0IGU9dGhpcy5jb29yZHNbMF1bMF0sdD10aGlzLmNvb3Jkc1swXVsxXSxhPWUscj10O2ZvcihsZXQgaT0xLG49dGhpcy5jb29yZHMubGVuZ3RoO2k8bjtpKyspe2NvbnN0IG49dGhpcy5jb29yZHNbaV1bMF0scz10aGlzLmNvb3Jkc1tpXVsxXTtlPWU+bj9uOmU7dD10PnM/czp0O2E9YTxuP246YTtyPXI8cz9zOnJ9dGhpcy5ib3VuZHM9W2UsdCxhLHJdfV9wYWNrRGF0YSgpe2xldCBlLHQsYSxyO2NvbnN0IGk9dGhpcy5jb29yZHMsbj1uZXcgRmxvYXQzMkFycmF5KDIqaS5sZW5ndGgpO2ZvcihlPTAsYT0wLHQ9aS5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1pW2VdO25bYSsrXT10WzBdO25bYSsrXT10WzFdfXRoaXMuY29vcmRzPW47Y29uc3Qgcz10aGlzLmNvbG9ycyxvPW5ldyBVaW50OEFycmF5KDMqcy5sZW5ndGgpO2ZvcihlPTAsYT0wLHQ9cy5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1zW2VdO29bYSsrXT10WzBdO29bYSsrXT10WzFdO29bYSsrXT10WzJdfXRoaXMuY29sb3JzPW87Y29uc3QgYz10aGlzLmZpZ3VyZXM7Zm9yKGU9MCx0PWMubGVuZ3RoO2U8dDtlKyspe2NvbnN0IHQ9Y1tlXSxpPXQuY29vcmRzLG49dC5jb2xvcnM7Zm9yKGE9MCxyPWkubGVuZ3RoO2E8cjthKyspe2lbYV0qPTI7blthXSo9M319fWdldElSKCl7Y29uc3R7Ym91bmRzOmV9PXRoaXM7aWYoZVsyXS1lWzBdPT0wfHxlWzNdLWVbMV09PTApdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIE1lc2hTaGFkaW5nIGJvdW5kczogWyR7ZX1dLmApO3JldHVyblsiTWVzaCIsdGhpcy5zaGFkaW5nVHlwZSx0aGlzLmNvb3Jkcyx0aGlzLmNvbG9ycyx0aGlzLmZpZ3VyZXMsZSx0aGlzLmJib3gsdGhpcy5iYWNrZ3JvdW5kXX19Y2xhc3MgRHVtbXlTaGFkaW5nIGV4dGVuZHMgQmFzZVNoYWRpbmd7Z2V0SVIoKXtyZXR1cm5bIkR1bW15Il19fWZ1bmN0aW9uIGdldFRpbGluZ1BhdHRlcm5JUihlLHQsYSl7Y29uc3Qgcj1sb29rdXBNYXRyaXgodC5nZXRBcnJheSgiTWF0cml4IiksbGEpLGk9bG9va3VwTm9ybWFsUmVjdCh0LmdldEFycmF5KCJCQm94IiksbnVsbCk7aWYoIWl8fGlbMl0taVswXT09MHx8aVszXS1pWzFdPT0wKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBnZXRUaWxpbmdQYXR0ZXJuSVIgL0JCb3ggYXJyYXkuIik7Y29uc3Qgbj10LmdldCgiWFN0ZXAiKTtpZigibnVtYmVyIiE9dHlwZW9mIG4pdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIGdldFRpbGluZ1BhdHRlcm5JUiAvWFN0ZXAgdmFsdWUuIik7Y29uc3Qgcz10LmdldCgiWVN0ZXAiKTtpZigibnVtYmVyIiE9dHlwZW9mIHMpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIGdldFRpbGluZ1BhdHRlcm5JUiAvWVN0ZXAgdmFsdWUuIik7Y29uc3Qgbz10LmdldCgiUGFpbnRUeXBlIik7aWYoIU51bWJlci5pc0ludGVnZXIobykpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIGdldFRpbGluZ1BhdHRlcm5JUiAvUGFpbnRUeXBlIHZhbHVlLiIpO2NvbnN0IGM9dC5nZXQoIlRpbGluZ1R5cGUiKTtpZighTnVtYmVyLmlzSW50ZWdlcihjKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkludmFsaWQgZ2V0VGlsaW5nUGF0dGVybklSIC9UaWxpbmdUeXBlIHZhbHVlLiIpO3JldHVyblsiVGlsaW5nUGF0dGVybiIsYSxlLHIsaSxuLHMsbyxjXX1jb25zdCB1aT1bMS4zODc3LDEsMSwxLC45NzgwMSwuOTI0ODIsLjg5NTUyLC45MTEzMywuODE5ODgsLjk3NTY2LC45ODE1MiwuOTM1NDgsLjkzNTQ4LDEuMjc5OCwuODUyODQsLjkyNzk0LDEsLjk2MTM0LDEuNTQ2NTcsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC44Mjg0NSwuODI4NDUsLjg1Mjg0LC44NTI4NCwuODUyODQsLjc1ODU5LC45MjEzOCwuODM5MDgsLjc3NjIsLjczMjkzLC44NzI4OSwuNzMxMzMsLjc1MTQsLjgxOTIxLC44NzM1NiwuOTU5NTgsLjU5NTI2LC43NTcyNywuNjkyMjUsMS4wNDkyNCwuOTEyMSwuODY5NDMsLjc5Nzk1LC44ODE5OCwuNzc5NTgsLjcwODY0LC44MTA1NSwuOTAzOTksLjg4NjUzLC45NjAxNywuODI1NzcsLjc3ODkyLC43ODI1NywuOTc1MDcsMS41NDY1NywuOTc1MDcsLjg1Mjg0LC44OTU1MiwuOTAxNzYsLjg4NzYyLC44Nzg1LC43NTI0MSwuODc4NSwuOTA1MTgsLjk1MDE1LC43NzYxOCwuODc4NSwuODg0MDEsLjkxOTE2LC44NjMwNCwuODg0MDEsLjkxNDg4LC44Nzg1LC44ODAxLC44Nzg1LC44Nzg1LC45MTM0MywuNzE3MywxLjA0MTA2LC44Nzg1LC44NTA3NSwuOTU3OTQsLjgyNjE2LC44NTE2MiwuNzk0OTIsLjg4MzMxLDEuNjk4MDgsLjg4MzMxLC44NTI4NCwuOTc4MDEsLjg5NTUyLC45MTEzMywuODk1NTIsLjkxMTMzLDEuNzgwMSwuODk1NTIsMS4yNDQ4NywxLjEzMjU0LDEuMTI0MDEsLjk2ODM5LC44NTI4NCwuNjg3ODcsLjcwNjQ1LC44NTU5MiwuOTA3NDcsMS4wMTQ2NiwxLjAwODgsLjkwMzIzLDEsMS4wNzQ2MywxLC45MTA1NiwuNzU4MDYsMS4xOTExOCwuOTY4MzksLjc4ODY0LC44Mjg0NSwuODQxMzMsLjc1ODU5LC44MzkwOCwuODM5MDgsLjgzOTA4LC44MzkwOCwuODM5MDgsLjgzOTA4LC43NzUzOSwuNzMyOTMsLjczMTMzLC43MzEzMywuNzMxMzMsLjczMTMzLC45NTk1OCwuOTU5NTgsLjk1OTU4LC45NTk1OCwuODg1MDYsLjkxMjEsLjg2OTQzLC44Njk0MywuODY5NDMsLjg2OTQzLC44Njk0MywuODUyODQsLjg3NTA4LC45MDM5OSwuOTAzOTksLjkwMzk5LC45MDM5OSwuNzc4OTIsLjc5Nzk1LC45MDgwNywuODg3NjIsLjg4NzYyLC44ODc2MiwuODg3NjIsLjg4NzYyLC44ODc2MiwuODcxNSwuNzUyNDEsLjkwNTE4LC45MDUxOCwuOTA1MTgsLjkwNTE4LC44ODQwMSwuODg0MDEsLjg4NDAxLC44ODQwMSwuODc4NSwuODc4NSwuODgwMSwuODgwMSwuODgwMSwuODgwMSwuODgwMSwuOTA3NDcsLjg5MDQ5LC44Nzg1LC44Nzg1LC44Nzg1LC44Nzg1LC44NTE2MiwuODc4NSwuODUxNjIsLjgzOTA4LC44ODc2MiwuODM5MDgsLjg4NzYyLC44MzkwOCwuODg3NjIsLjczMjkzLC43NTI0MSwuNzMyOTMsLjc1MjQxLC43MzI5MywuNzUyNDEsLjczMjkzLC43NTI0MSwuODcyODksLjgzMDE2LC44ODUwNiwuOTMxMjUsLjczMTMzLC45MDUxOCwuNzMxMzMsLjkwNTE4LC43MzEzMywuOTA1MTgsLjczMTMzLC45MDUxOCwuNzMxMzMsLjkwNTE4LC44MTkyMSwuNzc2MTgsLjgxOTIxLC43NzYxOCwuODE5MjEsLjc3NjE4LDEsMSwuODczNTYsLjg3ODUsLjkxMDc1LC44OTYwOCwuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjk1OTU4LC44ODQwMSwuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjc2MjI5LC45MDE2NywuNTk1MjYsLjkxOTE2LDEsMSwuODYzMDQsLjY5MjI1LC44ODQwMSwxLDEsLjcwNDI0LC43OTQ2OCwuOTE5MjYsLjg4MTc1LC43MDgyMywuOTQ5MDMsLjkxMjEsLjg3ODUsMSwxLC45MTIxLC44Nzg1LC44NzgwMiwuODg2NTYsLjg3ODUsLjg2OTQzLC44ODAxLC44Njk0MywuODgwMSwuODY5NDMsLjg4MDEsLjg3NDAyLC44OTI5MSwuNzc5NTgsLjkxMzQzLDEsMSwuNzc5NTgsLjkxMzQzLC43MDg2NCwuNzE3MywuNzA4NjQsLjcxNzMsLjcwODY0LC43MTczLC43MDg2NCwuNzE3MywxLDEsLjgxMDU1LC43NTg0MSwuODEwNTUsMS4wNjQ1MiwuOTAzOTksLjg3ODUsLjkwMzk5LC44Nzg1LC45MDM5OSwuODc4NSwuOTAzOTksLjg3ODUsLjkwMzk5LC44Nzg1LC45MDM5OSwuODc4NSwuOTYwMTcsLjk1Nzk0LC43Nzg5MiwuODUxNjIsLjc3ODkyLC43ODI1NywuNzk0OTIsLjc4MjU3LC43OTQ5MiwuNzgyNTcsLjc5NDkyLC45Mjk3LC41Njg5MiwuODM5MDgsLjg4NzYyLC43NzUzOSwuODcxNSwuODc1MDgsLjg5MDQ5LDEsMSwuODEwNTUsMS4wNDEwNiwxLjIwNTI4LDEuMjA1MjgsMSwxLjE1NTQzLC43MDY3NCwuOTgzODcsLjk0NzIxLDEuMzM0MzEsMS40NTg5NCwuOTUxNjEsMS4wNjMwMywuODM5MDgsLjgwMzUyLC41NzE4NCwuNjk2NSwuNTYyODksLjgyMDAxLC41NjAyOSwuODEyMzUsMS4wMjk4OCwuODM5MDgsLjc3NjIsLjY4MTU2LC44MDM2NywuNzMxMzMsLjc4MjU3LC44NzM1NiwuODY5NDMsLjk1OTU4LC43NTcyNywuODkwMTksMS4wNDkyNCwuOTEyMSwuNzY0OCwuODY5NDMsLjg3MzU2LC43OTc5NSwuNzgyNzUsLjgxMDU1LC43Nzg5MiwuOTc2MiwuODI1NzcsLjk5ODE5LC44NDg5NiwuOTU5NTgsLjc3ODkyLC45NjEwOCwxLjAxNDA3LC44OTA0OSwxLjAyOTg4LC45NDIxMSwuOTYxMDgsLjg5MzYsLjg0MDIxLC44Nzg0MiwuOTYzOTksLjc5MTA5LC44OTA0OSwxLjAwODEzLDEuMDI5ODgsLjg2MDc3LC44NzQ0NSwuOTIwOTksLjg0NzIzLC44NjUxMywuODgwMSwuNzU2MzgsLjg1NzE0LC43ODIxNiwuNzk1ODYsLjg3OTY1LC45NDIxMSwuOTc3NDcsLjc4Mjg3LC45NzkyNiwuODQ5NzEsMS4wMjk4OCwuOTQyMTEsLjg4MDEsLjk0MjExLC44NDk3MSwuNzMxMzMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjkwMjY0LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45MDUxOCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTA1NDgsMSwxLDEsMSwxLDEsLjk2MDE3LC45NTc5NCwuOTYwMTcsLjk1Nzk0LC45NjAxNywuOTU3OTQsLjc3ODkyLC44NTE2MiwxLDEsLjg5NTUyLC45MDUyNywxLC45MDM2MywuOTI3OTQsLjkyNzk0LC45Mjc5NCwuOTI3OTQsLjg3MDEyLC44NzAxMiwuODcwMTIsLjg5NTUyLC44OTU1MiwxLjQyMjU5LC43MTE0MywxLjA2MTUyLDEsMSwxLjAzMzcyLDEuMDMzNzIsLjk3MTcxLDEuNDk1NiwyLjI4MDcsLjkzODM1LC44MzQwNiwuOTExMzMsLjg0MTA3LC45MTEzMywxLDEsMSwuNzIwMjEsMSwxLjIzMTA4LC44MzQ4OSwuODg1MjUsLjg4NTI1LC44MTQ5OSwuOTA1MjcsMS44MTA1NSwuOTA1MjcsMS44MTA1NSwxLjMxMDA2LDEuNTM3MTEsLjk0NDM0LDEuMDg2OTYsMSwuOTUwMTgsLjc3MTkyLC44NTI4NCwuOTA3NDcsMS4xNzUzNCwuNjk4MjUsLjk3MTYsMS4zNzA3NywuOTA3NDcsLjkwNzQ3LC44NTM1NiwuOTA3NDcsLjkwNzQ3LDEuNDQ5NDcsLjg1Mjg0LC44OTQxLC44OTQxLC43MDU3MiwuOCwuNzA1NzIsLjcwNTcyLC43MDU3MiwuNzA1NzIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45OTg2MiwuOTk4NjIsMSwxLDEsMSwxLDEuMDgwMDQsLjkxMDI3LDEsMSwxLC45OTg2MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTA3MjcsLjkwNzI3LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSxkaT17bGluZUhlaWdodDoxLjIyMDcsbGluZUdhcDouMjIwN30sZmk9WzEuMzg3NywxLDEsMSwuOTc4MDEsLjkyNDgyLC44OTU1MiwuOTExMzMsLjgxOTg4LC45NzU2NiwuOTgxNTIsLjkzNTQ4LC45MzU0OCwxLjI3OTgsLjg1Mjg0LC45Mjc5NCwxLC45NjEzNCwxLjU2MjM5LC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuODI4NDUsLjgyODQ1LC44NTI4NCwuODUyODQsLjg1Mjg0LC43NTg1OSwuOTIxMzgsLjgzOTA4LC43NzYyLC43MTgwNSwuODcyODksLjczMTMzLC43NTE0LC44MTkyMSwuODczNTYsLjk1OTU4LC41OTUyNiwuNzU3MjcsLjY5MjI1LDEuMDQ5MjQsLjkwODcyLC44NTkzOCwuNzk3OTUsLjg3MDY4LC43Nzk1OCwuNjk3NjYsLjgxMDU1LC45MDM5OSwuODg2NTMsLjk2MDY4LC44MjU3NywuNzc4OTIsLjc4MjU3LC45NzUwNywxLjUyOSwuOTc1MDcsLjg1Mjg0LC44OTU1MiwuOTAxNzYsLjk0OTA4LC44NjQxMSwuNzQwMTIsLjg2NDExLC44ODMyMywuOTUwMTUsLjg2NDExLC44NjMzMSwuODg0MDEsLjkxOTE2LC44NjMwNCwuODg0MDEsLjkwMzksLjg2MzMxLC44NjMzMSwuODY0MTEsLjg2NDExLC45MDQ2NCwuNzA4NTIsMS4wNDEwNiwuODYzMzEsLjg0MzcyLC45NTc5NCwuODI2MTYsLjg0NTQ4LC43OTQ5MiwuODgzMzEsMS42OTgwOCwuODgzMzEsLjg1Mjg0LC45NzgwMSwuODk1NTIsLjkxMTMzLC44OTU1MiwuOTExMzMsMS43ODAxLC44OTU1MiwxLjI0NDg3LDEuMTMyNTQsMS4xOTEyOSwuOTY4MzksLjg1Mjg0LC42ODc4NywuNzA2NDUsLjg1NTkyLC45MDc0NywxLjAxNDY2LDEuMDA4OCwuOTAzMjMsMSwxLjA3NDYzLDEsLjkxMDU2LC43NTgwNiwxLjE5MTE4LC45NjgzOSwuNzg4NjQsLjgyODQ1LC44NDEzMywuNzU4NTksLjgzOTA4LC44MzkwOCwuODM5MDgsLjgzOTA4LC44MzkwOCwuODM5MDgsLjc3NTM5LC43MTgwNSwuNzMxMzMsLjczMTMzLC43MzEzMywuNzMxMzMsLjk1OTU4LC45NTk1OCwuOTU5NTgsLjk1OTU4LC44ODUwNiwuOTA4NzIsLjg1OTM4LC44NTkzOCwuODU5MzgsLjg1OTM4LC44NTkzOCwuODUyODQsLjg3MDY4LC45MDM5OSwuOTAzOTksLjkwMzk5LC45MDM5OSwuNzc4OTIsLjc5Nzk1LC45MDgwNywuOTQ5MDgsLjk0OTA4LC45NDkwOCwuOTQ5MDgsLjk0OTA4LC45NDkwOCwuODU4ODcsLjc0MDEyLC44ODMyMywuODgzMjMsLjg4MzIzLC44ODMyMywuODg0MDEsLjg4NDAxLC44ODQwMSwuODg0MDEsLjg3ODUsLjg2MzMxLC44NjMzMSwuODYzMzEsLjg2MzMxLC44NjMzMSwuODYzMzEsLjkwNzQ3LC44OTA0OSwuODYzMzEsLjg2MzMxLC44NjMzMSwuODYzMzEsLjg0NTQ4LC44NjQxMSwuODQ1NDgsLjgzOTA4LC45NDkwOCwuODM5MDgsLjk0OTA4LC44MzkwOCwuOTQ5MDgsLjcxODA1LC43NDAxMiwuNzE4MDUsLjc0MDEyLC43MTgwNSwuNzQwMTIsLjcxODA1LC43NDAxMiwuODcyODksLjc5NTM4LC44ODUwNiwuOTI3MjYsLjczMTMzLC44ODMyMywuNzMxMzMsLjg4MzIzLC43MzEzMywuODgzMjMsLjczMTMzLC44ODMyMywuNzMxMzMsLjg4MzIzLC44MTkyMSwuODY0MTEsLjgxOTIxLC44NjQxMSwuODE5MjEsLjg2NDExLDEsMSwuODczNTYsLjg2MzMxLC45MTA3NSwuODc3NywuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjk1OTU4LC44ODQwMSwuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjc2NDY3LC45MDE2NywuNTk1MjYsLjkxOTE2LDEsMSwuODYzMDQsLjY5MjI1LC44ODQwMSwxLDEsLjcwNDI0LC43NzMxMiwuOTE5MjYsLjg4MTc1LC43MDgyMywuOTQ5MDMsLjkwODcyLC44NjMzMSwxLDEsLjkwODcyLC44NjMzMSwuODY5MDYsLjg4MTE2LC44NjMzMSwuODU5MzgsLjg2MzMxLC44NTkzOCwuODYzMzEsLjg1OTM4LC44NjMzMSwuODc0MDIsLjg2NTQ5LC43Nzk1OCwuOTA0NjQsMSwxLC43Nzk1OCwuOTA0NjQsLjY5NzY2LC43MDg1MiwuNjk3NjYsLjcwODUyLC42OTc2NiwuNzA4NTIsLjY5NzY2LC43MDg1MiwxLDEsLjgxMDU1LC43NTg0MSwuODEwNTUsMS4wNjQ1MiwuOTAzOTksLjg2MzMxLC45MDM5OSwuODYzMzEsLjkwMzk5LC44NjMzMSwuOTAzOTksLjg2MzMxLC45MDM5OSwuODYzMzEsLjkwMzk5LC44NjMzMSwuOTYwNjgsLjk1Nzk0LC43Nzg5MiwuODQ1NDgsLjc3ODkyLC43ODI1NywuNzk0OTIsLjc4MjU3LC43OTQ5MiwuNzgyNTcsLjc5NDkyLC45Mjk3LC41Njg5MiwuODM5MDgsLjk0OTA4LC43NzUzOSwuODU4ODcsLjg3MDY4LC44OTA0OSwxLDEsLjgxMDU1LDEuMDQxMDYsMS4yMDUyOCwxLjIwNTI4LDEsMS4xNTU0MywuNzAwODgsLjk4Mzg3LC45NDcyMSwxLjMzNDMxLDEuNDU4OTQsLjk1MTYxLDEuNDgzODcsLjgzOTA4LC44MDM1MiwuNTcxMTgsLjY5NjUsLjU2MzQ3LC43OTE3OSwuNTU4NTMsLjgwMzQ2LDEuMDI5ODgsLjgzOTA4LC43NzYyLC42NzE3NCwuODYwMzYsLjczMTMzLC43ODI1NywuODczNTYsLjg2NDQxLC45NTk1OCwuNzU3MjcsLjg5MDE5LDEuMDQ5MjQsLjkwODcyLC43NDg4OSwuODU5MzgsLjg3ODkxLC43OTc5NSwuNzk1NywuODEwNTUsLjc3ODkyLC45NzQ0NywuODI1NzcsLjk3NDY2LC44NzE3OSwuOTU5NTgsLjc3ODkyLC45NDI1MiwuOTU2MTIsLjg3NTMsMS4wMjk4OCwuOTI3MzMsLjk0MjUyLC44NzQxMSwuODQwMjEsLjg3MjgsLjk1NjEyLC43NDA4MSwuODc1MywxLjAyMTg5LDEuMDI5ODgsLjg0ODE0LC44NzQ0NSwuOTE4MjIsLjg0NzIzLC44NTY2OCwuODYzMzEsLjgxMzQ0LC44NzU4MSwuNzY0MjIsLjgyMDQ2LC45NjA1NywuOTI3MzMsLjk5Mzc1LC43ODAyMiwuOTU0NTIsLjg2MDE1LDEuMDI5ODgsLjkyNzMzLC44NjMzMSwuOTI3MzMsLjg2MDE1LC43MzEzMywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTA2MzEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjg4MzIzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44NTE3NCwxLDEsMSwxLDEsMSwuOTYwNjgsLjk1Nzk0LC45NjA2OCwuOTU3OTQsLjk2MDY4LC45NTc5NCwuNzc4OTIsLjg0NTQ4LDEsMSwuODk1NTIsLjkwNTI3LDEsLjkwMzYzLC45Mjc5NCwuOTI3OTQsLjkyNzk0LC44OTgwNywuODcwMTIsLjg3MDEyLC44NzAxMiwuODk1NTIsLjg5NTUyLDEuNDIyNTksLjcxMDk0LDEuMDYxNTIsMSwxLDEuMDMzNzIsMS4wMzM3MiwuOTcxNzEsMS40OTU2LDIuMjgwNywuOTI5NzIsLjgzNDA2LC45MTEzMywuODMzMjYsLjkxMTMzLDEsMSwxLC43MjAyMSwxLDEuMjMxMDgsLjgzNDg5LC44ODUyNSwuODg1MjUsLjgxNDk5LC45MDYxNiwxLjgxMDU1LC45MDUyNywxLjgxMDU1LDEuMzEwNywxLjUzNzExLC45NDQzNCwxLjA4Njk2LDEsLjk1MDE4LC43NzE5MiwuODUyODQsLjkwNzQ3LDEuMTc1MzQsLjY5ODI1LC45NzE2LDEuMzcwNzcsLjkwNzQ3LC45MDc0NywuODUzNTYsLjkwNzQ3LC45MDc0NywxLjQ0OTQ3LC44NTI4NCwuODk0MSwuODk0MSwuNzA1NzIsLjgsLjcwNTcyLC43MDU3MiwuNzA1NzIsLjcwNTcyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTk4NjIsLjk5ODYyLDEsMSwxLDEsMSwxLjA4MDA0LC45MTAyNywxLDEsMSwuOTk4NjIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjkwNzI3LC45MDcyNywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sZ2k9e2xpbmVIZWlnaHQ6MS4yMjA3LGxpbmVHYXA6LjIyMDd9LHBpPVsxLjM4NzcsMSwxLDEsMS4xNzIyMywxLjEyOTMsLjg5NTUyLC45MTEzMywuODAzOTUsMS4wMjI2OSwxLjE1NjAxLC45MTA1NiwuOTEwNTYsMS4yNzk4LC44NTI4NCwuODk4MDcsMSwuOTA4NjEsMS4zOTU0MywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjk2MzA5LC45NjMwOSwuODUyODQsLjg1Mjg0LC44NTI4NCwuODMzMTksLjg4MDcxLC44Njc1LC44MTU1MiwuNzIzNDYsLjg1MTkzLC43MzIwNiwuNzUyMiwuODExMDUsLjg2Mjc1LC45MDY4NSwuNjM3NywuNzc4OTIsLjc1NTkzLDEuMDI2MzgsLjg5MjQ5LC44NDExOCwuNzc0NTIsLjg1Mzc0LC43NTE4NiwuNjc3ODksLjc5Nzc2LC44ODg0NCwuODUwNjYsLjk0MzA5LC43NzgxOCwuNzMwNiwuNzY2NTksMS4xMDM2OSwxLjM4MzEzLDEuMTAzNjksMS4wNjEzOSwuODk1NTIsLjg3MzksLjkyNDUsLjkyNDUsLjgzMjAzLC45MjQ1LC44NTg2NSwxLjA5ODQyLC45MjQ1LC45MjQ1LDEuMDMyOTcsMS4wNzY5MiwuOTA5MTgsMS4wMzI5NywuOTQ5NTksLjkyNDUsLjkyMjc0LC45MjQ1LC45MjQ1LDEuMDI5MzMsLjc3ODMyLDEuMjA1NjIsLjkyNDUsLjg5MTYsLjk4OTg2LC44NjYyMSwuODk0NTMsLjc5MDA0LC45NDE1MiwxLjc3MjU2LC45NDE1MiwuODUyODQsLjk3ODAxLC44OTU1MiwuOTExMzMsLjg5NTUyLC45MTEzMywxLjkxNzI5LC44OTU1MiwxLjE3ODg5LDEuMTMyNTQsMS4xNjM1OSwuOTIwOTgsLjg1Mjg0LC42ODc4NywuNzEzNTMsLjg0NzM3LC45MDc0NywxLjAwODgsMS4wMDQ0LC44NzY4MywxLDEuMDkwOTEsMSwuOTIyMjksLjczOSwxLjE1NjQyLC45MjA5OCwuNzYyODgsLjgwNTA0LC44MDk3MiwuNzU4NTksLjg2NzUsLjg2NzUsLjg2NzUsLjg2NzUsLjg2NzUsLjg2NzUsLjc2MzE4LC43MjM0NiwuNzMyMDYsLjczMjA2LC43MzIwNiwuNzMyMDYsLjkwNjg1LC45MDY4NSwuOTA2ODUsLjkwNjg1LC44NjQ3NywuODkyNDksLjg0MTE4LC44NDExOCwuODQxMTgsLjg0MTE4LC44NDExOCwuODUyODQsLjg0NTU3LC44ODg0NCwuODg4NDQsLjg4ODQ0LC44ODg0NCwuNzMwNiwuNzc0NTIsLjg2MzMxLC45MjQ1LC45MjQ1LC45MjQ1LC45MjQ1LC45MjQ1LC45MjQ1LC44NDg0MywuODMyMDMsLjg1ODY1LC44NTg2NSwuODU4NjUsLjg1ODY1LC44MjYwMSwuODI2MDEsLjgyNjAxLC44MjYwMSwuOTQ0NjksLjkyNDUsLjkyMjc0LC45MjI3NCwuOTIyNzQsLjkyMjc0LC45MjI3NCwuOTA3NDcsLjg2NjUxLC45MjQ1LC45MjQ1LC45MjQ1LC45MjQ1LC44OTQ1MywuOTI0NSwuODk0NTMsLjg2NzUsLjkyNDUsLjg2NzUsLjkyNDUsLjg2NzUsLjkyNDUsLjcyMzQ2LC44MzIwMywuNzIzNDYsLjgzMjAzLC43MjM0NiwuODMyMDMsLjcyMzQ2LC44MzIwMywuODUxOTMsLjg4NzUsLjg2NDc3LC45OTAzNCwuNzMyMDYsLjg1ODY1LC43MzIwNiwuODU4NjUsLjczMjA2LC44NTg2NSwuNzMyMDYsLjg1ODY1LC43MzIwNiwuODU4NjUsLjgxMTA1LC45MjQ1LC44MTEwNSwuOTI0NSwuODExMDUsLjkyNDUsMSwxLC44NjI3NSwuOTI0NSwuOTA4NzIsLjkzNTkxLC45MDY4NSwuODI2MDEsLjkwNjg1LC44MjYwMSwuOTA2ODUsLjgyNjAxLC45MDY4NSwxLjAzMjk3LC45MDY4NSwuODI2MDEsLjc3ODk2LDEuMDU2MTEsLjYzNzcsMS4wNzY5MiwxLDEsLjkwOTE4LC43NTU5MywxLjAzMjk3LDEsMSwuNzYwMzIsLjkzNzUsLjk4MTU2LC45MzQwNywuNzcyNjEsMS4xMTQyOSwuODkyNDksLjkyNDUsMSwxLC44OTI0OSwuOTI0NSwuOTI1MzQsLjg2Njk4LC45MjQ1LC44NDExOCwuOTIyNzQsLjg0MTE4LC45MjI3NCwuODQxMTgsLjkyMjc0LC44NjY3LC44NjI5MSwuNzUxODYsMS4wMjkzMywxLDEsLjc1MTg2LDEuMDI5MzMsLjY3Nzg5LC43NzgzMiwuNjc3ODksLjc3ODMyLC42Nzc4OSwuNzc4MzIsLjY3Nzg5LC43NzgzMiwxLDEsLjc5Nzc2LC45NzY1NSwuNzk3NzYsMS4yMzAyMywuODg4NDQsLjkyNDUsLjg4ODQ0LC45MjQ1LC44ODg0NCwuOTI0NSwuODg4NDQsLjkyNDUsLjg4ODQ0LC45MjQ1LC44ODg0NCwuOTI0NSwuOTQzMDksLjk4OTg2LC43MzA2LC44OTQ1MywuNzMwNiwuNzY2NTksLjc5MDA0LC43NjY1OSwuNzkwMDQsLjc2NjU5LC43OTAwNCwxLjA5MjMxLC41NDg3MywuODY3NSwuOTI0NSwuNzYzMTgsLjg0ODQzLC44NDU1NywuODY2NTEsMSwxLC43OTc3NiwxLjIwNTYyLDEuMTg2MjIsMS4xODYyMiwxLDEuMTQzNywuNjcwMDksLjk2MzM0LC45MzY5NSwxLjM1MTkxLDEuNDA5MDksLjk1MTYxLDEuNDgzODcsLjg2NzUsLjkwODYxLC42MTkyLC43MzYzLC42NDgyNCwuODI0MTEsLjU2MzIxLC44NTY5NiwxLjIzNTE2LC44Njc1LC44MTU1MiwuNzI4NiwuODQxMzQsLjczMjA2LC43NjY1OSwuODYyNzUsLjg0MzY5LC45MDY4NSwuNzc4OTIsLjg1ODcxLDEuMDI2MzgsLjg5MjQ5LC43NTgyOCwuODQxMTgsLjg1OTg0LC43NzQ1MiwuNzY0NjYsLjc5Nzc2LC43MzA2LC45MDc4MiwuNzc4MTgsLjkwMywuODcyOTEsLjkwNjg1LC43MzA2LC45OTA1OCwxLjAzNjY3LC45NDYzNSwxLjIzNTE2LC45ODQ5LC45OTA1OCwuOTIzOTMsLjg5MTYsLjk0MiwxLjAzNjY3LC43NTAyNiwuOTQ2MzUsMS4wMjk3LDEuMjM1MTYsLjkwOTE4LC45NDA0OCwuOTgyMTcsLjg5NzQ2LC44NDE1MywuOTIyNzQsLjgyNTA3LC44ODgzMiwuODQ0MzgsLjg4MTc4LDEuMDM1MjUsLjk4NDksMS4wMDIyNSwuNzgwODYsLjk3MjQ4LC44OTQwNCwxLjIzNTE2LC45ODQ5LC45MjI3NCwuOTg0OSwuODk0MDQsLjczMjA2LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44OTY5MywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuODU4NjUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjkwOTMzLDEsMSwxLDEsMSwxLC45NDMwOSwuOTg5ODYsLjk0MzA5LC45ODk4NiwuOTQzMDksLjk4OTg2LC43MzA2LC44OTQ1MywxLDEsLjg5NTUyLC45MDUyNywxLC45MDE4NiwxLjEyMzA4LDEuMTIzMDgsMS4xMjMwOCwxLjEyMzA4LDEuMjU2NiwxLjI1NjYsMS4yNTY2LC44OTU1MiwuODk1NTIsMS40MjI1OSwuNjg5OTQsMS4wMzgwOSwxLDEsMS4wMTc2LDEuMDE3NiwxLjExNTIzLDEuNDk1NiwyLjAxNDYyLC45Nzg1OCwuODI2MTYsLjkxMTMzLC44MzQzNywuOTExMzMsMSwxLDEsLjcwNTA4LDEsMS4yMzEwOCwuNzk4MDEsLjg0NDI2LC44NDQyNiwuNzc0LC45MDU3MiwxLjgxMDU1LC45MDc0OSwxLjgxMDU1LDEuMjg4MDksMS41NTQ2OSwuOTQ0MzQsMS4wNzgwNiwxLC45NzA5NCwuNzU4OSwuODUyODQsLjkwNzQ3LDEuMTk2NTgsLjY5ODI1LC45NzYyMiwxLjMzNTEyLC45MDc0NywuOTA3NDcsLjg1Mjg0LC45MDc0NywuOTA3NDcsMS40NDk0NywuODUyODQsLjg5NDEsLjg5NDEsLjcwNTcyLC44LC43MDU3MiwuNzA1NzIsLjcwNTcyLC43MDU3MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjk5ODYyLC45OTg2MiwxLDEsMSwxLDEsMS4wMzM2LC45MTAyNywxLDEsMSwuOTk4NjIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wNTg1OSwxLjA1ODU5LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSxtaT17bGluZUhlaWdodDoxLjIyMDcsbGluZUdhcDouMjIwN30sYmk9WzEuMzg3NywxLDEsMSwxLjE3MjIzLDEuMTI5MywuODk1NTIsLjkxMTMzLC44MDM5NSwxLjAyMjY5LDEuMTU2MDEsLjkxMDU2LC45MTA1NiwxLjI3OTgsLjg1Mjg0LC44OTgwNywxLC45MDg2MSwxLjM5MDE2LC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTYzMDksLjk2MzA5LC44NTI4NCwuODUyODQsLjg1Mjg0LC44MzMxOSwuODgwNzEsLjg2NzUsLjgxNTUyLC43MzgzNCwuODUxOTMsLjczMjA2LC43NTIyLC44MTEwNSwuODYyNzUsLjkwNjg1LC42Mzc3LC43Nzg5MiwuNzU1OTMsMS4wMjYzOCwuODkzODUsLjg1MTIyLC43NzQ1MiwuODY1MDMsLjc1MTg2LC42ODg4NywuNzk3NzYsLjg4ODQ0LC44NTA2NiwuOTQyNTgsLjc3ODE4LC43MzA2LC43NjY1OSwxLjEwMzY5LDEuMzkwMTYsMS4xMDM2OSwxLjA2MTM5LC44OTU1MiwuODczOSwuODYxMjgsLjk0NDY5LC44NDU3LC45NDQ2OSwuODk0NjQsMS4wOTg0MiwuODQ2MzYsLjk0NDY5LDEuMDMyOTcsMS4wNzY5MiwuOTA5MTgsMS4wMzI5NywuOTU4OTcsLjk0NDY5LC45NDgyLC45NDQ2OSwuOTQ0NjksMS4wNDY5MiwuNzgyMjMsMS4yMDU2MiwuOTQ0NjksLjkwMzMyLC45ODk4NiwuODY2MjEsLjkwNTI3LC43OTAwNCwuOTQxNTIsMS43NzI1NiwuOTQxNTIsLjg1Mjg0LC45NzgwMSwuODk1NTIsLjkxMTMzLC44OTU1MiwuOTExMzMsMS45MTcyOSwuODk1NTIsMS4xNzg4OSwxLjEzMjU0LDEuMDg3MDcsLjkyMDk4LC44NTI4NCwuNjg3ODcsLjcxMzUzLC44NDczNywuOTA3NDcsMS4wMDg4LDEuMDA0NCwuODc2ODMsMSwxLjA5MDkxLDEsLjkyMjI5LC43MzksMS4xNTY0MiwuOTIwOTgsLjc2Mjg4LC44MDUwNCwuODA5NzIsLjc1ODU5LC44Njc1LC44Njc1LC44Njc1LC44Njc1LC44Njc1LC44Njc1LC43NjMxOCwuNzM4MzQsLjczMjA2LC43MzIwNiwuNzMyMDYsLjczMjA2LC45MDY4NSwuOTA2ODUsLjkwNjg1LC45MDY4NSwuODY0NzcsLjg5Mzg1LC44NTEyMiwuODUxMjIsLjg1MTIyLC44NTEyMiwuODUxMjIsLjg1Mjg0LC44NTMxMSwuODg4NDQsLjg4ODQ0LC44ODg0NCwuODg4NDQsLjczMDYsLjc3NDUyLC44NjMzMSwuODYxMjgsLjg2MTI4LC44NjEyOCwuODYxMjgsLjg2MTI4LC44NjEyOCwuODY5MywuODQ1NywuODk0NjQsLjg5NDY0LC44OTQ2NCwuODk0NjQsLjgyNjAxLC44MjYwMSwuODI2MDEsLjgyNjAxLC45NDQ2OSwuOTQ0NjksLjk0ODIsLjk0ODIsLjk0ODIsLjk0ODIsLjk0ODIsLjkwNzQ3LC44NjY1MSwuOTQ0NjksLjk0NDY5LC45NDQ2OSwuOTQ0NjksLjkwNTI3LC45NDQ2OSwuOTA1MjcsLjg2NzUsLjg2MTI4LC44Njc1LC44NjEyOCwuODY3NSwuODYxMjgsLjczODM0LC44NDU3LC43MzgzNCwuODQ1NywuNzM4MzQsLjg0NTcsLjczODM0LC44NDU3LC44NTE5MywuOTI0NTQsLjg2NDc3LC45OTIxLC43MzIwNiwuODk0NjQsLjczMjA2LC44OTQ2NCwuNzMyMDYsLjg5NDY0LC43MzIwNiwuODk0NjQsLjczMjA2LC44OTQ2NCwuODExMDUsLjg0NjM2LC44MTEwNSwuODQ2MzYsLjgxMTA1LC44NDYzNiwxLDEsLjg2Mjc1LC45NDQ2OSwuOTA4NzIsLjk1Nzg2LC45MDY4NSwuODI2MDEsLjkwNjg1LC44MjYwMSwuOTA2ODUsLjgyNjAxLC45MDY4NSwxLjAzMjk3LC45MDY4NSwuODI2MDEsLjc3NzQxLDEuMDU2MTEsLjYzNzcsMS4wNzY5MiwxLDEsLjkwOTE4LC43NTU5MywxLjAzMjk3LDEsMSwuNzYwMzIsLjkwNDUyLC45ODE1NiwxLjExODQyLC43NzI2MSwxLjExNDI5LC44OTM4NSwuOTQ0NjksMSwxLC44OTM4NSwuOTQ0NjksLjk1ODc3LC44NjkwMSwuOTQ0NjksLjg1MTIyLC45NDgyLC44NTEyMiwuOTQ4MiwuODUxMjIsLjk0ODIsLjg2NjcsLjkwMDE2LC43NTE4NiwxLjA0NjkyLDEsMSwuNzUxODYsMS4wNDY5MiwuNjg4ODcsLjc4MjIzLC42ODg4NywuNzgyMjMsLjY4ODg3LC43ODIyMywuNjg4ODcsLjc4MjIzLDEsMSwuNzk3NzYsLjkyMTg4LC43OTc3NiwxLjIzMDIzLC44ODg0NCwuOTQ0NjksLjg4ODQ0LC45NDQ2OSwuODg4NDQsLjk0NDY5LC44ODg0NCwuOTQ0NjksLjg4ODQ0LC45NDQ2OSwuODg4NDQsLjk0NDY5LC45NDI1OCwuOTg5ODYsLjczMDYsLjkwNTI3LC43MzA2LC43NjY1OSwuNzkwMDQsLjc2NjU5LC43OTAwNCwuNzY2NTksLjc5MDA0LDEuMDkyMzEsLjU0ODczLC44Njc1LC44NjEyOCwuNzYzMTgsLjg2OTMsLjg1MzExLC44NjY1MSwxLDEsLjc5Nzc2LDEuMjA1NjIsMS4xODYyMiwxLjE4NjIyLDEsMS4xNDM3LC42Nzc0MiwuOTYzMzQsLjkzNjk1LDEuMzUxOTEsMS40MDkwOSwuOTUxNjEsMS40ODM4NywuODY2ODYsLjkwODYxLC42MjI2NywuNzQzNTksLjY1NjQ5LC44NTQ5OCwuNTY5NjMsLjg4MjU0LDEuMjM1MTYsLjg2NzUsLjgxNTUyLC43NTQ0MywuODQ1MDMsLjczMjA2LC43NjY1OSwuODYyNzUsLjg1MTIyLC45MDY4NSwuNzc4OTIsLjg1NzQ2LDEuMDI2MzgsLjg5Mzg1LC43NTY1NywuODUxMjIsLjg2Mjc1LC43NzQ1MiwuNzQxNzEsLjc5Nzc2LC43MzA2LC45NTE2NSwuNzc4MTgsLjg5NzcyLC44ODgzMSwuOTA2ODUsLjczMDYsLjk4MTQyLDEuMDIxOTEsLjk2NTc2LDEuMjM1MTYsLjk5MDE4LC45ODE0MiwuOTIzNiwuODkyNTgsLjk0MDM1LDEuMDIxOTEsLjc4ODQ4LC45NjU3NiwuOTU2MSwxLjIzNTE2LC45MDkxOCwuOTI1NzgsLjk1NDI0LC44OTc0NiwuODM5NjksLjk0ODIsLjgwMTEzLC44OTQ0MiwuODUyMDgsLjg2MTU1LC45ODAyMiwuOTkwMTgsMS4wMDQ1MiwuODEyMDksLjk5MjQ3LC44OTE4MSwxLjIzNTE2LC45OTAxOCwuOTQ4MiwuOTkwMTgsLjg5MTgxLC43MzIwNiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuODg4NDQsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjg5NDY0LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45Njc2NiwxLDEsMSwxLDEsMSwuOTQyNTgsLjk4OTg2LC45NDI1OCwuOTg5ODYsLjk0MjU4LC45ODk4NiwuNzMwNiwuOTA1MjcsMSwxLC44OTU1MiwuOTA1MjcsMSwuOTAxODYsMS4xMjMwOCwxLjEyMzA4LDEuMTIzMDgsMS4xMjMwOCwxLjI1NjYsMS4yNTY2LDEuMjU2NiwuODk1NTIsLjg5NTUyLDEuNDIyNTksLjY5MDQzLDEuMDM4MDksMSwxLDEuMDE3NiwxLjAxNzYsMS4xMTUyMywxLjQ5NTYsMi4wMTQ2MiwuOTkzMzEsLjgyNjE2LC45MTEzMywuODQyODYsLjkxMTMzLDEsMSwxLC43MDUwOCwxLDEuMjMxMDgsLjc5ODAxLC44NDQyNiwuODQ0MjYsLjc3NCwuOTA1MjcsMS44MTA1NSwuOTA1MjcsMS44MTA1NSwxLjI4ODA5LDEuNTU0NjksLjk0NDM0LDEuMDc4MDYsMSwuOTcwOTQsLjc1ODksLjg1Mjg0LC45MDc0NywxLjE5NjU4LC42OTgyNSwuOTc2MjIsMS4zMzUxMiwuOTA3NDcsLjkwNzQ3LC44NTM1NiwuOTA3NDcsLjkwNzQ3LDEuNDQ5NDcsLjg1Mjg0LC44OTQxLC44OTQxLC43MDU3MiwuOCwuNzA1NzIsLjcwNTcyLC43MDU3MiwuNzA1NzIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45OTg2MiwuOTk4NjIsMSwxLDEsMSwxLDEuMDMzNiwuOTEwMjcsMSwxLDEsLjk5ODYyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDU4NTksMS4wNTg1OSwxLDEsMSwxLjA3MTg1LC45OTQxMywuOTYzMzQsMS4wODA2NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLHlpPXtsaW5lSGVpZ2h0OjEuMjIwNyxsaW5lR2FwOi4yMjA3fSx3aT1bLjc2MTE2LDEsMSwxLjAwMDYsLjk5OTk4LC45OTk3NCwuOTk5NzMsLjk5OTczLC45OTk4MiwuOTk5NzcsMS4wMDA4NywuOTk5OTgsLjk5OTk4LC45OTk1OSwxLjAwMDAzLDEuMDAwNiwuOTk5OTgsMS4wMDA2LDEuMDAwNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTk4LDEsMS4wMDAwMywxLjAwMDAzLDEuMDAwMDMsMS4wMDAyNiwuOTk5OSwuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsMS4wMDAwMSwxLjAwMDI2LDEuMDAwMjIsLjk5OTc3LDEuMDAwNiwuOTk5NzMsLjk5OTc3LDEuMDAwMjYsLjk5OTk5LC45OTk3NywxLjAwMDIyLDEuMDAwMDEsMS4wMDAyMiwuOTk5NzcsMS4wMDAwMSwxLjAwMDI2LC45OTk3NywxLjAwMDAxLDEuMDAwMTYsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMjYsLjk5OTk4LDEuMDAwNiwuOTk5OTgsMS4wMDAwMywuOTk5NzMsLjk5OTk4LC45OTk3MywxLjAwMDI2LC45OTk3MywxLjAwMDI2LC45OTk3MywuOTk5OTgsMS4wMDAyNiwxLjAwMDI2LDEuMDAwNiwxLjAwMDYsLjk5OTczLDEuMDAwNiwuOTk5ODIsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwuOTk5NTksLjk5OTczLC45OTk5OCwxLjAwMDI2LC45OTk3MywxLjAwMDIyLC45OTk3MywuOTk5NzMsMSwuOTk5NTksMS4wMDA3NywuOTk5NTksMS4wMDAwMywuOTk5OTgsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDAwNzcsLjk5OTczLC45OTk5OCwxLjAwMDI1LC45OTk2OCwuOTk5NzMsMS4wMDAwMywxLjAwMDI1LC42MDI5OSwxLjAwMDI0LDEuMDY0MDksMSwxLC45OTk5OCwxLC45OTk3MywxLjAwMDYsLjk5OTk4LDEsLjk5OTM2LC45OTk3MywxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDI2LC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LDEsLjk5OTc3LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk3NywuOTk5NzcsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMDMsMS4wMDAyMiwuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMjYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTgyLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wNjQwOSwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsLjk5OTczLDEuMDAwMjYsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LDEuMDMzNzQsLjk5OTc3LDEuMDAwMjYsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDQyLC45OTk3MywuOTk5NzMsMS4wMDA2LC45OTk3NywuOTk5NzMsLjk5OTczLDEuMDAwMjYsMS4wMDA2LDEuMDAwMjYsMS4wMDA2LDEuMDAwMjYsMS4wMzgyOCwxLjAwMDI2LC45OTk5OSwxLjAwMDI2LDEuMDAwNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5MywuOTk5OCwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEsMS4wMDAxNiwuOTk5NzcsLjk5OTU5LC45OTk3NywuOTk5NTksLjk5OTc3LC45OTk1OSwxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDI2LC45OTk5OCwxLjAwMDI2LC44MTIxLDEuMDAwMjYsLjk5OTk4LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LDEuMDAwMTYsMS4wMDAyMiwxLjAwMDAxLC45OTk3MywxLjAwMDAxLDEuMDAwMjYsMSwxLjAwMDI2LDEsMS4wMDAyNiwxLDEuMDAwNiwuOTk5NzMsLjk5OTc3LC45OTk3MywxLC45OTk4MiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAwMSwuOTk5NzMsMS4wMDAyNiwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LDEuMDAwMzQsLjk5OTc3LDEsLjk5OTk3LDEuMDAwMjYsMS4wMDA3OCwxLjAwMDM2LC45OTk3MywxLjAwMDEzLDEuMDAwNiwuOTk5NzcsLjk5OTc3LC45OTk4OCwuODUxNDgsMS4wMDAwMSwxLjAwMDI2LC45OTk3NywxLjAwMDIyLDEuMDAwNiwuOTk5NzcsMS4wMDAwMSwuOTk5OTksLjk5OTc3LDEuMDAwNjksMS4wMDAyMiwuOTk5NzcsMS4wMDAwMSwuOTk5ODQsMS4wMDAyNiwxLjAwMDAxLDEuMDAwMjQsMS4wMDAwMSwuOTk5OSwxLDEuMDAwNiwxLjAwMDAxLDEuMDAwNDEsLjk5OTYyLDEuMDAwMjYsMS4wMDA2LC45OTk5NSwxLjAwMDQxLC45OTk0MiwuOTk5NzMsLjk5OTI3LDEuMDAwODIsLjk5OTAyLDEuMDAwMjYsMS4wMDA4NywxLjAwMDYsMS4wMDA2OSwuOTk5NzMsLjk5ODY3LC45OTk3MywuOTk5MywxLjAwMDI2LDEuMDAwNDksMS4wMDA1NiwxLC45OTk4OCwuOTk5MzUsLjk5OTk1LC45OTk1NCwxLjAwMDU1LC45OTk0NSwxLjAwMDMyLDEuMDAwNiwuOTk5OTUsMS4wMDAyNiwuOTk5OTUsMS4wMDAzMiwxLjAwMDAxLDEuMDAwMDgsLjk5OTcxLDEuMDAwMTksLjk5OTQsMS4wMDAwMSwxLjAwMDYsMS4wMDA0NCwuOTk5NzMsMS4wMDAyMywxLjAwMDQ3LDEsLjk5OTQyLC45OTU2MSwuOTk5ODksMS4wMDAzNSwuOTk5NzcsMS4wMDAzNSwuOTk5NzcsMS4wMDAxOSwuOTk5NDQsMS4wMDAwMSwxLjAwMDIxLC45OTkyNiwxLjAwMDM1LDEuMDAwMzUsLjk5OTQyLDEuMDAwNDgsLjk5OTk5LC45OTk3NywxLjAwMDIyLDEuMDAwMzUsMS4wMDAwMSwuOTk5NzcsMS4wMDAyNiwuOTk5ODksMS4wMDA1NywxLjAwMDAxLC45OTkzNiwxLjAwMDUyLDEuMDAwMTIsLjk5OTk2LDEuMDAwNDMsMSwxLjAwMDM1LC45OTk0LC45OTk3NiwxLjAwMDM1LC45OTk3MywxLjAwMDUyLDEuMDAwNDEsMS4wMDExOSwxLjAwMDM3LC45OTk3MywxLjAwMDAyLC45OTk4NiwxLjAwMDQxLDEuMDAwNDEsLjk5OTAyLC45OTk2LDEuMDAwMzQsLjk5OTk5LDEuMDAwMjYsLjk5OTk5LDEuMDAwMjYsLjk5OTczLDEuMDAwNTIsLjk5OTczLDEsLjk5OTczLDEuMDAwNDEsMS4wMDA3NSwuOTk5NCwxLjAwMDMsLjk5OTk5LDEsMS4wMDA0MSwuOTk5NTUsMSwuOTk5MTUsLjk5OTczLC45OTk3MywxLjAwMDI2LDEuMDAxMTksLjk5OTU1LC45OTk3MywxLjAwMDYsLjk5OTExLDEuMDAwNiwxLjAwMDI2LC45OTk3MiwxLjAwMDI2LC45OTkwMiwxLjAwMDQxLC45OTk3MywuOTk5OTksMSwxLDEuMDAwMzgsMS4wMDA1LDEuMDAwMTYsMS4wMDAyMiwxLjAwMDE2LDEuMDAwMjIsMS4wMDAxNiwxLjAwMDIyLDEuMDAwMDEsLjk5OTczLDEsMSwuOTk5NzMsMSwxLC45OTk1NSwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMSwxLDEsLjk5OTczLC45OTk3MywuOTk5NzIsMSwxLDEuMDAxMDYsLjk5OTk5LC45OTk5OCwuOTk5OTgsLjk5OTk5LC45OTk5OCwxLjY2NDc1LDEsLjk5OTczLC45OTk3MywxLjAwMDIzLC45OTk3MywuOTk5NzEsMS4wMDA0NywxLjAwMDIzLDEsLjk5OTkxLC45OTk4NCwxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEsMSwxLDEsMSwxLDEsLjk5OTcyLDEsMS4yMDk4NSwxLjM5NzEzLDEuMDAwMDMsMS4wMDAzMSwxLjAwMDE1LDEsLjk5NTYxLDEuMDAwMjcsMS4wMDAzMSwxLjAwMDMxLC45OTkxNSwxLjAwMDMxLDEuMDAwMzEsLjk5OTk5LDEuMDAwMDMsLjk5OTk5LC45OTk5OSwxLjQxMTQ0LDEuNiwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDA1NzksMS40MDU3OSwxLjM2NjI1LC45OTk5OSwxLC45OTg2MSwuOTk4NjEsMSwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LC45OTk3MiwuOTk5OTksLjk5OTk5LC45OTk5OSwuOTk5OTksMS40MDQ4MywxLC45OTk3NywxLjAwMDU0LDEsMSwuOTk5NTMsLjk5OTYyLDEuMDAwNDIsLjk5OTUsMSwxLDEsMSwxLDEsMSwxLC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLHhpPXtsaW5lSGVpZ2h0OjEuMixsaW5lR2FwOi4yfSxTaT1bLjc2MTE2LDEsMSwxLjAwMDYsLjk5OTk4LC45OTk3NCwuOTk5NzMsLjk5OTczLC45OTk4MiwuOTk5NzcsMS4wMDA4NywuOTk5OTgsLjk5OTk4LC45OTk1OSwxLjAwMDAzLDEuMDAwNiwuOTk5OTgsMS4wMDA2LDEuMDAwNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTk4LDEsMS4wMDAwMywxLjAwMDAzLDEuMDAwMDMsMS4wMDAyNiwuOTk5OSwuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsMS4wMDAwMSwxLjAwMDI2LDEuMDAwMjIsLjk5OTc3LDEuMDAwNiwuOTk5NzMsLjk5OTc3LDEuMDAwMjYsLjk5OTk5LC45OTk3NywxLjAwMDIyLDEuMDAwMDEsMS4wMDAyMiwuOTk5NzcsMS4wMDAwMSwxLjAwMDI2LC45OTk3NywxLjAwMDAxLDEuMDAwMTYsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMjYsLjk5OTk4LDEuMDAwNiwuOTk5OTgsMS4wMDAwMywuOTk5NzMsLjk5OTk4LC45OTk3MywxLjAwMDI2LC45OTk3MywxLjAwMDI2LC45OTk3MywuOTk5OTgsMS4wMDAyNiwxLjAwMDI2LDEuMDAwNiwxLjAwMDYsLjk5OTczLDEuMDAwNiwuOTk5ODIsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwuOTk5NTksLjk5OTczLC45OTk5OCwxLjAwMDI2LC45OTk3MywxLjAwMDIyLC45OTk3MywuOTk5NzMsMSwuOTk5NTksMS4wMDA3NywuOTk5NTksMS4wMDAwMywuOTk5OTgsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDAwNzcsLjk5OTczLC45OTk5OCwxLjAwMDI1LC45OTk2OCwuOTk5NzMsMS4wMDAwMywxLjAwMDI1LC42MDI5OSwxLjAwMDI0LDEuMDY0MDksMSwxLC45OTk5OCwxLC45OTk3MywxLjAwMDYsLjk5OTk4LDEsLjk5OTM2LC45OTk3MywxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDI2LC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LDEsLjk5OTc3LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk3NywuOTk5NzcsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMDMsMS4wMDAyMiwuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMjYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTgyLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wNjQwOSwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsLjk5OTczLDEuMDAwMjYsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LDEuMDA0NCwuOTk5NzcsMS4wMDAyNiwxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk3MSwuOTk5NzMsLjk5OTczLDEuMDAwNiwuOTk5NzcsLjk5OTczLC45OTk3MywxLjAwMDI2LDEuMDAwNiwxLjAwMDI2LDEuMDAwNiwxLjAwMDI2LDEuMDEwMTEsMS4wMDAyNiwuOTk5OTksMS4wMDAyNiwxLjAwMDYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTMsLjk5OTgsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwxLDEuMDAwMTYsLjk5OTc3LC45OTk1OSwuOTk5NzcsLjk5OTU5LC45OTk3NywuOTk5NTksMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAyNiwuOTk5OTgsMS4wMDAyNiwuODEyMSwxLjAwMDI2LC45OTk5OCwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwxLjAwMDE2LDEuMDAwMjIsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwxLjAwMDI2LDEsMS4wMDAyNiwxLDEuMDAwMjYsMSwxLjAwMDYsLjk5OTczLC45OTk3NywuOTk5NzMsMSwuOTk5ODIsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMDEsLjk5OTczLDEuMDAwMjYsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTc3LDEsMSwxLjAwMDI2LC45OTk2OSwuOTk5NzIsLjk5OTgxLC45OTk4LDEuMDAwNiwuOTk5NzcsLjk5OTc3LDEuMDAwMjIsLjkxMTU1LDEuMDAwMDEsMS4wMDAyNiwuOTk5NzcsMS4wMDAyMiwxLjAwMDYsLjk5OTc3LDEuMDAwMDEsLjk5OTk5LC45OTk3NywuOTk5NjYsMS4wMDAyMiwxLjAwMDMyLDEuMDAwMDEsLjk5OTQ0LDEuMDAwMjYsMS4wMDAwMSwuOTk5NjgsMS4wMDAwMSwxLjAwMDQ3LDEsMS4wMDA2LDEuMDAwMDEsLjk5OTgxLDEuMDAxMDEsMS4wMDAyNiwxLjAwMDYsLjk5OTQ4LC45OTk4MSwxLjAwMDY0LC45OTk3MywuOTk5NDIsMS4wMDEwMSwxLjAwMDYxLDEuMDAwMjYsMS4wMDA2OSwxLjAwMDYsMS4wMDAxNCwuOTk5NzMsMS4wMTMyMiwuOTk5NzMsMS4wMDA2NSwxLjAwMDI2LDEuMDAwMTIsLjk5OTIzLDEsMS4wMDA2NCwxLjAwMDc2LC45OTk0OCwxLjAwMDU1LDEuMDAwNjMsMS4wMDAwNywuOTk5NDMsMS4wMDA2LC45OTk0OCwxLjAwMDI2LC45OTk0OCwuOTk5NDMsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMjksMS4wMDAzOCwxLjAwMDM1LDEuMDAwMDEsMS4wMDA2LDEuMDAwNiwuOTk5NzMsLjk5OTc4LDEuMDAwMDEsMS4wMDA1NywuOTk5ODksLjk5OTY3LC45OTk2NCwuOTk5NjcsLjk5OTc3LC45OTk5OSwuOTk5NzcsMS4wMDAzOCwuOTk5NzcsMS4wMDAwMSwuOTk5NzMsMS4wMDA2NiwuOTk5NjcsLjk5OTY3LDEuMDAwNDEsLjk5OTk4LC45OTk5OSwuOTk5NzcsMS4wMDAyMiwuOTk5NjcsMS4wMDAwMSwuOTk5NzcsMS4wMDAyNiwuOTk5NjQsMS4wMDAzMSwxLjAwMDAxLC45OTk5OSwuOTk5OTksMSwxLjAwMDIzLDEsMSwuOTk5OTksMS4wMDAzNSwxLjAwMDAxLC45OTk5OSwuOTk5NzMsLjk5OTc3LC45OTk5OSwxLjAwMDU4LC45OTk3MywuOTk5NzMsLjk5OTU1LC45OTk1LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDMyLC45OTk4OSwxLjAwMDM0LC45OTk5OSwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwuOTk5NzMsLjQ1OTk4LC45OTk3MywxLjAwMDI2LC45OTk3MywxLjAwMDAxLC45OTk5OSwuOTk5ODIsLjk5OTk0LC45OTk5NiwxLDEuMDAwNDIsMS4wMDA0NCwxLjAwMDI5LDEuMDAwMjMsLjk5OTczLC45OTk3MywxLjAwMDI2LC45OTk0OSwxLjAwMDAyLC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwuOTk5NzUsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMzIsLjk4Njg1LC45OTk3MywxLjAwMDI2LDEsMSwuOTk5NjYsMS4wMDA0NCwxLjAwMDE2LDEuMDAwMjIsMS4wMDAxNiwxLjAwMDIyLDEuMDAwMTYsMS4wMDAyMiwxLjAwMDAxLC45OTk3MywxLDEsLjk5OTczLDEsMSwuOTk5NTUsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEsMSwxLC45OTk3MywuOTk5NzMsLjk5OTcyLDEsMSwxLjAwMTA2LC45OTk5OSwuOTk5OTgsLjk5OTk4LC45OTk5OSwuOTk5OTgsMS42NjQ3NSwxLC45OTk3MywuOTk5NzMsMSwuOTk5NzMsLjk5OTcxLC45OTk3OCwxLDEsLjk5OTkxLC45OTk4NCwxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwOTgsMSwxLDEsMS4wMDA0OSwxLDEsLjk5OTcyLDEsMS4yMDk4NSwxLjM5NzEzLDEuMDAwMDMsMS4wMDAzMSwxLjAwMDE1LDEsLjk5NTYxLDEuMDAwMjcsMS4wMDAzMSwxLjAwMDMxLC45OTkxNSwxLjAwMDMxLDEuMDAwMzEsLjk5OTk5LDEuMDAwMDMsLjk5OTk5LC45OTk5OSwxLjQxMTQ0LDEuNiwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDA1NzksMS40MDU3OSwxLjM2NjI1LC45OTk5OSwxLC45OTg2MSwuOTk4NjEsMSwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LC45OTk3MiwuOTk5OTksLjk5OTk5LC45OTk5OSwuOTk5OTksMS40MDQ4MywxLC45OTk3NywxLjAwMDU0LDEsMSwuOTk5NTMsLjk5OTYyLDEuMDAwNDIsLjk5OTUsMSwxLDEsMSwxLDEsMSwxLC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLEFpPXtsaW5lSGVpZ2h0OjEuMzUsbGluZUdhcDouMn0sa2k9Wy43NjExNiwxLDEsMS4wMDA2LDEuMDAwNiwxLjAwMDA2LC45OTk3MywuOTk5NzMsLjk5OTgyLDEuMDAwMDEsMS4wMDA0MywuOTk5OTgsLjk5OTk4LC45OTk1OSwxLjAwMDAzLDEuMDAwNiwuOTk5OTgsMS4wMDA2LDEuMDAwNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA2LDEsMS4wMDAwMywxLjAwMDAzLDEuMDAwMDMsLjk5OTczLC45OTk4NywxLjAwMDAxLDEuMDAwMDEsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMjYsMS4wMDAyMiwuOTk5NzcsMS4wMDA2LDEsMS4wMDAwMSwuOTk5NzMsLjk5OTk5LC45OTk3NywxLjAwMDIyLDEuMDAwMDEsMS4wMDAyMiwuOTk5NzcsMS4wMDAwMSwxLjAwMDI2LC45OTk3NywxLjAwMDAxLDEuMDAwMTYsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMjYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTQ5LC45OTk3MywuOTk5OTgsLjk5OTczLC45OTk3MywxLC45OTk3MywuOTk5NzMsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTI0LC45OTkyNCwxLC45OTkyNCwuOTk5OTksLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk5OCwxLDEuMDAwNiwuOTk5NzMsMSwuOTk5NzcsMSwxLDEsMS4wMDAwNSwxLjAwMDksMS4wMDAwNSwxLjAwMDAzLC45OTk5OCwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA5LC45OTk3MywuOTk5OTgsMS4wMDAyNSwuOTk5NjgsLjk5OTczLDEuMDAwMDMsMS4wMDAyNSwuNjAyOTksMS4wMDAyNCwxLjA2NDA5LDEsMSwuOTk5OTgsMSwuOTk5OCwxLjAwMDYsLjk5OTk4LDEsLjk5OTM2LC45OTk3MywxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDI2LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEsLjk5OTc3LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk3NywuOTk5NzcsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMDMsMS4wMDAyMiwuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMjYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTgyLDEsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wNjQwOSwxLjAwMDI2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLC45OTk3MywxLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLC45OTk3NywxLC45OTk3NywxLC45OTk3NywxLC45OTk3NywxLC45OTk3NywxLjAyODgsLjk5OTc3LC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDIyLC45OTk3MywxLjAwMDIyLC45OTk3MywxLjAwMDIyLC45OTk3MywxLjAwMDIyLC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTkyNCwxLjAwMDYsMS4wMDA2LC45OTk0NiwxLjAwMDM0LDEsLjk5OTI0LDEuMDAwMDEsMSwxLC45OTk3MywuOTk5MjQsLjk5OTczLC45OTkyNCwuOTk5NzMsMS4wNjMxMSwuOTk5NzMsMS4wMDAyNCwuOTk5NzMsLjk5OTI0LC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLDEuMDAwNDEsLjk5OTgsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEsMS4wMDAxNiwuOTk5NzcsLjk5OTk4LC45OTk3NywuOTk5OTgsLjk5OTc3LC45OTk5OCwxLjAwMDAxLDEsMS4wMDAwMSwxLDEuMDAwMDEsMSwxLjAwMDAxLDEsMS4wMDAyNiwxLjAwMDYsMS4wMDAyNiwuODk1NDcsMS4wMDAyNiwxLjAwMDYsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsMS4wMDAxNiwuOTk5NzcsMS4wMDAwMSwxLDEuMDAwMDEsMS4wMDAyNiwxLDEuMDAwMjYsMSwxLjAwMDI2LDEsLjk5OTI0LC45OTk3MywxLjAwMDAxLC45OTk3MywxLC45OTk4MiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAwMSwxLDEuMDAwMjYsMS4wMDA2LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsMS4wMDAwMSwxLDEuMDAwNTQsLjk5OTc3LDEuMDAwODQsMS4wMDAwNywuOTk5NzMsMS4wMDAxMywuOTk5MjQsMS4wMDAwMSwxLjAwMDAxLC45OTk0NSwuOTEyMjEsMS4wMDAwMSwxLjAwMDI2LC45OTk3NywxLjAwMDIyLDEuMDAwNiwxLjAwMDAxLDEuMDAwMDEsLjk5OTk5LC45OTk3NywuOTk5MzMsMS4wMDAyMiwxLjAwMDU0LDEuMDAwMDEsMS4wMDA2NSwxLjAwMDI2LDEuMDAwMDEsMS4wMDAxLDEuMDAwMDEsMS4wMDA1MiwxLDEuMDAwNiwxLjAwMDAxLC45OTk0NSwuOTk4OTcsLjk5OTY4LC45OTkyNCwxLjAwMDM2LC45OTk0NSwuOTk5NDksMSwxLjAwMDYsLjk5ODk3LC45OTkxOCwuOTk5NjgsLjk5OTExLC45OTkyNCwxLC45OTk2MiwxLjAxNDg3LDEsMS4wMDA1LC45OTk3MywxLjAwMDEyLDEuMDAwNDMsMSwuOTk5OTUsLjk5OTk0LDEuMDAwMzYsLjk5OTQ3LDEuMDAwMTksMS4wMDA2MywxLjAwMDI1LC45OTkyNCwxLjAwMDM2LC45OTk3MywxLjAwMDM2LDEuMDAwMjUsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMjcsMS4wMDAxLDEuMDAwNjgsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LDEsMS4wMDAwOCwuOTk5NTcsLjk5OTcyLC45OTk0LC45OTk1NCwuOTk5NzUsMS4wMDA1MSwxLjAwMDAxLDEuMDAwMTksMS4wMDAwMSwxLjAwMDEsLjk5OTg2LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDM4LC45OTk1NCwuOTk5NTQsLjk5OTQsMS4wMDA2NiwuOTk5OTksLjk5OTc3LDEuMDAwMjIsMS4wMDA1NCwxLjAwMDAxLC45OTk3NywxLjAwMDI2LC45OTk3NSwxLjAwMDEsMS4wMDAwMSwuOTk5OTMsLjk5OTUsLjk5OTU1LDEuMDAwMTYsLjk5OTc4LC45OTk3NCwxLjAwMDE5LDEuMDAwMjIsLjk5OTU1LDEuMDAwNTMsLjk5OTczLDEuMDAwODksMS4wMDAwNSwuOTk5NjcsMS4wMDA0OCwuOTk5NzMsMS4wMDAwMiwxLjAwMDM0LC45OTk3MywuOTk5NzMsLjk5OTY0LDEuMDAwMDYsMS4wMDA2NiwuOTk5NDcsLjk5OTczLC45ODg5NCwuOTk5NzMsMSwuNDQ4OTgsMSwuOTk5NDYsMSwxLjAwMDM5LDEuMDAwODIsLjk5OTkxLC45OTk5MSwuOTk5ODUsMS4wMDAyMiwxLjAwMDIzLDEuMDAwNjEsMS4wMDAwNiwuOTk5NjYsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDAxOSwxLjAwMDgsMSwuOTk5MjQsLjk5OTI0LC45OTkyNCwuOTk5ODMsMS4wMDA0NCwuOTk5NzMsLjk5OTY0LC45ODMzMiwxLC45OTk3MywxLDEsLjk5OTYyLC45OTg5NSwxLjAwMDE2LC45OTk3NywxLjAwMDE2LC45OTk3NywxLjAwMDE2LC45OTk3NywxLjAwMDAxLDEsMSwxLC45OTk3MywxLDEsLjk5OTU1LC45OTkyNCwuOTk5MjQsLjk5OTI0LC45OTkyNCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5NzMsLjk5OTczLC45OTk3MiwxLDEsMS4wMDI2NywuOTk5OTksLjk5OTk4LC45OTk5OCwxLC45OTk5OCwxLjY2NDc1LDEsLjk5OTczLC45OTk3MywxLjAwMDIzLC45OTk3MywxLjAwNDIzLC45OTkyNSwuOTk5OTksMSwuOTk5OTEsLjk5OTg0LDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDA0OSwxLDEuMDAyNDUsMSwxLDEsMSwuOTYzMjksMSwxLjIwOTg1LDEuMzk3MTMsMS4wMDAwMywuODI1NCwxLjAwMDE1LDEsMS4wMDAzNSwxLjAwMDI3LDEuMDAwMzEsMS4wMDAzMSwxLjAwMDAzLDEuMDAwMzEsMS4wMDAzMSwuOTk5OTksMS4wMDAwMywuOTk5OTksLjk5OTk5LDEuNDExNDQsMS42LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MDU3OSwxLjQwNTc5LDEuMzY2MjUsLjk5OTk5LDEsLjk5ODYxLC45OTg2MSwxLDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsLjk1MzE3LC45OTk5OSwuOTk5OTksLjk5OTk5LC45OTk5OSwxLjQwNDgzLDEsLjk5OTc3LDEuMDAwNTQsMSwxLC45OTk1MywuOTk5NjIsMS4wMDA0MiwuOTk5NSwxLDEsMSwxLDEsMSwxLDEsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sQ2k9e2xpbmVIZWlnaHQ6MS4zNSxsaW5lR2FwOi4yfSx2aT1bLjc2MTE2LDEsMSwxLjAwMDYsMS4wMDA2LDEuMDAwMDYsLjk5OTczLC45OTk3MywuOTk5ODIsMS4wMDAwMSwxLjAwMDQzLC45OTk5OCwuOTk5OTgsLjk5OTU5LDEuMDAwMDMsMS4wMDA2LC45OTk5OCwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDYsMSwxLjAwMDAzLDEuMDAwMDMsMS4wMDAwMywuOTk5NzMsLjk5OTg3LDEuMDAwMDEsMS4wMDAwMSwuOTk5NzcsLjk5OTc3LDEuMDAwMDEsMS4wMDAyNiwxLjAwMDIyLC45OTk3NywxLjAwMDYsMSwxLjAwMDAxLC45OTk3MywuOTk5OTksLjk5OTc3LDEuMDAwMjIsMS4wMDAwMSwxLjAwMDIyLC45OTk3NywxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMDEsMS4wMDAxNiwxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwuOTk5NDksLjk5OTczLC45OTk5OCwuOTk5NzMsLjk5OTczLDEsLjk5OTczLC45OTk3MywxLjAwMDYsLjk5OTczLC45OTk3MywuOTk5MjQsLjk5OTI0LDEsLjk5OTI0LC45OTk5OSwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTk4LDEsMS4wMDA2LC45OTk3MywxLC45OTk3NywxLDEsMSwxLjAwMDA1LDEuMDAwOSwxLjAwMDA1LDEuMDAwMDMsLjk5OTk4LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDksLjk5OTczLC45OTk5OCwxLjAwMDI1LC45OTk2OCwuOTk5NzMsMS4wMDAwMywxLjAwMDI1LC42MDI5OSwxLjAwMDI0LDEuMDY0MDksMSwxLC45OTk5OCwxLC45OTk4LDEuMDAwNiwuOTk5OTgsMSwuOTk5MzYsLjk5OTczLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMjYsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMSwuOTk5NzcsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTc3LC45OTk3NywxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAwMywxLjAwMDIyLC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5ODIsMSwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjA2NDA5LDEuMDAwMjYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEsLjk5OTczLDEsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsLjk5OTc3LDEsLjk5OTc3LDEsLjk5OTc3LDEsLjk5OTc3LDEsLjk5OTc3LDEuMDQ1OTYsLjk5OTc3LC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDIyLC45OTk3MywxLjAwMDIyLC45OTk3MywxLjAwMDIyLC45OTk3MywxLjAwMDIyLC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTkyNCwxLjAwMDYsMS4wMDA2LDEuMDAwMTksMS4wMDAzNCwxLC45OTkyNCwxLjAwMDAxLDEsMSwuOTk5NzMsLjk5OTI0LC45OTk3MywuOTk5MjQsLjk5OTczLDEuMDI1NzIsLjk5OTczLDEuMDAwMDUsLjk5OTczLC45OTkyNCwuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5OTksLjk5OTgsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEsMS4wMDAxNiwuOTk5NzcsLjk5OTk4LC45OTk3NywuOTk5OTgsLjk5OTc3LC45OTk5OCwxLjAwMDAxLDEsMS4wMDAwMSwxLDEuMDAwMDEsMSwxLjAwMDAxLDEsMS4wMDAyNiwxLjAwMDYsMS4wMDAyNiwuODQ1MzMsMS4wMDAyNiwxLjAwMDYsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsMS4wMDAxNiwuOTk5NzcsMS4wMDAwMSwxLDEuMDAwMDEsMS4wMDAyNiwxLDEuMDAwMjYsMSwxLjAwMDI2LDEsLjk5OTI0LC45OTk3MywxLjAwMDAxLC45OTk3MywxLC45OTk4MiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAwMSwxLDEuMDAwMjYsMS4wMDA2LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTI4LDEsLjk5OTc3LDEuMDAwMTMsMS4wMDA1NSwuOTk5NDcsLjk5OTQ1LC45OTk0MSwuOTk5MjQsMS4wMDAwMSwxLjAwMDAxLDEuMDAwNCwuOTE2MjEsMS4wMDAwMSwxLjAwMDI2LC45OTk3NywxLjAwMDIyLDEuMDAwNiwxLjAwMDAxLDEuMDAwMDUsLjk5OTk5LC45OTk3NywxLjAwMDE1LDEuMDAwMjIsLjk5OTc3LDEuMDAwMDEsLjk5OTczLDEuMDAwMjYsMS4wMDAwMSwxLjAwMDE5LDEuMDAwMDEsLjk5OTQ2LDEsMS4wMDA2LDEuMDAwMDEsLjk5OTc4LDEuMDAwNDUsLjk5OTczLC45OTkyNCwxLjAwMDIzLC45OTk3OCwuOTk5NjYsMSwxLjAwMDY1LDEuMDAwNDUsMS4wMDAxOSwuOTk5NzMsLjk5OTczLC45OTkyNCwxLDEsLjk2NDk5LDEsMS4wMDA1NSwuOTk5NzMsMS4wMDAwOCwxLjAwMDI3LDEsLjk5OTcsLjk5OTk1LDEuMDAwMjMsLjk5OTMzLDEuMDAwMTksMS4wMDAxNSwxLjAwMDMxLC45OTkyNCwxLjAwMDIzLC45OTk3MywxLjAwMDIzLDEuMDAwMzEsMS4wMDAwMSwuOTk5MjgsMS4wMDAyOSwxLjAwMDkyLDEuMDAwMzUsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LDEsLjk5OTg4LC45OTk3NSwxLDEuMDAwODIsLjk5NTYxLC45OTk2LDEuMDAwMzUsMS4wMDAwMSwuOTk5NjIsMS4wMDAwMSwxLjAwMDkyLC45OTk2NCwxLjAwMDAxLC45OTk2MywuOTk5OTksMS4wMDAzNSwxLjAwMDM1LDEuMDAwODIsLjk5OTYyLC45OTk5OSwuOTk5NzcsMS4wMDAyMiwxLjAwMDM1LDEuMDAwMDEsLjk5OTc3LDEuMDAwMjYsLjk5OTYsLjk5OTY3LDEuMDAwMDEsMS4wMDAzNCwxLjAwMDc0LDEuMDAwNTQsMS4wMDA1MywxLjAwMDYzLC45OTk3MSwuOTk5NjIsMS4wMDAzNSwuOTk5NzUsLjk5OTc3LC45OTk3MywxLjAwMDQzLC45OTk1MywxLjAwMDcsLjk5OTE1LC45OTk3MywxLjAwMDA4LC45OTg5MiwxLjAwMDczLDEuMDAwNzMsMS4wMDExNCwuOTk5MTUsMS4wMDA3MywuOTk5NTUsLjk5OTczLDEuMDAwOTIsLjk5OTczLDEsLjk5OTk4LDEsMS4wMDAzLDEsMS4wMDA0MywxLjAwMDAxLC45OTk2OSwxLjAwMDMsMSwxLjAwMDM1LDEuMDAwMDEsLjk5OTUsMSwxLjAwMDkyLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDAwNywuOTk5NSwxLC45OTkyNCwxLjAwMDYsLjk5OTI0LC45OTk3MiwxLjAwMDYyLC45OTk3MywxLjAwMTE0LDEuMDAwNzMsMSwuOTk5NTUsMSwxLDEuMDAwNDcsLjk5OTY4LDEuMDAwMTYsLjk5OTc3LDEuMDAwMTYsLjk5OTc3LDEuMDAwMTYsLjk5OTc3LDEuMDAwMDEsMSwxLDEsLjk5OTczLDEsMSwuOTk5NTUsLjk5OTI0LC45OTkyNCwuOTk5MjQsLjk5OTI0LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk3MywuOTk5NzMsLjk5OTcyLDEsMSwxLjAwMjY3LC45OTk5OSwuOTk5OTgsLjk5OTk4LDEsLjk5OTk4LDEuNjY0NzUsMSwuOTk5NzMsLjk5OTczLDEuMDAwMjMsLjk5OTczLC45OTk3MSwuOTk5MjUsMS4wMDAyMywxLC45OTk5MSwuOTk5ODQsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLDEsMSwxLDEsMSwxLC45NjMyOSwxLDEuMjA5ODUsMS4zOTcxMywxLjAwMDAzLC44MjU0LDEuMDAwMTUsMSwxLjAwMDM1LDEuMDAwMjcsMS4wMDAzMSwxLjAwMDMxLC45OTkxNSwxLjAwMDMxLDEuMDAwMzEsLjk5OTk5LDEuMDAwMDMsLjk5OTk5LC45OTk5OSwxLjQxMTQ0LDEuNiwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDA1NzksMS40MDU3OSwxLjM2NjI1LC45OTk5OSwxLC45OTg2MSwuOTk4NjEsMSwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LC45NTMxNywuOTk5OTksLjk5OTk5LC45OTk5OSwuOTk5OTksMS40MDQ4MywxLC45OTk3NywxLjAwMDU0LDEsMSwuOTk5NTMsLjk5OTYyLDEuMDAwNDIsLjk5OTUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSxGaT17bGluZUhlaWdodDoxLjIsbGluZUdhcDouMn0sSWk9WzM2NSwwLDMzMywyNzgsMzMzLDQ3NCw1NTYsNTU2LDg4OSw3MjIsMjM4LDMzMywzMzMsMzg5LDU4NCwyNzgsMzMzLDI3OCwyNzgsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDMzMywzMzMsNTg0LDU4NCw1ODQsNjExLDk3NSw3MjIsNzIyLDcyMiw3MjIsNjY3LDYxMSw3NzgsNzIyLDI3OCw1NTYsNzIyLDYxMSw4MzMsNzIyLDc3OCw2NjcsNzc4LDcyMiw2NjcsNjExLDcyMiw2NjcsOTQ0LDY2Nyw2NjcsNjExLDMzMywyNzgsMzMzLDU4NCw1NTYsMzMzLDU1Niw2MTEsNTU2LDYxMSw1NTYsMzMzLDYxMSw2MTEsMjc4LDI3OCw1NTYsMjc4LDg4OSw2MTEsNjExLDYxMSw2MTEsMzg5LDU1NiwzMzMsNjExLDU1Niw3NzgsNTU2LDU1Niw1MDAsMzg5LDI4MCwzODksNTg0LDMzMyw1NTYsNTU2LDU1Niw1NTYsMjgwLDU1NiwzMzMsNzM3LDM3MCw1NTYsNTg0LDczNyw1NTIsNDAwLDU0OSwzMzMsMzMzLDMzMyw1NzYsNTU2LDI3OCwzMzMsMzMzLDM2NSw1NTYsODM0LDgzNCw4MzQsNjExLDcyMiw3MjIsNzIyLDcyMiw3MjIsNzIyLDFlMyw3MjIsNjY3LDY2Nyw2NjcsNjY3LDI3OCwyNzgsMjc4LDI3OCw3MjIsNzIyLDc3OCw3NzgsNzc4LDc3OCw3NzgsNTg0LDc3OCw3MjIsNzIyLDcyMiw3MjIsNjY3LDY2Nyw2MTEsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsODg5LDU1Niw1NTYsNTU2LDU1Niw1NTYsMjc4LDI3OCwyNzgsMjc4LDYxMSw2MTEsNjExLDYxMSw2MTEsNjExLDYxMSw1NDksNjExLDYxMSw2MTEsNjExLDYxMSw1NTYsNjExLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw3MTksNzIyLDYxMSw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNzc4LDYxMSw3NzgsNjExLDc3OCw2MTEsNzc4LDYxMSw3MjIsNjExLDcyMiw2MTEsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDc4NSw1NTYsNTU2LDI3OCw3MjIsNTU2LDU1Niw2MTEsMjc4LDYxMSwyNzgsNjExLDM4NSw2MTEsNDc5LDYxMSwyNzgsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsNzA4LDcyMyw2MTEsNzc4LDYxMSw3NzgsNjExLDc3OCw2MTEsMWUzLDk0NCw3MjIsMzg5LDcyMiwzODksNzIyLDM4OSw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDYxMSwzMzMsNjExLDQ3OSw2MTEsMzMzLDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDk0NCw3NzgsNjY3LDU1Niw2NjcsNjExLDUwMCw2MTEsNTAwLDYxMSw1MDAsMjc4LDU1Niw3MjIsNTU2LDFlMyw4ODksNzc4LDYxMSw2NjcsNTU2LDYxMSwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDQ2NSw3MjIsMzMzLDg1Myw5MDYsNDc0LDgyNSw5MjcsODM4LDI3OCw3MjIsNzIyLDYwMSw3MTksNjY3LDYxMSw3MjIsNzc4LDI3OCw3MjIsNjY3LDgzMyw3MjIsNjQ0LDc3OCw3MjIsNjY3LDYwMCw2MTEsNjY3LDgyMSw2NjcsODA5LDgwMiwyNzgsNjY3LDYxNSw0NTEsNjExLDI3OCw1ODIsNjE1LDYxMCw1NTYsNjA2LDQ3NSw0NjAsNjExLDU0MSwyNzgsNTU4LDU1Niw2MTIsNTU2LDQ0NSw2MTEsNzY2LDYxOSw1MjAsNjg0LDQ0Niw1ODIsNzE1LDU3Niw3NTMsODQ1LDI3OCw1ODIsNjExLDU4Miw4NDUsNjY3LDY2OSw4ODUsNTY3LDcxMSw2NjcsMjc4LDI3Niw1NTYsMTA5NCwxMDYyLDg3NSw2MTAsNzIyLDYyMiw3MTksNzIyLDcxOSw3MjIsNTY3LDcxMiw2NjcsOTA0LDYyNiw3MTksNzE5LDYxMCw3MDIsODMzLDcyMiw3NzgsNzE5LDY2Nyw3MjIsNjExLDYyMiw4NTQsNjY3LDczMCw3MDMsMTAwNSwxMDE5LDg3MCw5NzksNzE5LDcxMSwxMDMxLDcxOSw1NTYsNjE4LDYxNSw0MTcsNjM1LDU1Niw3MDksNDk3LDYxNSw2MTUsNTAwLDYzNSw3NDAsNjA0LDYxMSw2MDQsNjExLDU1Niw0OTAsNTU2LDg3NSw1NTYsNjE1LDU4MSw4MzMsODQ0LDcyOSw4NTQsNjE1LDU1Miw4NTQsNTgzLDU1Niw1NTYsNjExLDQxNyw1NTIsNTU2LDI3OCwyODEsMjc4LDk2OSw5MDYsNjExLDUwMCw2MTUsNTU2LDYwNCw3NzgsNjExLDQ4Nyw0NDcsOTQ0LDc3OCw5NDQsNzc4LDk0NCw3NzgsNjY3LDU1NiwzMzMsMzMzLDU1NiwxZTMsMWUzLDU1MiwyNzgsMjc4LDI3OCwyNzgsNTAwLDUwMCw1MDAsNTU2LDU1NiwzNTAsMWUzLDFlMywyNDAsNDc5LDMzMywzMzMsNjA0LDMzMywxNjcsMzk2LDU1Niw1NTYsMTA5NCw1NTYsODg1LDQ4OSwxMTE1LDFlMyw3NjgsNjAwLDgzNCw4MzQsODM0LDgzNCwxZTMsNTAwLDFlMyw1MDAsMWUzLDUwMCw1MDAsNDk0LDYxMiw4MjMsNzEzLDU4NCw1NDksNzEzLDk3OSw3MjIsMjc0LDU0OSw1NDksNTgzLDU0OSw1NDksNjA0LDU4NCw2MDQsNjA0LDcwOCw2MjUsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzI5LDYwNCw2MDQsMzU0LDM1NCwxZTMsOTkwLDk5MCw5OTAsOTkwLDQ5NCw2MDQsNjA0LDYwNCw2MDQsMzU0LDEwMjEsMTA1Miw5MTcsNzUwLDc1MCw1MzEsNjU2LDU5NCw1MTAsNTAwLDc1MCw3NTAsNjExLDYxMSwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDIyMiwyMjIsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzM10sVGk9Wy0xLC0xLC0xLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMTExLDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMTIzLDEyNCwxMjUsMTI2LDE2MSwxNjIsMTYzLDE2NCwxNjUsMTY2LDE2NywxNjgsMTY5LDE3MCwxNzEsMTcyLDE3NCwxNzUsMTc2LDE3NywxNzgsMTc5LDE4MCwxODEsMTgyLDE4MywxODQsMTg1LDE4NiwxODcsMTg4LDE4OSwxOTAsMTkxLDE5MiwxOTMsMTk0LDE5NSwxOTYsMTk3LDE5OCwxOTksMjAwLDIwMSwyMDIsMjAzLDIwNCwyMDUsMjA2LDIwNywyMDgsMjA5LDIxMCwyMTEsMjEyLDIxMywyMTQsMjE1LDIxNiwyMTcsMjE4LDIxOSwyMjAsMjIxLDIyMiwyMjMsMjI0LDIyNSwyMjYsMjI3LDIyOCwyMjksMjMwLDIzMSwyMzIsMjMzLDIzNCwyMzUsMjM2LDIzNywyMzgsMjM5LDI0MCwyNDEsMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OSwyNTAsMjUxLDI1MiwyNTMsMjU0LDI1NSwyNTYsMjU3LDI1OCwyNTksMjYwLDI2MSwyNjIsMjYzLDI2NCwyNjUsMjY2LDI2NywyNjgsMjY5LDI3MCwyNzEsMjcyLDI3MywyNzQsMjc1LDI3NiwyNzcsMjc4LDI3OSwyODAsMjgxLDI4MiwyODMsMjg0LDI4NSwyODYsMjg3LDI4OCwyODksMjkwLDI5MSwyOTIsMjkzLDI5NCwyOTUsMjk2LDI5NywyOTgsMjk5LDMwMCwzMDEsMzAyLDMwMywzMDQsMzA1LDMwNiwzMDcsMzA4LDMwOSwzMTAsMzExLDMxMiwzMTMsMzE0LDMxNSwzMTYsMzE3LDMxOCwzMTksMzIwLDMyMSwzMjIsMzIzLDMyNCwzMjUsMzI2LDMyNywzMjgsMzI5LDMzMCwzMzEsMzMyLDMzMywzMzQsMzM1LDMzNiwzMzcsMzM4LDMzOSwzNDAsMzQxLDM0MiwzNDMsMzQ0LDM0NSwzNDYsMzQ3LDM0OCwzNDksMzUwLDM1MSwzNTIsMzUzLDM1NCwzNTUsMzU2LDM1NywzNTgsMzU5LDM2MCwzNjEsMzYyLDM2MywzNjQsMzY1LDM2NiwzNjcsMzY4LDM2OSwzNzAsMzcxLDM3MiwzNzMsMzc0LDM3NSwzNzYsMzc3LDM3OCwzNzksMzgwLDM4MSwzODIsMzgzLDQwMiw1MDYsNTA3LDUwOCw1MDksNTEwLDUxMSw1MzYsNTM3LDUzOCw1MzksNzEwLDcxMSw3MTMsNzI4LDcyOSw3MzAsNzMxLDczMiw3MzMsOTAwLDkwMSw5MDIsOTAzLDkwNCw5MDUsOTA2LDkwOCw5MTAsOTExLDkxMiw5MTMsOTE0LDkxNSw5MTYsOTE3LDkxOCw5MTksOTIwLDkyMSw5MjIsOTIzLDkyNCw5MjUsOTI2LDkyNyw5MjgsOTI5LDkzMSw5MzIsOTMzLDkzNCw5MzUsOTM2LDkzNyw5MzgsOTM5LDk0MCw5NDEsOTQyLDk0Myw5NDQsOTQ1LDk0Niw5NDcsOTQ4LDk0OSw5NTAsOTUxLDk1Miw5NTMsOTU0LDk1NSw5NTYsOTU3LDk1OCw5NTksOTYwLDk2MSw5NjIsOTYzLDk2NCw5NjUsOTY2LDk2Nyw5NjgsOTY5LDk3MCw5NzEsOTcyLDk3Myw5NzQsMTAyNCwxMDI1LDEwMjYsMTAyNywxMDI4LDEwMjksMTAzMCwxMDMxLDEwMzIsMTAzMywxMDM0LDEwMzUsMTAzNiwxMDM3LDEwMzgsMTAzOSwxMDQwLDEwNDEsMTA0MiwxMDQzLDEwNDQsMTA0NSwxMDQ2LDEwNDcsMTA0OCwxMDQ5LDEwNTAsMTA1MSwxMDUyLDEwNTMsMTA1NCwxMDU1LDEwNTYsMTA1NywxMDU4LDEwNTksMTA2MCwxMDYxLDEwNjIsMTA2MywxMDY0LDEwNjUsMTA2NiwxMDY3LDEwNjgsMTA2OSwxMDcwLDEwNzEsMTA3MiwxMDczLDEwNzQsMTA3NSwxMDc2LDEwNzcsMTA3OCwxMDc5LDEwODAsMTA4MSwxMDgyLDEwODMsMTA4NCwxMDg1LDEwODYsMTA4NywxMDg4LDEwODksMTA5MCwxMDkxLDEwOTIsMTA5MywxMDk0LDEwOTUsMTA5NiwxMDk3LDEwOTgsMTA5OSwxMTAwLDExMDEsMTEwMiwxMTAzLDExMDQsMTEwNSwxMTA2LDExMDcsMTEwOCwxMTA5LDExMTAsMTExMSwxMTEyLDExMTMsMTExNCwxMTE1LDExMTYsMTExNywxMTE4LDExMTksMTEzOCwxMTM5LDExNjgsMTE2OSw3ODA4LDc4MDksNzgxMCw3ODExLDc4MTIsNzgxMyw3OTIyLDc5MjMsODIwOCw4MjA5LDgyMTEsODIxMiw4MjEzLDgyMTUsODIxNiw4MjE3LDgyMTgsODIxOSw4MjIwLDgyMjEsODIyMiw4MjI0LDgyMjUsODIyNiw4MjMwLDgyNDAsODI0Miw4MjQzLDgyNDksODI1MCw4MjUyLDgyNTQsODI2MCw4MzE5LDgzNTUsODM1Niw4MzU5LDgzNjQsODQ1Myw4NDY3LDg0NzAsODQ4Miw4NDg2LDg0OTQsODUzOSw4NTQwLDg1NDEsODU0Miw4NTkyLDg1OTMsODU5NCw4NTk1LDg1OTYsODU5Nyw4NjE2LDg3MDYsODcxMCw4NzE5LDg3MjEsODcyMiw4NzMwLDg3MzQsODczNSw4NzQ1LDg3NDcsODc3Niw4ODAwLDg4MDEsODgwNCw4ODA1LDg5NjIsODk3Niw4OTkyLDg5OTMsOTQ3Miw5NDc0LDk0ODQsOTQ4OCw5NDkyLDk0OTYsOTUwMCw5NTA4LDk1MTYsOTUyNCw5NTMyLDk1NTIsOTU1Myw5NTU0LDk1NTUsOTU1Niw5NTU3LDk1NTgsOTU1OSw5NTYwLDk1NjEsOTU2Miw5NTYzLDk1NjQsOTU2NSw5NTY2LDk1NjcsOTU2OCw5NTY5LDk1NzAsOTU3MSw5NTcyLDk1NzMsOTU3NCw5NTc1LDk1NzYsOTU3Nyw5NTc4LDk1NzksOTU4MCw5NjAwLDk2MDQsOTYwOCw5NjEyLDk2MTYsOTYxNyw5NjE4LDk2MTksOTYzMiw5NjMzLDk2NDIsOTY0Myw5NjQ0LDk2NTAsOTY1OCw5NjYwLDk2NjgsOTY3NCw5Njc1LDk2NzksOTY4OCw5Njg5LDk3MDIsOTc4Niw5Nzg3LDk3ODgsOTc5Miw5Nzk0LDk4MjQsOTgyNyw5ODI5LDk4MzAsOTgzNCw5ODM1LDk4MzYsNjE0NDEsNjE0NDIsNjE0NDUsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTFdLE9pPVszNjUsMCwzMzMsMjc4LDMzMyw0NzQsNTU2LDU1Niw4ODksNzIyLDIzOCwzMzMsMzMzLDM4OSw1ODQsMjc4LDMzMywyNzgsMjc4LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1NiwzMzMsMzMzLDU4NCw1ODQsNTg0LDYxMSw5NzUsNzIyLDcyMiw3MjIsNzIyLDY2Nyw2MTEsNzc4LDcyMiwyNzgsNTU2LDcyMiw2MTEsODMzLDcyMiw3NzgsNjY3LDc3OCw3MjIsNjY3LDYxMSw3MjIsNjY3LDk0NCw2NjcsNjY3LDYxMSwzMzMsMjc4LDMzMyw1ODQsNTU2LDMzMyw1NTYsNjExLDU1Niw2MTEsNTU2LDMzMyw2MTEsNjExLDI3OCwyNzgsNTU2LDI3OCw4ODksNjExLDYxMSw2MTEsNjExLDM4OSw1NTYsMzMzLDYxMSw1NTYsNzc4LDU1Niw1NTYsNTAwLDM4OSwyODAsMzg5LDU4NCwzMzMsNTU2LDU1Niw1NTYsNTU2LDI4MCw1NTYsMzMzLDczNywzNzAsNTU2LDU4NCw3MzcsNTUyLDQwMCw1NDksMzMzLDMzMywzMzMsNTc2LDU1NiwyNzgsMzMzLDMzMywzNjUsNTU2LDgzNCw4MzQsODM0LDYxMSw3MjIsNzIyLDcyMiw3MjIsNzIyLDcyMiwxZTMsNzIyLDY2Nyw2NjcsNjY3LDY2NywyNzgsMjc4LDI3OCwyNzgsNzIyLDcyMiw3NzgsNzc4LDc3OCw3NzgsNzc4LDU4NCw3NzgsNzIyLDcyMiw3MjIsNzIyLDY2Nyw2NjcsNjExLDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDg4OSw1NTYsNTU2LDU1Niw1NTYsNTU2LDI3OCwyNzgsMjc4LDI3OCw2MTEsNjExLDYxMSw2MTEsNjExLDYxMSw2MTEsNTQ5LDYxMSw2MTEsNjExLDYxMSw2MTEsNTU2LDYxMSw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNzQwLDcyMiw2MTEsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDc3OCw2MTEsNzc4LDYxMSw3NzgsNjExLDc3OCw2MTEsNzIyLDYxMSw3MjIsNjExLDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCw3ODIsNTU2LDU1NiwyNzgsNzIyLDU1Niw1NTYsNjExLDI3OCw2MTEsMjc4LDYxMSwzOTYsNjExLDQ3OSw2MTEsMjc4LDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDcwOCw3MjMsNjExLDc3OCw2MTEsNzc4LDYxMSw3NzgsNjExLDFlMyw5NDQsNzIyLDM4OSw3MjIsMzg5LDcyMiwzODksNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2MTEsMzMzLDYxMSw0NzksNjExLDMzMyw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw5NDQsNzc4LDY2Nyw1NTYsNjY3LDYxMSw1MDAsNjExLDUwMCw2MTEsNTAwLDI3OCw1NTYsNzIyLDU1NiwxZTMsODg5LDc3OCw2MTEsNjY3LDU1Niw2MTEsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsNzIyLDMzMyw4NTQsOTA2LDQ3Myw4NDQsOTMwLDg0NywyNzgsNzIyLDcyMiw2MTAsNjcxLDY2Nyw2MTEsNzIyLDc3OCwyNzgsNzIyLDY2Nyw4MzMsNzIyLDY1Nyw3NzgsNzE4LDY2Nyw1OTAsNjExLDY2Nyw4MjIsNjY3LDgyOSw3ODEsMjc4LDY2Nyw2MjAsNDc5LDYxMSwyNzgsNTkxLDYyMCw2MjEsNTU2LDYxMCw0NzksNDkyLDYxMSw1NTgsMjc4LDU2Niw1NTYsNjAzLDU1Niw0NTAsNjExLDcxMiw2MDUsNTMyLDY2NCw0MDksNTkxLDcwNCw1NzgsNzczLDgzNCwyNzgsNTkxLDYxMSw1OTEsODM0LDY2Nyw2NjcsODg2LDYxNCw3MTksNjY3LDI3OCwyNzgsNTU2LDEwOTQsMTA0Miw4NTQsNjIyLDcxOSw2NzcsNzE5LDcyMiw3MDgsNzIyLDYxNCw3MjIsNjY3LDkyNyw2NDMsNzE5LDcxOSw2MTUsNjg3LDgzMyw3MjIsNzc4LDcxOSw2NjcsNzIyLDYxMSw2NzcsNzgxLDY2Nyw3MjksNzA4LDk3OSw5ODksODU0LDFlMyw3MDgsNzE5LDEwNDIsNzI5LDU1Niw2MTksNjA0LDUzNCw2MTgsNTU2LDczNiw1MTAsNjExLDYxMSw1MDcsNjIyLDc0MCw2MDQsNjExLDYxMSw2MTEsNTU2LDg4OSw1NTYsODg1LDU1Niw2NDYsNTgzLDg4OSw5MzUsNzA3LDg1NCw1OTQsNTUyLDg2NSw1ODksNTU2LDU1Niw2MTEsNDY5LDU2Myw1NTYsMjc4LDI3OCwyNzgsOTY5LDkwNiw2MTEsNTA3LDYxOSw1NTYsNjExLDc3OCw2MTEsNTc1LDQ2Nyw5NDQsNzc4LDk0NCw3NzgsOTQ0LDc3OCw2NjcsNTU2LDMzMywzMzMsNTU2LDFlMywxZTMsNTUyLDI3OCwyNzgsMjc4LDI3OCw1MDAsNTAwLDUwMCw1NTYsNTU2LDM1MCwxZTMsMWUzLDI0MCw0NzksMzMzLDMzMyw2MDQsMzMzLDE2NywzOTYsNTU2LDU1NiwxMTA0LDU1Niw4ODUsNTE2LDExNDYsMWUzLDc2OCw2MDAsODM0LDgzNCw4MzQsODM0LDk5OSw1MDAsMWUzLDUwMCwxZTMsNTAwLDUwMCw0OTQsNjEyLDgyMyw3MTMsNTg0LDU0OSw3MTMsOTc5LDcyMiwyNzQsNTQ5LDU0OSw1ODMsNTQ5LDU0OSw2MDQsNTg0LDYwNCw2MDQsNzA4LDYyNSw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MjksNjA0LDYwNCwzNTQsMzU0LDFlMyw5OTAsOTkwLDk5MCw5OTAsNDk0LDYwNCw2MDQsNjA0LDYwNCwzNTQsMTAyMSwxMDUyLDkxNyw3NTAsNzUwLDUzMSw2NTYsNTk0LDUxMCw1MDAsNzUwLDc1MCw2MTEsNjExLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMjIyLDIyMiwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzXSxNaT1bLTEsLTEsLTEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwxMTEsMTEyLDExMywxMTQsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwxMjMsMTI0LDEyNSwxMjYsMTYxLDE2MiwxNjMsMTY0LDE2NSwxNjYsMTY3LDE2OCwxNjksMTcwLDE3MSwxNzIsMTc0LDE3NSwxNzYsMTc3LDE3OCwxNzksMTgwLDE4MSwxODIsMTgzLDE4NCwxODUsMTg2LDE4NywxODgsMTg5LDE5MCwxOTEsMTkyLDE5MywxOTQsMTk1LDE5NiwxOTcsMTk4LDE5OSwyMDAsMjAxLDIwMiwyMDMsMjA0LDIwNSwyMDYsMjA3LDIwOCwyMDksMjEwLDIxMSwyMTIsMjEzLDIxNCwyMTUsMjE2LDIxNywyMTgsMjE5LDIyMCwyMjEsMjIyLDIyMywyMjQsMjI1LDIyNiwyMjcsMjI4LDIyOSwyMzAsMjMxLDIzMiwyMzMsMjM0LDIzNSwyMzYsMjM3LDIzOCwyMzksMjQwLDI0MSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5LDI1MCwyNTEsMjUyLDI1MywyNTQsMjU1LDI1NiwyNTcsMjU4LDI1OSwyNjAsMjYxLDI2MiwyNjMsMjY0LDI2NSwyNjYsMjY3LDI2OCwyNjksMjcwLDI3MSwyNzIsMjczLDI3NCwyNzUsMjc2LDI3NywyNzgsMjc5LDI4MCwyODEsMjgyLDI4MywyODQsMjg1LDI4NiwyODcsMjg4LDI4OSwyOTAsMjkxLDI5MiwyOTMsMjk0LDI5NSwyOTYsMjk3LDI5OCwyOTksMzAwLDMwMSwzMDIsMzAzLDMwNCwzMDUsMzA2LDMwNywzMDgsMzA5LDMxMCwzMTEsMzEyLDMxMywzMTQsMzE1LDMxNiwzMTcsMzE4LDMxOSwzMjAsMzIxLDMyMiwzMjMsMzI0LDMyNSwzMjYsMzI3LDMyOCwzMjksMzMwLDMzMSwzMzIsMzMzLDMzNCwzMzUsMzM2LDMzNywzMzgsMzM5LDM0MCwzNDEsMzQyLDM0MywzNDQsMzQ1LDM0NiwzNDcsMzQ4LDM0OSwzNTAsMzUxLDM1MiwzNTMsMzU0LDM1NSwzNTYsMzU3LDM1OCwzNTksMzYwLDM2MSwzNjIsMzYzLDM2NCwzNjUsMzY2LDM2NywzNjgsMzY5LDM3MCwzNzEsMzcyLDM3MywzNzQsMzc1LDM3NiwzNzcsMzc4LDM3OSwzODAsMzgxLDM4MiwzODMsNDAyLDUwNiw1MDcsNTA4LDUwOSw1MTAsNTExLDUzNiw1MzcsNTM4LDUzOSw3MTAsNzExLDcxMyw3MjgsNzI5LDczMCw3MzEsNzMyLDczMyw5MDAsOTAxLDkwMiw5MDMsOTA0LDkwNSw5MDYsOTA4LDkxMCw5MTEsOTEyLDkxMyw5MTQsOTE1LDkxNiw5MTcsOTE4LDkxOSw5MjAsOTIxLDkyMiw5MjMsOTI0LDkyNSw5MjYsOTI3LDkyOCw5MjksOTMxLDkzMiw5MzMsOTM0LDkzNSw5MzYsOTM3LDkzOCw5MzksOTQwLDk0MSw5NDIsOTQzLDk0NCw5NDUsOTQ2LDk0Nyw5NDgsOTQ5LDk1MCw5NTEsOTUyLDk1Myw5NTQsOTU1LDk1Niw5NTcsOTU4LDk1OSw5NjAsOTYxLDk2Miw5NjMsOTY0LDk2NSw5NjYsOTY3LDk2OCw5NjksOTcwLDk3MSw5NzIsOTczLDk3NCwxMDI0LDEwMjUsMTAyNiwxMDI3LDEwMjgsMTAyOSwxMDMwLDEwMzEsMTAzMiwxMDMzLDEwMzQsMTAzNSwxMDM2LDEwMzcsMTAzOCwxMDM5LDEwNDAsMTA0MSwxMDQyLDEwNDMsMTA0NCwxMDQ1LDEwNDYsMTA0NywxMDQ4LDEwNDksMTA1MCwxMDUxLDEwNTIsMTA1MywxMDU0LDEwNTUsMTA1NiwxMDU3LDEwNTgsMTA1OSwxMDYwLDEwNjEsMTA2MiwxMDYzLDEwNjQsMTA2NSwxMDY2LDEwNjcsMTA2OCwxMDY5LDEwNzAsMTA3MSwxMDcyLDEwNzMsMTA3NCwxMDc1LDEwNzYsMTA3NywxMDc4LDEwNzksMTA4MCwxMDgxLDEwODIsMTA4MywxMDg0LDEwODUsMTA4NiwxMDg3LDEwODgsMTA4OSwxMDkwLDEwOTEsMTA5MiwxMDkzLDEwOTQsMTA5NSwxMDk2LDEwOTcsMTA5OCwxMDk5LDExMDAsMTEwMSwxMTAyLDExMDMsMTEwNCwxMTA1LDExMDYsMTEwNywxMTA4LDExMDksMTExMCwxMTExLDExMTIsMTExMywxMTE0LDExMTUsMTExNiwxMTE3LDExMTgsMTExOSwxMTM4LDExMzksMTE2OCwxMTY5LDc4MDgsNzgwOSw3ODEwLDc4MTEsNzgxMiw3ODEzLDc5MjIsNzkyMyw4MjA4LDgyMDksODIxMSw4MjEyLDgyMTMsODIxNSw4MjE2LDgyMTcsODIxOCw4MjE5LDgyMjAsODIyMSw4MjIyLDgyMjQsODIyNSw4MjI2LDgyMzAsODI0MCw4MjQyLDgyNDMsODI0OSw4MjUwLDgyNTIsODI1NCw4MjYwLDgzMTksODM1NSw4MzU2LDgzNTksODM2NCw4NDUzLDg0NjcsODQ3MCw4NDgyLDg0ODYsODQ5NCw4NTM5LDg1NDAsODU0MSw4NTQyLDg1OTIsODU5Myw4NTk0LDg1OTUsODU5Niw4NTk3LDg2MTYsODcwNiw4NzEwLDg3MTksODcyMSw4NzIyLDg3MzAsODczNCw4NzM1LDg3NDUsODc0Nyw4Nzc2LDg4MDAsODgwMSw4ODA0LDg4MDUsODk2Miw4OTc2LDg5OTIsODk5Myw5NDcyLDk0NzQsOTQ4NCw5NDg4LDk0OTIsOTQ5Niw5NTAwLDk1MDgsOTUxNiw5NTI0LDk1MzIsOTU1Miw5NTUzLDk1NTQsOTU1NSw5NTU2LDk1NTcsOTU1OCw5NTU5LDk1NjAsOTU2MSw5NTYyLDk1NjMsOTU2NCw5NTY1LDk1NjYsOTU2Nyw5NTY4LDk1NjksOTU3MCw5NTcxLDk1NzIsOTU3Myw5NTc0LDk1NzUsOTU3Niw5NTc3LDk1NzgsOTU3OSw5NTgwLDk2MDAsOTYwNCw5NjA4LDk2MTIsOTYxNiw5NjE3LDk2MTgsOTYxOSw5NjMyLDk2MzMsOTY0Miw5NjQzLDk2NDQsOTY1MCw5NjU4LDk2NjAsOTY2OCw5Njc0LDk2NzUsOTY3OSw5Njg4LDk2ODksOTcwMiw5Nzg2LDk3ODcsOTc4OCw5NzkyLDk3OTQsOTgyNCw5ODI3LDk4MjksOTgzMCw5ODM0LDk4MzUsOTgzNiw2MTQ0MSw2MTQ0Miw2MTQ0NSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMV0sRGk9WzM2NSwwLDMzMywyNzgsMjc4LDM1NSw1NTYsNTU2LDg4OSw2NjcsMTkxLDMzMywzMzMsMzg5LDU4NCwyNzgsMzMzLDI3OCwyNzgsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDI3OCwyNzgsNTg0LDU4NCw1ODQsNTU2LDEwMTUsNjY3LDY2Nyw3MjIsNzIyLDY2Nyw2MTEsNzc4LDcyMiwyNzgsNTAwLDY2Nyw1NTYsODMzLDcyMiw3NzgsNjY3LDc3OCw3MjIsNjY3LDYxMSw3MjIsNjY3LDk0NCw2NjcsNjY3LDYxMSwyNzgsMjc4LDI3OCw0NjksNTU2LDMzMyw1NTYsNTU2LDUwMCw1NTYsNTU2LDI3OCw1NTYsNTU2LDIyMiwyMjIsNTAwLDIyMiw4MzMsNTU2LDU1Niw1NTYsNTU2LDMzMyw1MDAsMjc4LDU1Niw1MDAsNzIyLDUwMCw1MDAsNTAwLDMzNCwyNjAsMzM0LDU4NCwzMzMsNTU2LDU1Niw1NTYsNTU2LDI2MCw1NTYsMzMzLDczNywzNzAsNTU2LDU4NCw3MzcsNTUyLDQwMCw1NDksMzMzLDMzMywzMzMsNTc2LDUzNywyNzgsMzMzLDMzMywzNjUsNTU2LDgzNCw4MzQsODM0LDYxMSw2NjcsNjY3LDY2Nyw2NjcsNjY3LDY2NywxZTMsNzIyLDY2Nyw2NjcsNjY3LDY2NywyNzgsMjc4LDI3OCwyNzgsNzIyLDcyMiw3NzgsNzc4LDc3OCw3NzgsNzc4LDU4NCw3NzgsNzIyLDcyMiw3MjIsNzIyLDY2Nyw2NjcsNjExLDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDg4OSw1MDAsNTU2LDU1Niw1NTYsNTU2LDI3OCwyNzgsMjc4LDI3OCw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTQ5LDYxMSw1NTYsNTU2LDU1Niw1NTYsNTAwLDU1Niw1MDAsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNzIyLDUwMCw3MjIsNTAwLDcyMiw1MDAsNzIyLDUwMCw3MjIsNjI1LDcyMiw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDc3OCw1NTYsNzc4LDU1Niw3NzgsNTU2LDc3OCw1NTYsNzIyLDU1Niw3MjIsNTU2LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyMjIsMjc4LDI3OCw3MzMsNDQ0LDUwMCwyMjIsNjY3LDUwMCw1MDAsNTU2LDIyMiw1NTYsMjIyLDU1NiwyODEsNTU2LDQwMCw1NTYsMjIyLDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDYxNSw3MjMsNTU2LDc3OCw1NTYsNzc4LDU1Niw3NzgsNTU2LDFlMyw5NDQsNzIyLDMzMyw3MjIsMzMzLDcyMiwzMzMsNjY3LDUwMCw2NjcsNTAwLDY2Nyw1MDAsNjY3LDUwMCw2MTEsMjc4LDYxMSwzNTQsNjExLDI3OCw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw5NDQsNzIyLDY2Nyw1MDAsNjY3LDYxMSw1MDAsNjExLDUwMCw2MTEsNTAwLDIyMiw1NTYsNjY3LDU1NiwxZTMsODg5LDc3OCw2MTEsNjY3LDUwMCw2MTEsMjc4LDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsNjY3LDI3OCw3ODksODQ2LDM4OSw3OTQsODY1LDc3NSwyMjIsNjY3LDY2Nyw1NzAsNjcxLDY2Nyw2MTEsNzIyLDc3OCwyNzgsNjY3LDY2Nyw4MzMsNzIyLDY0OCw3NzgsNzI1LDY2Nyw2MDAsNjExLDY2Nyw4MzcsNjY3LDgzMSw3NjEsMjc4LDY2Nyw1NzAsNDM5LDU1NSwyMjIsNTUwLDU3MCw1NzEsNTAwLDU1Niw0MzksNDYzLDU1NSw1NDIsMjIyLDUwMCw0OTIsNTQ4LDUwMCw0NDcsNTU2LDY3MCw1NzMsNDg2LDYwMywzNzQsNTUwLDY1Miw1NDYsNzI4LDc3OSwyMjIsNTUwLDU1Niw1NTAsNzc5LDY2Nyw2NjcsODQzLDU0NCw3MDgsNjY3LDI3OCwyNzgsNTAwLDEwNjYsOTgyLDg0NCw1ODksNzE1LDYzOSw3MjQsNjY3LDY1MSw2NjcsNTQ0LDcwNCw2NjcsOTE3LDYxNCw3MTUsNzE1LDU4OSw2ODYsODMzLDcyMiw3NzgsNzI1LDY2Nyw3MjIsNjExLDYzOSw3OTUsNjY3LDcyNyw2NzMsOTIwLDkyMyw4MDUsODg2LDY1MSw2OTQsMTAyMiw2ODIsNTU2LDU2Miw1MjIsNDkzLDU1Myw1NTYsNjg4LDQ2NSw1NTYsNTU2LDQ3Miw1NjQsNjg2LDU1MCw1NTYsNTU2LDU1Niw1MDAsODMzLDUwMCw4MzUsNTAwLDU3Miw1MTgsODMwLDg1MSw2MjEsNzM2LDUyNiw0OTIsNzUyLDUzNCw1NTYsNTU2LDU1NiwzNzgsNDk2LDUwMCwyMjIsMjIyLDIyMiw5MTAsODI4LDU1Niw0NzIsNTY1LDUwMCw1NTYsNzc4LDU1Niw0OTIsMzM5LDk0NCw3MjIsOTQ0LDcyMiw5NDQsNzIyLDY2Nyw1MDAsMzMzLDMzMyw1NTYsMWUzLDFlMyw1NTIsMjIyLDIyMiwyMjIsMjIyLDMzMywzMzMsMzMzLDU1Niw1NTYsMzUwLDFlMywxZTMsMTg4LDM1NCwzMzMsMzMzLDUwMCwzMzMsMTY3LDM2NSw1NTYsNTU2LDEwOTQsNTU2LDg4NSwzMjMsMTA4MywxZTMsNzY4LDYwMCw4MzQsODM0LDgzNCw4MzQsMWUzLDUwMCw5OTgsNTAwLDFlMyw1MDAsNTAwLDQ5NCw2MTIsODIzLDcxMyw1ODQsNTQ5LDcxMyw5NzksNzE5LDI3NCw1NDksNTQ5LDU4NCw1NDksNTQ5LDYwNCw1ODQsNjA0LDYwNCw3MDgsNjI1LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcyOSw2MDQsNjA0LDM1NCwzNTQsMWUzLDk5MCw5OTAsOTkwLDk5MCw0OTQsNjA0LDYwNCw2MDQsNjA0LDM1NCwxMDIxLDEwNTIsOTE3LDc1MCw3NTAsNTMxLDY1Niw1OTQsNTEwLDUwMCw3NTAsNzUwLDUwMCw1MDAsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywyMjIsMjIyLDI5NCwyOTQsMzI0LDMyNCwzMTYsMzI4LDM5OCwyODVdLEJpPVstMSwtMSwtMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDExMSwxMTIsMTEzLDExNCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDEyMywxMjQsMTI1LDEyNiwxNjEsMTYyLDE2MywxNjQsMTY1LDE2NiwxNjcsMTY4LDE2OSwxNzAsMTcxLDE3MiwxNzQsMTc1LDE3NiwxNzcsMTc4LDE3OSwxODAsMTgxLDE4MiwxODMsMTg0LDE4NSwxODYsMTg3LDE4OCwxODksMTkwLDE5MSwxOTIsMTkzLDE5NCwxOTUsMTk2LDE5NywxOTgsMTk5LDIwMCwyMDEsMjAyLDIwMywyMDQsMjA1LDIwNiwyMDcsMjA4LDIwOSwyMTAsMjExLDIxMiwyMTMsMjE0LDIxNSwyMTYsMjE3LDIxOCwyMTksMjIwLDIyMSwyMjIsMjIzLDIyNCwyMjUsMjI2LDIyNywyMjgsMjI5LDIzMCwyMzEsMjMyLDIzMywyMzQsMjM1LDIzNiwyMzcsMjM4LDIzOSwyNDAsMjQxLDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDksMjUwLDI1MSwyNTIsMjUzLDI1NCwyNTUsMjU2LDI1NywyNTgsMjU5LDI2MCwyNjEsMjYyLDI2MywyNjQsMjY1LDI2NiwyNjcsMjY4LDI2OSwyNzAsMjcxLDI3MiwyNzMsMjc0LDI3NSwyNzYsMjc3LDI3OCwyNzksMjgwLDI4MSwyODIsMjgzLDI4NCwyODUsMjg2LDI4NywyODgsMjg5LDI5MCwyOTEsMjkyLDI5MywyOTQsMjk1LDI5NiwyOTcsMjk4LDI5OSwzMDAsMzAxLDMwMiwzMDMsMzA0LDMwNSwzMDYsMzA3LDMwOCwzMDksMzEwLDMxMSwzMTIsMzEzLDMxNCwzMTUsMzE2LDMxNywzMTgsMzE5LDMyMCwzMjEsMzIyLDMyMywzMjQsMzI1LDMyNiwzMjcsMzI4LDMyOSwzMzAsMzMxLDMzMiwzMzMsMzM0LDMzNSwzMzYsMzM3LDMzOCwzMzksMzQwLDM0MSwzNDIsMzQzLDM0NCwzNDUsMzQ2LDM0NywzNDgsMzQ5LDM1MCwzNTEsMzUyLDM1MywzNTQsMzU1LDM1NiwzNTcsMzU4LDM1OSwzNjAsMzYxLDM2MiwzNjMsMzY0LDM2NSwzNjYsMzY3LDM2OCwzNjksMzcwLDM3MSwzNzIsMzczLDM3NCwzNzUsMzc2LDM3NywzNzgsMzc5LDM4MCwzODEsMzgyLDM4Myw0MDIsNTA2LDUwNyw1MDgsNTA5LDUxMCw1MTEsNTM2LDUzNyw1MzgsNTM5LDcxMCw3MTEsNzEzLDcyOCw3MjksNzMwLDczMSw3MzIsNzMzLDkwMCw5MDEsOTAyLDkwMyw5MDQsOTA1LDkwNiw5MDgsOTEwLDkxMSw5MTIsOTEzLDkxNCw5MTUsOTE2LDkxNyw5MTgsOTE5LDkyMCw5MjEsOTIyLDkyMyw5MjQsOTI1LDkyNiw5MjcsOTI4LDkyOSw5MzEsOTMyLDkzMyw5MzQsOTM1LDkzNiw5MzcsOTM4LDkzOSw5NDAsOTQxLDk0Miw5NDMsOTQ0LDk0NSw5NDYsOTQ3LDk0OCw5NDksOTUwLDk1MSw5NTIsOTUzLDk1NCw5NTUsOTU2LDk1Nyw5NTgsOTU5LDk2MCw5NjEsOTYyLDk2Myw5NjQsOTY1LDk2Niw5NjcsOTY4LDk2OSw5NzAsOTcxLDk3Miw5NzMsOTc0LDEwMjQsMTAyNSwxMDI2LDEwMjcsMTAyOCwxMDI5LDEwMzAsMTAzMSwxMDMyLDEwMzMsMTAzNCwxMDM1LDEwMzYsMTAzNywxMDM4LDEwMzksMTA0MCwxMDQxLDEwNDIsMTA0MywxMDQ0LDEwNDUsMTA0NiwxMDQ3LDEwNDgsMTA0OSwxMDUwLDEwNTEsMTA1MiwxMDUzLDEwNTQsMTA1NSwxMDU2LDEwNTcsMTA1OCwxMDU5LDEwNjAsMTA2MSwxMDYyLDEwNjMsMTA2NCwxMDY1LDEwNjYsMTA2NywxMDY4LDEwNjksMTA3MCwxMDcxLDEwNzIsMTA3MywxMDc0LDEwNzUsMTA3NiwxMDc3LDEwNzgsMTA3OSwxMDgwLDEwODEsMTA4MiwxMDgzLDEwODQsMTA4NSwxMDg2LDEwODcsMTA4OCwxMDg5LDEwOTAsMTA5MSwxMDkyLDEwOTMsMTA5NCwxMDk1LDEwOTYsMTA5NywxMDk4LDEwOTksMTEwMCwxMTAxLDExMDIsMTEwMywxMTA0LDExMDUsMTEwNiwxMTA3LDExMDgsMTEwOSwxMTEwLDExMTEsMTExMiwxMTEzLDExMTQsMTExNSwxMTE2LDExMTcsMTExOCwxMTE5LDExMzgsMTEzOSwxMTY4LDExNjksNzgwOCw3ODA5LDc4MTAsNzgxMSw3ODEyLDc4MTMsNzkyMiw3OTIzLDgyMDgsODIwOSw4MjExLDgyMTIsODIxMyw4MjE1LDgyMTYsODIxNyw4MjE4LDgyMTksODIyMCw4MjIxLDgyMjIsODIyNCw4MjI1LDgyMjYsODIzMCw4MjQwLDgyNDIsODI0Myw4MjQ5LDgyNTAsODI1Miw4MjU0LDgyNjAsODMxOSw4MzU1LDgzNTYsODM1OSw4MzY0LDg0NTMsODQ2Nyw4NDcwLDg0ODIsODQ4Niw4NDk0LDg1MzksODU0MCw4NTQxLDg1NDIsODU5Miw4NTkzLDg1OTQsODU5NSw4NTk2LDg1OTcsODYxNiw4NzA2LDg3MTAsODcxOSw4NzIxLDg3MjIsODczMCw4NzM0LDg3MzUsODc0NSw4NzQ3LDg3NzYsODgwMCw4ODAxLDg4MDQsODgwNSw4OTYyLDg5NzYsODk5Miw4OTkzLDk0NzIsOTQ3NCw5NDg0LDk0ODgsOTQ5Miw5NDk2LDk1MDAsOTUwOCw5NTE2LDk1MjQsOTUzMiw5NTUyLDk1NTMsOTU1NCw5NTU1LDk1NTYsOTU1Nyw5NTU4LDk1NTksOTU2MCw5NTYxLDk1NjIsOTU2Myw5NTY0LDk1NjUsOTU2Niw5NTY3LDk1NjgsOTU2OSw5NTcwLDk1NzEsOTU3Miw5NTczLDk1NzQsOTU3NSw5NTc2LDk1NzcsOTU3OCw5NTc5LDk1ODAsOTYwMCw5NjA0LDk2MDgsOTYxMiw5NjE2LDk2MTcsOTYxOCw5NjE5LDk2MzIsOTYzMyw5NjQyLDk2NDMsOTY0NCw5NjUwLDk2NTgsOTY2MCw5NjY4LDk2NzQsOTY3NSw5Njc5LDk2ODgsOTY4OSw5NzAyLDk3ODYsOTc4Nyw5Nzg4LDk3OTIsOTc5NCw5ODI0LDk4MjcsOTgyOSw5ODMwLDk4MzQsOTgzNSw5ODM2LDYxNDQxLDYxNDQyLDYxNDQ1LC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xXSxSaT1bMzY1LDAsMzMzLDI3OCwyNzgsMzU1LDU1Niw1NTYsODg5LDY2NywxOTEsMzMzLDMzMywzODksNTg0LDI3OCwzMzMsMjc4LDI3OCw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsMjc4LDI3OCw1ODQsNTg0LDU4NCw1NTYsMTAxNSw2NjcsNjY3LDcyMiw3MjIsNjY3LDYxMSw3NzgsNzIyLDI3OCw1MDAsNjY3LDU1Niw4MzMsNzIyLDc3OCw2NjcsNzc4LDcyMiw2NjcsNjExLDcyMiw2NjcsOTQ0LDY2Nyw2NjcsNjExLDI3OCwyNzgsMjc4LDQ2OSw1NTYsMzMzLDU1Niw1NTYsNTAwLDU1Niw1NTYsMjc4LDU1Niw1NTYsMjIyLDIyMiw1MDAsMjIyLDgzMyw1NTYsNTU2LDU1Niw1NTYsMzMzLDUwMCwyNzgsNTU2LDUwMCw3MjIsNTAwLDUwMCw1MDAsMzM0LDI2MCwzMzQsNTg0LDMzMyw1NTYsNTU2LDU1Niw1NTYsMjYwLDU1NiwzMzMsNzM3LDM3MCw1NTYsNTg0LDczNyw1NTIsNDAwLDU0OSwzMzMsMzMzLDMzMyw1NzYsNTM3LDI3OCwzMzMsMzMzLDM2NSw1NTYsODM0LDgzNCw4MzQsNjExLDY2Nyw2NjcsNjY3LDY2Nyw2NjcsNjY3LDFlMyw3MjIsNjY3LDY2Nyw2NjcsNjY3LDI3OCwyNzgsMjc4LDI3OCw3MjIsNzIyLDc3OCw3NzgsNzc4LDc3OCw3NzgsNTg0LDc3OCw3MjIsNzIyLDcyMiw3MjIsNjY3LDY2Nyw2MTEsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsODg5LDUwMCw1NTYsNTU2LDU1Niw1NTYsMjc4LDI3OCwyNzgsMjc4LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NDksNjExLDU1Niw1NTYsNTU2LDU1Niw1MDAsNTU2LDUwMCw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw3MjIsNTAwLDcyMiw1MDAsNzIyLDUwMCw3MjIsNTAwLDcyMiw2MTUsNzIyLDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNzc4LDU1Niw3NzgsNTU2LDc3OCw1NTYsNzc4LDU1Niw3MjIsNTU2LDcyMiw1NTYsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDIyMiwyNzgsMjc4LDczNSw0NDQsNTAwLDIyMiw2NjcsNTAwLDUwMCw1NTYsMjIyLDU1NiwyMjIsNTU2LDI5Miw1NTYsMzM0LDU1NiwyMjIsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNjA0LDcyMyw1NTYsNzc4LDU1Niw3NzgsNTU2LDc3OCw1NTYsMWUzLDk0NCw3MjIsMzMzLDcyMiwzMzMsNzIyLDMzMyw2NjcsNTAwLDY2Nyw1MDAsNjY3LDUwMCw2NjcsNTAwLDYxMSwyNzgsNjExLDM3NSw2MTEsMjc4LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDk0NCw3MjIsNjY3LDUwMCw2NjcsNjExLDUwMCw2MTEsNTAwLDYxMSw1MDAsMjIyLDU1Niw2NjcsNTU2LDFlMyw4ODksNzc4LDYxMSw2NjcsNTAwLDYxMSwyNzgsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMyw2NjcsMjc4LDc4NCw4MzgsMzg0LDc3NCw4NTUsNzUyLDIyMiw2NjcsNjY3LDU1MSw2NjgsNjY3LDYxMSw3MjIsNzc4LDI3OCw2NjcsNjY4LDgzMyw3MjIsNjUwLDc3OCw3MjIsNjY3LDYxOCw2MTEsNjY3LDc5OCw2NjcsODM1LDc0OCwyNzgsNjY3LDU3OCw0NDYsNTU2LDIyMiw1NDcsNTc4LDU3NSw1MDAsNTU3LDQ0Niw0NDEsNTU2LDU1NiwyMjIsNTAwLDUwMCw1NzYsNTAwLDQ0OCw1NTYsNjkwLDU2OSw0ODIsNjE3LDM5NSw1NDcsNjQ4LDUyNSw3MTMsNzgxLDIyMiw1NDcsNTU2LDU0Nyw3ODEsNjY3LDY2Nyw4NjUsNTQyLDcxOSw2NjcsMjc4LDI3OCw1MDAsMTA1NywxMDEwLDg1NCw1ODMsNzIyLDYzNSw3MTksNjY3LDY1Niw2NjcsNTQyLDY3Nyw2NjcsOTIzLDYwNCw3MTksNzE5LDU4Myw2NTYsODMzLDcyMiw3NzgsNzE5LDY2Nyw3MjIsNjExLDYzNSw3NjAsNjY3LDc0MCw2NjcsOTE3LDkzOCw3OTIsODg1LDY1Niw3MTksMTAxMCw3MjIsNTU2LDU3Myw1MzEsMzY1LDU4Myw1NTYsNjY5LDQ1OCw1NTksNTU5LDQzOCw1ODMsNjg4LDU1Miw1NTYsNTQyLDU1Niw1MDAsNDU4LDUwMCw4MjMsNTAwLDU3Myw1MjEsODAyLDgyMyw2MjUsNzE5LDUyMSw1MTAsNzUwLDU0Miw1NTYsNTU2LDU1NiwzNjUsNTEwLDUwMCwyMjIsMjc4LDIyMiw5MDYsODEyLDU1Niw0MzgsNTU5LDUwMCw1NTIsNzc4LDU1Niw0ODksNDExLDk0NCw3MjIsOTQ0LDcyMiw5NDQsNzIyLDY2Nyw1MDAsMzMzLDMzMyw1NTYsMWUzLDFlMyw1NTIsMjIyLDIyMiwyMjIsMjIyLDMzMywzMzMsMzMzLDU1Niw1NTYsMzUwLDFlMywxZTMsMTg4LDM1NCwzMzMsMzMzLDUwMCwzMzMsMTY3LDM2NSw1NTYsNTU2LDEwOTQsNTU2LDg4NSwzMjMsMTA3MywxZTMsNzY4LDYwMCw4MzQsODM0LDgzNCw4MzQsMWUzLDUwMCwxZTMsNTAwLDFlMyw1MDAsNTAwLDQ5NCw2MTIsODIzLDcxMyw1ODQsNTQ5LDcxMyw5NzksNzE5LDI3NCw1NDksNTQ5LDU4Myw1NDksNTQ5LDYwNCw1ODQsNjA0LDYwNCw3MDgsNjI1LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcyOSw2MDQsNjA0LDM1NCwzNTQsMWUzLDk5MCw5OTAsOTkwLDk5MCw0OTQsNjA0LDYwNCw2MDQsNjA0LDM1NCwxMDIxLDEwNTIsOTE3LDc1MCw3NTAsNTMxLDY1Niw1OTQsNTEwLDUwMCw3NTAsNzUwLDUwMCw1MDAsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywyMjIsMjIyLDI5NCwyOTQsMzI0LDMyNCwzMTYsMzI4LDM5OCwyODVdLE5pPVstMSwtMSwtMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDExMSwxMTIsMTEzLDExNCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDEyMywxMjQsMTI1LDEyNiwxNjEsMTYyLDE2MywxNjQsMTY1LDE2NiwxNjcsMTY4LDE2OSwxNzAsMTcxLDE3MiwxNzQsMTc1LDE3NiwxNzcsMTc4LDE3OSwxODAsMTgxLDE4MiwxODMsMTg0LDE4NSwxODYsMTg3LDE4OCwxODksMTkwLDE5MSwxOTIsMTkzLDE5NCwxOTUsMTk2LDE5NywxOTgsMTk5LDIwMCwyMDEsMjAyLDIwMywyMDQsMjA1LDIwNiwyMDcsMjA4LDIwOSwyMTAsMjExLDIxMiwyMTMsMjE0LDIxNSwyMTYsMjE3LDIxOCwyMTksMjIwLDIyMSwyMjIsMjIzLDIyNCwyMjUsMjI2LDIyNywyMjgsMjI5LDIzMCwyMzEsMjMyLDIzMywyMzQsMjM1LDIzNiwyMzcsMjM4LDIzOSwyNDAsMjQxLDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDksMjUwLDI1MSwyNTIsMjUzLDI1NCwyNTUsMjU2LDI1NywyNTgsMjU5LDI2MCwyNjEsMjYyLDI2MywyNjQsMjY1LDI2NiwyNjcsMjY4LDI2OSwyNzAsMjcxLDI3MiwyNzMsMjc0LDI3NSwyNzYsMjc3LDI3OCwyNzksMjgwLDI4MSwyODIsMjgzLDI4NCwyODUsMjg2LDI4NywyODgsMjg5LDI5MCwyOTEsMjkyLDI5MywyOTQsMjk1LDI5NiwyOTcsMjk4LDI5OSwzMDAsMzAxLDMwMiwzMDMsMzA0LDMwNSwzMDYsMzA3LDMwOCwzMDksMzEwLDMxMSwzMTIsMzEzLDMxNCwzMTUsMzE2LDMxNywzMTgsMzE5LDMyMCwzMjEsMzIyLDMyMywzMjQsMzI1LDMyNiwzMjcsMzI4LDMyOSwzMzAsMzMxLDMzMiwzMzMsMzM0LDMzNSwzMzYsMzM3LDMzOCwzMzksMzQwLDM0MSwzNDIsMzQzLDM0NCwzNDUsMzQ2LDM0NywzNDgsMzQ5LDM1MCwzNTEsMzUyLDM1MywzNTQsMzU1LDM1NiwzNTcsMzU4LDM1OSwzNjAsMzYxLDM2MiwzNjMsMzY0LDM2NSwzNjYsMzY3LDM2OCwzNjksMzcwLDM3MSwzNzIsMzczLDM3NCwzNzUsMzc2LDM3NywzNzgsMzc5LDM4MCwzODEsMzgyLDM4Myw0MDIsNTA2LDUwNyw1MDgsNTA5LDUxMCw1MTEsNTM2LDUzNyw1MzgsNTM5LDcxMCw3MTEsNzEzLDcyOCw3MjksNzMwLDczMSw3MzIsNzMzLDkwMCw5MDEsOTAyLDkwMyw5MDQsOTA1LDkwNiw5MDgsOTEwLDkxMSw5MTIsOTEzLDkxNCw5MTUsOTE2LDkxNyw5MTgsOTE5LDkyMCw5MjEsOTIyLDkyMyw5MjQsOTI1LDkyNiw5MjcsOTI4LDkyOSw5MzEsOTMyLDkzMyw5MzQsOTM1LDkzNiw5MzcsOTM4LDkzOSw5NDAsOTQxLDk0Miw5NDMsOTQ0LDk0NSw5NDYsOTQ3LDk0OCw5NDksOTUwLDk1MSw5NTIsOTUzLDk1NCw5NTUsOTU2LDk1Nyw5NTgsOTU5LDk2MCw5NjEsOTYyLDk2Myw5NjQsOTY1LDk2Niw5NjcsOTY4LDk2OSw5NzAsOTcxLDk3Miw5NzMsOTc0LDEwMjQsMTAyNSwxMDI2LDEwMjcsMTAyOCwxMDI5LDEwMzAsMTAzMSwxMDMyLDEwMzMsMTAzNCwxMDM1LDEwMzYsMTAzNywxMDM4LDEwMzksMTA0MCwxMDQxLDEwNDIsMTA0MywxMDQ0LDEwNDUsMTA0NiwxMDQ3LDEwNDgsMTA0OSwxMDUwLDEwNTEsMTA1MiwxMDUzLDEwNTQsMTA1NSwxMDU2LDEwNTcsMTA1OCwxMDU5LDEwNjAsMTA2MSwxMDYyLDEwNjMsMTA2NCwxMDY1LDEwNjYsMTA2NywxMDY4LDEwNjksMTA3MCwxMDcxLDEwNzIsMTA3MywxMDc0LDEwNzUsMTA3NiwxMDc3LDEwNzgsMTA3OSwxMDgwLDEwODEsMTA4MiwxMDgzLDEwODQsMTA4NSwxMDg2LDEwODcsMTA4OCwxMDg5LDEwOTAsMTA5MSwxMDkyLDEwOTMsMTA5NCwxMDk1LDEwOTYsMTA5NywxMDk4LDEwOTksMTEwMCwxMTAxLDExMDIsMTEwMywxMTA0LDExMDUsMTEwNiwxMTA3LDExMDgsMTEwOSwxMTEwLDExMTEsMTExMiwxMTEzLDExMTQsMTExNSwxMTE2LDExMTcsMTExOCwxMTE5LDExMzgsMTEzOSwxMTY4LDExNjksNzgwOCw3ODA5LDc4MTAsNzgxMSw3ODEyLDc4MTMsNzkyMiw3OTIzLDgyMDgsODIwOSw4MjExLDgyMTIsODIxMyw4MjE1LDgyMTYsODIxNyw4MjE4LDgyMTksODIyMCw4MjIxLDgyMjIsODIyNCw4MjI1LDgyMjYsODIzMCw4MjQwLDgyNDIsODI0Myw4MjQ5LDgyNTAsODI1Miw4MjU0LDgyNjAsODMxOSw4MzU1LDgzNTYsODM1OSw4MzY0LDg0NTMsODQ2Nyw4NDcwLDg0ODIsODQ4Niw4NDk0LDg1MzksODU0MCw4NTQxLDg1NDIsODU5Miw4NTkzLDg1OTQsODU5NSw4NTk2LDg1OTcsODYxNiw4NzA2LDg3MTAsODcxOSw4NzIxLDg3MjIsODczMCw4NzM0LDg3MzUsODc0NSw4NzQ3LDg3NzYsODgwMCw4ODAxLDg4MDQsODgwNSw4OTYyLDg5NzYsODk5Miw4OTkzLDk0NzIsOTQ3NCw5NDg0LDk0ODgsOTQ5Miw5NDk2LDk1MDAsOTUwOCw5NTE2LDk1MjQsOTUzMiw5NTUyLDk1NTMsOTU1NCw5NTU1LDk1NTYsOTU1Nyw5NTU4LDk1NTksOTU2MCw5NTYxLDk1NjIsOTU2Myw5NTY0LDk1NjUsOTU2Niw5NTY3LDk1NjgsOTU2OSw5NTcwLDk1NzEsOTU3Miw5NTczLDk1NzQsOTU3NSw5NTc2LDk1NzcsOTU3OCw5NTc5LDk1ODAsOTYwMCw5NjA0LDk2MDgsOTYxMiw5NjE2LDk2MTcsOTYxOCw5NjE5LDk2MzIsOTYzMyw5NjQyLDk2NDMsOTY0NCw5NjUwLDk2NTgsOTY2MCw5NjY4LDk2NzQsOTY3NSw5Njc5LDk2ODgsOTY4OSw5NzAyLDk3ODYsOTc4Nyw5Nzg4LDk3OTIsOTc5NCw5ODI0LDk4MjcsOTgyOSw5ODMwLDk4MzQsOTgzNSw5ODM2LDYxNDQxLDYxNDQyLDYxNDQ1LC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xXSxFaT1bMS4zNjg5OCwxLDEsLjcyNzA2LC44MDQ3OSwuODM3MzQsLjk4ODk0LC45OTc5MywuOTg5NywuOTM4ODQsLjg2MjA5LC45NDI5MiwuOTQyOTIsMS4xNjY2MSwxLjAyMDU4LC45MzU4MiwuOTY2OTQsLjkzNTgyLDEuMTkxMzcsLjk5NzkzLC45OTc5MywuOTk3OTMsLjk5NzkzLC45OTc5MywuOTk3OTMsLjk5NzkzLC45OTc5MywuOTk3OTMsLjk5NzkzLC43ODA3NiwuNzgwNzYsMS4wMjA1OCwxLjAyMDU4LDEuMDIwNTgsLjcyODUxLC43ODk2NiwuOTA4MzgsLjgzNjM3LC44MjM5MSwuOTYzNzYsLjgwMDYxLC44NjI3NSwuODc2OCwuOTU0MDcsMS4wMjU4LC43MzkwMSwuODUwMjIsLjgzNjU1LDEuMDE1NiwuOTU1NDYsLjkyMTc5LC44NzEwNywuOTIxNzksLjgyMTE0LC44MDk2LC44OTcxMywuOTQ0MzgsLjk1MzUzLC45NDA4MywuOTE5MDUsLjkwNDA2LC45NDQ2LC45NDI5MiwxLjE4Nzc3LC45NDI5MiwxLjAyMDU4LC44OTkwMywuOTAwODgsLjk0OTM4LC45Nzg5OCwuODEwOTMsLjk3NTcxLC45NDkzOCwxLjAyNCwuOTU3NywuOTU5MzMsLjk4NjIxLDEuMDQ3NCwuOTc0NTUsLjk4OTgxLC45NjcyLC45NTkzMywuOTQ0NiwuOTc4OTgsLjk3NDA3LC45NzY0NiwuNzgwMzYsMS4xMDIwOCwuOTU0NDIsLjk1Mjk4LC45NzU3OSwuOTMzMiwuOTQwMzksLjkzOCwuODA2ODcsMS4wMTE0OSwuODA2ODcsMS4wMjA1OCwuODA0NzksLjk5NzkzLC45OTc5MywuOTk3OTMsLjk5NzkzLDEuMDExNDksMS4wMDg3MiwuOTAwODgsLjkxODgyLDEuMDIxMywuODM2MSwxLjAyMDU4LC42MjI5NSwuNTQzMjQsLjg5MDIyLDEuMDg1OTUsMSwxLC45MDA4OCwxLC45NzQ1NSwuOTM1ODIsLjkwMDg4LDEsMS4wNTY4NiwuODM2MSwuOTk2NDIsLjk5NjQyLC45OTY0MiwuNzI4NTEsLjkwODM4LC45MDgzOCwuOTA4MzgsLjkwODM4LC45MDgzOCwuOTA4MzgsLjg2OCwuODIzOTEsLjgwMDYxLC44MDA2MSwuODAwNjEsLjgwMDYxLDEuMDI1OCwxLjAyNTgsMS4wMjU4LDEuMDI1OCwuOTc0ODQsLjk1NTQ2LC45MjE3OSwuOTIxNzksLjkyMTc5LC45MjE3OSwuOTIxNzksMS4wMjA1OCwuOTIxNzksLjk0NDM4LC45NDQzOCwuOTQ0MzgsLjk0NDM4LC45MDQwNiwuODY5NTgsLjk4MjI1LC45NDkzOCwuOTQ5MzgsLjk0OTM4LC45NDkzOCwuOTQ5MzgsLjk0OTM4LC45MDMxLC44MTA5MywuOTQ5MzgsLjk0OTM4LC45NDkzOCwuOTQ5MzgsLjk4NjIxLC45ODYyMSwuOTg2MjEsLjk4NjIxLC45Mzk2OSwuOTU5MzMsLjk0NDYsLjk0NDYsLjk0NDYsLjk0NDYsLjk0NDYsMS4wODU5NSwuOTQ0NiwuOTU0NDIsLjk1NDQyLC45NTQ0MiwuOTU0NDIsLjk0MDM5LC45Nzg5OCwuOTQwMzksLjkwODM4LC45NDkzOCwuOTA4MzgsLjk0OTM4LC45MDgzOCwuOTQ5MzgsLjgyMzkxLC44MTA5MywuODIzOTEsLjgxMDkzLC44MjM5MSwuODEwOTMsLjgyMzkxLC44MTA5MywuOTYzNzYsLjg0MzEzLC45NzQ4NCwuOTc1NzEsLjgwMDYxLC45NDkzOCwuODAwNjEsLjk0OTM4LC44MDA2MSwuOTQ5MzgsLjgwMDYxLC45NDkzOCwuODAwNjEsLjk0OTM4LC44NzY4LC45NTc3LC44NzY4LC45NTc3LC44NzY4LC45NTc3LDEsMSwuOTU0MDcsLjk1OTMzLC45NzA2OSwuOTU5MzMsMS4wMjU4LC45ODYyMSwxLjAyNTgsLjk4NjIxLDEuMDI1OCwuOTg2MjEsMS4wMjU4LC45ODYyMSwxLjAyNTgsLjk4NjIxLC44ODcsMS4wMTU5MSwuNzM5MDEsMS4wNDc0LDEsMSwuOTc0NTUsLjgzNjU1LC45ODk4MSwxLDEsLjgzNjU1LC43Mzk3NywuODM2NTUsLjczOTAzLC44NDYzOCwxLjAzMywuOTU1NDYsLjk1OTMzLDEsMSwuOTU1NDYsLjk1OTMzLC44MjcxLC45NTQxNywuOTU5MzMsLjkyMTc5LC45NDQ2LC45MjE3OSwuOTQ0NiwuOTIxNzksLjk0NDYsLjkzNiwuOTE5NjQsLjgyMTE0LC45NzY0NiwxLDEsLjgyMTE0LC45NzY0NiwuODA5NiwuNzgwMzYsLjgwOTYsLjc4MDM2LDEsMSwuODA5NiwuNzgwMzYsMSwxLC44OTcxMywuNzc0NTIsLjg5NzEzLDEuMTAyMDgsLjk0NDM4LC45NTQ0MiwuOTQ0MzgsLjk1NDQyLC45NDQzOCwuOTU0NDIsLjk0NDM4LC45NTQ0MiwuOTQ0MzgsLjk1NDQyLC45NDQzOCwuOTU0NDIsLjk0MDgzLC45NzU3OSwuOTA0MDYsLjk0MDM5LC45MDQwNiwuOTQ0NiwuOTM4LC45NDQ2LC45MzgsLjk0NDYsLjkzOCwxLC45OTc5MywuOTA4MzgsLjk0OTM4LC44NjgsLjkwMzEsLjkyMTc5LC45NDQ2LDEsMSwuODk3MTMsMS4xMDIwOCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTA5ODksLjkzNTgsLjkxOTQ1LC44MzE4MSwuNzUyNjEsLjg3OTkyLC44Mjk3NiwuOTYwMzQsLjgzNjg5LC45NzI2OCwxLjAwNzgsLjkwODM4LC44MzYzNywuODAxOSwuOTAxNTcsLjgwMDYxLC45NDQ2LC45NTQwNywuOTI0MzYsMS4wMjU4LC44NTAyMiwuOTcxNTMsMS4wMTU2LC45NTU0NiwuODkxOTIsLjkyMTc5LC45MjM2MSwuODcxMDcsLjk2MzE4LC44OTcxMywuOTM3MDQsLjk1NjM4LC45MTkwNSwuOTE3MDksLjkyNzk2LDEuMDI1OCwuOTM3MDQsLjk0ODM2LDEuMDM3MywuOTU5MzMsMS4wMDc4LC45NTg3MSwuOTQ4MzYsLjk2MTc0LC45MjYwMSwuOTQ5OCwuOTg2MDcsLjk1Nzc2LC45NTkzMywxLjA1NDUzLDEuMDA3OCwuOTgyNzUsLjkzMTQsLjk1NjE3LC45MTcwMSwxLjA1OTkzLC45NDQ2LC43ODM2NywuOTU1MywxLC44NjgzMiwxLjAxMjgsLjk1ODcxLC45OTM5NCwuODc1NDgsLjk2MzYxLC44Njc3NCwxLjAwNzgsLjk1ODcxLC45NDQ2LC45NTg3MSwuODY3NzQsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTQwODMsLjk3NTc5LC45NDA4MywuOTc1NzksLjk0MDgzLC45NzU3OSwuOTA0MDYsLjk0MDM5LC45NjY5NCwxLC44OTkwMywxLDEsMSwuOTM1ODIsLjkzNTgyLC45MzU4MiwxLC45MDgsLjkwOCwuOTE4LC45NDIxOSwuOTQyMTksLjk2NTQ0LDEsMS4yODUsMSwxLC44MTA3OSwuODEwNzksMSwxLC43NDg1NCwxLDEsMSwxLC45OTc5MywxLDEsMSwuNjUsMSwxLjM2MTQ1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjE3MTczLDEsLjgwNTM1LC43NjE2OSwxLjAyMDU4LDEuMDczMiwxLjA1NDg2LDEsMSwxLjMwNjkyLDEuMDg1OTUsMS4wODU5NSwxLDEuMDg1OTUsMS4wODU5NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMTYxNjEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sUGk9e2xpbmVIZWlnaHQ6MS4yLGxpbmVHYXA6LjJ9LGppPVsxLjM2ODk4LDEsMSwuNjYyMjcsLjgwNzc5LC44MTYyNSwuOTcyNzYsLjk3Mjc2LC45NzczMywuOTIyMjIsLjgzMjY2LC45NDI5MiwuOTQyOTIsMS4xNjE0OCwxLjAyMDU4LC45MzU4MiwuOTY2OTQsLjkzNTgyLDEuMTczMzcsLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC43ODA3NiwuNzgwNzYsMS4wMjA1OCwxLjAyMDU4LDEuMDIwNTgsLjcxNTQxLC43NjgxMywuODU1NzYsLjgwNTkxLC44MDcyOSwuOTQyOTksLjc3NTEyLC44MzY1NSwuODY1MjMsLjkyMjIyLC45ODYyMSwuNzE3NDMsLjgxNjk4LC43OTcyNiwuOTg1NTgsLjkyMjIyLC45MDYzNywuODM4MDksLjkwNjM3LC44MDcyOSwuNzY0NjMsLjg2Mjc1LC45MDY5OSwuOTE2MDUsLjkxNTQsLjg1MzA4LC44NTQ1OCwuOTA1MzEsLjk0MjkyLDEuMjEyOTYsLjk0MjkyLDEuMDIwNTgsLjg5OTAzLDEuMTg2MTYsLjk5NjEzLC45MTY3NywuNzgyMTYsLjkxNjc3LC45MDA4MywuOTg3OTYsLjkxMzUsLjkyMTY4LC45NTM4MSwuOTg5ODEsLjk1Mjk4LC45NTM4MSwuOTM0NTksLjkyMTY4LC45MTUxMywuOTIwMDQsLjkxNjc3LC45NTA3NywuNzQ4LDEuMDQ1MDIsLjkxNjc3LC45MjA2MSwuOTQyMzYsLjg5NTQ0LC44OTM2NCwuOSwuODA2ODcsLjg1NzgsLjgwNjg3LDEuMDIwNTgsLjgwNzc5LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC45NzI3NiwuODU3OCwuOTk5NzMsMS4xODYxNiwuOTEzMzksMS4wODA3NCwuODI4OTEsMS4wMjA1OCwuNTU1MDksLjcxNTI2LC44OTAyMiwxLjA4NTk1LDEsMSwxLjE4NjE2LDEsLjk2NzM2LC45MzU4MiwxLjE4NjE2LDEsMS4wNDg2NCwuODI3MTEsLjk5MDQzLC45OTA0MywuOTkwNDMsLjcxNTQxLC44NTU3NiwuODU1NzYsLjg1NTc2LC44NTU3NiwuODU1NzYsLjg1NTc2LC44NDUsLjgwNzI5LC43NzUxMiwuNzc1MTIsLjc3NTEyLC43NzUxMiwuOTg2MjEsLjk4NjIxLC45ODYyMSwuOTg2MjEsLjk1OTYxLC45MjIyMiwuOTA2MzcsLjkwNjM3LC45MDYzNywuOTA2MzcsLjkwNjM3LDEuMDIwNTgsLjkwMjUxLC45MDY5OSwuOTA2OTksLjkwNjk5LC45MDY5OSwuODU0NTgsLjgzNjU5LC45NDk1MSwuOTk2MTMsLjk5NjEzLC45OTYxMywuOTk2MTMsLjk5NjEzLC45OTYxMywuODU4MTEsLjc4MjE2LC45MDA4MywuOTAwODMsLjkwMDgzLC45MDA4MywuOTUzODEsLjk1MzgxLC45NTM4MSwuOTUzODEsLjkxMzUsLjkyMTY4LC45MTUxMywuOTE1MTMsLjkxNTEzLC45MTUxMywuOTE1MTMsMS4wODU5NSwuOTE2NzcsLjkxNjc3LC45MTY3NywuOTE2NzcsLjkxNjc3LC44OTM2NCwuOTIzMzIsLjg5MzY0LC44NTU3NiwuOTk2MTMsLjg1NTc2LC45OTYxMywuODU1NzYsLjk5NjEzLC44MDcyOSwuNzgyMTYsLjgwNzI5LC43ODIxNiwuODA3MjksLjc4MjE2LC44MDcyOSwuNzgyMTYsLjk0Mjk5LC43Njc4MywuOTU5NjEsLjkxNjc3LC43NzUxMiwuOTAwODMsLjc3NTEyLC45MDA4MywuNzc1MTIsLjkwMDgzLC43NzUxMiwuOTAwODMsLjc3NTEyLC45MDA4MywuODY1MjMsLjkxMzUsLjg2NTIzLC45MTM1LC44NjUyMywuOTEzNSwxLDEsLjkyMjIyLC45MjE2OCwuOTIyMjIsLjkyMTY4LC45ODYyMSwuOTUzODEsLjk4NjIxLC45NTM4MSwuOTg2MjEsLjk1MzgxLC45ODYyMSwuOTUzODEsLjk4NjIxLC45NTM4MSwuODYwMzYsLjk3MDk2LC43MTc0MywuOTg5ODEsMSwxLC45NTI5OCwuNzk3MjYsLjk1MzgxLDEsMSwuNzk3MjYsLjY4OTQsLjc5NzI2LC43NDMyMSwuODE2OTEsMS4wMDA2LC45MjIyMiwuOTIxNjgsMSwxLC45MjIyMiwuOTIxNjgsLjc5NDY0LC45MjA5OCwuOTIxNjgsLjkwNjM3LC45MTUxMywuOTA2MzcsLjkxNTEzLC45MDYzNywuOTE1MTMsLjkwOSwuODc1MTQsLjgwNzI5LC45NTA3NywxLDEsLjgwNzI5LC45NTA3NywuNzY0NjMsLjc0OCwuNzY0NjMsLjc0OCwxLDEsLjc2NDYzLC43NDgsMSwxLC44NjI3NSwuNzI2NTEsLjg2Mjc1LDEuMDQ1MDIsLjkwNjk5LC45MTY3NywuOTA2OTksLjkxNjc3LC45MDY5OSwuOTE2NzcsLjkwNjk5LC45MTY3NywuOTA2OTksLjkxNjc3LC45MDY5OSwuOTE2NzcsLjkxNTQsLjk0MjM2LC44NTQ1OCwuODkzNjQsLjg1NDU4LC45MDUzMSwuOSwuOTA1MzEsLjksLjkwNTMxLC45LDEsLjk3Mjc2LC44NTU3NiwuOTk2MTMsLjg0NSwuODU4MTEsLjkwMjUxLC45MTY3NywxLDEsLjg2Mjc1LDEuMDQ1MDIsMS4xODYxNiwxLjE4NjE2LDEuMTg2MTYsMS4xODYxNiwxLjE4NjE2LDEuMTg2MTYsMS4xODYxNiwxLjE4NjE2LDEuMTg2MTYsMS4wMDg5OSwxLjMwNjI4LC44NTU3NiwuODAxNzgsLjY2ODYyLC43OTI3LC42OTMyMywuODgxMjcsLjcyNDU5LC44OTcxMSwuOTUzODEsLjg1NTc2LC44MDU5MSwuNzgwNSwuOTQ3MjksLjc3NTEyLC45MDUzMSwuOTIyMjIsLjkwNjM3LC45ODYyMSwuODE2OTgsLjkyNjU1LC45ODU1OCwuOTIyMjIsLjg1MzU5LC45MDYzNywuOTA5NzYsLjgzODA5LC45NDUyMywuODYyNzUsLjgzNTA5LC45MzE1NywuODUzMDgsLjgzMzkyLC45MjM0NiwuOTg2MjEsLjgzNTA5LC45Mjg4NiwuOTEzMjQsLjkyMTY4LC45NTM4MSwuOTA2NDYsLjkyODg2LC45MDU1NywuODY4NDcsLjkwMjc2LC45MTMyNCwuODY4NDIsLjkyMTY4LC45OTUzMSwuOTUzODEsLjkyMjQsLjg1NDA4LC45MjY5OSwuODY4NDcsMS4wMDUxLC45MTUxMywuODA0ODcsLjkzNDgxLDEsLjg4MTU5LDEuMDUyMTQsLjkwNjQ2LC45NzM1NSwuODE1MzksLjg5Mzk4LC44NTkyMywuOTUzODEsLjkwNjQ2LC45MTUxMywuOTA2NDYsLjg1OTIzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjkxNTQsLjk0MjM2LC45MTU0LC45NDIzNiwuOTE1NCwuOTQyMzYsLjg1NDU4LC44OTM2NCwuOTY2OTQsMSwuODk5MDMsMSwxLDEsLjkxNzgyLC45MTc4MiwuOTE3ODIsMSwuODk2LC44OTYsLjg5NiwuOTMzMiwuOTMzMiwuOTU5NzMsMSwxLjI2LDEsMSwuODA0NzksLjgwMTc4LDEsMSwuODU2MzMsMSwxLDEsMSwuOTcyNzYsMSwxLDEsLjY5OCwxLDEuMzYxNDUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMTQ1NDIsMSwuNzkxOTksLjc4Njk0LDEuMDIwNTgsMS4wMzQ5MywxLjA1NDg2LDEsMSwxLjIzMDI2LDEuMDg1OTUsMS4wODU5NSwxLDEuMDg1OTUsMS4wODU5NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMjAwMDYsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sX2k9e2xpbmVIZWlnaHQ6MS4yLGxpbmVHYXA6LjJ9LFhpPVsxLjM2ODk4LDEsMSwuNjU1MDcsLjg0OTQzLC44NTYzOSwuODg0NjUsLjg4NDY1LC44NjkzNiwuODgzMDcsLjg2OTQ4LC44NTI4MywuODUyODMsMS4wNjM4MywxLjAyMDU4LC43NTk0NSwuOTIxOSwuNzU5NDUsMS4xNzMzNywuODg0NjUsLjg4NDY1LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44ODQ2NSwuODg0NjUsLjc1OTQ1LC43NTk0NSwxLjAyMDU4LDEuMDIwNTgsMS4wMjA1OCwuNjkwNDYsLjcwOTI2LC44NTE1OCwuNzc4MTIsLjc2ODUyLC44OTU5MSwuNzA0NjYsLjc2MTI1LC44MDA5NCwuODY4MjIsLjgzODY0LC43MjgsLjc3MjEyLC43OTQ3NSwuOTM2MzcsLjg3NTE0LC44NTg4LC43NjAxMywuODU4OCwuNzI0MjEsLjY5ODY2LC43NzU5OCwuODU5OTEsLjgwODExLC44NzgzMiwuNzgxMTIsLjc3NTEyLC44NTYyLDEuMDIyMiwxLjE4NDE3LDEuMDIyMiwxLjI3MDE0LC44OTkwMywxLjE1MDEyLC45Mzg1OSwuOTQzOTksLjg0NiwuOTQzOTksLjgxNDUzLDEuMDE4NiwuOTQyMTksLjk2MDE3LDEuMDMwNzUsMS4wMjE3NSwuOTEyLDEuMDMwNzUsLjk2OTk4LC45NjAxNywuOTM4NTksLjk0Mzk5LC45NDM5OSwuOTU0OTMsLjc0NiwxLjEyNjU4LC45NDU3OCwuOTEsLjk3OSwuODgyLC44ODIsLjgzLC44NTAzNCwuODM1MzcsLjg1MDM0LDEuMDIwNTgsLjcwODY5LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44ODQ2NSwuODM1MzcsLjkwMDgzLDEuMTUwMTIsLjkxNjEsLjk0NTY1LC43MzU0MSwxLjAyMDU4LC41MzYwOSwuNjkzNTMsLjc5NTE5LDEuMDg1OTUsMSwxLDEuMTUwMTIsMSwuOTE5NzQsLjc1OTQ1LDEuMTUwMTIsMSwuOTQ0NiwuNzMzNjEsLjkwMDUsLjkwMDUsLjkwMDUsLjYyODY0LC44NTE1OCwuODUxNTgsLjg1MTU4LC44NTE1OCwuODUxNTgsLjg1MTU4LC43NzMsLjc2ODUyLC43MDQ2NiwuNzA0NjYsLjcwNDY2LC43MDQ2NiwuODM4NjQsLjgzODY0LC44Mzg2NCwuODM4NjQsLjkwNTYxLC44NzUxNCwuODU4OCwuODU4OCwuODU4OCwuODU4OCwuODU4OCwxLjAyMDU4LC44NTc1MSwuODU5OTEsLjg1OTkxLC44NTk5MSwuODU5OTEsLjc3NTEyLC43NjAxMywuODgwNzUsLjkzODU5LC45Mzg1OSwuOTM4NTksLjkzODU5LC45Mzg1OSwuOTM4NTksLjgwNzUsLjg0NiwuODE0NTMsLjgxNDUzLC44MTQ1MywuODE0NTMsLjgyNDI0LC44MjQyNCwuODI0MjQsLjgyNDI0LC45Mjc4LC45NjAxNywuOTM4NTksLjkzODU5LC45Mzg1OSwuOTM4NTksLjkzODU5LDEuMDg1OTUsLjg1NjIsLjk0NTc4LC45NDU3OCwuOTQ1NzgsLjk0NTc4LC44ODIsLjk0NTc4LC44ODIsLjg1MTU4LC45Mzg1OSwuODUxNTgsLjkzODU5LC44NTE1OCwuOTM4NTksLjc2ODUyLC44NDYsLjc2ODUyLC44NDYsLjc2ODUyLC44NDYsLjc2ODUyLC44NDYsLjg5NTkxLC44NTQ0LC45MDU2MSwuOTQzOTksLjcwNDY2LC44MTQ1MywuNzA0NjYsLjgxNDUzLC43MDQ2NiwuODE0NTMsLjcwNDY2LC44MTQ1MywuNzA0NjYsLjgxNDUzLC44MDA5NCwuOTQyMTksLjgwMDk0LC45NDIxOSwuODAwOTQsLjk0MjE5LDEsMSwuODY4MjIsLjk2MDE3LC44NjgyMiwuOTYwMTcsLjgzODY0LC44MjQyNCwuODM4NjQsLjgyNDI0LC44Mzg2NCwuODI0MjQsLjgzODY0LDEuMDMwNzUsLjgzODY0LC44MjQyNCwuODE0MDIsMS4wMjczOCwuNzI4LDEuMDIxNzUsMSwxLC45MTIsLjc5NDc1LDEuMDMwNzUsMSwxLC43OTQ3NSwuODM5MTEsLjc5NDc1LC42NjI2NiwuODA1NTMsMS4wNjY3NiwuODc1MTQsLjk2MDE3LDEsMSwuODc1MTQsLjk2MDE3LC44Njg2NSwuODczOTYsLjk2MDE3LC44NTg4LC45Mzg1OSwuODU4OCwuOTM4NTksLjg1ODgsLjkzODU5LC44NjcsLjg0NzU5LC43MjQyMSwuOTU0OTMsMSwxLC43MjQyMSwuOTU0OTMsLjY5ODY2LC43NDYsLjY5ODY2LC43NDYsMSwxLC42OTg2NiwuNzQ2LDEsMSwuNzc1OTgsLjg4NDE3LC43NzU5OCwxLjEyNjU4LC44NTk5MSwuOTQ1NzgsLjg1OTkxLC45NDU3OCwuODU5OTEsLjk0NTc4LC44NTk5MSwuOTQ1NzgsLjg1OTkxLC45NDU3OCwuODU5OTEsLjk0NTc4LC44NzgzMiwuOTc5LC43NzUxMiwuODgyLC43NzUxMiwuODU2MiwuODMsLjg1NjIsLjgzLC44NTYyLC44MywxLC44ODQ2NSwuODUxNTgsLjkzODU5LC43NzMsLjgwNzUsLjg1NzUxLC44NTYyLDEsMSwuNzc1OTgsMS4xMjY1OCwxLjE1MDEyLDEuMTUwMTIsMS4xNTAxMiwxLjE1MDEyLDEuMTUwMTIsMS4xNTMxMywxLjE1MDEyLDEuMTUwMTIsMS4xNTAxMiwxLjA4MTA2LDEuMDM5MDEsLjg1MTU4LC43NzAyNSwuNjIyNjQsLjc2NDYsLjY1MzUxLC44NjAyNiwuNjk0NjEsLjg5OTQ3LDEuMDMwNzUsLjg1MTU4LC43NzgxMiwuNzY0NDksLjg4ODM2LC43MDQ2NiwuODU2MiwuODY4MjIsLjg1ODgsLjgzODY0LC43NzIxMiwuODUzMDgsLjkzNjM3LC44NzUxNCwuODIzNTIsLjg1ODgsLjg1NzAxLC43NjAxMywuODkwNTgsLjc3NTk4LC44MTU2LC44MjU2NSwuNzgxMTIsLjc3ODk5LC44OTM4NiwuODM4NjQsLjgxNTYsLjk0ODYsLjkyMzg4LC45NjE4NiwxLjAzMDc1LC45MTEyMywuOTQ4NiwuOTMyOTgsLjg3OCwuOTM5NDIsLjkyMzg4LC44NDU5NiwuOTYxODYsLjk1MTE5LDEuMDMwNzUsLjkyMiwuODg3ODcsLjk1ODI5LC44OCwuOTM1NTksLjkzODU5LC43ODgxNSwuOTM3NTgsMSwuODkyMTcsMS4wMzczNywuOTExMjMsLjkzOTY5LC43NzQ4NywuODU3NjksLjg2Nzk5LDEuMDMwNzUsLjkxMTIzLC45Mzg1OSwuOTExMjMsLjg2Nzk5LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjg3ODMyLC45NzksLjg3ODMyLC45NzksLjg3ODMyLC45NzksLjc3NTEyLC44ODIsLjkyMTksMSwuODk5MDMsMSwxLDEsLjg3MzIxLC44NzMyMSwuODczMjEsMSwxLjAyNywxLjAyNywxLjAyNywuODY4NDcsLjg2ODQ3LC43OTEyMSwxLDEuMTI0LDEsMSwuNzM1NzIsLjczNTcyLDEsMSwuODUwMzQsMSwxLDEsMSwuODg0NjUsMSwxLDEsLjY2OSwxLDEuMzYxNDUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDQ4MjgsMSwuNzQ5NDgsLjc1MTg3LDEuMDIwNTgsLjk4MzkxLDEuMDIxMTksMSwxLDEuMDYyMzMsMS4wODU5NSwxLjA4NTk1LDEsMS4wODU5NSwxLjA4NTk1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wNTIzMywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSxxaT17bGluZUhlaWdodDoxLjIsbGluZUdhcDouMn0sSGk9WzEuMzY4OTgsMSwxLC43NjMwNSwuODI3ODQsLjk0OTM1LC44OTM2NCwuOTIyNDEsLjg5MDczLC45MDcwNiwuOTg0NzIsLjg1MjgzLC44NTI4MywxLjA2NjQsMS4wMjA1OCwuNzQ1MDUsLjkyMTksLjc0NTA1LDEuMjM0NTYsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjkyMjQxLC43NDUwNSwuNzQ1MDUsMS4wMjA1OCwxLjAyMDU4LDEuMDIwNTgsLjczMDAyLC43MjYwMSwuOTE3NTUsLjgxMjYsLjgwMzE0LC45MjIyMiwuNzM3NjQsLjc5NzI2LC44MzA1MSwuOTAyODQsLjg2MDIzLC43NCwuODEyNiwuODQ4NjksLjk2NTE4LC45MTExNSwuODg1OCwuNzk3NjEsLjg4NTgsLjc0NDk4LC43MzkxNCwuODEzNjMsLjg5NTkxLC44MzY1OSwuODk2MzMsLjg1NjA4LC44MTExLC45MDUzMSwxLjAyMjIsMS4yMjczNiwxLjAyMjIsMS4yNzAxNCwuODk5MDMsLjkwMDg4LC44NjY2NywxLjAyMzEsLjg5NiwxLjAxNDExLC45MDA4MywxLjA1MDk5LDEuMDA1MTIsLjk5NzkzLDEuMDUzMjYsMS4wOTM3NywuOTM4LDEuMDYyMjYsMS4wMDExOSwuOTk3OTMsLjk4NzE0LDEuMDIzMSwxLjAxMjMxLC45ODE5NiwuNzkyLDEuMTkxMzcsLjk5MDc0LC45NjIsMS4wMTkxNSwuOTI2LC45NDIsLjg1NiwuODUwMzQsLjkyMDA2LC44NTAzNCwxLjAyMDU4LC42OTA2NywuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjkyMDA2LC45MzMyLC45MDA4OCwuOTE4ODIsLjkzNDg0LC43NTMzOSwxLjAyMDU4LC41Njg2NiwuNTQzMjQsLjc5NTE5LDEuMDg1OTUsMSwxLC45MDA4OCwxLC45NTMyNSwuNzQ1MDUsLjkwMDg4LDEsLjk3MTk4LC43NTMzOSwuOTEwMDksLjkxMDA5LC45MTAwOSwuNjY0NjYsLjkxNzU1LC45MTc1NSwuOTE3NTUsLjkxNzU1LC45MTc1NSwuOTE3NTUsLjc4OCwuODAzMTQsLjczNzY0LC43Mzc2NCwuNzM3NjQsLjczNzY0LC44NjAyMywuODYwMjMsLjg2MDIzLC44NjAyMywuOTI5MTUsLjkxMTE1LC44ODU4LC44ODU4LC44ODU4LC44ODU4LC44ODU4LDEuMDIwNTgsLjg4NTgsLjg5NTkxLC44OTU5MSwuODk1OTEsLjg5NTkxLC44MTExLC43OTYxMSwuODk3MTMsLjg2NjY3LC44NjY2NywuODY2NjcsLjg2NjY3LC44NjY2NywuODY2NjcsLjg2OTM2LC44OTYsLjkwMDgzLC45MDA4MywuOTAwODMsLjkwMDgzLC44NDIyNCwuODQyMjQsLjg0MjI0LC44NDIyNCwuOTcyNzYsLjk5NzkzLC45ODcxNCwuOTg3MTQsLjk4NzE0LC45ODcxNCwuOTg3MTQsMS4wODU5NSwuODk4NzYsLjk5MDc0LC45OTA3NCwuOTkwNzQsLjk5MDc0LC45NDIsMS4wMjMxLC45NDIsLjkxNzU1LC44NjY2NywuOTE3NTUsLjg2NjY3LC45MTc1NSwuODY2NjcsLjgwMzE0LC44OTYsLjgwMzE0LC44OTYsLjgwMzE0LC44OTYsLjgwMzE0LC44OTYsLjkyMjIyLC45MzM3MiwuOTI5MTUsMS4wMTQxMSwuNzM3NjQsLjkwMDgzLC43Mzc2NCwuOTAwODMsLjczNzY0LC45MDA4MywuNzM3NjQsLjkwMDgzLC43Mzc2NCwuOTAwODMsLjgzMDUxLDEuMDA1MTIsLjgzMDUxLDEuMDA1MTIsLjgzMDUxLDEuMDA1MTIsMSwxLC45MDI4NCwuOTk3OTMsLjkwOTc2LC45OTc5MywuODYwMjMsLjg0MjI0LC44NjAyMywuODQyMjQsLjg2MDIzLC44NDIyNCwuODYwMjMsMS4wNTMyNiwuODYwMjMsLjg0MjI0LC44Mjg3MywxLjA3NDY5LC43NCwxLjA5Mzc3LDEsMSwuOTM4LC44NDg2OSwxLjA2MjI2LDEsMSwuODQ4NjksLjgzNzA0LC44NDg2OSwuODE0NDEsLjg1NTg4LDEuMDg5MjcsLjkxMTE1LC45OTc5MywxLDEsLjkxMTE1LC45OTc5MywuOTE4ODcsLjkwOTkxLC45OTc5MywuODg1OCwuOTg3MTQsLjg4NTgsLjk4NzE0LC44ODU4LC45ODcxNCwuODk0LC45MTQzNCwuNzQ0OTgsLjk4MTk2LDEsMSwuNzQ0OTgsLjk4MTk2LC43MzkxNCwuNzkyLC43MzkxNCwuNzkyLDEsMSwuNzM5MTQsLjc5MiwxLDEsLjgxMzYzLC45MDQsLjgxMzYzLDEuMTkxMzcsLjg5NTkxLC45OTA3NCwuODk1OTEsLjk5MDc0LC44OTU5MSwuOTkwNzQsLjg5NTkxLC45OTA3NCwuODk1OTEsLjk5MDc0LC44OTU5MSwuOTkwNzQsLjg5NjMzLDEuMDE5MTUsLjgxMTEsLjk0MiwuODExMSwuOTA1MzEsLjg1NiwuOTA1MzEsLjg1NiwuOTA1MzEsLjg1NiwxLC45MjI0MSwuOTE3NTUsLjg2NjY3LC43ODgsLjg2OTM2LC44ODU4LC44OTg3NiwxLDEsLjgxMzYzLDEuMTkxMzcsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMzg4LDEuMDM5MDEsLjkyMTM4LC43ODEwNSwuNzE1NCwuODYxNjksLjgwNTEzLC45NDAwNywuODI1MjgsLjk4NjEyLDEuMDYyMjYsLjkxNzU1LC44MTI2LC44MTg4NCwuOTI4MTksLjczNzY0LC45MDUzMSwuOTAyODQsLjg4NTgsLjg2MDIzLC44MTI2LC45MTE3MiwuOTY1MTgsLjkxMTE1LC44MzA4OSwuODg1OCwuODc3OTEsLjc5NzYxLC44OTI5NywuODEzNjMsLjg4MTU3LC44OTk5MiwuODU2MDgsLjgxOTkyLC45NDMwNywuODYwMjMsLjg4MTU3LC45NTMwOCwuOTg2OTksLjk5NzkzLDEuMDYyMjYsLjk1ODE3LC45NTMwOCwuOTczNTgsLjkyOCwuOTgwODgsLjk4Njk5LC45Mjc2MSwuOTk3OTMsLjk2MDE3LDEuMDYyMjYsLjk4NiwuOTQ0LC45NTk3OCwuOTM4LC45NjcwNSwuOTg3MTQsLjgwNDQyLC45ODk3MiwxLC44OTc2MiwxLjA0NTUyLC45NTgxNywuOTkwMDcsLjg3MDY0LC45MTg3OSwuODg4ODgsMS4wNjIyNiwuOTU4MTcsLjk4NzE0LC45NTgxNywuODg4ODgsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuODk2MzMsMS4wMTkxNSwuODk2MzMsMS4wMTkxNSwuODk2MzMsMS4wMTkxNSwuODExMSwuOTQyLC45MjE5LDEsLjg5OTAzLDEsMSwxLC45MzE3MywuOTMxNzMsLjkzMTczLDEsMS4wNjMwNCwxLjA2MzA0LDEuMDY5MDQsLjg5OTAzLC44OTkwMywuODA1NDksMSwxLjE1NiwxLDEsLjc2NTc1LC43NjU3NSwxLDEsLjcyNDU4LDEsMSwxLDEsLjkyMjQxLDEsMSwxLC42MTksMSwxLjM2MTQ1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjA3MjU3LDEsLjc0NzA1LC43MTExOSwxLjAyMDU4LDEuMDI0LDEuMDIxMTksMSwxLDEuMTUzNiwxLjA4NTk1LDEuMDg1OTUsMSwxLjA4NTk1LDEuMDg1OTUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjA1NjM4LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLFdpPXtsaW5lSGVpZ2h0OjEuMixsaW5lR2FwOi4yfSx6aT1bMS43NjczOCwxLDEsLjk5Mjk3LC45ODI0LDEuMDQwMTYsMS4wNjQ5NywxLjAzNDI0LC45NzUyOSwxLjE3NjQ3LDEuMjMyMDMsMS4xMDg1LDEuMTA4NSwxLjE2OTM5LDEuMjEwNywuOTc1NCwxLjIxNDA4LC45NzU0LDEuNTk1NzgsMS4wMzQyNCwxLjAzNDI0LDEuMDM0MjQsMS4wMzQyNCwxLjAzNDI0LDEuMDM0MjQsMS4wMzQyNCwxLjAzNDI0LDEuMDM0MjQsMS4wMzQyNCwuODEzNzgsLjgxMzc4LDEuMjEwNywxLjIxMDcsMS4yMTA3LC43MTcwMywuOTc4NDcsLjk3MzYzLC44ODc3NiwuODY0MSwxLjAyMDk2LC43OTc5NSwuODUxMzIsLjkxNCwxLjA2MDg1LDEuMTQwNiwuODAwNywuODk4NTgsLjgzNjkzLDEuMTQ4ODksMS4wOTM5OCwuOTc0ODksLjkyMDk0LC45NzQ4OSwuOTAzOTksLjg0MDQxLC45NTkyMywxLjAwMTM1LDEsMS4wNjQ2NywuOTgyNDMsLjkwOTk2LC45OTM2MSwxLjEwODUsMS41Njk0MiwxLjEwODUsMS4yMTA3LC43NDYyNywuOTQyODIsLjk2NzUyLDEuMDE1MTksLjg2MzA0LDEuMDEzNTksLjk3Mjc4LDEuMTUxMDMsMS4wMTM1OSwuOTg1NjEsMS4wMjI4NSwxLjAyMjg1LDEuMDA1MjcsMS4wMjI4NSwxLjAzMDIsLjk5MDQxLDEuMDAwOCwxLjAxNTE5LDEuMDEzNTksMS4wMjI1OCwuNzkxMDQsMS4xNjg2MiwuOTkwNDEsLjk3NDU0LDEuMDI1MTEsLjk5Mjk4LC45Njc1MiwuOTU4MDEsLjk0ODU2LDEuMTY1NzksLjk0ODU2LDEuMjEwNywuOTgyNCwxLjAzNDI0LDEuMDM0MjQsMSwxLjAzNDI0LDEuMTY1NzksLjg3MjcsMS4zODcxLDEuMTg2MjIsMS4xMDgxOCwxLjA0NDc4LDEuMjEwNywxLjE4NjIyLC43NTE1NSwuOTQ5OTQsMS4yODgyNiwxLjIxNDA4LDEuMjE0MDgsLjkxMDU2LDEsLjkxNTcyLC45NzU0LC42NDY2MywxLjE4MzI4LDEuMjQ4NjYsMS4wNDQ3OCwxLjE0MTY5LDEuMTU3NDksMS4xNzM4OSwuNzE3MDMsLjk3MzYzLC45NzM2MywuOTczNjMsLjk3MzYzLC45NzM2MywuOTczNjMsLjkzNTA2LC44NjQxLC43OTc5NSwuNzk3OTUsLjc5Nzk1LC43OTc5NSwxLjE0MDYsMS4xNDA2LDEuMTQwNiwxLjE0MDYsMS4wMjA5NiwxLjA5Mzk4LC45NzQyNiwuOTc0MjYsLjk3NDI2LC45NzQyNiwuOTc0MjYsMS4yMTA3LC45NzQ4OSwxLjAwMTM1LDEuMDAxMzUsMS4wMDEzNSwxLjAwMTM1LC45MDk5NiwuOTIwOTQsMS4wMjc5OCwuOTY3NTIsLjk2NzUyLC45Njc1MiwuOTY3NTIsLjk2NzUyLC45Njc1MiwuOTMxMzYsLjg2MzA0LC45NzI3OCwuOTcyNzgsLjk3Mjc4LC45NzI3OCwxLjAyMjg1LDEuMDIyODUsMS4wMjI4NSwxLjAyMjg1LC45NzEyMiwuOTkwNDEsMSwxLDEsMSwxLDEuMjg4MjYsMS4wMDA4LC45OTA0MSwuOTkwNDEsLjk5MDQxLC45OTA0MSwuOTY3NTIsMS4wMTUxOSwuOTY3NTIsLjk3MzYzLC45Njc1MiwuOTczNjMsLjk2NzUyLC45NzM2MywuOTY3NTIsLjg2NDEsLjg2MzA0LC44NjQxLC44NjMwNCwuODY0MSwuODYzMDQsLjg2NDEsLjg2MzA0LDEuMDIwOTYsMS4wMzA1NywxLjAyMDk2LDEuMDM1MTcsLjc5Nzk1LC45NzI3OCwuNzk3OTUsLjk3Mjc4LC43OTc5NSwuOTcyNzgsLjc5Nzk1LC45NzI3OCwuNzk3OTUsLjk3Mjc4LC45MTQsMS4wMTM1OSwuOTE0LDEuMDEzNTksLjkxNCwxLjAxMzU5LDEsMSwxLjA2MDg1LC45ODU2MSwxLjA2MDg1LDEuMDA4NzksMS4xNDA2LDEuMDIyODUsMS4xNDA2LDEuMDIyODUsMS4xNDA2LDEuMDIyODUsMS4xNDA2LDEuMDIyODUsMS4xNDA2LDEuMDIyODUsLjk3MTM4LDEuMDg2OTIsLjgwMDcsMS4wMjI4NSwxLDEsMS4wMDUyNywuODM2OTMsMS4wMjI4NSwxLDEsLjgzNjkzLC45NDU1LC44MzY5MywuOTA0MTgsLjgzNjkzLDEuMTMwMDUsMS4wOTM5OCwuOTkwNDEsMSwxLDEuMDkzOTgsLjk5MDQxLC45NjY5MiwxLjA5MjUxLC45OTA0MSwuOTc0ODksMS4wMDA4LC45NzQ4OSwxLjAwMDgsLjk3NDg5LDEuMDAwOCwuOTM5OTQsLjk3OTMxLC45MDM5OSwxLjAyMjU4LDEsMSwuOTAzOTksMS4wMjI1OCwuODQwNDEsLjc5MTA0LC44NDA0MSwuNzkxMDQsLjg0MDQxLC43OTEwNCwuODQwNDEsLjc5MTA0LDEsMSwuOTU5MjMsMS4wNzAzNCwuOTU5MjMsMS4xNjg2MiwxLjAwMTM1LC45OTA0MSwxLjAwMTM1LC45OTA0MSwxLjAwMTM1LC45OTA0MSwxLjAwMTM1LC45OTA0MSwxLjAwMTM1LC45OTA0MSwxLjAwMTM1LC45OTA0MSwxLjA2NDY3LDEuMDI1MTEsLjkwOTk2LC45Njc1MiwuOTA5OTYsLjk5MzYxLC45NTgwMSwuOTkzNjEsLjk1ODAxLC45OTM2MSwuOTU4MDEsMS4wNzczMywxLjAzNDI0LC45NzM2MywuOTY3NTIsLjkzNTA2LC45MzEzNiwuOTc0ODksMS4wMDA4LDEsMSwuOTU5MjMsMS4xNjg2MiwxLjE1MTAzLDEuMTUxMDMsMS4wMTE3MywxLjAzOTU5LC43NTk1MywuODEzNzgsLjc5OTEyLDEuMTUxMDMsMS4yMTk5NCwuOTUxNjEsLjg3ODE1LDEuMDExNDksLjgxNTI1LC43Njc2LC45ODE2NywxLjAxMTM0LDEuMDI1NDYsLjg0MDk3LDEuMDMwODksMS4xODEwMiwuOTczNjMsLjg4Nzc2LC44NTEzNCwuOTc4MjYsLjc5Nzk1LC45OTM2MSwxLjA2MDg1LC45NzQ4OSwxLjE0MDYsLjg5ODU4LDEuMDM4OCwxLjE0ODg5LDEuMDkzOTgsLjg2MDM5LC45NzQ4OSwxLjA1OTUsLjkyMDk0LC45NDc5MywuOTU5MjMsLjkwOTk2LC45OTM0NiwuOTgyNDMsMS4wMjExMiwuOTU0OTMsMS4xNDA2LC45MDk5NiwxLjAzNTc0LDEuMDI1OTcsMS4wMDA4LDEuMTgxMDIsMS4wNjYyOCwxLjAzNTc0LDEuMDE5MiwxLjAxOTMyLDEuMDA4ODYsLjk3NTMxLDEuMDEwNiwxLjAwMDgsMS4xMzE4OSwxLjE4MTAyLDEuMDIyNzcsLjk4NjgzLDEuMDAxNiwuOTk1NjEsMS4wNzIzNywxLjAwMDgsLjkwNDM0LC45OTkyMSwuOTM4MDMsLjg5NjUsMS4yMzA4NSwxLjA2NjI4LDEuMDQ5ODMsLjk2MjY4LDEuMDQ5OSwuOTg0MzksMS4xODEwMiwxLjA2NjI4LDEuMDAwOCwxLjA2NjI4LC45ODQzOSwuNzk3OTUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wOTQ2NiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTcyNzgsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wMjA2NSwxLDEsMSwxLDEsMSwxLjA2NDY3LDEuMDI1MTEsMS4wNjQ2NywxLjAyNTExLDEuMDY0NjcsMS4wMjUxMSwuOTA5OTYsLjk2NzUyLDEsMS4yMTQwOCwuODk5MDMsMSwxLC43NTE1NSwxLjA0Mzk0LDEuMDQzOTQsMS4wNDM5NCwxLjA0Mzk0LC45ODYzMywuOTg2MzMsLjk4NjMzLC43MzA0NywuNzMwNDcsMS4yMDY0MiwuOTEyMTEsMS4yNTYzNSwxLjIyMiwxLjAyOTU2LDEuMDMzNzIsMS4wMzM3MiwuOTYwMzksMS4yNDYzMywxLDEuMTI0NTQsLjkzNTAzLDEuMDM0MjQsMS4xOTY4NywxLjAzNDI0LDEsMSwxLC43NzEsMSwxLDEuMTU3NDksMS4xNTc0OSwxLjE1NzQ5LDEuMTA5NDgsLjg2Mjc5LC45NDQzNCwuODYyNzksLjk0NDM0LC44NjE4MiwxLDEsMS4xNjg5NywxLC45NjA4NSwuOTAxMzcsMS4yMTA3LDEuMTg0MTYsMS4xMzk3MywuNjk4MjUsLjk3MTYsMi4xMDMzOSwxLjI5MDA0LDEuMjkwMDQsMS4yMTE3MiwxLjI5MDA0LDEuMjkwMDQsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjQyNjAzLDEsLjk5ODYyLC45OTg2MiwxLC44NzAyNSwuODcwMjUsLjg3MDI1LC44NzAyNSwxLjE4ODc0LDEuNDI2MDMsMSwxLjQyNjAzLDEuNDI2MDMsLjk5ODYyLDEsMSwxLDEsMSwxLjI4ODYsMS4wNDMxNSwxLjE1Mjk2LDEuMzQxNjMsMSwxLDEsMS4wOTE5MywxLjA5MTkzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSwkaT17bGluZUhlaWdodDoxLjMzMDA4LGxpbmVHYXA6MH0sR2k9WzEuNzY3MzgsMSwxLC45ODk0NiwxLjAzOTU5LDEuMDQwMTYsMS4wMjgwOSwxLjAzNiwuOTc2MzksMS4xMDk1MywxLjIzMjAzLDEuMTExNDQsMS4xMTE0NCwxLjE2OTM5LDEuMjEyMzcsLjk3NTQsMS4yMTI2MSwuOTc1NCwxLjU5NzU0LDEuMDM2LDEuMDM2LDEuMDM2LDEuMDM2LDEuMDM2LDEuMDM2LDEuMDM2LDEuMDM2LDEuMDM2LDEuMDM2LC44MTM3OCwuODEzNzgsMS4yMTIzNywxLjIxMjM3LDEuMjEyMzcsLjczNTQxLC45Nzg0NywuOTczNjMsLjg5NzIzLC44Nzg5NywxLjA0MjYsLjc5NDI5LC44NTI5MiwuOTExNDksMS4wNTgxNSwxLjE0MDYsLjc5NjMxLC45MDEyOCwuODM4NTMsMS4wNDM5NiwxLjEwNjE1LC45NzU1MiwuOTQ0MzYsLjk3NTUyLC44ODY0MSwuODA1MjcsLjk2MDgzLDEuMDAxMzUsMSwxLjA2Nzc3LC45ODE3LC45MTE0MiwuOTkzNjEsMS4xMTE0NCwxLjU3MjkzLDEuMTExNDQsMS4yMTIzNywuNzQ2MjcsMS4zMTgxOCwxLjA2NTg1LC45NzA0MiwuODMwNTUsLjk3MDQyLC45MzUwMywxLjEyNjEsLjk3MDQyLC45NzkyMiwxLjE0MjM2LC45NDU1MiwxLjAxMDU0LDEuMTQyMzYsMS4wMjQ3MSwuOTc5MjIsLjk0MTY1LC45NzA0MiwuOTcwNDIsMS4wMjc2LC43ODkyOSwxLjEyNjEsLjk3OTIyLC45NTg3NCwxLjAyMTk3LC45ODUwNywuOTY3NTIsLjk3MTY4LC45NTEwNywxLjE2NTc5LC45NTEwNywxLjIxMjM3LDEuMDM5NTksMS4wMzYsMS4wMzYsMSwxLjAzNiwxLjE2NTc5LC44NzM1NywxLjMxODE4LDEuMTg3NTQsMS4yNjc4MSwxLjA1MzU2LDEuMjEyMzcsMS4xODYyMiwuNzk0ODcsLjk0OTk0LDEuMjkwMDQsMS4yNDA0NywxLjI0MDQ3LDEuMzE4MTgsMSwuOTE0ODQsLjk3NTQsMS4zMTgxOCwxLjEzNDksMS4yNDg2NiwxLjA1MzU2LDEuMTM5MzQsMS4xNTU3NCwxLjE3Mzg5LC43MzU0MSwuOTczNjMsLjk3MzYzLC45NzM2MywuOTczNjMsLjk3MzYzLC45NzM2MywuOTQzODUsLjg3ODk3LC43OTQyOSwuNzk0MjksLjc5NDI5LC43OTQyOSwxLjE0MDYsMS4xNDA2LDEuMTQwNiwxLjE0MDYsMS4wNDI2LDEuMTA2MTUsLjk3NTUyLC45NzU1MiwuOTc1NTIsLjk3NTUyLC45NzU1MiwxLjIxMjM3LC45NzU1MiwxLjAwMTM1LDEuMDAxMzUsMS4wMDEzNSwxLjAwMTM1LC45MTE0MiwuOTQ0MzYsLjk4NzIxLDEuMDY1ODUsMS4wNjU4NSwxLjA2NTg1LDEuMDY1ODUsMS4wNjU4NSwxLjA2NTg1LC45NjcwNSwuODMwNTUsLjkzNTAzLC45MzUwMywuOTM1MDMsLjkzNTAzLDEuMTQyMzYsMS4xNDIzNiwxLjE0MjM2LDEuMTQyMzYsLjkzMTI1LC45NzkyMiwuOTQxNjUsLjk0MTY1LC45NDE2NSwuOTQxNjUsLjk0MTY1LDEuMjkwMDQsLjk0MTY1LC45NzkyMiwuOTc5MjIsLjk3OTIyLC45NzkyMiwuOTY3NTIsLjk3MDQyLC45Njc1MiwuOTczNjMsMS4wNjU4NSwuOTczNjMsMS4wNjU4NSwuOTczNjMsMS4wNjU4NSwuODc4OTcsLjgzMDU1LC44Nzg5NywuODMwNTUsLjg3ODk3LC44MzA1NSwuODc4OTcsLjgzMDU1LDEuMDQyNiwxLjAwMzMsMS4wNDI2LC45NzA0MiwuNzk0MjksLjkzNTAzLC43OTQyOSwuOTM1MDMsLjc5NDI5LC45MzUwMywuNzk0MjksLjkzNTAzLC43OTQyOSwuOTM1MDMsLjkxMTQ5LC45NzA0MiwuOTExNDksLjk3MDQyLC45MTE0OSwuOTcwNDIsMSwxLDEuMDU4MTUsLjk3OTIyLDEuMDU4MTUsLjk3OTIyLDEuMTQwNiwxLjE0MjM2LDEuMTQwNiwxLjE0MjM2LDEuMTQwNiwxLjE0MjM2LDEuMTQwNiwxLjE0MjM2LDEuMTQwNiwxLjE0MjM2LC45NzQ0MSwxLjA0MzAyLC43OTYzMSwxLjAxNTgyLDEsMSwxLjAxMDU0LC44Mzg1MywxLjE0MjM2LDEsMSwuODM4NTMsMS4wOTEyNSwuODM4NTMsLjkwNDE4LC44Mzg1MywxLjE5NTA4LDEuMTA2MTUsLjk3OTIyLDEsMSwxLjEwNjE1LC45NzkyMiwxLjAxMDM0LDEuMTA0NjYsLjk3OTIyLC45NzU1MiwuOTQxNjUsLjk3NTUyLC45NDE2NSwuOTc1NTIsLjk0MTY1LC45MTYwMiwuOTE5ODEsLjg4NjQxLDEuMDI3NiwxLDEsLjg4NjQxLDEuMDI3NiwuODA1MjcsLjc4OTI5LC44MDUyNywuNzg5MjksLjgwNTI3LC43ODkyOSwuODA1MjcsLjc4OTI5LDEsMSwuOTYwODMsMS4wNTQwMywuOTU5MjMsMS4xNjg2MiwxLjAwMTM1LC45NzkyMiwxLjAwMTM1LC45NzkyMiwxLjAwMTM1LC45NzkyMiwxLjAwMTM1LC45NzkyMiwxLjAwMTM1LC45NzkyMiwxLjAwMTM1LC45NzkyMiwxLjA2Nzc3LDEuMDIxOTcsLjkxMTQyLC45Njc1MiwuOTExNDIsLjk5MzYxLC45NzE2OCwuOTkzNjEsLjk3MTY4LC45OTM2MSwuOTcxNjgsMS4yMzE5OSwxLjAzNiwuOTczNjMsMS4wNjU4NSwuOTQzODUsLjk2NzA1LC45NzU1MiwuOTQxNjUsMSwxLC45NjA4MywxLjEyNjEsMS4zMTgxOCwxLjMxODE4LDEuMzE4MTgsMS4zMTgxOCwxLjMxODE4LDEuMzE4MTgsMS4zMTgxOCwxLjMxODE4LDEuMzE4MTgsLjk1MTYxLDEuMjcxMjYsMS4wMDgxMSwuODMyODQsLjc3NzAyLC45OTEzNywuOTUyNTMsMS4wMzQ3LC44NjE0MiwxLjA3MjA1LDEuMTQyMzYsLjk3MzYzLC44OTcyMywuODY4NjksMS4wOTgxOCwuNzk0MjksLjk5MzYxLDEuMDU4MTUsLjk3NTUyLDEuMTQwNiwuOTAxMjgsMS4wNjY2MiwxLjA0Mzk2LDEuMTA2MTUsLjg0OTE4LC45NzU1MiwxLjA0Njk0LC45NDQzNiwuOTgwMTUsLjk2MDgzLC45MTE0MiwxLjAwMzU2LC45ODE3LDEuMDE5NDUsLjk4OTk5LDEuMTQwNiwuOTExNDIsMS4wNDk2MSwuOTg5OCwxLjAwNjM5LDEuMTQyMzYsMS4wNzUxNCwxLjA0OTYxLC45OTYwNywxLjAyODk3LDEuMDA4LC45ODk4LC45NTEzNCwxLjAwNjM5LDEuMTExMjEsMS4xNDIzNiwxLjAwNTE4LC45Nzk4MSwxLjAyMTg2LDEsMS4wODU3OCwuOTQxNjUsLjk5MzE0LC45ODM4NywuOTMwMjgsLjkzMzc3LDEuMzUxMjUsMS4wNzUxNCwxLjEwNjg3LC45MzQ5MSwxLjA0MjMyLDEuMDAzNTEsMS4xNDIzNiwxLjA3NTE0LC45NDE2NSwxLjA3NTE0LDEuMDAzNTEsLjc5NDI5LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDkwOTcsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjkzNTAzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45NjYwOSwxLDEsMSwxLDEsMSwxLjA2Nzc3LDEuMDIxOTcsMS4wNjc3NywxLjAyMTk3LDEuMDY3NzcsMS4wMjE5NywuOTExNDIsLjk2NzUyLDEsMS4yMTI2MSwuODk5MDMsMSwxLC43NTE1NSwxLjA0NzQ1LDEuMDQ3NDUsMS4wNDc0NSwxLjA0Mzk0LC45ODYzMywuOTg2MzMsLjk4NjMzLC43Mjk1OSwuNzI5NTksMS4yMDUwMiwuOTE0MDYsMS4yNjUxNCwxLjIyMiwxLjAyOTU2LDEuMDMzNzIsMS4wMzM3MiwuOTYwMzksMS4yNDYzMywxLDEuMDkxMjUsLjkzMzI3LDEuMDMzMzYsMS4xNjU0MSwxLjAzNiwxLDEsMSwuNzcxLDEsMSwxLjE1NTc0LDEuMTU1NzQsMS4xNTU3NCwxLjE1NTc0LC44NjM2NCwuOTQ0MzQsLjg2Mjc5LC45NDQzNCwuODYyMjQsMSwxLDEuMTY3OTgsMSwuOTYwODUsLjkwMDY4LDEuMjEyMzcsMS4xODQxNiwxLjEzOTA0LC42OTgyNSwuOTcxNiwyLjEwMzM5LDEuMjkwMDQsMS4yOTAwNCwxLjIxMzM5LDEuMjkwMDQsMS4yOTAwNCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuNDI2MDMsMSwuOTk4NjIsLjk5ODYyLDEsLjg3MDI1LC44NzAyNSwuODcwMjUsLjg3MDI1LDEuMTg3NzUsMS40MjYwMywxLDEuNDI2MDMsMS40MjYwMywuOTk4NjIsMSwxLDEsMSwxLDEuMjg4NiwxLjA0MzE1LDEuMTUyOTYsMS4zNDE2MywxLDEsMSwxLjEzMjY5LDEuMTMyNjksMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLFZpPXtsaW5lSGVpZ2h0OjEuMzMwMDgsbGluZUdhcDowfSxLaT1bMS43NjczOCwxLDEsLjk4OTQ2LDEuMTQ3NjMsMS4wNTM2NSwxLjA2MjM0LC45NjkyNywuOTI1ODYsMS4xNTM3MywxLjE4NDE0LC45MTM0OSwuOTEzNDksMS4wNzQwMywxLjE3MzA4LC43ODM4MywxLjIwMDg4LC43ODM4MywxLjQyNTMxLC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuNzgzODMsLjc4MzgzLDEuMTczMDgsMS4xNzMwOCwxLjE3MzA4LC43NzM0OSwuOTQ1NjUsLjk0NzI5LC44NTk0NCwuODg1MDYsLjk4NTgsLjc0ODE3LC44MDAxNiwuODg0NDksLjk4MDM5LC45NTc4MiwuNjkyMzgsLjg5ODk4LC44MzIzMSwuOTgxODMsMS4wMzk4OSwuOTY5MjQsLjg2MjM3LC45NjkyNCwuODA1OTUsLjc0NTI0LC44NjA5MSwuOTU0MDIsLjk0MTQzLC45ODQ0OCwuODg1OCwuODMwODksLjkzMjg1LDEuMDk0OSwxLjM5MDE2LDEuMDk0OSwxLjQ1OTk0LC43NDYyNywxLjA0ODM5LC45NzQ1NCwuOTc0NTQsLjg3MjA3LC45NzQ1NCwuODc1MzMsMS4wNjE1MSwuOTc0NTQsMS4wMDE3NiwxLjE2NDg0LDEuMDgxMzIsLjk4MDQ3LDEuMTY0ODQsMS4wMjk4OSwxLjAxMDU0LC45NjIyNSwuOTc0NTQsLjk3NDU0LDEuMDY1OTgsLjc5MDA0LDEuMTYzNDQsMS4wMDM1MSwuOTQ2MjksLjk5NzMsLjkxMDE2LC45Njc3NywuOTA0MywuOTEwODIsLjkyNDgxLC45MTA4MiwxLjE3MzA4LC45NTc0OCwuOTY5MjcsLjk2OTI3LDEsLjk2OTI3LC45MjQ4MSwuODA1OTcsMS4wNDgzOSwxLjIzMzkzLDEuMTc4MSwuOTI0NSwxLjE3MzA4LDEuMjA4MDgsLjYzMjE4LC45NDI2MSwxLjI0ODIyLDEuMDk5NzEsMS4wOTk3MSwxLjA0ODM5LDEsLjg1MjczLC43ODAzMiwxLjA0ODM5LDEuMDk5NzEsMS4yMjMyNiwuOTI0NSwxLjA5ODM2LDEuMTM1MjUsMS4xNTIyMiwuNzA0MjQsLjk0NzI5LC45NDcyOSwuOTQ3MjksLjk0NzI5LC45NDcyOSwuOTQ3MjksLjg1NDk4LC44ODUwNiwuNzQ4MTcsLjc0ODE3LC43NDgxNywuNzQ4MTcsLjk1NzgyLC45NTc4MiwuOTU3ODIsLjk1NzgyLC45ODU4LDEuMDM5ODksLjk2OTI0LC45NjkyNCwuOTY5MjQsLjk2OTI0LC45NjkyNCwxLjE3MzA4LC45NjkyNCwuOTU0MDIsLjk1NDAyLC45NTQwMiwuOTU0MDIsLjgzMDg5LC44NjIzNywuODg0MDksLjk3NDU0LC45NzQ1NCwuOTc0NTQsLjk3NDU0LC45NzQ1NCwuOTc0NTQsLjkyOTE2LC44NzIwNywuODc1MzMsLjg3NTMzLC44NzUzMywuODc1MzMsLjkzMTQ2LC45MzE0NiwuOTMxNDYsLjkzMTQ2LC45Mzg1NCwxLjAxMDU0LC45NjIyNSwuOTYyMjUsLjk2MjI1LC45NjIyNSwuOTYyMjUsMS4yNDgyMiwuODc2MSwxLjAwMzUxLDEuMDAzNTEsMS4wMDM1MSwxLjAwMzUxLC45Njc3NywuOTc0NTQsLjk2Nzc3LC45NDcyOSwuOTc0NTQsLjk0NzI5LC45NzQ1NCwuOTQ3MjksLjk3NDU0LC44ODUwNiwuODcyMDcsLjg4NTA2LC44NzIwNywuODg1MDYsLjg3MjA3LC44ODUwNiwuODcyMDcsLjk4NTgsLjk1MzkxLC45ODU4LC45NzQ1NCwuNzQ4MTcsLjg3NTMzLC43NDgxNywuODc1MzMsLjc0ODE3LC44NzUzMywuNzQ4MTcsLjg3NTMzLC43NDgxNywuODc1MzMsLjg4NDQ5LC45NzQ1NCwuODg0NDksLjk3NDU0LC44ODQ0OSwuOTc0NTQsMSwxLC45ODAzOSwxLjAwMTc2LC45ODAzOSwxLjAwMTc2LC45NTc4MiwuOTMxNDYsLjk1NzgyLC45MzE0NiwuOTU3ODIsLjkzMTQ2LC45NTc4MiwxLjE2NDg0LC45NTc4MiwuOTMxNDYsLjg0NDIxLDEuMTI3NjEsLjY5MjM4LDEuMDgxMzIsMSwxLC45ODA0NywuODMyMzEsMS4xNjQ4NCwxLDEsLjg0NzIzLDEuMDQ4NjEsLjg0NzIzLC43ODc1NSwuODMyMzEsMS4yMzczNiwxLjAzOTg5LDEuMDEwNTQsMSwxLDEuMDM5ODksMS4wMTA1NCwuOTg1NywxLjAzODQ5LDEuMDEwNTQsLjk2OTI0LC45NjIyNSwuOTY5MjQsLjk2MjI1LC45NjkyNCwuOTYyMjUsLjkyMzgzLC45MDE3MSwuODA1OTUsMS4wNjU5OCwxLDEsLjgwNTk1LDEuMDY1OTgsLjc0NTI0LC43OTAwNCwuNzQ1MjQsLjc5MDA0LC43NDUyNCwuNzkwMDQsLjc0NTI0LC43OTAwNCwxLDEsLjg2MDkxLDEuMDI3NTksLjg1NzcxLDEuMTYzNDQsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk1NDAyLDEuMDAzNTEsLjk4NDQ4LC45OTczLC44MzA4OSwuOTY3NzcsLjgzMDg5LC45MzI4NSwuOTA0MywuOTMyODUsLjkwNDMsLjkzMjg1LC45MDQzLDEuMzE4NjgsLjk2OTI3LC45NDcyOSwuOTc0NTQsLjg1NDk4LC45MjkxNiwuOTY5MjQsLjg3NjEsMSwxLC44NjA5MSwxLjE2MzQ0LDEuMDQ4MzksMS4wNDgzOSwxLjA0ODM5LDEuMDQ4MzksMS4wNDgzOSwxLjA0ODM5LDEuMDQ4MzksMS4wNDgzOSwxLjA0ODM5LC44MTk2NSwuODE5NjUsLjk0NzI5LC43ODAzMiwuNzEwMjIsLjkwODgzLC44NDE3MSwuOTk4NzcsLjc3NTk2LDEuMDU3MzQsMS4yLC45NDcyOSwuODU5NDQsLjgyNzkxLC45NjA3LC43NDgxNywuOTMyODUsLjk4MDM5LC45NjkyNCwuOTU3ODIsLjg5ODk4LC45ODMxNiwuOTgxODMsMS4wMzk4OSwuNzg2MTQsLjk2OTI0LC45NzY0MiwuODYyMzcsLjg2MDc1LC44NjA5MSwuODMwODksLjkwMDgyLC44ODU4LC45NzI5NiwxLjAxMjg0LC45NTc4MiwuODMwODksMS4wOTc2LDEuMDQsMS4wMzM0MiwxLjIsMS4wNjc1LDEuMDk3NiwuOTgyMDUsMS4wMzgwOSwxLjA1MDk3LDEuMDQsLjk1MzY0LDEuMDMzNDIsMS4wNTQwMSwxLjIsMS4wMjE0OCwxLjAxMTksMS4wNDcyNCwxLjAxMjcsMS4wMjczMiwuOTYyMjUsLjg5NjUsLjk3NzgzLC45MzU3NCwuOTQ4MTgsMS4zMDY3OSwxLjA2NzUsMS4xMTgyNiwuOTk4MjEsMS4wNTU3LDEuMDMyNiwxLjIsMS4wNjc1LC45NjIyNSwxLjA2NzUsMS4wMzI2LC43NDgxNywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjAzNzU0LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44NzUzMywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTg3MDUsMSwxLDEsMSwxLDEsLjk4NDQ4LC45OTczLC45ODQ0OCwuOTk3MywuOTg0NDgsLjk5NzMsLjgzMDg5LC45Njc3NywxLDEuMjAwODgsLjg5OTAzLDEsMSwuNzUxNTUsLjk0OTQ1LC45NDk0NSwuOTQ5NDUsLjk0OTQ1LDEuMTIzMTcsMS4xMjMxNywxLjEyMzE3LC42NzYwMywuNjc2MDMsMS4xNTYyMSwuNzM1ODQsMS4yMTE5MSwxLjIyMTM1LDEuMDY0ODMsLjk0ODY4LC45NDg2OCwuOTU5OTYsMS4yNDYzMywxLDEuMDc0OTcsLjg3NzA5LC45NjkyNywxLjAxNDczLC45NjkyNywxLDEsMSwuNzcyOTUsMSwxLDEuMDk4MzYsMS4wOTgzNiwxLjA5ODM2LDEuMDE1MjIsLjg2MzIxLC45NDQzNCwuODY0OSwuOTQ0MzQsLjg2MTgyLDEsMSwxLjA4MywxLC45MTU3OCwuODY0MzgsMS4xNzMwOCwxLjE4NDE2LDEuMTQ1ODksLjY5ODI1LC45NzYyMiwxLjk2NzkxLDEuMjQ4MjIsMS4yNDgyMiwxLjE3MzA4LDEuMjQ4MjIsMS4yNDgyMiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuNDI2MDMsMSwuOTk4NjIsLjk5ODYyLDEsLjg3MDI1LC44NzAyNSwuODcwMjUsLjg3MDI1LDEuMTc5ODQsMS40MjYwMywxLDEuNDI2MDMsMS40MjYwMywuOTk4NjIsMSwxLDEsMSwxLDEuMjg4NiwxLjA0MzE1LDEuMTUyOTYsMS4zNDE2MywxLDEsMSwxLjEwNzQyLDEuMTA3NDIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLEppPXtsaW5lSGVpZ2h0OjEuMzMwMDgsbGluZUdhcDowfSxZaT1bMS43NjczOCwxLDEsLjk4NTk0LDEuMDIyODUsMS4xMDQ1NCwxLjA2MjM0LC45NjkyNywuOTIwMzcsMS4xOTk4NSwxLjIwNDYsLjkwNjE2LC45MDYxNiwxLjA3MTUyLDEuMTcxNCwuNzgwMzIsMS4yMDA4OCwuNzgwMzIsMS40MDI0NiwuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjc4MDMyLC43ODAzMiwxLjE3MTQsMS4xNzE0LDEuMTcxNCwuODA1OTcsLjk0MDg0LC45NjcwNiwuODU5NDQsLjg1NzM0LC45NzA5MywuNzU4NDIsLjc5OTM2LC44ODE5OCwuOTgzMSwuOTU3ODIsLjcxMzg3LC44Njk2OSwuODQ2MzYsMS4wNzc5NiwxLjAzNTg0LC45NjkyNCwuODM5NjgsLjk2OTI0LC44MjgyNiwuNzk2NDksLjg1NzcxLC45NTEzMiwuOTMxMTksLjk4OTY1LC44ODQzMywuODI4NywuOTMzNjUsMS4wODYxMiwxLjM2MzgsMS4wODYxMiwxLjQ1Nzg2LC43NDYyNywuODA0OTksLjkxNDg0LDEuMDU3MDcsLjkyMzgzLDEuMDU4ODIsLjk0MDMsMS4xMjY1NCwxLjA1ODgyLDEuMDE3NTYsMS4wOTAxMSwxLjA5MDExLC45OTQxNCwxLjA5MDExLDEuMDM0LDEuMDE3NTYsMS4wNTM1NiwxLjA1NzA3LDEuMDU4ODIsMS4wNDM5OSwuODQ4NjMsMS4yMTk2OCwxLjAxNzU2LC45NTgwMSwxLjAwMDY4LC45MTc5NywuOTY3NzcsLjkwNDMsLjkwMzUxLC45MjEwNSwuOTAzNTEsMS4xNzE0LC44NTMzNywuOTY5MjcsLjk2OTI3LC45OTkxMiwuOTY5MjcsLjkyMTA1LC44MDU5NywxLjI0MzQsMS4yMDgwOCwxLjA1OTM3LC45MDk1NywxLjE3MTQsMS4yMDgwOCwuNzUxNTUsLjk0MjYxLDEuMjQ2NDQsMS4wOTk3MSwxLjA5OTcxLC44NDc1MSwxLC44NTI3MywuNzgwMzIsLjYxNTg0LDEuMDU0MjUsMS4xNzkxNCwuOTA5NTcsMS4wODY2NSwxLjExNTkzLDEuMTQxNjksLjczMzgxLC45NjcwNiwuOTY3MDYsLjk2NzA2LC45NjcwNiwuOTY3MDYsLjk2NzA2LC44NjAzNSwuODU3MzQsLjc1ODQyLC43NTg0MiwuNzU4NDIsLjc1ODQyLC45NTc4MiwuOTU3ODIsLjk1NzgyLC45NTc4MiwuOTcwOTMsMS4wMzU4NCwuOTY5MjQsLjk2OTI0LC45NjkyNCwuOTY5MjQsLjk2OTI0LDEuMTcxNCwuOTY5MjQsLjk1MTMyLC45NTEzMiwuOTUxMzIsLjk1MTMyLC44Mjg3LC44Mzk2OCwuODkwNDksLjkxNDg0LC45MTQ4NCwuOTE0ODQsLjkxNDg0LC45MTQ4NCwuOTE0ODQsLjkzNTc1LC45MjM4MywuOTQwMywuOTQwMywuOTQwMywuOTQwMywuODcxNywuODcxNywuODcxNywuODcxNywxLjAwNTI3LDEuMDE3NTYsMS4wNTM1NiwxLjA1MzU2LDEuMDUzNTYsMS4wNTM1NiwxLjA1MzU2LDEuMjQ2NDQsLjk1OTIzLDEuMDE3NTYsMS4wMTc1NiwxLjAxNzU2LDEuMDE3NTYsLjk2Nzc3LDEuMDU3MDcsLjk2Nzc3LC45NjcwNiwuOTE0ODQsLjk2NzA2LC45MTQ4NCwuOTY3MDYsLjkxNDg0LC44NTczNCwuOTIzODMsLjg1NzM0LC45MjM4MywuODU3MzQsLjkyMzgzLC44NTczNCwuOTIzODMsLjk3MDkzLDEuMDk2OSwuOTcwOTMsMS4wNTg4MiwuNzU4NDIsLjk0MDMsLjc1ODQyLC45NDAzLC43NTg0MiwuOTQwMywuNzU4NDIsLjk0MDMsLjc1ODQyLC45NDAzLC44ODE5OCwxLjA1ODgyLC44ODE5OCwxLjA1ODgyLC44ODE5OCwxLjA1ODgyLDEsMSwuOTgzMSwxLjAxNzU2LC45ODMxLDEuMDE3NTYsLjk1NzgyLC44NzE3LC45NTc4MiwuODcxNywuOTU3ODIsLjg3MTcsLjk1NzgyLDEuMDkwMTEsLjk1NzgyLC44NzE3LC44NDc4NCwxLjExNTUxLC43MTM4NywxLjA5MDExLDEsMSwuOTk0MTQsLjg0NjM2LDEuMDkwMTEsMSwxLC44NDYzNiwxLjA1MzYsLjg0NjM2LC45NDI5OCwuODQ2MzYsMS4yMzI5NywxLjAzNTg0LDEuMDE3NTYsMSwxLDEuMDM1ODQsMS4wMTc1NiwxLjAwMzIzLDEuMDM0NDQsMS4wMTc1NiwuOTY5MjQsMS4wNTM1NiwuOTY5MjQsMS4wNTM1NiwuOTY5MjQsMS4wNTM1NiwuOTMwNjYsLjk4MjkzLC44MjgyNiwxLjA0Mzk5LDEsMSwuODI4MjYsMS4wNDM5OSwuNzk2NDksLjg0ODYzLC43OTY0OSwuODQ4NjMsLjc5NjQ5LC44NDg2MywuNzk2NDksLjg0ODYzLDEsMSwuODU3NzEsMS4xNzMxOCwuODU3NzEsMS4yMTk2OCwuOTUxMzIsMS4wMTc1NiwuOTUxMzIsMS4wMTc1NiwuOTUxMzIsMS4wMTc1NiwuOTUxMzIsMS4wMTc1NiwuOTUxMzIsMS4wMTc1NiwuOTUxMzIsMS4wMTc1NiwuOTg5NjUsMS4wMDA2OCwuODI4NywuOTY3NzcsLjgyODcsLjkzMzY1LC45MDQzLC45MzM2NSwuOTA0MywuOTMzNjUsLjkwNDMsMS4wODU3MSwuOTY5MjcsLjk2NzA2LC45MTQ4NCwuODYwMzUsLjkzNTc1LC45NjkyNCwuOTU5MjMsMSwxLC44NTc3MSwxLjIxOTY4LDEuMTE0MzcsMS4xMTQzNywuOTMxMDksLjkxMjAyLC42MDQxMSwuODQxNjQsLjU1NTcyLDEuMDExNzMsLjk3MzYxLC44MTgxOCwuODE4MTgsLjk2NjM1LC43ODAzMiwuNzI3MjcsLjkyMzY2LC45ODYwMSwxLjAzNDA1LC43Nzk2OCwxLjA5Nzk5LDEuMiwuOTY3MDYsLjg1OTQ0LC44NTYzOCwuOTY0OTEsLjc1ODQyLC45MzM2NSwuOTgzMSwuOTY5MjQsLjk1NzgyLC44Njk2OSwuOTQxNTIsMS4wNzc5NiwxLjAzNTg0LC43ODQzNywuOTY5MjQsLjk4NzE1LC44Mzk2OCwuODM0OTEsLjg1NzcxLC44Mjg3LC45NDQ5MiwuODg0MzMsLjkyODcsMS4wMDk4LC45NTc4MiwuODI4NywxLjA2MjUsLjk4MjQ4LDEuMDM0MjQsMS4yLDEuMDEwNzEsMS4wNjI1LC45NTI0NiwxLjAzODA5LDEuMDQ5MTIsLjk4MjQ4LDEuMDAyMjEsMS4wMzQyNCwxLjA1NDQzLDEuMiwxLjA0Nzg1LC45OTYwOSwxLjAwMTY5LDEuMDUxNzYsLjk5MzQ2LDEuMDUzNTYsLjkwODcsMS4wMzAwNCwuOTU1NDIsLjkzMTE3LDEuMjMzNjIsMS4wMTA3MSwxLjA3ODMxLDEuMDI1MTIsMS4wNTIwNSwxLjAzNTAyLDEuMiwxLjAxMDcxLDEuMDUzNTYsMS4wMTA3MSwxLjAzNTAyLC43NTg0MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjAzNzE5LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45NDAzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDQwMjEsMSwxLDEsMSwxLDEsLjk4OTY1LDEuMDAwNjgsLjk4OTY1LDEuMDAwNjgsLjk4OTY1LDEuMDAwNjgsLjgyODcsLjk2Nzc3LDEsMS4yMDA4OCwuODk5MDMsMSwxLC43NTE1NSwxLjAzMDc3LDEuMDMwNzcsMS4wMzA3NywxLjAzMDc3LDEuMTMxOTYsMS4xMzE5NiwxLjEzMTk2LC42NzQyOCwuNjc0MjgsMS4xNjAzOSwuNzMyOTEsMS4yMDk5NiwxLjIyMTM1LDEuMDY0ODMsLjk0ODY4LC45NDg2OCwuOTU5OTYsMS4yNDYzMywxLDEuMDc0OTcsLjg3Nzk2LC45NjkyNywxLjAxNTE4LC45NjkyNywxLDEsMSwuNzcyOTUsMSwxLDEuMTA1MzksMS4xMDUzOSwxLjExMzU4LDEuMDY5NjcsLjg2Mjc5LC45NDQzNCwuODYyNzksLjk0NDM0LC44NjE4MiwxLDEsMS4wODMsMSwuOTE1NzgsLjg2NTA3LDEuMTcxNCwxLjE4NDE2LDEuMTQ1ODksLjY5ODI1LC45NzYyMiwxLjk2OTcsMS4yNDgyMiwxLjI0ODIyLDEuMTcyMzgsMS4yNDgyMiwxLjI0ODIyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS40MjYwMywxLC45OTg2MiwuOTk4NjIsMSwuODcwMjUsLjg3MDI1LC44NzAyNSwuODcwMjUsMS4xODA4MywxLjQyNjAzLDEsMS40MjYwMywxLjQyNjAzLC45OTg2MiwxLDEsMSwxLDEsMS4yODg2LDEuMDQzMTUsMS4xNTI5NiwxLjM0MTYzLDEsMSwxLDEuMTA5MzgsMS4xMDkzOCwxLDEsMSwxLjA1NDI1LDEuMDk5NzEsMS4wOTk3MSwxLjA5OTcxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sWmk9e2xpbmVIZWlnaHQ6MS4zMzAwOCxsaW5lR2FwOjB9LFFpPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZVsiTXlyaWFkUHJvLVJlZ3VsYXIiXT1lWyJQZGZKUy1GYWxsYmFjay1SZWd1bGFyIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLVJlZ3VsYXIiLGZhY3RvcnM6SGksYmFzZVdpZHRoczpSaSxiYXNlTWFwcGluZzpOaSxtZXRyaWNzOldpfTtlWyJNeXJpYWRQcm8tQm9sZCJdPWVbIlBkZkpTLUZhbGxiYWNrLUJvbGQiXT17bmFtZToiTGliZXJhdGlvblNhbnMtQm9sZCIsZmFjdG9yczpFaSxiYXNlV2lkdGhzOklpLGJhc2VNYXBwaW5nOlRpLG1ldHJpY3M6UGl9O2VbIk15cmlhZFByby1JdCJdPWVbIk15cmlhZFByby1JdGFsaWMiXT1lWyJQZGZKUy1GYWxsYmFjay1JdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtSXRhbGljIixmYWN0b3JzOlhpLGJhc2VXaWR0aHM6RGksYmFzZU1hcHBpbmc6QmksbWV0cmljczpxaX07ZVsiTXlyaWFkUHJvLUJvbGRJdCJdPWVbIk15cmlhZFByby1Cb2xkSXRhbGljIl09ZVsiUGRmSlMtRmFsbGJhY2stQm9sZEl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1Cb2xkSXRhbGljIixmYWN0b3JzOmppLGJhc2VXaWR0aHM6T2ksYmFzZU1hcHBpbmc6TWksbWV0cmljczpfaX07ZS5BcmlhbE1UPWUuQXJpYWw9ZVsiQXJpYWwtUmVndWxhciJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1SZWd1bGFyIixiYXNlV2lkdGhzOlJpLGJhc2VNYXBwaW5nOk5pfTtlWyJBcmlhbC1Cb2xkTVQiXT1lWyJBcmlhbC1Cb2xkIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGQiLGJhc2VXaWR0aHM6SWksYmFzZU1hcHBpbmc6VGl9O2VbIkFyaWFsLUl0YWxpY01UIl09ZVsiQXJpYWwtSXRhbGljIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUl0YWxpYyIsYmFzZVdpZHRoczpEaSxiYXNlTWFwcGluZzpCaX07ZVsiQXJpYWwtQm9sZEl0YWxpY01UIl09ZVsiQXJpYWwtQm9sZEl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1Cb2xkSXRhbGljIixiYXNlV2lkdGhzOk9pLGJhc2VNYXBwaW5nOk1pfTtlWyJDYWxpYnJpLVJlZ3VsYXIiXT17bmFtZToiTGliZXJhdGlvblNhbnMtUmVndWxhciIsZmFjdG9yczpiaSxiYXNlV2lkdGhzOlJpLGJhc2VNYXBwaW5nOk5pLG1ldHJpY3M6eWl9O2VbIkNhbGlicmktQm9sZCJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1Cb2xkIixmYWN0b3JzOnVpLGJhc2VXaWR0aHM6SWksYmFzZU1hcHBpbmc6VGksbWV0cmljczpkaX07ZVsiQ2FsaWJyaS1JdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtSXRhbGljIixmYWN0b3JzOnBpLGJhc2VXaWR0aHM6RGksYmFzZU1hcHBpbmc6QmksbWV0cmljczptaX07ZVsiQ2FsaWJyaS1Cb2xkSXRhbGljIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMiLGZhY3RvcnM6ZmksYmFzZVdpZHRoczpPaSxiYXNlTWFwcGluZzpNaSxtZXRyaWNzOmdpfTtlWyJTZWdvZXVpLVJlZ3VsYXIiXT17bmFtZToiTGliZXJhdGlvblNhbnMtUmVndWxhciIsZmFjdG9yczpZaSxiYXNlV2lkdGhzOlJpLGJhc2VNYXBwaW5nOk5pLG1ldHJpY3M6Wml9O2VbIlNlZ29ldWktQm9sZCJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1Cb2xkIixmYWN0b3JzOnppLGJhc2VXaWR0aHM6SWksYmFzZU1hcHBpbmc6VGksbWV0cmljczokaX07ZVsiU2Vnb2V1aS1JdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtSXRhbGljIixmYWN0b3JzOktpLGJhc2VXaWR0aHM6RGksYmFzZU1hcHBpbmc6QmksbWV0cmljczpKaX07ZVsiU2Vnb2V1aS1Cb2xkSXRhbGljIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMiLGZhY3RvcnM6R2ksYmFzZVdpZHRoczpPaSxiYXNlTWFwcGluZzpNaSxtZXRyaWNzOlZpfTtlWyJIZWx2ZXRpY2EtUmVndWxhciJdPWUuSGVsdmV0aWNhPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1SZWd1bGFyIixmYWN0b3JzOnZpLGJhc2VXaWR0aHM6UmksYmFzZU1hcHBpbmc6TmksbWV0cmljczpGaX07ZVsiSGVsdmV0aWNhLUJvbGQiXT17bmFtZToiTGliZXJhdGlvblNhbnMtQm9sZCIsZmFjdG9yczp3aSxiYXNlV2lkdGhzOklpLGJhc2VNYXBwaW5nOlRpLG1ldHJpY3M6eGl9O2VbIkhlbHZldGljYS1JdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtSXRhbGljIixmYWN0b3JzOmtpLGJhc2VXaWR0aHM6RGksYmFzZU1hcHBpbmc6QmksbWV0cmljczpDaX07ZVsiSGVsdmV0aWNhLUJvbGRJdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtQm9sZEl0YWxpYyIsZmFjdG9yczpTaSxiYXNlV2lkdGhzOk9pLGJhc2VNYXBwaW5nOk1pLG1ldHJpY3M6QWl9fSkpO2Z1bmN0aW9uIGdldFhmYUZvbnROYW1lKGUpe2NvbnN0IHQ9bm9ybWFsaXplRm9udE5hbWUoZSk7cmV0dXJuIFFpKClbdF19ZnVuY3Rpb24gZ2V0WGZhRm9udERpY3QoZSl7Y29uc3QgdD1mdW5jdGlvbiBnZXRYZmFGb250V2lkdGhzKGUpe2NvbnN0IHQ9Z2V0WGZhRm9udE5hbWUoZSk7aWYoIXQpcmV0dXJuIG51bGw7Y29uc3R7YmFzZVdpZHRoczphLGJhc2VNYXBwaW5nOnIsZmFjdG9yczppfT10LG49aT9hLm1hcCgoKGUsdCk9PmUqaVt0XSkpOmE7bGV0IHMsbz0tMjtjb25zdCBjPVtdO2Zvcihjb25zdFtlLHRdb2Ygci5tYXAoKChlLHQpPT5bZSx0XSkpLnNvcnQoKChbZV0sW3RdKT0+ZS10KSkpaWYoLTEhPT1lKWlmKGU9PT1vKzEpe3MucHVzaChuW3RdKTtvKz0xfWVsc2V7bz1lO3M9W25bdF1dO2MucHVzaChlLHMpfXJldHVybiBjfShlKSxhPW5ldyBEaWN0KG51bGwpO2Euc2V0KCJCYXNlRm9udCIsTmFtZS5nZXQoZSkpO2Euc2V0KCJUeXBlIixOYW1lLmdldCgiRm9udCIpKTthLnNldCgiU3VidHlwZSIsTmFtZS5nZXQoIkNJREZvbnRUeXBlMiIpKTthLnNldCgiRW5jb2RpbmciLE5hbWUuZ2V0KCJJZGVudGl0eS1IIikpO2Euc2V0KCJDSURUb0dJRE1hcCIsTmFtZS5nZXQoIklkZW50aXR5IikpO2Euc2V0KCJXIix0KTthLnNldCgiRmlyc3RDaGFyIix0WzBdKTthLnNldCgiTGFzdENoYXIiLHQuYXQoLTIpK3QuYXQoLTEpLmxlbmd0aC0xKTtjb25zdCByPW5ldyBEaWN0KG51bGwpO2Euc2V0KCJGb250RGVzY3JpcHRvciIscik7Y29uc3QgaT1uZXcgRGljdChudWxsKTtpLnNldCgiT3JkZXJpbmciLCJJZGVudGl0eSIpO2kuc2V0KCJSZWdpc3RyeSIsIkFkb2JlIik7aS5zZXQoIlN1cHBsZW1lbnQiLDApO2Euc2V0KCJDSURTeXN0ZW1JbmZvIixpKTtyZXR1cm4gYX1jbGFzcyBQb3N0U2NyaXB0UGFyc2Vye2NvbnN0cnVjdG9yKGUpe3RoaXMubGV4ZXI9ZTt0aGlzLm9wZXJhdG9ycz1bXTt0aGlzLnRva2VuPW51bGw7dGhpcy5wcmV2PW51bGx9bmV4dFRva2VuKCl7dGhpcy5wcmV2PXRoaXMudG9rZW47dGhpcy50b2tlbj10aGlzLmxleGVyLmdldFRva2VuKCl9YWNjZXB0KGUpe2lmKHRoaXMudG9rZW4udHlwZT09PWUpe3RoaXMubmV4dFRva2VuKCk7cmV0dXJuITB9cmV0dXJuITF9ZXhwZWN0KGUpe2lmKHRoaXMuYWNjZXB0KGUpKXJldHVybiEwO3Rocm93IG5ldyBGb3JtYXRFcnJvcihgVW5leHBlY3RlZCBzeW1ib2w6IGZvdW5kICR7dGhpcy50b2tlbi50eXBlfSBleHBlY3RlZCAke2V9LmApfXBhcnNlKCl7dGhpcy5uZXh0VG9rZW4oKTt0aGlzLmV4cGVjdChlbi5MQlJBQ0UpO3RoaXMucGFyc2VCbG9jaygpO3RoaXMuZXhwZWN0KGVuLlJCUkFDRSk7cmV0dXJuIHRoaXMub3BlcmF0b3JzfXBhcnNlQmxvY2soKXtmb3IoOzspaWYodGhpcy5hY2NlcHQoZW4uTlVNQkVSKSl0aGlzLm9wZXJhdG9ycy5wdXNoKHRoaXMucHJldi52YWx1ZSk7ZWxzZSBpZih0aGlzLmFjY2VwdChlbi5PUEVSQVRPUikpdGhpcy5vcGVyYXRvcnMucHVzaCh0aGlzLnByZXYudmFsdWUpO2Vsc2V7aWYoIXRoaXMuYWNjZXB0KGVuLkxCUkFDRSkpcmV0dXJuO3RoaXMucGFyc2VDb25kaXRpb24oKX19cGFyc2VDb25kaXRpb24oKXtjb25zdCBlPXRoaXMub3BlcmF0b3JzLmxlbmd0aDt0aGlzLm9wZXJhdG9ycy5wdXNoKG51bGwsbnVsbCk7dGhpcy5wYXJzZUJsb2NrKCk7dGhpcy5leHBlY3QoZW4uUkJSQUNFKTtpZih0aGlzLmFjY2VwdChlbi5JRikpe3RoaXMub3BlcmF0b3JzW2VdPXRoaXMub3BlcmF0b3JzLmxlbmd0aDt0aGlzLm9wZXJhdG9yc1tlKzFdPSJqeiJ9ZWxzZXtpZighdGhpcy5hY2NlcHQoZW4uTEJSQUNFKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlBTIEZ1bmN0aW9uOiBlcnJvciBwYXJzaW5nIGNvbmRpdGlvbmFsLiIpO3tjb25zdCB0PXRoaXMub3BlcmF0b3JzLmxlbmd0aDt0aGlzLm9wZXJhdG9ycy5wdXNoKG51bGwsbnVsbCk7Y29uc3QgYT10aGlzLm9wZXJhdG9ycy5sZW5ndGg7dGhpcy5wYXJzZUJsb2NrKCk7dGhpcy5leHBlY3QoZW4uUkJSQUNFKTt0aGlzLmV4cGVjdChlbi5JRkVMU0UpO3RoaXMub3BlcmF0b3JzW3RdPXRoaXMub3BlcmF0b3JzLmxlbmd0aDt0aGlzLm9wZXJhdG9yc1t0KzFdPSJqIjt0aGlzLm9wZXJhdG9yc1tlXT1hO3RoaXMub3BlcmF0b3JzW2UrMV09Imp6In19fX1jb25zdCBlbj17TEJSQUNFOjAsUkJSQUNFOjEsTlVNQkVSOjIsT1BFUkFUT1I6MyxJRjo0LElGRUxTRTo1fTtjbGFzcyBQb3N0U2NyaXB0VG9rZW57c3RhdGljIGdldCBvcENhY2hlKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJvcENhY2hlIixPYmplY3QuY3JlYXRlKG51bGwpKX1jb25zdHJ1Y3RvcihlLHQpe3RoaXMudHlwZT1lO3RoaXMudmFsdWU9dH1zdGF0aWMgZ2V0T3BlcmF0b3IoZSl7cmV0dXJuIFBvc3RTY3JpcHRUb2tlbi5vcENhY2hlW2VdfHw9bmV3IFBvc3RTY3JpcHRUb2tlbihlbi5PUEVSQVRPUixlKX1zdGF0aWMgZ2V0IExCUkFDRSgpe3JldHVybiBzaGFkb3codGhpcywiTEJSQUNFIixuZXcgUG9zdFNjcmlwdFRva2VuKGVuLkxCUkFDRSwieyIpKX1zdGF0aWMgZ2V0IFJCUkFDRSgpe3JldHVybiBzaGFkb3codGhpcywiUkJSQUNFIixuZXcgUG9zdFNjcmlwdFRva2VuKGVuLlJCUkFDRSwifSIpKX1zdGF0aWMgZ2V0IElGKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJJRiIsbmV3IFBvc3RTY3JpcHRUb2tlbihlbi5JRiwiSUYiKSl9c3RhdGljIGdldCBJRkVMU0UoKXtyZXR1cm4gc2hhZG93KHRoaXMsIklGRUxTRSIsbmV3IFBvc3RTY3JpcHRUb2tlbihlbi5JRkVMU0UsIklGRUxTRSIpKX19Y2xhc3MgUG9zdFNjcmlwdExleGVye2NvbnN0cnVjdG9yKGUpe3RoaXMuc3RyZWFtPWU7dGhpcy5uZXh0Q2hhcigpO3RoaXMuc3RyQnVmPVtdfW5leHRDaGFyKCl7cmV0dXJuIHRoaXMuY3VycmVudENoYXI9dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpfWdldFRva2VuKCl7bGV0IGU9ITEsdD10aGlzLmN1cnJlbnRDaGFyO2Zvcig7Oyl7aWYodDwwKXJldHVybiBhYTtpZihlKTEwIT09dCYmMTMhPT10fHwoZT0hMSk7ZWxzZSBpZigzNz09PXQpZT0hMDtlbHNlIGlmKCFpc1doaXRlU3BhY2UodCkpYnJlYWs7dD10aGlzLm5leHRDaGFyKCl9c3dpdGNoKDB8dCl7Y2FzZSA0ODpjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmNhc2UgNTY6Y2FzZSA1NzpjYXNlIDQzOmNhc2UgNDU6Y2FzZSA0NjpyZXR1cm4gbmV3IFBvc3RTY3JpcHRUb2tlbihlbi5OVU1CRVIsdGhpcy5nZXROdW1iZXIoKSk7Y2FzZSAxMjM6dGhpcy5uZXh0Q2hhcigpO3JldHVybiBQb3N0U2NyaXB0VG9rZW4uTEJSQUNFO2Nhc2UgMTI1OnRoaXMubmV4dENoYXIoKTtyZXR1cm4gUG9zdFNjcmlwdFRva2VuLlJCUkFDRX1jb25zdCBhPXRoaXMuc3RyQnVmO2EubGVuZ3RoPTA7YVswXT1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO2Zvcig7KHQ9dGhpcy5uZXh0Q2hhcigpKT49MCYmKHQ+PTY1JiZ0PD05MHx8dD49OTcmJnQ8PTEyMik7KWEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHQpKTtjb25zdCByPWEuam9pbigiIik7c3dpdGNoKHIudG9Mb3dlckNhc2UoKSl7Y2FzZSJpZiI6cmV0dXJuIFBvc3RTY3JpcHRUb2tlbi5JRjtjYXNlImlmZWxzZSI6cmV0dXJuIFBvc3RTY3JpcHRUb2tlbi5JRkVMU0U7ZGVmYXVsdDpyZXR1cm4gUG9zdFNjcmlwdFRva2VuLmdldE9wZXJhdG9yKHIpfX1nZXROdW1iZXIoKXtsZXQgZT10aGlzLmN1cnJlbnRDaGFyO2NvbnN0IHQ9dGhpcy5zdHJCdWY7dC5sZW5ndGg9MDt0WzBdPVN0cmluZy5mcm9tQ2hhckNvZGUoZSk7Zm9yKDsoZT10aGlzLm5leHRDaGFyKCkpPj0wJiYoZT49NDgmJmU8PTU3fHw0NT09PWV8fDQ2PT09ZSk7KXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKTtjb25zdCBhPXBhcnNlRmxvYXQodC5qb2luKCIiKSk7aWYoaXNOYU4oYSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIGZsb2F0aW5nIHBvaW50IG51bWJlcjogJHthfWApO3JldHVybiBhfX1jbGFzcyBCYXNlTG9jYWxDYWNoZXtjb25zdHJ1Y3RvcihlKXt0aGlzLl9vbmx5UmVmcz0hMD09PWU/Lm9ubHlSZWZzO2lmKCF0aGlzLl9vbmx5UmVmcyl7dGhpcy5fbmFtZVJlZk1hcD1uZXcgTWFwO3RoaXMuX2ltYWdlTWFwPW5ldyBNYXB9dGhpcy5faW1hZ2VDYWNoZT1uZXcgUmVmU2V0Q2FjaGV9Z2V0QnlOYW1lKGUpe3RoaXMuX29ubHlSZWZzJiZ1bnJlYWNoYWJsZSgiU2hvdWxkIG5vdCBjYWxsIGBnZXRCeU5hbWVgIG1ldGhvZC4iKTtjb25zdCB0PXRoaXMuX25hbWVSZWZNYXAuZ2V0KGUpO3JldHVybiB0P3RoaXMuZ2V0QnlSZWYodCk6dGhpcy5faW1hZ2VNYXAuZ2V0KGUpfHxudWxsfWdldEJ5UmVmKGUpe3JldHVybiB0aGlzLl9pbWFnZUNhY2hlLmdldChlKXx8bnVsbH1zZXQoZSx0LGEpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBtZXRob2QgYHNldGAgY2FsbGVkLiIpfX1jbGFzcyBMb2NhbEltYWdlQ2FjaGUgZXh0ZW5kcyBCYXNlTG9jYWxDYWNoZXtzZXQoZSx0PW51bGwsYSl7aWYoInN0cmluZyIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcignTG9jYWxJbWFnZUNhY2hlLnNldCAtIGV4cGVjdGVkICJuYW1lIiBhcmd1bWVudC4nKTtpZih0KXtpZih0aGlzLl9pbWFnZUNhY2hlLmhhcyh0KSlyZXR1cm47dGhpcy5fbmFtZVJlZk1hcC5zZXQoZSx0KTt0aGlzLl9pbWFnZUNhY2hlLnB1dCh0LGEpfWVsc2UgdGhpcy5faW1hZ2VNYXAuaGFzKGUpfHx0aGlzLl9pbWFnZU1hcC5zZXQoZSxhKX19Y2xhc3MgTG9jYWxDb2xvclNwYWNlQ2FjaGUgZXh0ZW5kcyBCYXNlTG9jYWxDYWNoZXtzZXQoZT1udWxsLHQ9bnVsbCxhKXtpZigic3RyaW5nIiE9dHlwZW9mIGUmJiF0KXRocm93IG5ldyBFcnJvcignTG9jYWxDb2xvclNwYWNlQ2FjaGUuc2V0IC0gZXhwZWN0ZWQgIm5hbWUiIGFuZC9vciAicmVmIiBhcmd1bWVudC4nKTtpZih0KXtpZih0aGlzLl9pbWFnZUNhY2hlLmhhcyh0KSlyZXR1cm47bnVsbCE9PWUmJnRoaXMuX25hbWVSZWZNYXAuc2V0KGUsdCk7dGhpcy5faW1hZ2VDYWNoZS5wdXQodCxhKX1lbHNlIHRoaXMuX2ltYWdlTWFwLmhhcyhlKXx8dGhpcy5faW1hZ2VNYXAuc2V0KGUsYSl9fWNsYXNzIExvY2FsRnVuY3Rpb25DYWNoZSBleHRlbmRzIEJhc2VMb2NhbENhY2hle2NvbnN0cnVjdG9yKGUpe3N1cGVyKHtvbmx5UmVmczohMH0pfXNldChlPW51bGwsdCxhKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsRnVuY3Rpb25DYWNoZS5zZXQgLSBleHBlY3RlZCAicmVmIiBhcmd1bWVudC4nKTt0aGlzLl9pbWFnZUNhY2hlLmhhcyh0KXx8dGhpcy5faW1hZ2VDYWNoZS5wdXQodCxhKX19Y2xhc3MgTG9jYWxHU3RhdGVDYWNoZSBleHRlbmRzIEJhc2VMb2NhbENhY2hle3NldChlLHQ9bnVsbCxhKXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKCdMb2NhbEdTdGF0ZUNhY2hlLnNldCAtIGV4cGVjdGVkICJuYW1lIiBhcmd1bWVudC4nKTtpZih0KXtpZih0aGlzLl9pbWFnZUNhY2hlLmhhcyh0KSlyZXR1cm47dGhpcy5fbmFtZVJlZk1hcC5zZXQoZSx0KTt0aGlzLl9pbWFnZUNhY2hlLnB1dCh0LGEpfWVsc2UgdGhpcy5faW1hZ2VNYXAuaGFzKGUpfHx0aGlzLl9pbWFnZU1hcC5zZXQoZSxhKX19Y2xhc3MgTG9jYWxUaWxpbmdQYXR0ZXJuQ2FjaGUgZXh0ZW5kcyBCYXNlTG9jYWxDYWNoZXtjb25zdHJ1Y3RvcihlKXtzdXBlcih7b25seVJlZnM6ITB9KX1zZXQoZT1udWxsLHQsYSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCdMb2NhbFRpbGluZ1BhdHRlcm5DYWNoZS5zZXQgLSBleHBlY3RlZCAicmVmIiBhcmd1bWVudC4nKTt0aGlzLl9pbWFnZUNhY2hlLmhhcyh0KXx8dGhpcy5faW1hZ2VDYWNoZS5wdXQodCxhKX19Y2xhc3MgUmVnaW9uYWxJbWFnZUNhY2hlIGV4dGVuZHMgQmFzZUxvY2FsQ2FjaGV7Y29uc3RydWN0b3IoZSl7c3VwZXIoe29ubHlSZWZzOiEwfSl9c2V0KGU9bnVsbCx0LGEpe2lmKCF0KXRocm93IG5ldyBFcnJvcignUmVnaW9uYWxJbWFnZUNhY2hlLnNldCAtIGV4cGVjdGVkICJyZWYiIGFyZ3VtZW50LicpO3RoaXMuX2ltYWdlQ2FjaGUuaGFzKHQpfHx0aGlzLl9pbWFnZUNhY2hlLnB1dCh0LGEpfX1jbGFzcyBHbG9iYWxDb2xvclNwYWNlQ2FjaGUgZXh0ZW5kcyBCYXNlTG9jYWxDYWNoZXtjb25zdHJ1Y3RvcihlKXtzdXBlcih7b25seVJlZnM6ITB9KX1zZXQoZT1udWxsLHQsYSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCdHbG9iYWxDb2xvclNwYWNlQ2FjaGUuc2V0IC0gZXhwZWN0ZWQgInJlZiIgYXJndW1lbnQuJyk7dGhpcy5faW1hZ2VDYWNoZS5oYXModCl8fHRoaXMuX2ltYWdlQ2FjaGUucHV0KHQsYSl9Y2xlYXIoKXt0aGlzLl9pbWFnZUNhY2hlLmNsZWFyKCl9fWNsYXNzIEdsb2JhbEltYWdlQ2FjaGV7c3RhdGljIE5VTV9QQUdFU19USFJFU0hPTEQ9MjtzdGF0aWMgTUlOX0lNQUdFU19UT19DQUNIRT0xMDtzdGF0aWMgTUFYX0JZVEVfU0laRT01ZTc7I0g9bmV3IFJlZlNldDtjb25zdHJ1Y3Rvcigpe3RoaXMuX3JlZkNhY2hlPW5ldyBSZWZTZXRDYWNoZTt0aGlzLl9pbWFnZUNhY2hlPW5ldyBSZWZTZXRDYWNoZX1nZXQjVygpe2xldCBlPTA7Zm9yKGNvbnN0IHQgb2YgdGhpcy5faW1hZ2VDYWNoZSllKz10LmJ5dGVTaXplO3JldHVybiBlfWdldCN6KCl7cmV0dXJuISh0aGlzLl9pbWFnZUNhY2hlLnNpemU8R2xvYmFsSW1hZ2VDYWNoZS5NSU5fSU1BR0VTX1RPX0NBQ0hFKSYmISh0aGlzLiNXPEdsb2JhbEltYWdlQ2FjaGUuTUFYX0JZVEVfU0laRSl9c2hvdWxkQ2FjaGUoZSx0KXtsZXQgYT10aGlzLl9yZWZDYWNoZS5nZXQoZSk7aWYoIWEpe2E9bmV3IFNldDt0aGlzLl9yZWZDYWNoZS5wdXQoZSxhKX1hLmFkZCh0KTtyZXR1cm4hKGEuc2l6ZTxHbG9iYWxJbWFnZUNhY2hlLk5VTV9QQUdFU19USFJFU0hPTEQpJiYhKCF0aGlzLl9pbWFnZUNhY2hlLmhhcyhlKSYmdGhpcy4jeil9YWRkRGVjb2RlRmFpbGVkKGUpe3RoaXMuI0gucHV0KGUpfWhhc0RlY29kZUZhaWxlZChlKXtyZXR1cm4gdGhpcy4jSC5oYXMoZSl9YWRkQnl0ZVNpemUoZSx0KXtjb25zdCBhPXRoaXMuX2ltYWdlQ2FjaGUuZ2V0KGUpO2EmJihhLmJ5dGVTaXplfHwoYS5ieXRlU2l6ZT10KSl9Z2V0RGF0YShlLHQpe2NvbnN0IGE9dGhpcy5fcmVmQ2FjaGUuZ2V0KGUpO2lmKCFhKXJldHVybiBudWxsO2lmKGEuc2l6ZTxHbG9iYWxJbWFnZUNhY2hlLk5VTV9QQUdFU19USFJFU0hPTEQpcmV0dXJuIG51bGw7Y29uc3Qgcj10aGlzLl9pbWFnZUNhY2hlLmdldChlKTtpZighcilyZXR1cm4gbnVsbDthLmFkZCh0KTtyZXR1cm4gcn1zZXREYXRhKGUsdCl7aWYoIXRoaXMuX3JlZkNhY2hlLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoJ0dsb2JhbEltYWdlQ2FjaGUuc2V0RGF0YSAtIGV4cGVjdGVkICJzaG91bGRDYWNoZSIgdG8gaGF2ZSBiZWVuIGNhbGxlZC4nKTt0aGlzLl9pbWFnZUNhY2hlLmhhcyhlKXx8KHRoaXMuI3o/d2FybigiR2xvYmFsSW1hZ2VDYWNoZS5zZXREYXRhIC0gY2FjaGUgbGltaXQgcmVhY2hlZC4iKTp0aGlzLl9pbWFnZUNhY2hlLnB1dChlLHQpKX1jbGVhcihlPSExKXtpZighZSl7dGhpcy4jSC5jbGVhcigpO3RoaXMuX3JlZkNhY2hlLmNsZWFyKCl9dGhpcy5faW1hZ2VDYWNoZS5jbGVhcigpfX1jbGFzcyBQREZGdW5jdGlvbkZhY3Rvcnl7Y29uc3RydWN0b3Ioe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dD0hMH0pe3RoaXMueHJlZj1lO3RoaXMuaXNFdmFsU3VwcG9ydGVkPSExIT09dH1jcmVhdGUoZSx0PSExKXtsZXQgYSxyO2UgaW5zdGFuY2VvZiBSZWY/YT1lOmUgaW5zdGFuY2VvZiBEaWN0P2E9ZS5vYmpJZDplIGluc3RhbmNlb2YgQmFzZVN0cmVhbSYmKGE9ZS5kaWN0Py5vYmpJZCk7aWYoYSl7Y29uc3QgZT10aGlzLl9sb2NhbEZ1bmN0aW9uQ2FjaGUuZ2V0QnlSZWYoYSk7aWYoZSlyZXR1cm4gZX1jb25zdCBpPXRoaXMueHJlZi5mZXRjaElmUmVmKGUpO2lmKEFycmF5LmlzQXJyYXkoaSkpe2lmKCF0KXRocm93IG5ldyBFcnJvcignUERGRnVuY3Rpb25GYWN0b3J5LmNyZWF0ZSAtIGV4cGVjdGVkICJwYXJzZUFycmF5IiBhcmd1bWVudC4nKTtyPVBERkZ1bmN0aW9uLnBhcnNlQXJyYXkodGhpcyxpKX1lbHNlIHI9UERGRnVuY3Rpb24ucGFyc2UodGhpcyxpKTthJiZ0aGlzLl9sb2NhbEZ1bmN0aW9uQ2FjaGUuc2V0KG51bGwsYSxyKTtyZXR1cm4gcn1nZXQgX2xvY2FsRnVuY3Rpb25DYWNoZSgpe3JldHVybiBzaGFkb3codGhpcywiX2xvY2FsRnVuY3Rpb25DYWNoZSIsbmV3IExvY2FsRnVuY3Rpb25DYWNoZSl9fWZ1bmN0aW9uIHRvTnVtYmVyQXJyYXkoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/aXNOdW1iZXJBcnJheShlLG51bGwpP2U6ZS5tYXAoKGU9PitlKSk6bnVsbH1jbGFzcyBQREZGdW5jdGlvbntzdGF0aWMgZ2V0U2FtcGxlQXJyYXkoZSx0LGEscil7bGV0IGksbixzPTE7Zm9yKGk9MCxuPWUubGVuZ3RoO2k8bjtpKyspcyo9ZVtpXTtzKj10O2NvbnN0IG89bmV3IEFycmF5KHMpO2xldCBjPTAsbD0wO2NvbnN0IGg9MS8oMioqYS0xKSx1PXIuZ2V0Qnl0ZXMoKHMqYSs3KS84KTtsZXQgZD0wO2ZvcihpPTA7aTxzO2krKyl7Zm9yKDtjPGE7KXtsPDw9ODtsfD11W2QrK107Yys9OH1jLT1hO29baV09KGw+PmMpKmg7bCY9KDE8PGMpLTF9cmV0dXJuIG99c3RhdGljIHBhcnNlKGUsdCl7Y29uc3QgYT10LmRpY3R8fHQ7c3dpdGNoKGEuZ2V0KCJGdW5jdGlvblR5cGUiKSl7Y2FzZSAwOnJldHVybiB0aGlzLmNvbnN0cnVjdFNhbXBsZWQoZSx0LGEpO2Nhc2UgMTpicmVhaztjYXNlIDI6cmV0dXJuIHRoaXMuY29uc3RydWN0SW50ZXJwb2xhdGVkKGUsYSk7Y2FzZSAzOnJldHVybiB0aGlzLmNvbnN0cnVjdFN0aWNoZWQoZSxhKTtjYXNlIDQ6cmV0dXJuIHRoaXMuY29uc3RydWN0UG9zdFNjcmlwdChlLHQsYSl9dGhyb3cgbmV3IEZvcm1hdEVycm9yKCJVbmtub3duIHR5cGUgb2YgZnVuY3Rpb24iKX1zdGF0aWMgcGFyc2VBcnJheShlLHQpe2NvbnN0e3hyZWY6YX09ZSxyPVtdO2Zvcihjb25zdCBpIG9mIHQpci5wdXNoKHRoaXMucGFyc2UoZSxhLmZldGNoSWZSZWYoaSkpKTtyZXR1cm4gZnVuY3Rpb24oZSx0LGEsaSl7Zm9yKGxldCBuPTAscz1yLmxlbmd0aDtuPHM7bisrKXJbbl0oZSx0LGEsaStuKX19c3RhdGljIGNvbnN0cnVjdFNhbXBsZWQoZSx0LGEpe2Z1bmN0aW9uIHRvTXVsdGlBcnJheShlKXtjb25zdCB0PWUubGVuZ3RoLGE9W107bGV0IHI9MDtmb3IobGV0IGk9MDtpPHQ7aSs9MilhW3IrK109W2VbaV0sZVtpKzFdXTtyZXR1cm4gYX1mdW5jdGlvbiBpbnRlcnBvbGF0ZShlLHQsYSxyLGkpe3JldHVybiByKyhpLXIpLyhhLXQpKihlLXQpfWxldCByPXRvTnVtYmVyQXJyYXkoYS5nZXRBcnJheSgiRG9tYWluIikpLGk9dG9OdW1iZXJBcnJheShhLmdldEFycmF5KCJSYW5nZSIpKTtpZighcnx8IWkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJObyBkb21haW4gb3IgcmFuZ2UiKTtjb25zdCBuPXIubGVuZ3RoLzIscz1pLmxlbmd0aC8yO3I9dG9NdWx0aUFycmF5KHIpO2k9dG9NdWx0aUFycmF5KGkpO2NvbnN0IG89dG9OdW1iZXJBcnJheShhLmdldEFycmF5KCJTaXplIikpLGM9YS5nZXQoIkJpdHNQZXJTYW1wbGUiKSxsPWEuZ2V0KCJPcmRlciIpfHwxOzEhPT1sJiZpbmZvKCJObyBzdXBwb3J0IGZvciBjdWJpYyBzcGxpbmUgaW50ZXJwb2xhdGlvbjogIitsKTtsZXQgaD10b051bWJlckFycmF5KGEuZ2V0QXJyYXkoIkVuY29kZSIpKTtpZihoKWg9dG9NdWx0aUFycmF5KGgpO2Vsc2V7aD1bXTtmb3IobGV0IGU9MDtlPG47KytlKWgucHVzaChbMCxvW2VdLTFdKX1sZXQgdT10b051bWJlckFycmF5KGEuZ2V0QXJyYXkoIkRlY29kZSIpKTt1PXU/dG9NdWx0aUFycmF5KHUpOmk7Y29uc3QgZD10aGlzLmdldFNhbXBsZUFycmF5KG8scyxjLHQpO3JldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RTYW1wbGVkRm4oZSx0LGEsYyl7Y29uc3QgbD0xPDxuLGY9bmV3IEZsb2F0NjRBcnJheShsKS5maWxsKDEpLGc9bmV3IFVpbnQzMkFycmF5KGwpO2xldCBwLG0sYj1zLHk9MTtmb3IocD0wO3A8bjsrK3Ape2NvbnN0IGE9cltwXVswXSxpPXJbcF1bMV07bGV0IG49aW50ZXJwb2xhdGUoTWF0aENsYW1wKGVbdCtwXSxhLGkpLGEsaSxoW3BdWzBdLGhbcF1bMV0pO2NvbnN0IHM9b1twXTtuPU1hdGhDbGFtcChuLDAscy0xKTtjb25zdCBjPW48cy0xP01hdGguZmxvb3Iobik6bi0xLHU9YysxLW4sZD1uLWMsdz1jKmIseD13K2I7Zm9yKG09MDttPGw7bSsrKWlmKG0meSl7ZlttXSo9ZDtnW21dKz14fWVsc2V7ZlttXSo9dTtnW21dKz13fWIqPXM7eTw8PTF9Zm9yKG09MDttPHM7KyttKXtsZXQgZT0wO2ZvcihwPTA7cDxsO3ArKyllKz1kW2dbcF0rbV0qZltwXTtlPWludGVycG9sYXRlKGUsMCwxLHVbbV1bMF0sdVttXVsxXSk7YVtjK21dPU1hdGhDbGFtcChlLGlbbV1bMF0saVttXVsxXSl9fX1zdGF0aWMgY29uc3RydWN0SW50ZXJwb2xhdGVkKGUsdCl7Y29uc3QgYT10b051bWJlckFycmF5KHQuZ2V0QXJyYXkoIkMwIikpfHxbMF0scj10b051bWJlckFycmF5KHQuZ2V0QXJyYXkoIkMxIikpfHxbMV0saT10LmdldCgiTiIpLG49W107Zm9yKGxldCBlPTAsdD1hLmxlbmd0aDtlPHQ7KytlKW4ucHVzaChyW2VdLWFbZV0pO2NvbnN0IHM9bi5sZW5ndGg7cmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdEludGVycG9sYXRlZEZuKGUsdCxyLG8pe2NvbnN0IGM9MT09PWk/ZVt0XTplW3RdKippO2ZvcihsZXQgZT0wO2U8czsrK2UpcltvK2VdPWFbZV0rYypuW2VdfX1zdGF0aWMgY29uc3RydWN0U3RpY2hlZChlLHQpe2NvbnN0IGE9dG9OdW1iZXJBcnJheSh0LmdldEFycmF5KCJEb21haW4iKSk7aWYoIWEpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJObyBkb21haW4iKTtpZigxIT09YS5sZW5ndGgvMil0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkJhZCBkb21haW4gZm9yIHN0aWNoZWQgZnVuY3Rpb24iKTtjb25zdHt4cmVmOnJ9PWUsaT1bXTtmb3IoY29uc3QgYSBvZiB0LmdldCgiRnVuY3Rpb25zIikpaS5wdXNoKHRoaXMucGFyc2UoZSxyLmZldGNoSWZSZWYoYSkpKTtjb25zdCBuPXRvTnVtYmVyQXJyYXkodC5nZXRBcnJheSgiQm91bmRzIikpLHM9dG9OdW1iZXJBcnJheSh0LmdldEFycmF5KCJFbmNvZGUiKSksbz1uZXcgRmxvYXQzMkFycmF5KDEpO3JldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RTdGljaGVkRm4oZSx0LHIsYyl7Y29uc3QgbD1NYXRoQ2xhbXAoZVt0XSxhWzBdLGFbMV0pLGg9bi5sZW5ndGg7bGV0IHU7Zm9yKHU9MDt1PGgmJiEobDxuW3VdKTsrK3UpO2xldCBkPWFbMF07dT4wJiYoZD1uW3UtMV0pO2xldCBmPWFbMV07dTxuLmxlbmd0aCYmKGY9blt1XSk7Y29uc3QgZz1zWzIqdV0scD1zWzIqdSsxXTtvWzBdPWQ9PT1mP2c6ZysobC1kKSoocC1nKS8oZi1kKTtpW3VdKG8sMCxyLGMpfX1zdGF0aWMgY29uc3RydWN0UG9zdFNjcmlwdChlLHQsYSl7Y29uc3Qgcj10b051bWJlckFycmF5KGEuZ2V0QXJyYXkoIkRvbWFpbiIpKSxpPXRvTnVtYmVyQXJyYXkoYS5nZXRBcnJheSgiUmFuZ2UiKSk7aWYoIXIpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJObyBkb21haW4uIik7aWYoIWkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJObyByYW5nZS4iKTtjb25zdCBuPW5ldyBQb3N0U2NyaXB0TGV4ZXIodCkscz1uZXcgUG9zdFNjcmlwdFBhcnNlcihuKS5wYXJzZSgpO2lmKGUuaXNFdmFsU3VwcG9ydGVkJiZGZWF0dXJlVGVzdC5pc0V2YWxTdXBwb3J0ZWQpe2NvbnN0IGU9KG5ldyBQb3N0U2NyaXB0Q29tcGlsZXIpLmNvbXBpbGUocyxyLGkpO2lmKGUpcmV0dXJuIG5ldyBGdW5jdGlvbigic3JjIiwic3JjT2Zmc2V0IiwiZGVzdCIsImRlc3RPZmZzZXQiLGUpfWluZm8oIlVuYWJsZSB0byBjb21waWxlIFBTIGZ1bmN0aW9uIik7Y29uc3Qgbz1pLmxlbmd0aD4+MSxjPXIubGVuZ3RoPj4xLGw9bmV3IFBvc3RTY3JpcHRFdmFsdWF0b3IocyksaD1PYmplY3QuY3JlYXRlKG51bGwpO2xldCB1PTgxOTI7Y29uc3QgZD1uZXcgRmxvYXQzMkFycmF5KGMpO3JldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RQb3N0U2NyaXB0Rm4oZSx0LGEscil7bGV0IG4scyxmPSIiO2NvbnN0IGc9ZDtmb3Iobj0wO248YztuKyspe3M9ZVt0K25dO2dbbl09cztmKz1zKyJfIn1jb25zdCBwPWhbZl07aWYodm9pZCAwIT09cCl7YS5zZXQocCxyKTtyZXR1cm59Y29uc3QgbT1uZXcgRmxvYXQzMkFycmF5KG8pLGI9bC5leGVjdXRlKGcpLHk9Yi5sZW5ndGgtbztmb3Iobj0wO248bztuKyspe3M9Ylt5K25dO2xldCBlPWlbMipuXTtpZihzPGUpcz1lO2Vsc2V7ZT1pWzIqbisxXTtzPmUmJihzPWUpfW1bbl09c31pZih1PjApe3UtLTtoW2ZdPW19YS5zZXQobSxyKX19fWZ1bmN0aW9uIGlzUERGRnVuY3Rpb24oZSl7bGV0IHQ7aWYoZSBpbnN0YW5jZW9mIERpY3QpdD1lO2Vsc2V7aWYoIShlIGluc3RhbmNlb2YgQmFzZVN0cmVhbSkpcmV0dXJuITE7dD1lLmRpY3R9cmV0dXJuIHQuaGFzKCJGdW5jdGlvblR5cGUiKX1jbGFzcyBQb3N0U2NyaXB0U3RhY2t7c3RhdGljIE1BWF9TVEFDS19TSVpFPTEwMDtjb25zdHJ1Y3RvcihlKXt0aGlzLnN0YWNrPWU/QXJyYXkuZnJvbShlKTpbXX1wdXNoKGUpe2lmKHRoaXMuc3RhY2subGVuZ3RoPj1Qb3N0U2NyaXB0U3RhY2suTUFYX1NUQUNLX1NJWkUpdGhyb3cgbmV3IEVycm9yKCJQb3N0U2NyaXB0IGZ1bmN0aW9uIHN0YWNrIG92ZXJmbG93LiIpO3RoaXMuc3RhY2sucHVzaChlKX1wb3AoKXtpZih0aGlzLnN0YWNrLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoIlBvc3RTY3JpcHQgZnVuY3Rpb24gc3RhY2sgdW5kZXJmbG93LiIpO3JldHVybiB0aGlzLnN0YWNrLnBvcCgpfWNvcHkoZSl7aWYodGhpcy5zdGFjay5sZW5ndGgrZT49UG9zdFNjcmlwdFN0YWNrLk1BWF9TVEFDS19TSVpFKXRocm93IG5ldyBFcnJvcigiUG9zdFNjcmlwdCBmdW5jdGlvbiBzdGFjayBvdmVyZmxvdy4iKTtjb25zdCB0PXRoaXMuc3RhY2s7Zm9yKGxldCBhPXQubGVuZ3RoLWUscj1lLTE7cj49MDtyLS0sYSsrKXQucHVzaCh0W2FdKX1pbmRleChlKXt0aGlzLnB1c2godGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC1lLTFdKX1yb2xsKGUsdCl7Y29uc3QgYT10aGlzLnN0YWNrLHI9YS5sZW5ndGgtZSxpPWEubGVuZ3RoLTEsbj1yKyh0LU1hdGguZmxvb3IodC9lKSplKTtmb3IobGV0IGU9cix0PWk7ZTx0O2UrKyx0LS0pe2NvbnN0IHI9YVtlXTthW2VdPWFbdF07YVt0XT1yfWZvcihsZXQgZT1yLHQ9bi0xO2U8dDtlKyssdC0tKXtjb25zdCByPWFbZV07YVtlXT1hW3RdO2FbdF09cn1mb3IobGV0IGU9bix0PWk7ZTx0O2UrKyx0LS0pe2NvbnN0IHI9YVtlXTthW2VdPWFbdF07YVt0XT1yfX19Y2xhc3MgUG9zdFNjcmlwdEV2YWx1YXRvcntjb25zdHJ1Y3RvcihlKXt0aGlzLm9wZXJhdG9ycz1lfWV4ZWN1dGUoZSl7Y29uc3QgdD1uZXcgUG9zdFNjcmlwdFN0YWNrKGUpO2xldCBhPTA7Y29uc3Qgcj10aGlzLm9wZXJhdG9ycyxpPXIubGVuZ3RoO2xldCBuLHMsbztmb3IoO2E8aTspe249clthKytdO2lmKCJudW1iZXIiIT10eXBlb2Ygbilzd2l0Y2gobil7Y2FzZSJqeiI6bz10LnBvcCgpO3M9dC5wb3AoKTtzfHwoYT1vKTticmVhaztjYXNlImoiOnM9dC5wb3AoKTthPXM7YnJlYWs7Y2FzZSJhYnMiOnM9dC5wb3AoKTt0LnB1c2goTWF0aC5hYnMocykpO2JyZWFrO2Nhc2UiYWRkIjpvPXQucG9wKCk7cz10LnBvcCgpO3QucHVzaChzK28pO2JyZWFrO2Nhc2UiYW5kIjpvPXQucG9wKCk7cz10LnBvcCgpOyJib29sZWFuIj09dHlwZW9mIHMmJiJib29sZWFuIj09dHlwZW9mIG8/dC5wdXNoKHMmJm8pOnQucHVzaChzJm8pO2JyZWFrO2Nhc2UiYXRhbiI6bz10LnBvcCgpO3M9dC5wb3AoKTtzPU1hdGguYXRhbjIocyxvKS9NYXRoLlBJKjE4MDtzPDAmJihzKz0zNjApO3QucHVzaChzKTticmVhaztjYXNlImJpdHNoaWZ0IjpvPXQucG9wKCk7cz10LnBvcCgpO3M+MD90LnB1c2goczw8byk6dC5wdXNoKHM+Pm8pO2JyZWFrO2Nhc2UiY2VpbGluZyI6cz10LnBvcCgpO3QucHVzaChNYXRoLmNlaWwocykpO2JyZWFrO2Nhc2UiY29weSI6cz10LnBvcCgpO3QuY29weShzKTticmVhaztjYXNlImNvcyI6cz10LnBvcCgpO3QucHVzaChNYXRoLmNvcyhzJTM2MC8xODAqTWF0aC5QSSkpO2JyZWFrO2Nhc2UiY3ZpIjpzPTB8dC5wb3AoKTt0LnB1c2gocyk7YnJlYWs7Y2FzZSJjdnIiOmJyZWFrO2Nhc2UiZGl2IjpvPXQucG9wKCk7cz10LnBvcCgpO3QucHVzaChzL28pO2JyZWFrO2Nhc2UiZHVwIjp0LmNvcHkoMSk7YnJlYWs7Y2FzZSJlcSI6bz10LnBvcCgpO3M9dC5wb3AoKTt0LnB1c2gocz09PW8pO2JyZWFrO2Nhc2UiZXhjaCI6dC5yb2xsKDIsMSk7YnJlYWs7Y2FzZSJleHAiOm89dC5wb3AoKTtzPXQucG9wKCk7dC5wdXNoKHMqKm8pO2JyZWFrO2Nhc2UiZmFsc2UiOnQucHVzaCghMSk7YnJlYWs7Y2FzZSJmbG9vciI6cz10LnBvcCgpO3QucHVzaChNYXRoLmZsb29yKHMpKTticmVhaztjYXNlImdlIjpvPXQucG9wKCk7cz10LnBvcCgpO3QucHVzaChzPj1vKTticmVhaztjYXNlImd0IjpvPXQucG9wKCk7cz10LnBvcCgpO3QucHVzaChzPm8pO2JyZWFrO2Nhc2UiaWRpdiI6bz10LnBvcCgpO3M9dC5wb3AoKTt0LnB1c2gocy9vfDApO2JyZWFrO2Nhc2UiaW5kZXgiOnM9dC5wb3AoKTt0LmluZGV4KHMpO2JyZWFrO2Nhc2UibGUiOm89dC5wb3AoKTtzPXQucG9wKCk7dC5wdXNoKHM8PW8pO2JyZWFrO2Nhc2UibG4iOnM9dC5wb3AoKTt0LnB1c2goTWF0aC5sb2cocykpO2JyZWFrO2Nhc2UibG9nIjpzPXQucG9wKCk7dC5wdXNoKE1hdGgubG9nMTAocykpO2JyZWFrO2Nhc2UibHQiOm89dC5wb3AoKTtzPXQucG9wKCk7dC5wdXNoKHM8byk7YnJlYWs7Y2FzZSJtb2QiOm89dC5wb3AoKTtzPXQucG9wKCk7dC5wdXNoKHMlbyk7YnJlYWs7Y2FzZSJtdWwiOm89dC5wb3AoKTtzPXQucG9wKCk7dC5wdXNoKHMqbyk7YnJlYWs7Y2FzZSJuZSI6bz10LnBvcCgpO3M9dC5wb3AoKTt0LnB1c2gocyE9PW8pO2JyZWFrO2Nhc2UibmVnIjpzPXQucG9wKCk7dC5wdXNoKC1zKTticmVhaztjYXNlIm5vdCI6cz10LnBvcCgpOyJib29sZWFuIj09dHlwZW9mIHM/dC5wdXNoKCFzKTp0LnB1c2gofnMpO2JyZWFrO2Nhc2Uib3IiOm89dC5wb3AoKTtzPXQucG9wKCk7ImJvb2xlYW4iPT10eXBlb2YgcyYmImJvb2xlYW4iPT10eXBlb2Ygbz90LnB1c2goc3x8byk6dC5wdXNoKHN8byk7YnJlYWs7Y2FzZSJwb3AiOnQucG9wKCk7YnJlYWs7Y2FzZSJyb2xsIjpvPXQucG9wKCk7cz10LnBvcCgpO3Qucm9sbChzLG8pO2JyZWFrO2Nhc2Uicm91bmQiOnM9dC5wb3AoKTt0LnB1c2goTWF0aC5yb3VuZChzKSk7YnJlYWs7Y2FzZSJzaW4iOnM9dC5wb3AoKTt0LnB1c2goTWF0aC5zaW4ocyUzNjAvMTgwKk1hdGguUEkpKTticmVhaztjYXNlInNxcnQiOnM9dC5wb3AoKTt0LnB1c2goTWF0aC5zcXJ0KHMpKTticmVhaztjYXNlInN1YiI6bz10LnBvcCgpO3M9dC5wb3AoKTt0LnB1c2gocy1vKTticmVhaztjYXNlInRydWUiOnQucHVzaCghMCk7YnJlYWs7Y2FzZSJ0cnVuY2F0ZSI6cz10LnBvcCgpO3M9czwwP01hdGguY2VpbChzKTpNYXRoLmZsb29yKHMpO3QucHVzaChzKTticmVhaztjYXNlInhvciI6bz10LnBvcCgpO3M9dC5wb3AoKTsiYm9vbGVhbiI9PXR5cGVvZiBzJiYiYm9vbGVhbiI9PXR5cGVvZiBvP3QucHVzaChzIT09byk6dC5wdXNoKHNebyk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVua25vd24gb3BlcmF0b3IgJHtufWApfWVsc2UgdC5wdXNoKG4pfXJldHVybiB0LnN0YWNrfX1jbGFzcyBBc3ROb2Rle2NvbnN0cnVjdG9yKGUpe3RoaXMudHlwZT1lfXZpc2l0KGUpe3VucmVhY2hhYmxlKCJhYnN0cmFjdCBtZXRob2QiKX19Y2xhc3MgQXN0QXJndW1lbnQgZXh0ZW5kcyBBc3ROb2Rle2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcigiYXJncyIpO3RoaXMuaW5kZXg9ZTt0aGlzLm1pbj10O3RoaXMubWF4PWF9dmlzaXQoZSl7ZS52aXNpdEFyZ3VtZW50KHRoaXMpfX1jbGFzcyBBc3RMaXRlcmFsIGV4dGVuZHMgQXN0Tm9kZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigibGl0ZXJhbCIpO3RoaXMubnVtYmVyPWU7dGhpcy5taW49ZTt0aGlzLm1heD1lfXZpc2l0KGUpe2UudmlzaXRMaXRlcmFsKHRoaXMpfX1jbGFzcyBBc3RCaW5hcnlPcGVyYXRpb24gZXh0ZW5kcyBBc3ROb2Rle2NvbnN0cnVjdG9yKGUsdCxhLHIsaSl7c3VwZXIoImJpbmFyeSIpO3RoaXMub3A9ZTt0aGlzLmFyZzE9dDt0aGlzLmFyZzI9YTt0aGlzLm1pbj1yO3RoaXMubWF4PWl9dmlzaXQoZSl7ZS52aXNpdEJpbmFyeU9wZXJhdGlvbih0aGlzKX19Y2xhc3MgQXN0TWluIGV4dGVuZHMgQXN0Tm9kZXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCJtYXgiKTt0aGlzLmFyZz1lO3RoaXMubWluPWUubWluO3RoaXMubWF4PXR9dmlzaXQoZSl7ZS52aXNpdE1pbih0aGlzKX19Y2xhc3MgQXN0VmFyaWFibGUgZXh0ZW5kcyBBc3ROb2Rle2NvbnN0cnVjdG9yKGUsdCxhKXtzdXBlcigidmFyIik7dGhpcy5pbmRleD1lO3RoaXMubWluPXQ7dGhpcy5tYXg9YX12aXNpdChlKXtlLnZpc2l0VmFyaWFibGUodGhpcyl9fWNsYXNzIEFzdFZhcmlhYmxlRGVmaW5pdGlvbiBleHRlbmRzIEFzdE5vZGV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigiZGVmaW5pdGlvbiIpO3RoaXMudmFyaWFibGU9ZTt0aGlzLmFyZz10fXZpc2l0KGUpe2UudmlzaXRWYXJpYWJsZURlZmluaXRpb24odGhpcyl9fWNsYXNzIEV4cHJlc3Npb25CdWlsZGVyVmlzaXRvcntjb25zdHJ1Y3Rvcigpe3RoaXMucGFydHM9W119dmlzaXRBcmd1bWVudChlKXt0aGlzLnBhcnRzLnB1c2goIk1hdGgubWF4KCIsZS5taW4sIiwgTWF0aC5taW4oIixlLm1heCwiLCBzcmNbc3JjT2Zmc2V0ICsgIixlLmluZGV4LCJdKSkiKX12aXNpdFZhcmlhYmxlKGUpe3RoaXMucGFydHMucHVzaCgidiIsZS5pbmRleCl9dmlzaXRMaXRlcmFsKGUpe3RoaXMucGFydHMucHVzaChlLm51bWJlcil9dmlzaXRCaW5hcnlPcGVyYXRpb24oZSl7dGhpcy5wYXJ0cy5wdXNoKCIoIik7ZS5hcmcxLnZpc2l0KHRoaXMpO3RoaXMucGFydHMucHVzaCgiICIsZS5vcCwiICIpO2UuYXJnMi52aXNpdCh0aGlzKTt0aGlzLnBhcnRzLnB1c2goIikiKX12aXNpdFZhcmlhYmxlRGVmaW5pdGlvbihlKXt0aGlzLnBhcnRzLnB1c2goInZhciAiKTtlLnZhcmlhYmxlLnZpc2l0KHRoaXMpO3RoaXMucGFydHMucHVzaCgiID0gIik7ZS5hcmcudmlzaXQodGhpcyk7dGhpcy5wYXJ0cy5wdXNoKCI7Iil9dmlzaXRNaW4oZSl7dGhpcy5wYXJ0cy5wdXNoKCJNYXRoLm1pbigiKTtlLmFyZy52aXNpdCh0aGlzKTt0aGlzLnBhcnRzLnB1c2goIiwgIixlLm1heCwiKSIpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMucGFydHMuam9pbigiIil9fWZ1bmN0aW9uIGJ1aWxkQWRkT3BlcmF0aW9uKGUsdCl7cmV0dXJuImxpdGVyYWwiPT09dC50eXBlJiYwPT09dC5udW1iZXI/ZToibGl0ZXJhbCI9PT1lLnR5cGUmJjA9PT1lLm51bWJlcj90OiJsaXRlcmFsIj09PXQudHlwZSYmImxpdGVyYWwiPT09ZS50eXBlP25ldyBBc3RMaXRlcmFsKGUubnVtYmVyK3QubnVtYmVyKTpuZXcgQXN0QmluYXJ5T3BlcmF0aW9uKCIrIixlLHQsZS5taW4rdC5taW4sZS5tYXgrdC5tYXgpfWZ1bmN0aW9uIGJ1aWxkTXVsT3BlcmF0aW9uKGUsdCl7aWYoImxpdGVyYWwiPT09dC50eXBlKXtpZigwPT09dC5udW1iZXIpcmV0dXJuIG5ldyBBc3RMaXRlcmFsKDApO2lmKDE9PT10Lm51bWJlcilyZXR1cm4gZTtpZigibGl0ZXJhbCI9PT1lLnR5cGUpcmV0dXJuIG5ldyBBc3RMaXRlcmFsKGUubnVtYmVyKnQubnVtYmVyKX1pZigibGl0ZXJhbCI9PT1lLnR5cGUpe2lmKDA9PT1lLm51bWJlcilyZXR1cm4gbmV3IEFzdExpdGVyYWwoMCk7aWYoMT09PWUubnVtYmVyKXJldHVybiB0fWNvbnN0IGE9TWF0aC5taW4oZS5taW4qdC5taW4sZS5taW4qdC5tYXgsZS5tYXgqdC5taW4sZS5tYXgqdC5tYXgpLHI9TWF0aC5tYXgoZS5taW4qdC5taW4sZS5taW4qdC5tYXgsZS5tYXgqdC5taW4sZS5tYXgqdC5tYXgpO3JldHVybiBuZXcgQXN0QmluYXJ5T3BlcmF0aW9uKCIqIixlLHQsYSxyKX1mdW5jdGlvbiBidWlsZFN1Yk9wZXJhdGlvbihlLHQpe2lmKCJsaXRlcmFsIj09PXQudHlwZSl7aWYoMD09PXQubnVtYmVyKXJldHVybiBlO2lmKCJsaXRlcmFsIj09PWUudHlwZSlyZXR1cm4gbmV3IEFzdExpdGVyYWwoZS5udW1iZXItdC5udW1iZXIpfXJldHVybiJiaW5hcnkiPT09dC50eXBlJiYiLSI9PT10Lm9wJiYibGl0ZXJhbCI9PT1lLnR5cGUmJjE9PT1lLm51bWJlciYmImxpdGVyYWwiPT09dC5hcmcxLnR5cGUmJjE9PT10LmFyZzEubnVtYmVyP3QuYXJnMjpuZXcgQXN0QmluYXJ5T3BlcmF0aW9uKCItIixlLHQsZS5taW4tdC5tYXgsZS5tYXgtdC5taW4pfWZ1bmN0aW9uIGJ1aWxkTWluT3BlcmF0aW9uKGUsdCl7cmV0dXJuIGUubWluPj10P25ldyBBc3RMaXRlcmFsKHQpOmUubWF4PD10P2U6bmV3IEFzdE1pbihlLHQpfWNsYXNzIFBvc3RTY3JpcHRDb21waWxlcntjb21waWxlKGUsdCxhKXtjb25zdCByPVtdLGk9W10sbj10Lmxlbmd0aD4+MSxzPWEubGVuZ3RoPj4xO2xldCBvLGMsbCxoLHUsZCxmLGcscD0wO2ZvcihsZXQgZT0wO2U8bjtlKyspci5wdXNoKG5ldyBBc3RBcmd1bWVudChlLHRbMiplXSx0WzIqZSsxXSkpO2ZvcihsZXQgdD0wLGE9ZS5sZW5ndGg7dDxhO3QrKyl7Zz1lW3RdO2lmKCJudW1iZXIiIT10eXBlb2YgZylzd2l0Y2goZyl7Y2FzZSJhZGQiOmlmKHIubGVuZ3RoPDIpcmV0dXJuIG51bGw7aD1yLnBvcCgpO2w9ci5wb3AoKTtyLnB1c2goYnVpbGRBZGRPcGVyYXRpb24obCxoKSk7YnJlYWs7Y2FzZSJjdnIiOmlmKHIubGVuZ3RoPDEpcmV0dXJuIG51bGw7YnJlYWs7Y2FzZSJtdWwiOmlmKHIubGVuZ3RoPDIpcmV0dXJuIG51bGw7aD1yLnBvcCgpO2w9ci5wb3AoKTtyLnB1c2goYnVpbGRNdWxPcGVyYXRpb24obCxoKSk7YnJlYWs7Y2FzZSJzdWIiOmlmKHIubGVuZ3RoPDIpcmV0dXJuIG51bGw7aD1yLnBvcCgpO2w9ci5wb3AoKTtyLnB1c2goYnVpbGRTdWJPcGVyYXRpb24obCxoKSk7YnJlYWs7Y2FzZSJleGNoIjppZihyLmxlbmd0aDwyKXJldHVybiBudWxsO3U9ci5wb3AoKTtkPXIucG9wKCk7ci5wdXNoKHUsZCk7YnJlYWs7Y2FzZSJwb3AiOmlmKHIubGVuZ3RoPDEpcmV0dXJuIG51bGw7ci5wb3AoKTticmVhaztjYXNlImluZGV4IjppZihyLmxlbmd0aDwxKXJldHVybiBudWxsO2w9ci5wb3AoKTtpZigibGl0ZXJhbCIhPT1sLnR5cGUpcmV0dXJuIG51bGw7bz1sLm51bWJlcjtpZihvPDB8fCFOdW1iZXIuaXNJbnRlZ2VyKG8pfHxyLmxlbmd0aDxvKXJldHVybiBudWxsO3U9cltyLmxlbmd0aC1vLTFdO2lmKCJsaXRlcmFsIj09PXUudHlwZXx8InZhciI9PT11LnR5cGUpe3IucHVzaCh1KTticmVha31mPW5ldyBBc3RWYXJpYWJsZShwKyssdS5taW4sdS5tYXgpO3Jbci5sZW5ndGgtby0xXT1mO3IucHVzaChmKTtpLnB1c2gobmV3IEFzdFZhcmlhYmxlRGVmaW5pdGlvbihmLHUpKTticmVhaztjYXNlImR1cCI6aWYoci5sZW5ndGg8MSlyZXR1cm4gbnVsbDtpZigibnVtYmVyIj09dHlwZW9mIGVbdCsxXSYmImd0Ij09PWVbdCsyXSYmZVt0KzNdPT09dCs3JiYianoiPT09ZVt0KzRdJiYicG9wIj09PWVbdCs1XSYmZVt0KzZdPT09ZVt0KzFdKXtsPXIucG9wKCk7ci5wdXNoKGJ1aWxkTWluT3BlcmF0aW9uKGwsZVt0KzFdKSk7dCs9NjticmVha311PXIuYXQoLTEpO2lmKCJsaXRlcmFsIj09PXUudHlwZXx8InZhciI9PT11LnR5cGUpe3IucHVzaCh1KTticmVha31mPW5ldyBBc3RWYXJpYWJsZShwKyssdS5taW4sdS5tYXgpO3Jbci5sZW5ndGgtMV09ZjtyLnB1c2goZik7aS5wdXNoKG5ldyBBc3RWYXJpYWJsZURlZmluaXRpb24oZix1KSk7YnJlYWs7Y2FzZSJyb2xsIjppZihyLmxlbmd0aDwyKXJldHVybiBudWxsO2g9ci5wb3AoKTtsPXIucG9wKCk7aWYoImxpdGVyYWwiIT09aC50eXBlfHwibGl0ZXJhbCIhPT1sLnR5cGUpcmV0dXJuIG51bGw7Yz1oLm51bWJlcjtvPWwubnVtYmVyO2lmKG88PTB8fCFOdW1iZXIuaXNJbnRlZ2VyKG8pfHwhTnVtYmVyLmlzSW50ZWdlcihjKXx8ci5sZW5ndGg8bylyZXR1cm4gbnVsbDtjPShjJW8rbyklbztpZigwPT09YylicmVhaztyLnB1c2goLi4uci5zcGxpY2Uoci5sZW5ndGgtbyxvLWMpKTticmVhaztkZWZhdWx0OnJldHVybiBudWxsfWVsc2Ugci5wdXNoKG5ldyBBc3RMaXRlcmFsKGcpKX1pZihyLmxlbmd0aCE9PXMpcmV0dXJuIG51bGw7Y29uc3QgbT1bXTtmb3IoY29uc3QgZSBvZiBpKXtjb25zdCB0PW5ldyBFeHByZXNzaW9uQnVpbGRlclZpc2l0b3I7ZS52aXNpdCh0KTttLnB1c2godC50b1N0cmluZygpKX1mb3IobGV0IGU9MCx0PXIubGVuZ3RoO2U8dDtlKyspe2NvbnN0IHQ9cltlXSxpPW5ldyBFeHByZXNzaW9uQnVpbGRlclZpc2l0b3I7dC52aXNpdChpKTtjb25zdCBuPWFbMiplXSxzPWFbMiplKzFdLG89W2kudG9TdHJpbmcoKV07aWYobj50Lm1pbil7by51bnNoaWZ0KCJNYXRoLm1heCgiLG4sIiwgIik7by5wdXNoKCIpIil9aWYoczx0Lm1heCl7by51bnNoaWZ0KCJNYXRoLm1pbigiLHMsIiwgIik7by5wdXNoKCIpIil9by51bnNoaWZ0KCJkZXN0W2Rlc3RPZmZzZXQgKyAiLGUsIl0gPSAiKTtvLnB1c2goIjsiKTttLnB1c2goby5qb2luKCIiKSl9cmV0dXJuIG0uam9pbigiXG4iKX19Y29uc3QgdG49WyJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJTIiwiQiIsIlMiLCJXUyIsIkIiLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQiIsIkIiLCJCIiwiUyIsIldTIiwiT04iLCJPTiIsIkVUIiwiRVQiLCJFVCIsIk9OIiwiT04iLCJPTiIsIk9OIiwiT04iLCJFUyIsIkNTIiwiRVMiLCJDUyIsIkNTIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJDUyIsIk9OIiwiT04iLCJPTiIsIk9OIiwiT04iLCJPTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiT04iLCJPTiIsIk9OIiwiT04iLCJPTiIsIk9OIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJPTiIsIk9OIiwiT04iLCJPTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkIiLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQ1MiLCJPTiIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiT04iLCJPTiIsIk9OIiwiT04iLCJMIiwiT04iLCJPTiIsIkJOIiwiT04iLCJPTiIsIkVUIiwiRVQiLCJFTiIsIkVOIiwiT04iLCJMIiwiT04iLCJPTiIsIk9OIiwiRU4iLCJMIiwiT04iLCJPTiIsIk9OIiwiT04iLCJPTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiT04iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiT04iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCJdLGFuPVsiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiT04iLCJPTiIsIkFMIiwiRVQiLCJFVCIsIkFMIiwiQ1MiLCJBTCIsIk9OIiwiT04iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJBTCIsIkFMIiwiIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJFVCIsIkFOIiwiQU4iLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJPTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIkFMIiwiQUwiLCJOU00iLCJOU00iLCJPTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIkFMIiwiQUwiLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCJdO2Z1bmN0aW9uIGlzT2RkKGUpe3JldHVybiEhKDEmZSl9ZnVuY3Rpb24gaXNFdmVuKGUpe3JldHVybiEoMSZlKX1mdW5jdGlvbiBmaW5kVW5lcXVhbChlLHQsYSl7bGV0IHIsaTtmb3Iocj10LGk9ZS5sZW5ndGg7cjxpOysrcilpZihlW3JdIT09YSlyZXR1cm4gcjtyZXR1cm4gcn1mdW5jdGlvbiByZXZlcnNlVmFsdWVzKGUsdCxhKXtmb3IobGV0IHI9dCxpPWEtMTtyPGk7KytyLC0taSl7Y29uc3QgdD1lW3JdO2Vbcl09ZVtpXTtlW2ldPXR9fWZ1bmN0aW9uIGNyZWF0ZUJpZGlUZXh0KGUsdCxhPSExKXtsZXQgcj0ibHRyIjthP3I9InR0YiI6dHx8KHI9InJ0bCIpO3JldHVybntzdHI6ZSxkaXI6cn19Y29uc3Qgcm49W10sbm49W107ZnVuY3Rpb24gYmlkaShlLHQ9LTEsYT0hMSl7bGV0IHI9ITA7Y29uc3QgaT1lLmxlbmd0aDtpZigwPT09aXx8YSlyZXR1cm4gY3JlYXRlQmlkaVRleHQoZSxyLGEpO3JuLmxlbmd0aD1pO25uLmxlbmd0aD1pO2xldCBuLHMsbz0wO2ZvcihuPTA7bjxpOysrbil7cm5bbl09ZS5jaGFyQXQobik7Y29uc3QgdD1lLmNoYXJDb2RlQXQobik7bGV0IGE9IkwiO2lmKHQ8PTI1NSlhPXRuW3RdO2Vsc2UgaWYoMTQyNDw9dCYmdDw9MTUyNClhPSJSIjtlbHNlIGlmKDE1MzY8PXQmJnQ8PTE3OTEpe2E9YW5bMjU1JnRdO2F8fHdhcm4oIkJpZGk6IGludmFsaWQgVW5pY29kZSBjaGFyYWN0ZXIgIit0LnRvU3RyaW5nKDE2KSl9ZWxzZSgxNzkyPD10JiZ0PD0yMjIwfHw2NDMzNjw9dCYmdDw9NjUwMjN8fDY1MTM2PD10JiZ0PD02NTI3OSkmJihhPSJBTCIpOyJSIiE9PWEmJiJBTCIhPT1hJiYiQU4iIT09YXx8bysrO25uW25dPWF9aWYoMD09PW8pe3I9ITA7cmV0dXJuIGNyZWF0ZUJpZGlUZXh0KGUscil9aWYoLTE9PT10KWlmKG8vaTwuMyYmaT40KXtyPSEwO3Q9MH1lbHNle3I9ITE7dD0xfWNvbnN0IGM9W107Zm9yKG49MDtuPGk7KytuKWNbbl09dDtjb25zdCBsPWlzT2RkKHQpPyJSIjoiTCIsaD1sLHU9aDtsZXQgZCxmPWg7Zm9yKG49MDtuPGk7KytuKSJOU00iPT09bm5bbl0/bm5bbl09ZjpmPW5uW25dO2Y9aDtmb3Iobj0wO248aTsrK24pe2Q9bm5bbl07IkVOIj09PWQ/bm5bbl09IkFMIj09PWY/IkFOIjoiRU4iOiJSIiE9PWQmJiJMIiE9PWQmJiJBTCIhPT1kfHwoZj1kKX1mb3Iobj0wO248aTsrK24pe2Q9bm5bbl07IkFMIj09PWQmJihubltuXT0iUiIpfWZvcihuPTE7bjxpLTE7KytuKXsiRVMiPT09bm5bbl0mJiJFTiI9PT1ubltuLTFdJiYiRU4iPT09bm5bbisxXSYmKG5uW25dPSJFTiIpOyJDUyIhPT1ubltuXXx8IkVOIiE9PW5uW24tMV0mJiJBTiIhPT1ubltuLTFdfHxubltuKzFdIT09bm5bbi0xXXx8KG5uW25dPW5uW24tMV0pfWZvcihuPTA7bjxpOysrbilpZigiRU4iPT09bm5bbl0pe2ZvcihsZXQgZT1uLTE7ZT49MCYmIkVUIj09PW5uW2VdOy0tZSlubltlXT0iRU4iO2ZvcihsZXQgZT1uKzE7ZTxpJiYiRVQiPT09bm5bZV07KytlKW5uW2VdPSJFTiJ9Zm9yKG49MDtuPGk7KytuKXtkPW5uW25dOyJXUyIhPT1kJiYiRVMiIT09ZCYmIkVUIiE9PWQmJiJDUyIhPT1kfHwobm5bbl09Ik9OIil9Zj1oO2ZvcihuPTA7bjxpOysrbil7ZD1ubltuXTsiRU4iPT09ZD9ubltuXT0iTCI9PT1mPyJMIjoiRU4iOiJSIiE9PWQmJiJMIiE9PWR8fChmPWQpfWZvcihuPTA7bjxpOysrbilpZigiT04iPT09bm5bbl0pe2NvbnN0IGU9ZmluZFVuZXF1YWwobm4sbisxLCJPTiIpO2xldCB0PWg7bj4wJiYodD1ubltuLTFdKTtsZXQgYT11O2UrMTxpJiYoYT1ubltlKzFdKTsiTCIhPT10JiYodD0iUiIpOyJMIiE9PWEmJihhPSJSIik7dD09PWEmJm5uLmZpbGwodCxuLGUpO249ZS0xfWZvcihuPTA7bjxpOysrbikiT04iPT09bm5bbl0mJihubltuXT1sKTtmb3Iobj0wO248aTsrK24pe2Q9bm5bbl07aXNFdmVuKGNbbl0pPyJSIj09PWQ/Y1tuXSs9MToiQU4iIT09ZCYmIkVOIiE9PWR8fChjW25dKz0yKToiTCIhPT1kJiYiQU4iIT09ZCYmIkVOIiE9PWR8fChjW25dKz0xKX1sZXQgZyxwPS0xLG09OTk7Zm9yKG49MCxzPWMubGVuZ3RoO248czsrK24pe2c9Y1tuXTtwPGcmJihwPWcpO20+ZyYmaXNPZGQoZykmJihtPWcpfWZvcihnPXA7Zz49bTstLWcpe2xldCBlPS0xO2ZvcihuPTAscz1jLmxlbmd0aDtuPHM7KytuKWlmKGNbbl08Zyl7aWYoZT49MCl7cmV2ZXJzZVZhbHVlcyhybixlLG4pO2U9LTF9fWVsc2UgZTwwJiYoZT1uKTtlPj0wJiZyZXZlcnNlVmFsdWVzKHJuLGUsYy5sZW5ndGgpfWZvcihuPTAscz1ybi5sZW5ndGg7bjxzOysrbil7Y29uc3QgZT1ybltuXTsiPCIhPT1lJiYiPiIhPT1lfHwocm5bbl09IiIpfXJldHVybiBjcmVhdGVCaWRpVGV4dChybi5qb2luKCIiKSxyKX1jb25zdCBzbj17c3R5bGU6Im5vcm1hbCIsd2VpZ2h0OiJub3JtYWwifSxvbj17c3R5bGU6Im5vcm1hbCIsd2VpZ2h0OiJib2xkIn0sY249e3N0eWxlOiJpdGFsaWMiLHdlaWdodDoibm9ybWFsIn0sbG49e3N0eWxlOiJpdGFsaWMiLHdlaWdodDoiYm9sZCJ9LGhuPW5ldyBNYXAoW1siVGltZXMtUm9tYW4iLHtsb2NhbDpbIlRpbWVzIE5ldyBSb21hbiIsIlRpbWVzLVJvbWFuIiwiVGltZXMiLCJMaWJlcmF0aW9uIFNlcmlmIiwiTmltYnVzIFJvbWFuIiwiTmltYnVzIFJvbWFuIEwiLCJUaW5vcyIsIlRob3JuZGFsZSIsIlRlWCBHeXJlIFRlcm1lcyIsIkZyZWVTZXJpZiIsIkxpbnV4IExpYmVydGluZSBPIiwiTGliZXJ0aW51cyBTZXJpZiIsIkRlamFWdSBTZXJpZiIsIkJpdHN0cmVhbSBWZXJhIFNlcmlmIiwiVWJ1bnR1Il0sc3R5bGU6c24sdWx0aW1hdGU6InNlcmlmIn1dLFsiVGltZXMtQm9sZCIse2FsaWFzOiJUaW1lcy1Sb21hbiIsc3R5bGU6b24sdWx0aW1hdGU6InNlcmlmIn1dLFsiVGltZXMtSXRhbGljIix7YWxpYXM6IlRpbWVzLVJvbWFuIixzdHlsZTpjbix1bHRpbWF0ZToic2VyaWYifV0sWyJUaW1lcy1Cb2xkSXRhbGljIix7YWxpYXM6IlRpbWVzLVJvbWFuIixzdHlsZTpsbix1bHRpbWF0ZToic2VyaWYifV0sWyJIZWx2ZXRpY2EiLHtsb2NhbDpbIkhlbHZldGljYSIsIkhlbHZldGljYSBOZXVlIiwiQXJpYWwiLCJBcmlhbCBOb3ZhIiwiTGliZXJhdGlvbiBTYW5zIiwiQXJpbW8iLCJOaW1idXMgU2FucyIsIk5pbWJ1cyBTYW5zIEwiLCJBMDMwIiwiVGVYIEd5cmUgSGVyb3MiLCJGcmVlU2FucyIsIkRlamFWdSBTYW5zIiwiQWxiYW55IiwiQml0c3RyZWFtIFZlcmEgU2FucyIsIkFyaWFsIFVuaWNvZGUgTVMiLCJNaWNyb3NvZnQgU2FucyBTZXJpZiIsIkFwcGxlIFN5bWJvbHMiLCJDYW50YXJlbGwiXSxwYXRoOiJMaWJlcmF0aW9uU2Fucy1SZWd1bGFyLnR0ZiIsc3R5bGU6c24sdWx0aW1hdGU6InNhbnMtc2VyaWYifV0sWyJIZWx2ZXRpY2EtQm9sZCIse2FsaWFzOiJIZWx2ZXRpY2EiLHBhdGg6IkxpYmVyYXRpb25TYW5zLUJvbGQudHRmIixzdHlsZTpvbix1bHRpbWF0ZToic2Fucy1zZXJpZiJ9XSxbIkhlbHZldGljYS1PYmxpcXVlIix7YWxpYXM6IkhlbHZldGljYSIscGF0aDoiTGliZXJhdGlvblNhbnMtSXRhbGljLnR0ZiIsc3R5bGU6Y24sdWx0aW1hdGU6InNhbnMtc2VyaWYifV0sWyJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiLHthbGlhczoiSGVsdmV0aWNhIixwYXRoOiJMaWJlcmF0aW9uU2Fucy1Cb2xkSXRhbGljLnR0ZiIsc3R5bGU6bG4sdWx0aW1hdGU6InNhbnMtc2VyaWYifV0sWyJDb3VyaWVyIix7bG9jYWw6WyJDb3VyaWVyIiwiQ291cmllciBOZXciLCJMaWJlcmF0aW9uIE1vbm8iLCJOaW1idXMgTW9ubyIsIk5pbWJ1cyBNb25vIEwiLCJDb3VzaW5lIiwiQ3VtYmVybGFuZCIsIlRlWCBHeXJlIEN1cnNvciIsIkZyZWVNb25vIiwiTGludXggTGliZXJ0aW5lIE1vbm8gTyIsIkxpYmVydGludXMgTW9ubyJdLHN0eWxlOnNuLHVsdGltYXRlOiJtb25vc3BhY2UifV0sWyJDb3VyaWVyLUJvbGQiLHthbGlhczoiQ291cmllciIsc3R5bGU6b24sdWx0aW1hdGU6Im1vbm9zcGFjZSJ9XSxbIkNvdXJpZXItT2JsaXF1ZSIse2FsaWFzOiJDb3VyaWVyIixzdHlsZTpjbix1bHRpbWF0ZToibW9ub3NwYWNlIn1dLFsiQ291cmllci1Cb2xkT2JsaXF1ZSIse2FsaWFzOiJDb3VyaWVyIixzdHlsZTpsbix1bHRpbWF0ZToibW9ub3NwYWNlIn1dLFsiQXJpYWxCbGFjayIse2xvY2FsOlsiQXJpYWwgQmxhY2siXSxzdHlsZTp7c3R5bGU6Im5vcm1hbCIsd2VpZ2h0OiI5MDAifSxmYWxsYmFjazoiSGVsdmV0aWNhLUJvbGQifV0sWyJBcmlhbEJsYWNrLUJvbGQiLHthbGlhczoiQXJpYWxCbGFjayJ9XSxbIkFyaWFsQmxhY2stSXRhbGljIix7YWxpYXM6IkFyaWFsQmxhY2siLHN0eWxlOntzdHlsZToiaXRhbGljIix3ZWlnaHQ6IjkwMCJ9LGZhbGxiYWNrOiJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUifV0sWyJBcmlhbEJsYWNrLUJvbGRJdGFsaWMiLHthbGlhczoiQXJpYWxCbGFjay1JdGFsaWMifV0sWyJBcmlhbE5hcnJvdyIse2xvY2FsOlsiQXJpYWwgTmFycm93IiwiTGliZXJhdGlvbiBTYW5zIE5hcnJvdyIsIkhlbHZldGljYSBDb25kZW5zZWQiLCJOaW1idXMgU2FucyBOYXJyb3ciLCJUZVggR3lyZSBIZXJvcyBDbiJdLHN0eWxlOnNuLGZhbGxiYWNrOiJIZWx2ZXRpY2EifV0sWyJBcmlhbE5hcnJvdy1Cb2xkIix7YWxpYXM6IkFyaWFsTmFycm93IixzdHlsZTpvbixmYWxsYmFjazoiSGVsdmV0aWNhLUJvbGQifV0sWyJBcmlhbE5hcnJvdy1JdGFsaWMiLHthbGlhczoiQXJpYWxOYXJyb3ciLHN0eWxlOmNuLGZhbGxiYWNrOiJIZWx2ZXRpY2EtT2JsaXF1ZSJ9XSxbIkFyaWFsTmFycm93LUJvbGRJdGFsaWMiLHthbGlhczoiQXJpYWxOYXJyb3ciLHN0eWxlOmxuLGZhbGxiYWNrOiJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUifV0sWyJDYWxpYnJpIix7bG9jYWw6WyJDYWxpYnJpIiwiQ2FybGl0byJdLHN0eWxlOnNuLGZhbGxiYWNrOiJIZWx2ZXRpY2EifV0sWyJDYWxpYnJpLUJvbGQiLHthbGlhczoiQ2FsaWJyaSIsc3R5bGU6b24sZmFsbGJhY2s6IkhlbHZldGljYS1Cb2xkIn1dLFsiQ2FsaWJyaS1JdGFsaWMiLHthbGlhczoiQ2FsaWJyaSIsc3R5bGU6Y24sZmFsbGJhY2s6IkhlbHZldGljYS1PYmxpcXVlIn1dLFsiQ2FsaWJyaS1Cb2xkSXRhbGljIix7YWxpYXM6IkNhbGlicmkiLHN0eWxlOmxuLGZhbGxiYWNrOiJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUifV0sWyJXaW5nZGluZ3MiLHtsb2NhbDpbIldpbmdkaW5ncyIsIlVSVyBEaW5nYmF0cyJdLHN0eWxlOnNufV0sWyJXaW5nZGluZ3MtUmVndWxhciIse2FsaWFzOiJXaW5nZGluZ3MifV0sWyJXaW5nZGluZ3MtQm9sZCIse2FsaWFzOiJXaW5nZGluZ3MifV1dKSx1bj1uZXcgTWFwKFtbIkFyaWFsLUJsYWNrIiwiQXJpYWxCbGFjayJdXSk7ZnVuY3Rpb24gZ2V0RmFtaWx5TmFtZShlKXtjb25zdCB0PW5ldyBTZXQoWyJ0aGluIiwiZXh0cmFsaWdodCIsInVsdHJhbGlnaHQiLCJkZW1pbGlnaHQiLCJzZW1pbGlnaHQiLCJsaWdodCIsImJvb2siLCJyZWd1bGFyIiwibm9ybWFsIiwibWVkaXVtIiwiZGVtaWJvbGQiLCJzZW1pYm9sZCIsImJvbGQiLCJleHRyYWJvbGQiLCJ1bHRyYWJvbGQiLCJibGFjayIsImhlYXZ5IiwiZXh0cmFibGFjayIsInVsdHJhYmxhY2siLCJyb21hbiIsIml0YWxpYyIsIm9ibGlxdWUiLCJ1bHRyYWNvbmRlbnNlZCIsImV4dHJhY29uZGVuc2VkIiwiY29uZGVuc2VkIiwic2VtaWNvbmRlbnNlZCIsIm5vcm1hbCIsInNlbWlleHBhbmRlZCIsImV4cGFuZGVkIiwiZXh0cmFleHBhbmRlZCIsInVsdHJhZXhwYW5kZWQiLCJib2xkaXRhbGljIl0pO3JldHVybiBlLnNwbGl0KC9bLSAsK10rL2cpLmZpbHRlcigoZT0+IXQuaGFzKGUudG9Mb3dlckNhc2UoKSkpKS5qb2luKCIgIil9ZnVuY3Rpb24gZ2VuZXJhdGVGb250KHthbGlhczplLGxvY2FsOnQscGF0aDphLGZhbGxiYWNrOnIsc3R5bGU6aSx1bHRpbWF0ZTpufSxzLG8sYz0hMCxsPSEwLGg9IiIpe2NvbnN0IHU9e3N0eWxlOm51bGwsdWx0aW1hdGU6bnVsbH07aWYodCl7Y29uc3QgZT1oP2AgJHtofWA6IiI7Zm9yKGNvbnN0IGEgb2YgdClzLnB1c2goYGxvY2FsKCR7YX0ke2V9KWApfWlmKGUpe2NvbnN0IHQ9aG4uZ2V0KGUpLG49aHx8ZnVuY3Rpb24gZ2V0U3R5bGVUb0FwcGVuZChlKXtzd2l0Y2goZSl7Y2FzZSBvbjpyZXR1cm4iQm9sZCI7Y2FzZSBjbjpyZXR1cm4iSXRhbGljIjtjYXNlIGxuOnJldHVybiJCb2xkIEl0YWxpYyI7ZGVmYXVsdDppZigiYm9sZCI9PT1lPy53ZWlnaHQpcmV0dXJuIkJvbGQiO2lmKCJpdGFsaWMiPT09ZT8uc3R5bGUpcmV0dXJuIkl0YWxpYyJ9cmV0dXJuIiJ9KGkpO09iamVjdC5hc3NpZ24odSxnZW5lcmF0ZUZvbnQodCxzLG8sYyYmIXIsbCYmIWEsbikpfWkmJih1LnN0eWxlPWkpO24mJih1LnVsdGltYXRlPW4pO2lmKGMmJnIpe2NvbnN0IGU9aG4uZ2V0KHIpLHt1bHRpbWF0ZTp0fT1nZW5lcmF0ZUZvbnQoZSxzLG8sYyxsJiYhYSxoKTt1LnVsdGltYXRlfHw9dH1sJiZhJiZvJiZzLnB1c2goYHVybCgke299JHthfSlgKTtyZXR1cm4gdX1mdW5jdGlvbiBnZXRGb250U3Vic3RpdHV0aW9uKGUsdCxhLHIsaSxuKXtpZihyLnN0YXJ0c1dpdGgoIkludmFsaWRQREZqc0ZvbnRfIikpcmV0dXJuIG51bGw7IlRydWVUeXBlIiE9PW4mJiJUeXBlMSIhPT1ufHwhL15bQS1aXXs2fVwrLy50ZXN0KHIpfHwocj1yLnNsaWNlKDcpKTtjb25zdCBzPXI9bm9ybWFsaXplRm9udE5hbWUocik7bGV0IG89ZS5nZXQocyk7aWYobylyZXR1cm4gbztsZXQgYz1obi5nZXQocik7aWYoIWMpZm9yKGNvbnN0W2UsdF1vZiB1bilpZihyLnN0YXJ0c1dpdGgoZSkpe3I9YCR7dH0ke3Iuc3Vic3RyaW5nKGUubGVuZ3RoKX1gO2M9aG4uZ2V0KHIpO2JyZWFrfWxldCBsPSExO2lmKCFjKXtjPWhuLmdldChpKTtsPSEwfWNvbnN0IGg9YCR7dC5nZXREb2NJZCgpfV9zJHt0LmNyZWF0ZUZvbnRJZCgpfWA7aWYoIWMpe2lmKCF2YWxpZGF0ZUZvbnROYW1lKHIpKXt3YXJuKGBDYW5ub3Qgc3Vic3RpdHV0ZSB0aGUgZm9udCBiZWNhdXNlIG9mIGl0cyBuYW1lOiAke3J9YCk7ZS5zZXQocyxudWxsKTtyZXR1cm4gbnVsbH1jb25zdCB0PS9ib2xkL2dpLnRlc3QociksYT0vb2JsaXF1ZXxpdGFsaWMvZ2kudGVzdChyKSxpPXQmJmEmJmxufHx0JiZvbnx8YSYmY258fHNuO289e2NzczpgIiR7Z2V0RmFtaWx5TmFtZShyKX0iLCR7aH1gLGd1ZXNzRmFsbGJhY2s6ITAsbG9hZGVkTmFtZTpoLGJhc2VGb250TmFtZTpyLHNyYzpgbG9jYWwoJHtyfSlgLHN0eWxlOml9O2Uuc2V0KHMsbyk7cmV0dXJuIG99Y29uc3QgdT1bXTtsJiZ2YWxpZGF0ZUZvbnROYW1lKHIpJiZ1LnB1c2goYGxvY2FsKCR7cn0pYCk7Y29uc3R7c3R5bGU6ZCx1bHRpbWF0ZTpmfT1nZW5lcmF0ZUZvbnQoYyx1LGEpLGc9bnVsbD09PWYscD1nPyIiOmAsJHtmfWA7bz17Y3NzOmAiJHtnZXRGYW1pbHlOYW1lKHIpfSIsJHtofSR7cH1gLGd1ZXNzRmFsbGJhY2s6Zyxsb2FkZWROYW1lOmgsYmFzZUZvbnROYW1lOnIsc3JjOnUuam9pbigiLCIpLHN0eWxlOmR9O2Uuc2V0KHMsbyk7cmV0dXJuIG99Y29uc3QgZG49MzI4NTM3NzUyMCxmbj00Mjk0OTAxNzYwLGduPTY1NTM1O2NsYXNzIE11cm11ckhhc2gzXzY0e2NvbnN0cnVjdG9yKGUpe3RoaXMuaDE9ZT80Mjk0OTY3Mjk1JmU6ZG47dGhpcy5oMj1lPzQyOTQ5NjcyOTUmZTpkbn11cGRhdGUoZSl7bGV0IHQsYTtpZigic3RyaW5nIj09dHlwZW9mIGUpe3Q9bmV3IFVpbnQ4QXJyYXkoMiplLmxlbmd0aCk7YT0wO2ZvcihsZXQgcj0wLGk9ZS5sZW5ndGg7cjxpO3IrKyl7Y29uc3QgaT1lLmNoYXJDb2RlQXQocik7aWYoaTw9MjU1KXRbYSsrXT1pO2Vsc2V7dFthKytdPWk+Pj44O3RbYSsrXT0yNTUmaX19fWVsc2V7aWYoIUFycmF5QnVmZmVyLmlzVmlldyhlKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgZGF0YSBmb3JtYXQsIG11c3QgYmUgYSBzdHJpbmcgb3IgVHlwZWRBcnJheS4iKTt0PWUuc2xpY2UoKTthPXQuYnl0ZUxlbmd0aH1jb25zdCByPWE+PjIsaT1hLTQqcixuPW5ldyBVaW50MzJBcnJheSh0LmJ1ZmZlciwwLHIpO2xldCBzPTAsbz0wLGM9dGhpcy5oMSxsPXRoaXMuaDI7Y29uc3QgaD0zNDMyOTE4MzUzLHU9NDYxODQ1OTA3LGQ9MTE2MDEsZj0xMzcxNTtmb3IobGV0IGU9MDtlPHI7ZSsrKWlmKDEmZSl7cz1uW2VdO3M9cypoJmZufHMqZCZnbjtzPXM8PDE1fHM+Pj4xNztzPXMqdSZmbnxzKmYmZ247Y149cztjPWM8PDEzfGM+Pj4xOTtjPTUqYyszODY0MjkyMTk2fWVsc2V7bz1uW2VdO289bypoJmZufG8qZCZnbjtvPW88PDE1fG8+Pj4xNztvPW8qdSZmbnxvKmYmZ247bF49bztsPWw8PDEzfGw+Pj4xOTtsPTUqbCszODY0MjkyMTk2fXM9MDtzd2l0Y2goaSl7Y2FzZSAzOnNePXRbNCpyKzJdPDwxNjtjYXNlIDI6c149dFs0KnIrMV08PDg7Y2FzZSAxOnNePXRbNCpyXTtzPXMqaCZmbnxzKmQmZ247cz1zPDwxNXxzPj4+MTc7cz1zKnUmZm58cypmJmduOzEmcj9jXj1zOmxePXN9dGhpcy5oMT1jO3RoaXMuaDI9bH1oZXhkaWdlc3QoKXtsZXQgZT10aGlzLmgxLHQ9dGhpcy5oMjtlXj10Pj4+MTtlPTM5ODE4MDY3OTcqZSZmbnwzNjA0NSplJmduO3Q9NDI4MzU0MzUxMSp0JmZufCgyOTUwMTYzNzk3Kih0PDwxNnxlPj4+MTYpJmZuKT4+PjE2O2VePXQ+Pj4xO2U9NDQ0OTg0NDAzKmUmZm58NjA0OTkqZSZnbjt0PTMzMDE4ODIzNjYqdCZmbnwoMzEyMDQzNzg5MyoodDw8MTZ8ZT4+PjE2KSZmbik+Pj4xNjtlXj10Pj4+MTtyZXR1cm4oZT4+PjApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCIwIikrKHQ+Pj4wKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwiMCIpfX1mdW5jdGlvbiByZXNpemVJbWFnZU1hc2soZSx0LGEscixpLG4pe2NvbnN0IHM9aSpuO2xldCBvO289dDw9OD9uZXcgVWludDhBcnJheShzKTp0PD0xNj9uZXcgVWludDE2QXJyYXkocyk6bmV3IFVpbnQzMkFycmF5KHMpO2NvbnN0IGM9YS9pLGw9ci9uO2xldCBoLHUsZCxmLGc9MDtjb25zdCBwPW5ldyBVaW50MTZBcnJheShpKSxtPWE7Zm9yKGg9MDtoPGk7aCsrKXBbaF09TWF0aC5mbG9vcihoKmMpO2ZvcihoPTA7aDxuO2grKyl7ZD1NYXRoLmZsb29yKGgqbCkqbTtmb3IodT0wO3U8aTt1Kyspe2Y9ZCtwW3VdO29bZysrXT1lW2ZdfX1yZXR1cm4gb31jbGFzcyBQREZJbWFnZXtjb25zdHJ1Y3Rvcih7eHJlZjplLHJlczp0LGltYWdlOmEsaXNJbmxpbmU6cj0hMSxzbWFzazppPW51bGwsbWFzazpuPW51bGwsaXNNYXNrOnM9ITEscGRmRnVuY3Rpb25GYWN0b3J5Om8sZ2xvYmFsQ29sb3JTcGFjZUNhY2hlOmMsbG9jYWxDb2xvclNwYWNlQ2FjaGU6bH0pe3RoaXMuaW1hZ2U9YTtjb25zdCBoPWEuZGljdCx1PWguZ2V0KCJGIiwiRmlsdGVyIik7bGV0IGQ7aWYodSBpbnN0YW5jZW9mIE5hbWUpZD11Lm5hbWU7ZWxzZSBpZihBcnJheS5pc0FycmF5KHUpKXtjb25zdCB0PWUuZmV0Y2hJZlJlZih1WzBdKTt0IGluc3RhbmNlb2YgTmFtZSYmKGQ9dC5uYW1lKX1zd2l0Y2goZCl7Y2FzZSJKUFhEZWNvZGUiOih7d2lkdGg6YS53aWR0aCxoZWlnaHQ6YS5oZWlnaHQsY29tcG9uZW50c0NvdW50OmEubnVtQ29tcHMsYml0c1BlckNvbXBvbmVudDphLmJpdHNQZXJDb21wb25lbnR9PUpweEltYWdlLnBhcnNlSW1hZ2VQcm9wZXJ0aWVzKGEuc3RyZWFtKSk7YS5zdHJlYW0ucmVzZXQoKTtjb25zdCBlPUltYWdlUmVzaXplci5nZXRSZWR1Y2VQb3dlckZvckpQWChhLndpZHRoLGEuaGVpZ2h0LGEubnVtQ29tcHMpO3RoaXMuanB4RGVjb2Rlck9wdGlvbnM9e251bUNvbXBvbmVudHM6MCxpc0luZGV4ZWRDb2xvcm1hcDohMSxzbWFza0luRGF0YTpoLmhhcygiU01hc2tJbkRhdGEiKSxyZWR1Y2VQb3dlcjplfTtpZihlKXtjb25zdCB0PTIqKmU7YS53aWR0aD1NYXRoLmNlaWwoYS53aWR0aC90KTthLmhlaWdodD1NYXRoLmNlaWwoYS5oZWlnaHQvdCl9YnJlYWs7Y2FzZSJKQklHMkRlY29kZSI6YS5iaXRzUGVyQ29tcG9uZW50PTE7YS5udW1Db21wcz0xfWxldCBmPWguZ2V0KCJXIiwiV2lkdGgiKSxnPWguZ2V0KCJIIiwiSGVpZ2h0Iik7aWYoTnVtYmVyLmlzSW50ZWdlcihhLndpZHRoKSYmYS53aWR0aD4wJiZOdW1iZXIuaXNJbnRlZ2VyKGEuaGVpZ2h0KSYmYS5oZWlnaHQ+MCYmKGEud2lkdGghPT1mfHxhLmhlaWdodCE9PWcpKXt3YXJuKCJQREZJbWFnZSAtIHVzaW5nIHRoZSBXaWR0aC9IZWlnaHQgb2YgdGhlIGltYWdlIGRhdGEsIHJhdGhlciB0aGFuIHRoZSBpbWFnZSBkaWN0aW9uYXJ5LiIpO2Y9YS53aWR0aDtnPWEuaGVpZ2h0fWVsc2V7Y29uc3QgZT0ibnVtYmVyIj09dHlwZW9mIGYmJmY+MCx0PSJudW1iZXIiPT10eXBlb2YgZyYmZz4wO2lmKCFlfHwhdCl7aWYoIWEuZmFsbGJhY2tEaW1zKXRocm93IG5ldyBGb3JtYXRFcnJvcihgSW52YWxpZCBpbWFnZSB3aWR0aDogJHtmfSBvciBoZWlnaHQ6ICR7Z31gKTt3YXJuKCJQREZJbWFnZSAtIHVzaW5nIHRoZSBXaWR0aC9IZWlnaHQgb2YgdGhlIHBhcmVudCBpbWFnZSwgZm9yIFNNYXNrL01hc2sgZGF0YS4iKTtlfHwoZj1hLmZhbGxiYWNrRGltcy53aWR0aCk7dHx8KGc9YS5mYWxsYmFja0RpbXMuaGVpZ2h0KX19dGhpcy53aWR0aD1mO3RoaXMuaGVpZ2h0PWc7dGhpcy5pbnRlcnBvbGF0ZT1oLmdldCgiSSIsIkludGVycG9sYXRlIik7dGhpcy5pbWFnZU1hc2s9aC5nZXQoIklNIiwiSW1hZ2VNYXNrIil8fCExO3RoaXMubWF0dGU9aC5nZXQoIk1hdHRlIil8fCExO2xldCBwPWEuYml0c1BlckNvbXBvbmVudDtpZighcCl7cD1oLmdldCgiQlBDIiwiQml0c1BlckNvbXBvbmVudCIpO2lmKCFwKXtpZighdGhpcy5pbWFnZU1hc2spdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBCaXRzIHBlciBjb21wb25lbnQgbWlzc2luZyBpbiBpbWFnZTogJHt0aGlzLmltYWdlTWFza31gKTtwPTF9fXRoaXMuYnBjPXA7aWYoIXRoaXMuaW1hZ2VNYXNrKXtsZXQgaT1oLmdldFJhdygiQ1MiKXx8aC5nZXRSYXcoIkNvbG9yU3BhY2UiKTtjb25zdCBuPSEhaTtpZihuKXRoaXMuanB4RGVjb2Rlck9wdGlvbnM/LnNtYXNrSW5EYXRhJiYoaT1OYW1lLmdldCgiRGV2aWNlUkdCQSIpKTtlbHNlIGlmKHRoaXMuanB4RGVjb2Rlck9wdGlvbnMpaT1OYW1lLmdldCgiRGV2aWNlUkdCQSIpO2Vsc2Ugc3dpdGNoKGEubnVtQ29tcHMpe2Nhc2UgMTppPU5hbWUuZ2V0KCJEZXZpY2VHcmF5Iik7YnJlYWs7Y2FzZSAzOmk9TmFtZS5nZXQoIkRldmljZVJHQiIpO2JyZWFrO2Nhc2UgNDppPU5hbWUuZ2V0KCJEZXZpY2VDTVlLIik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEltYWdlcyB3aXRoICR7YS5udW1Db21wc30gY29sb3IgY29tcG9uZW50cyBub3Qgc3VwcG9ydGVkLmApfXRoaXMuY29sb3JTcGFjZT1Db2xvclNwYWNlVXRpbHMucGFyc2Uoe2NzOmkseHJlZjplLHJlc291cmNlczpyP3Q6bnVsbCxwZGZGdW5jdGlvbkZhY3Rvcnk6byxnbG9iYWxDb2xvclNwYWNlQ2FjaGU6Yyxsb2NhbENvbG9yU3BhY2VDYWNoZTpsfSk7dGhpcy5udW1Db21wcz10aGlzLmNvbG9yU3BhY2UubnVtQ29tcHM7aWYodGhpcy5qcHhEZWNvZGVyT3B0aW9ucyl7dGhpcy5qcHhEZWNvZGVyT3B0aW9ucy5udW1Db21wb25lbnRzPW4/dGhpcy5udW1Db21wczowO3RoaXMuanB4RGVjb2Rlck9wdGlvbnMuaXNJbmRleGVkQ29sb3JtYXA9IkluZGV4ZWQiPT09dGhpcy5jb2xvclNwYWNlLm5hbWV9fXRoaXMuZGVjb2RlPWguZ2V0QXJyYXkoIkQiLCJEZWNvZGUiKTt0aGlzLm5lZWRzRGVjb2RlPSExO2lmKHRoaXMuZGVjb2RlJiYodGhpcy5jb2xvclNwYWNlJiYhdGhpcy5jb2xvclNwYWNlLmlzRGVmYXVsdERlY29kZSh0aGlzLmRlY29kZSxwKXx8cyYmIUNvbG9yU3BhY2UuaXNEZWZhdWx0RGVjb2RlKHRoaXMuZGVjb2RlLDEpKSl7dGhpcy5uZWVkc0RlY29kZT0hMDtjb25zdCBlPSgxPDxwKS0xO3RoaXMuZGVjb2RlQ29lZmZpY2llbnRzPVtdO3RoaXMuZGVjb2RlQWRkZW5kcz1bXTtjb25zdCB0PSJJbmRleGVkIj09PXRoaXMuY29sb3JTcGFjZT8ubmFtZTtmb3IobGV0IGE9MCxyPTA7YTx0aGlzLmRlY29kZS5sZW5ndGg7YSs9MiwrK3Ipe2NvbnN0IGk9dGhpcy5kZWNvZGVbYV0sbj10aGlzLmRlY29kZVthKzFdO3RoaXMuZGVjb2RlQ29lZmZpY2llbnRzW3JdPXQ/KG4taSkvZTpuLWk7dGhpcy5kZWNvZGVBZGRlbmRzW3JdPXQ/aTplKml9fWlmKGkpe2kuZmFsbGJhY2tEaW1zPz89e3dpZHRoOmYsaGVpZ2h0Omd9O3RoaXMuc21hc2s9bmV3IFBERkltYWdlKHt4cmVmOmUscmVzOnQsaW1hZ2U6aSxpc0lubGluZTpyLHBkZkZ1bmN0aW9uRmFjdG9yeTpvLGdsb2JhbENvbG9yU3BhY2VDYWNoZTpjLGxvY2FsQ29sb3JTcGFjZUNhY2hlOmx9KX1lbHNlIGlmKG4paWYobiBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pe2lmKG4uZGljdC5nZXQoIklNIiwiSW1hZ2VNYXNrIikpe24uZmFsbGJhY2tEaW1zPz89e3dpZHRoOmYsaGVpZ2h0Omd9O3RoaXMubWFzaz1uZXcgUERGSW1hZ2Uoe3hyZWY6ZSxyZXM6dCxpbWFnZTpuLGlzSW5saW5lOnIsaXNNYXNrOiEwLHBkZkZ1bmN0aW9uRmFjdG9yeTpvLGdsb2JhbENvbG9yU3BhY2VDYWNoZTpjLGxvY2FsQ29sb3JTcGFjZUNhY2hlOmx9KX1lbHNlIHdhcm4oIklnbm9yaW5nIC9NYXNrIGluIGltYWdlIHdpdGhvdXQgL0ltYWdlTWFzay4iKX1lbHNlIHRoaXMubWFzaz1ufXN0YXRpYyBhc3luYyBidWlsZEltYWdlKHt4cmVmOmUscmVzOnQsaW1hZ2U6YSxpc0lubGluZTpyPSExLHBkZkZ1bmN0aW9uRmFjdG9yeTppLGdsb2JhbENvbG9yU3BhY2VDYWNoZTpuLGxvY2FsQ29sb3JTcGFjZUNhY2hlOnN9KXtjb25zdCBvPWE7bGV0IGM9bnVsbCxsPW51bGw7Y29uc3QgaD1hLmRpY3QuZ2V0KCJTTWFzayIpLHU9YS5kaWN0LmdldCgiTWFzayIpO2g/aCBpbnN0YW5jZW9mIEJhc2VTdHJlYW0/Yz1oOndhcm4oIlVuc3VwcG9ydGVkIC9TTWFzayBmb3JtYXQuIik6dSYmKHUgaW5zdGFuY2VvZiBCYXNlU3RyZWFtfHxBcnJheS5pc0FycmF5KHUpP2w9dTp3YXJuKCJVbnN1cHBvcnRlZCAvTWFzayBmb3JtYXQuIikpO3JldHVybiBuZXcgUERGSW1hZ2Uoe3hyZWY6ZSxyZXM6dCxpbWFnZTpvLGlzSW5saW5lOnIsc21hc2s6YyxtYXNrOmwscGRmRnVuY3Rpb25GYWN0b3J5OmksZ2xvYmFsQ29sb3JTcGFjZUNhY2hlOm4sbG9jYWxDb2xvclNwYWNlQ2FjaGU6c30pfXN0YXRpYyBhc3luYyBjcmVhdGVNYXNrKHtpbWFnZTplLGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkOnQ9ITF9KXtjb25zdHtkaWN0OmF9PWUscj1hLmdldCgiVyIsIldpZHRoIiksaT1hLmdldCgiSCIsIkhlaWdodCIpLG49YS5nZXQoIkkiLCJJbnRlcnBvbGF0ZSIpLHM9YS5nZXRBcnJheSgiRCIsIkRlY29kZSIpLG89cz8uWzBdPjAsYz0ocis3Pj4zKSppLGw9ZS5nZXRCeXRlcyhjKSxoPTE9PT1yJiYxPT09aSYmbz09PSgwPT09bC5sZW5ndGh8fCEhKDEyOCZsWzBdKSk7aWYoaClyZXR1cm57aXNTaW5nbGVPcGFxdWVQaXhlbDpofTtpZih0KXtpZihJbWFnZVJlc2l6ZXIubmVlZHNUb0JlUmVzaXplZChyLGkpKXtjb25zdCBlPW5ldyBVaW50OENsYW1wZWRBcnJheShyKmkqNCk7Y29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe3NyYzpsLGRlc3Q6ZSx3aWR0aDpyLGhlaWdodDppLG5vbkJsYWNrQ29sb3I6MCxpbnZlcnNlRGVjb2RlOm99KTtyZXR1cm4gSW1hZ2VSZXNpemVyLmNyZWF0ZUltYWdlKHtraW5kOnYsZGF0YTplLHdpZHRoOnIsaGVpZ2h0OmksaW50ZXJwb2xhdGU6bn0pfWNvbnN0IGU9bmV3IE9mZnNjcmVlbkNhbnZhcyhyLGkpLHQ9ZS5nZXRDb250ZXh0KCIyZCIpLGE9dC5jcmVhdGVJbWFnZURhdGEocixpKTtjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSh7c3JjOmwsZGVzdDphLmRhdGEsd2lkdGg6cixoZWlnaHQ6aSxub25CbGFja0NvbG9yOjAsaW52ZXJzZURlY29kZTpvfSk7dC5wdXRJbWFnZURhdGEoYSwwLDApO3JldHVybntkYXRhOm51bGwsd2lkdGg6cixoZWlnaHQ6aSxpbnRlcnBvbGF0ZTpuLGJpdG1hcDplLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpfX1jb25zdCB1PWwuYnl0ZUxlbmd0aDtsZXQgZDtpZihlIGluc3RhbmNlb2YgRGVjb2RlU3RyZWFtJiYoIW98fGM9PT11KSlkPWw7ZWxzZSBpZihvKXtkPW5ldyBVaW50OEFycmF5KGMpO2Quc2V0KGwpO2QuZmlsbCgyNTUsdSl9ZWxzZSBkPW5ldyBVaW50OEFycmF5KGwpO2lmKG8pZm9yKGxldCBlPTA7ZTx1O2UrKylkW2VdXj0yNTU7cmV0dXJue2RhdGE6ZCx3aWR0aDpyLGhlaWdodDppLGludGVycG9sYXRlOm59fWdldCBkcmF3V2lkdGgoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy53aWR0aCx0aGlzLnNtYXNrPy53aWR0aHx8MCx0aGlzLm1hc2s/LndpZHRofHwwKX1nZXQgZHJhd0hlaWdodCgpe3JldHVybiBNYXRoLm1heCh0aGlzLmhlaWdodCx0aGlzLnNtYXNrPy5oZWlnaHR8fDAsdGhpcy5tYXNrPy5oZWlnaHR8fDApfWRlY29kZUJ1ZmZlcihlKXtjb25zdCB0PXRoaXMuYnBjLGE9dGhpcy5udW1Db21wcyxyPXRoaXMuZGVjb2RlQWRkZW5kcyxpPXRoaXMuZGVjb2RlQ29lZmZpY2llbnRzLG49KDE8PHQpLTE7bGV0IHMsbztpZigxPT09dCl7Zm9yKHM9MCxvPWUubGVuZ3RoO3M8bztzKyspZVtzXT0rIWVbc107cmV0dXJufWxldCBjPTA7Zm9yKHM9MCxvPXRoaXMud2lkdGgqdGhpcy5oZWlnaHQ7czxvO3MrKylmb3IobGV0IHQ9MDt0PGE7dCsrKXtlW2NdPU1hdGhDbGFtcChyW3RdK2VbY10qaVt0XSwwLG4pO2MrK319Z2V0Q29tcG9uZW50cyhlKXtjb25zdCB0PXRoaXMuYnBjO2lmKDg9PT10KXJldHVybiBlO2NvbnN0IGE9dGhpcy53aWR0aCxyPXRoaXMuaGVpZ2h0LGk9dGhpcy5udW1Db21wcyxuPWEqcippO2xldCBzLG89MDtzPXQ8PTg/bmV3IFVpbnQ4QXJyYXkobik6dDw9MTY/bmV3IFVpbnQxNkFycmF5KG4pOm5ldyBVaW50MzJBcnJheShuKTtjb25zdCBjPWEqaSxsPSgxPDx0KS0xO2xldCBoLHUsZD0wO2lmKDE9PT10KXtsZXQgdCxhLGk7Zm9yKGxldCBuPTA7bjxyO24rKyl7YT1kKygtOCZjKTtpPWQrYztmb3IoO2Q8YTspe3U9ZVtvKytdO3NbZF09dT4+NyYxO3NbZCsxXT11Pj42JjE7c1tkKzJdPXU+PjUmMTtzW2QrM109dT4+NCYxO3NbZCs0XT11Pj4zJjE7c1tkKzVdPXU+PjImMTtzW2QrNl09dT4+MSYxO3NbZCs3XT0xJnU7ZCs9OH1pZihkPGkpe3U9ZVtvKytdO3Q9MTI4O2Zvcig7ZDxpOyl7c1tkKytdPSshISh1JnQpO3Q+Pj0xfX19fWVsc2V7bGV0IGE9MDt1PTA7Zm9yKGQ9MCxoPW47ZDxoOysrZCl7aWYoZCVjPT0wKXt1PTA7YT0wfWZvcig7YTx0Oyl7dT11PDw4fGVbbysrXTthKz04fWNvbnN0IHI9YS10O2xldCBpPXU+PnI7aTwwP2k9MDppPmwmJihpPWwpO3NbZF09aTt1Jj0oMTw8ciktMTthPXJ9fXJldHVybiBzfWFzeW5jIGZpbGxPcGFjaXR5KGUsdCxhLHIsaSl7Y29uc3Qgbj10aGlzLnNtYXNrLHM9dGhpcy5tYXNrO2xldCBvLGMsbCxoLHUsZDtpZihuKXtjPW4ud2lkdGg7bD1uLmhlaWdodDtvPW5ldyBVaW50OENsYW1wZWRBcnJheShjKmwpO2F3YWl0IG4uZmlsbEdyYXlCdWZmZXIobyk7Yz09PXQmJmw9PT1hfHwobz1yZXNpemVJbWFnZU1hc2sobyxuLmJwYyxjLGwsdCxhKSl9ZWxzZSBpZihzKWlmKHMgaW5zdGFuY2VvZiBQREZJbWFnZSl7Yz1zLndpZHRoO2w9cy5oZWlnaHQ7bz1uZXcgVWludDhDbGFtcGVkQXJyYXkoYypsKTtzLm51bUNvbXBzPTE7YXdhaXQgcy5maWxsR3JheUJ1ZmZlcihvKTtmb3IoaD0wLHU9YypsO2g8dTsrK2gpb1toXT0yNTUtb1toXTtjPT09dCYmbD09PWF8fChvPXJlc2l6ZUltYWdlTWFzayhvLHMuYnBjLGMsbCx0LGEpKX1lbHNle2lmKCFBcnJheS5pc0FycmF5KHMpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiVW5rbm93biBtYXNrIGZvcm1hdC4iKTt7bz1uZXcgVWludDhDbGFtcGVkQXJyYXkodCphKTtjb25zdCBlPXRoaXMubnVtQ29tcHM7Zm9yKGg9MCx1PXQqYTtoPHU7KytoKXtsZXQgdD0wO2NvbnN0IGE9aCplO2ZvcihkPTA7ZDxlOysrZCl7Y29uc3QgZT1pW2ErZF0scj0yKmQ7aWYoZTxzW3JdfHxlPnNbcisxXSl7dD0yNTU7YnJlYWt9fW9baF09dH19fWlmKG8pZm9yKGg9MCxkPTMsdT10KnI7aDx1OysraCxkKz00KWVbZF09b1toXTtlbHNlIGZvcihoPTAsZD0zLHU9dCpyO2g8dTsrK2gsZCs9NCllW2RdPTI1NX11bmRvUHJlYmxlbmQoZSx0LGEpe2NvbnN0IHI9dGhpcy5zbWFzaz8ubWF0dGU7aWYoIXIpcmV0dXJuO2NvbnN0IGk9dGhpcy5jb2xvclNwYWNlLmdldFJnYihyLDApLG49aVswXSxzPWlbMV0sbz1pWzJdLGM9dCphKjQ7Zm9yKGxldCB0PTA7dDxjO3QrPTQpe2NvbnN0IGE9ZVt0KzNdO2lmKDA9PT1hKXtlW3RdPTI1NTtlW3QrMV09MjU1O2VbdCsyXT0yNTU7Y29udGludWV9Y29uc3Qgcj0yNTUvYTtlW3RdPShlW3RdLW4pKnIrbjtlW3QrMV09KGVbdCsxXS1zKSpyK3M7ZVt0KzJdPShlW3QrMl0tbykqcitvfX1hc3luYyBjcmVhdGVJbWFnZURhdGEoZT0hMSx0PSExKXtjb25zdCBhPXRoaXMuZHJhd1dpZHRoLHI9dGhpcy5kcmF3SGVpZ2h0LGk9e3dpZHRoOmEsaGVpZ2h0OnIsaW50ZXJwb2xhdGU6dGhpcy5pbnRlcnBvbGF0ZSxraW5kOjAsZGF0YTpudWxsfSxuPXRoaXMubnVtQ29tcHMscz10aGlzLndpZHRoLG89dGhpcy5oZWlnaHQsYz10aGlzLmJwYyxsPXMqbipjKzc+PjMsaD10JiZJbWFnZVJlc2l6ZXIubmVlZHNUb0JlUmVzaXplZChhLHIpO2lmKCF0aGlzLnNtYXNrJiYhdGhpcy5tYXNrJiYiRGV2aWNlUkdCQSI9PT10aGlzLmNvbG9yU3BhY2UubmFtZSl7aS5raW5kPXY7Y29uc3QgZT1pLmRhdGE9YXdhaXQgdGhpcy5nZXRJbWFnZUJ5dGVzKG8qcyo0LHt9KTtyZXR1cm4gdD9oP0ltYWdlUmVzaXplci5jcmVhdGVJbWFnZShpLCExKTp0aGlzLmNyZWF0ZUJpdG1hcCh2LGEscixlKTppfWlmKCFlKXtsZXQgZTsiRGV2aWNlR3JheSI9PT10aGlzLmNvbG9yU3BhY2UubmFtZSYmMT09PWM/ZT1rOiJEZXZpY2VSR0IiIT09dGhpcy5jb2xvclNwYWNlLm5hbWV8fDghPT1jfHx0aGlzLm5lZWRzRGVjb2RlfHwoZT1DKTtpZihlJiYhdGhpcy5zbWFzayYmIXRoaXMubWFzayYmYT09PXMmJnI9PT1vKXtjb25zdCBuPWF3YWl0IHRoaXMuIyQocyxvKTtpZihuKXJldHVybiBuO2NvbnN0IGM9YXdhaXQgdGhpcy5nZXRJbWFnZUJ5dGVzKG8qbCx7fSk7aWYodClyZXR1cm4gaD9JbWFnZVJlc2l6ZXIuY3JlYXRlSW1hZ2Uoe2RhdGE6YyxraW5kOmUsd2lkdGg6YSxoZWlnaHQ6cixpbnRlcnBvbGF0ZTp0aGlzLmludGVycG9sYXRlfSx0aGlzLm5lZWRzRGVjb2RlKTp0aGlzLmNyZWF0ZUJpdG1hcChlLHMsbyxjKTtpLmtpbmQ9ZTtpLmRhdGE9YztpZih0aGlzLm5lZWRzRGVjb2RlKXthc3NlcnQoZT09PWssIlBERkltYWdlLmNyZWF0ZUltYWdlRGF0YTogVGhlIGltYWdlIG11c3QgYmUgZ3JheXNjYWxlLiIpO2NvbnN0IHQ9aS5kYXRhO2ZvcihsZXQgZT0wLGE9dC5sZW5ndGg7ZTxhO2UrKyl0W2VdXj0yNTV9cmV0dXJuIGl9aWYodGhpcy5pbWFnZSBpbnN0YW5jZW9mIEpwZWdTdHJlYW0mJiF0aGlzLnNtYXNrJiYhdGhpcy5tYXNrJiYhdGhpcy5uZWVkc0RlY29kZSl7bGV0IGU9bypsO2lmKHQmJiFoKXtsZXQgdD0hMTtzd2l0Y2godGhpcy5jb2xvclNwYWNlLm5hbWUpe2Nhc2UiRGV2aWNlR3JheSI6ZSo9NDt0PSEwO2JyZWFrO2Nhc2UiRGV2aWNlUkdCIjplPWUvMyo0O3Q9ITA7YnJlYWs7Y2FzZSJEZXZpY2VDTVlLIjp0PSEwfWlmKHQpe2NvbnN0IHQ9YXdhaXQgdGhpcy4jJChhLHIpO2lmKHQpcmV0dXJuIHQ7Y29uc3QgaT1hd2FpdCB0aGlzLmdldEltYWdlQnl0ZXMoZSx7ZHJhd1dpZHRoOmEsZHJhd0hlaWdodDpyLGZvcmNlUkdCQTohMH0pO3JldHVybiB0aGlzLmNyZWF0ZUJpdG1hcCh2LGEscixpKX19ZWxzZSBzd2l0Y2godGhpcy5jb2xvclNwYWNlLm5hbWUpe2Nhc2UiRGV2aWNlR3JheSI6ZSo9MztjYXNlIkRldmljZVJHQiI6Y2FzZSJEZXZpY2VDTVlLIjppLmtpbmQ9QztpLmRhdGE9YXdhaXQgdGhpcy5nZXRJbWFnZUJ5dGVzKGUse2RyYXdXaWR0aDphLGRyYXdIZWlnaHQ6cixmb3JjZVJHQjohMH0pO3JldHVybiBoP0ltYWdlUmVzaXplci5jcmVhdGVJbWFnZShpKTppfX19Y29uc3QgdT1hd2FpdCB0aGlzLmdldEltYWdlQnl0ZXMobypsLHtpbnRlcm5hbDohMH0pLGQ9MHx1Lmxlbmd0aC9sKnIvbyxmPXRoaXMuZ2V0Q29tcG9uZW50cyh1KTtsZXQgZyxwLG0sYix5LHc7aWYodCYmIWgpe209bmV3IE9mZnNjcmVlbkNhbnZhcyhhLHIpO2I9bS5nZXRDb250ZXh0KCIyZCIpO3k9Yi5jcmVhdGVJbWFnZURhdGEoYSxyKTt3PXkuZGF0YX1pLmtpbmQ9djtpZihlfHx0aGlzLnNtYXNrfHx0aGlzLm1hc2spe3QmJiFofHwodz1uZXcgVWludDhDbGFtcGVkQXJyYXkoYSpyKjQpKTtnPTE7cD0hMDthd2FpdCB0aGlzLmZpbGxPcGFjaXR5KHcsYSxyLGQsZil9ZWxzZXtpZighdHx8aCl7aS5raW5kPUM7dz1uZXcgVWludDhDbGFtcGVkQXJyYXkoYSpyKjMpO2c9MH1lbHNle25ldyBVaW50MzJBcnJheSh3LmJ1ZmZlcikuZmlsbChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbj80Mjc4MTkwMDgwOjI1NSk7Zz0xfXA9ITF9dGhpcy5uZWVkc0RlY29kZSYmdGhpcy5kZWNvZGVCdWZmZXIoZik7dGhpcy5jb2xvclNwYWNlLmZpbGxSZ2IodyxzLG8sYSxyLGQsYyxmLGcpO3AmJnRoaXMudW5kb1ByZWJsZW5kKHcsYSxkKTtpZih0JiYhaCl7Yi5wdXRJbWFnZURhdGEoeSwwLDApO3JldHVybntkYXRhOm51bGwsd2lkdGg6YSxoZWlnaHQ6cixiaXRtYXA6bS50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxpbnRlcnBvbGF0ZTp0aGlzLmludGVycG9sYXRlfX1pLmRhdGE9dztyZXR1cm4gaD9JbWFnZVJlc2l6ZXIuY3JlYXRlSW1hZ2UoaSk6aX1hc3luYyBmaWxsR3JheUJ1ZmZlcihlKXtjb25zdCB0PXRoaXMubnVtQ29tcHM7aWYoMSE9PXQpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBSZWFkaW5nIGdyYXkgc2NhbGUgZnJvbSBhIGNvbG9yIGltYWdlOiAke3R9YCk7Y29uc3QgYT10aGlzLndpZHRoLHI9dGhpcy5oZWlnaHQsaT10aGlzLmJwYyxuPWEqdCppKzc+PjMscz1hd2FpdCB0aGlzLmdldEltYWdlQnl0ZXMocipuLHtpbnRlcm5hbDohMH0pLG89dGhpcy5nZXRDb21wb25lbnRzKHMpO2xldCBjLGw7aWYoMT09PWkpe2w9YSpyO2lmKHRoaXMubmVlZHNEZWNvZGUpZm9yKGM9MDtjPGw7KytjKWVbY109b1tjXS0xJjI1NTtlbHNlIGZvcihjPTA7YzxsOysrYyllW2NdPTI1NSYtb1tjXTtyZXR1cm59dGhpcy5uZWVkc0RlY29kZSYmdGhpcy5kZWNvZGVCdWZmZXIobyk7bD1hKnI7Y29uc3QgaD0yNTUvKCgxPDxpKS0xKTtmb3IoYz0wO2M8bDsrK2MpZVtjXT1oKm9bY119Y3JlYXRlQml0bWFwKGUsdCxhLHIpe2NvbnN0IGk9bmV3IE9mZnNjcmVlbkNhbnZhcyh0LGEpLG49aS5nZXRDb250ZXh0KCIyZCIpO2xldCBzO2lmKGU9PT12KXM9bmV3IEltYWdlRGF0YShyLHQsYSk7ZWxzZXtzPW4uY3JlYXRlSW1hZ2VEYXRhKHQsYSk7Y29udmVydFRvUkdCQSh7a2luZDplLHNyYzpyLGRlc3Q6bmV3IFVpbnQzMkFycmF5KHMuZGF0YS5idWZmZXIpLHdpZHRoOnQsaGVpZ2h0OmEsaW52ZXJzZURlY29kZTp0aGlzLm5lZWRzRGVjb2RlfSl9bi5wdXRJbWFnZURhdGEocywwLDApO3JldHVybntkYXRhOm51bGwsd2lkdGg6dCxoZWlnaHQ6YSxiaXRtYXA6aS50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxpbnRlcnBvbGF0ZTp0aGlzLmludGVycG9sYXRlfX1hc3luYyMkKGUsdCl7Y29uc3QgYT1hd2FpdCB0aGlzLmltYWdlLmdldFRyYW5zZmVyYWJsZUltYWdlKCk7cmV0dXJuIGE/e2RhdGE6bnVsbCx3aWR0aDplLGhlaWdodDp0LGJpdG1hcDphLGludGVycG9sYXRlOnRoaXMuaW50ZXJwb2xhdGV9Om51bGx9YXN5bmMgZ2V0SW1hZ2VCeXRlcyhlLHtkcmF3V2lkdGg6dCxkcmF3SGVpZ2h0OmEsZm9yY2VSR0JBOnI9ITEsZm9yY2VSR0I6aT0hMSxpbnRlcm5hbDpuPSExfSl7dGhpcy5pbWFnZS5yZXNldCgpO3RoaXMuaW1hZ2UuZHJhd1dpZHRoPXR8fHRoaXMud2lkdGg7dGhpcy5pbWFnZS5kcmF3SGVpZ2h0PWF8fHRoaXMuaGVpZ2h0O3RoaXMuaW1hZ2UuZm9yY2VSR0JBPSEhcjt0aGlzLmltYWdlLmZvcmNlUkdCPSEhaTtjb25zdCBzPWF3YWl0IHRoaXMuaW1hZ2UuZ2V0SW1hZ2VEYXRhKGUsdGhpcy5qcHhEZWNvZGVyT3B0aW9ucyk7aWYobnx8dGhpcy5pbWFnZSBpbnN0YW5jZW9mIERlY29kZVN0cmVhbSlyZXR1cm4gczthc3NlcnQocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksJ1BERkltYWdlLmdldEltYWdlQnl0ZXM6IFVuc3VwcG9ydGVkICJpbWFnZUJ5dGVzIiB0eXBlLicpO3JldHVybiBuZXcgVWludDhBcnJheShzKX19Y29uc3QgcG49T2JqZWN0LmZyZWV6ZSh7bWF4SW1hZ2VTaXplOi0xLGRpc2FibGVGb250RmFjZTohMSxpZ25vcmVFcnJvcnM6ITEsaXNFdmFsU3VwcG9ydGVkOiEwLGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkOiExLGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkOiExLGNhbnZhc01heEFyZWFJbkJ5dGVzOi0xLGZvbnRFeHRyYVByb3BlcnRpZXM6ITEsdXNlU3lzdGVtRm9udHM6ITAsdXNlV2FzbTohMCx1c2VXb3JrZXJGZXRjaDohMCxjTWFwVXJsOm51bGwsaWNjVXJsOm51bGwsc3RhbmRhcmRGb250RGF0YVVybDpudWxsLHdhc21Vcmw6bnVsbH0pLG1uPTEsYm49Mix5bj1Qcm9taXNlLnJlc29sdmUoKTtmdW5jdGlvbiBub3JtYWxpemVCbGVuZE1vZGUoZSx0PSExKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IoY29uc3QgdCBvZiBlKXtjb25zdCBlPW5vcm1hbGl6ZUJsZW5kTW9kZSh0LCEwKTtpZihlKXJldHVybiBlfXdhcm4oYFVuc3VwcG9ydGVkIGJsZW5kIG1vZGUgQXJyYXk6ICR7ZX1gKTtyZXR1cm4ic291cmNlLW92ZXIifWlmKCEoZSBpbnN0YW5jZW9mIE5hbWUpKXJldHVybiB0P251bGw6InNvdXJjZS1vdmVyIjtzd2l0Y2goZS5uYW1lKXtjYXNlIk5vcm1hbCI6Y2FzZSJDb21wYXRpYmxlIjpyZXR1cm4ic291cmNlLW92ZXIiO2Nhc2UiTXVsdGlwbHkiOnJldHVybiJtdWx0aXBseSI7Y2FzZSJTY3JlZW4iOnJldHVybiJzY3JlZW4iO2Nhc2UiT3ZlcmxheSI6cmV0dXJuIm92ZXJsYXkiO2Nhc2UiRGFya2VuIjpyZXR1cm4iZGFya2VuIjtjYXNlIkxpZ2h0ZW4iOnJldHVybiJsaWdodGVuIjtjYXNlIkNvbG9yRG9kZ2UiOnJldHVybiJjb2xvci1kb2RnZSI7Y2FzZSJDb2xvckJ1cm4iOnJldHVybiJjb2xvci1idXJuIjtjYXNlIkhhcmRMaWdodCI6cmV0dXJuImhhcmQtbGlnaHQiO2Nhc2UiU29mdExpZ2h0IjpyZXR1cm4ic29mdC1saWdodCI7Y2FzZSJEaWZmZXJlbmNlIjpyZXR1cm4iZGlmZmVyZW5jZSI7Y2FzZSJFeGNsdXNpb24iOnJldHVybiJleGNsdXNpb24iO2Nhc2UiSHVlIjpyZXR1cm4iaHVlIjtjYXNlIlNhdHVyYXRpb24iOnJldHVybiJzYXR1cmF0aW9uIjtjYXNlIkNvbG9yIjpyZXR1cm4iY29sb3IiO2Nhc2UiTHVtaW5vc2l0eSI6cmV0dXJuImx1bWlub3NpdHkifWlmKHQpcmV0dXJuIG51bGw7d2FybihgVW5zdXBwb3J0ZWQgYmxlbmQgbW9kZTogJHtlLm5hbWV9YCk7cmV0dXJuInNvdXJjZS1vdmVyIn1mdW5jdGlvbiBhZGRDYWNoZWRJbWFnZU9wcyhlLHtvYmpJZDp0LGZuOmEsYXJnczpyLG9wdGlvbmFsQ29udGVudDppLGhhc01hc2s6bn0pe3QmJmUuYWRkRGVwZW5kZW5jeSh0KTtlLmFkZEltYWdlT3BzKGEscixpLG4pO2E9PT1EdCYmclswXT8uY291bnQ+MCYmclswXS5jb3VudCsrfWNsYXNzIFRpbWVTbG90TWFuYWdlcntzdGF0aWMgVElNRV9TTE9UX0RVUkFUSU9OX01TPTIwO3N0YXRpYyBDSEVDS19USU1FX0VWRVJZPTEwMDtjb25zdHJ1Y3Rvcigpe3RoaXMucmVzZXQoKX1jaGVjaygpe2lmKCsrdGhpcy5jaGVja2VkPFRpbWVTbG90TWFuYWdlci5DSEVDS19USU1FX0VWRVJZKXJldHVybiExO3RoaXMuY2hlY2tlZD0wO3JldHVybiB0aGlzLmVuZFRpbWU8PURhdGUubm93KCl9cmVzZXQoKXt0aGlzLmVuZFRpbWU9RGF0ZS5ub3coKStUaW1lU2xvdE1hbmFnZXIuVElNRV9TTE9UX0RVUkFUSU9OX01TO3RoaXMuY2hlY2tlZD0wfX1jbGFzcyBQYXJ0aWFsRXZhbHVhdG9ye2NvbnN0cnVjdG9yKHt4cmVmOmUsaGFuZGxlcjp0LHBhZ2VJbmRleDphLGlkRmFjdG9yeTpyLGZvbnRDYWNoZTppLGJ1aWx0SW5DTWFwQ2FjaGU6bixzdGFuZGFyZEZvbnREYXRhQ2FjaGU6cyxnbG9iYWxDb2xvclNwYWNlQ2FjaGU6byxnbG9iYWxJbWFnZUNhY2hlOmMsc3lzdGVtRm9udENhY2hlOmwsb3B0aW9uczpoPW51bGx9KXt0aGlzLnhyZWY9ZTt0aGlzLmhhbmRsZXI9dDt0aGlzLnBhZ2VJbmRleD1hO3RoaXMuaWRGYWN0b3J5PXI7dGhpcy5mb250Q2FjaGU9aTt0aGlzLmJ1aWx0SW5DTWFwQ2FjaGU9bjt0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZT1zO3RoaXMuZ2xvYmFsQ29sb3JTcGFjZUNhY2hlPW87dGhpcy5nbG9iYWxJbWFnZUNhY2hlPWM7dGhpcy5zeXN0ZW1Gb250Q2FjaGU9bDt0aGlzLm9wdGlvbnM9aHx8cG47dGhpcy50eXBlM0ZvbnRSZWZzPW51bGw7dGhpcy5fcmVnaW9uYWxJbWFnZUNhY2hlPW5ldyBSZWdpb25hbEltYWdlQ2FjaGU7dGhpcy5fZmV0Y2hCdWlsdEluQ01hcEJvdW5kPXRoaXMuZmV0Y2hCdWlsdEluQ01hcC5iaW5kKHRoaXMpfWdldCBfcGRmRnVuY3Rpb25GYWN0b3J5KCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJfcGRmRnVuY3Rpb25GYWN0b3J5IixuZXcgUERGRnVuY3Rpb25GYWN0b3J5KHt4cmVmOnRoaXMueHJlZixpc0V2YWxTdXBwb3J0ZWQ6dGhpcy5vcHRpb25zLmlzRXZhbFN1cHBvcnRlZH0pKX1nZXQgcGFyc2luZ1R5cGUzRm9udCgpe3JldHVybiEhdGhpcy50eXBlM0ZvbnRSZWZzfWNsb25lKGU9bnVsbCl7Y29uc3QgdD1PYmplY3QuY3JlYXRlKHRoaXMpO3Qub3B0aW9ucz1PYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5vcHRpb25zLGUpO3JldHVybiB0fWhhc0JsZW5kTW9kZXMoZSx0KXtpZighKGUgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm4hMTtpZihlLm9iaklkJiZ0LmhhcyhlLm9iaklkKSlyZXR1cm4hMTtjb25zdCBhPW5ldyBSZWZTZXQodCk7ZS5vYmpJZCYmYS5wdXQoZS5vYmpJZCk7Y29uc3Qgcj1bZV0saT10aGlzLnhyZWY7Zm9yKDtyLmxlbmd0aDspe2NvbnN0IGU9ci5zaGlmdCgpLHQ9ZS5nZXQoIkV4dEdTdGF0ZSIpO2lmKHQgaW5zdGFuY2VvZiBEaWN0KWZvcihsZXQgZSBvZiB0LmdldFJhd1ZhbHVlcygpKXtpZihlIGluc3RhbmNlb2YgUmVmKXtpZihhLmhhcyhlKSljb250aW51ZTt0cnl7ZT1pLmZldGNoKGUpfWNhdGNoKHQpe2EucHV0KGUpO2luZm8oYGhhc0JsZW5kTW9kZXMgLSBpZ25vcmluZyBFeHRHU3RhdGU6ICIke3R9Ii5gKTtjb250aW51ZX19aWYoIShlIGluc3RhbmNlb2YgRGljdCkpY29udGludWU7ZS5vYmpJZCYmYS5wdXQoZS5vYmpJZCk7Y29uc3QgdD1lLmdldCgiQk0iKTtpZih0IGluc3RhbmNlb2YgTmFtZSl7aWYoIk5vcm1hbCIhPT10Lm5hbWUpcmV0dXJuITB9ZWxzZSBpZih2b2lkIDAhPT10JiZBcnJheS5pc0FycmF5KHQpKWZvcihjb25zdCBlIG9mIHQpaWYoZSBpbnN0YW5jZW9mIE5hbWUmJiJOb3JtYWwiIT09ZS5uYW1lKXJldHVybiEwfWNvbnN0IG49ZS5nZXQoIlhPYmplY3QiKTtpZihuIGluc3RhbmNlb2YgRGljdClmb3IobGV0IGUgb2Ygbi5nZXRSYXdWYWx1ZXMoKSl7aWYoZSBpbnN0YW5jZW9mIFJlZil7aWYoYS5oYXMoZSkpY29udGludWU7dHJ5e2U9aS5mZXRjaChlKX1jYXRjaCh0KXthLnB1dChlKTtpbmZvKGBoYXNCbGVuZE1vZGVzIC0gaWdub3JpbmcgWE9iamVjdDogIiR7dH0iLmApO2NvbnRpbnVlfX1pZighKGUgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKSljb250aW51ZTtlLmRpY3Qub2JqSWQmJmEucHV0KGUuZGljdC5vYmpJZCk7Y29uc3QgdD1lLmRpY3QuZ2V0KCJSZXNvdXJjZXMiKTtpZih0IGluc3RhbmNlb2YgRGljdCYmKCF0Lm9iaklkfHwhYS5oYXModC5vYmpJZCkpKXtyLnB1c2godCk7dC5vYmpJZCYmYS5wdXQodC5vYmpJZCl9fX1mb3IoY29uc3QgZSBvZiBhKXQucHV0KGUpO3JldHVybiExfWFzeW5jIGZldGNoQnVpbHRJbkNNYXAoZSl7Y29uc3QgdD10aGlzLmJ1aWx0SW5DTWFwQ2FjaGUuZ2V0KGUpO2lmKHQpcmV0dXJuIHQ7bGV0IGE7YT10aGlzLm9wdGlvbnMudXNlV29ya2VyRmV0Y2g/e2NNYXBEYXRhOmF3YWl0IGZldGNoQmluYXJ5RGF0YShgJHt0aGlzLm9wdGlvbnMuY01hcFVybH0ke2V9LmJjbWFwYCksaXNDb21wcmVzc2VkOiEwfTphd2FpdCB0aGlzLmhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKCJGZXRjaEJpbmFyeURhdGEiLHt0eXBlOiJjTWFwUmVhZGVyRmFjdG9yeSIsbmFtZTplfSk7dGhpcy5idWlsdEluQ01hcENhY2hlLnNldChlLGEpO3JldHVybiBhfWFzeW5jIGZldGNoU3RhbmRhcmRGb250RGF0YShlKXtjb25zdCB0PXRoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlLmdldChlKTtpZih0KXJldHVybiBuZXcgU3RyZWFtKHQpO2lmKHRoaXMub3B0aW9ucy51c2VTeXN0ZW1Gb250cyYmIlN5bWJvbCIhPT1lJiYiWmFwZkRpbmdiYXRzIiE9PWUpcmV0dXJuIG51bGw7Y29uc3QgYT1OcigpW2VdO2xldCByO3RyeXtyPXRoaXMub3B0aW9ucy51c2VXb3JrZXJGZXRjaD9hd2FpdCBmZXRjaEJpbmFyeURhdGEoYCR7dGhpcy5vcHRpb25zLnN0YW5kYXJkRm9udERhdGFVcmx9JHthfWApOmF3YWl0IHRoaXMuaGFuZGxlci5zZW5kV2l0aFByb21pc2UoIkZldGNoQmluYXJ5RGF0YSIse3R5cGU6InN0YW5kYXJkRm9udERhdGFGYWN0b3J5IixmaWxlbmFtZTphfSl9Y2F0Y2goZSl7d2FybihlKTtyZXR1cm4gbnVsbH10aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZS5zZXQoZSxyKTtyZXR1cm4gbmV3IFN0cmVhbShyKX1hc3luYyBidWlsZEZvcm1YT2JqZWN0KGUsdCxhLHIsaSxuLHMsbyl7Y29uc3R7ZGljdDpjfT10LGw9bG9va3VwTWF0cml4KGMuZ2V0QXJyYXkoIk1hdHJpeCIpLG51bGwpLGg9bG9va3VwTm9ybWFsUmVjdChjLmdldEFycmF5KCJCQm94IiksbnVsbCk7bGV0IHUsZDtjLmhhcygiT0MiKSYmKHU9YXdhaXQgdGhpcy5wYXJzZU1hcmtlZENvbnRlbnRQcm9wcyhjLmdldCgiT0MiKSxlKSk7dm9pZCAwIT09dSYmci5hZGRPcChTdCxbIk9DIix1XSk7Y29uc3QgZj1jLmdldCgiR3JvdXAiKTtpZihmKXtkPXttYXRyaXg6bCxiYm94Omgsc21hc2s6YSxpc29sYXRlZDohMSxrbm9ja291dDohMX07bGV0IHQ9bnVsbDtpZihpc05hbWUoZi5nZXQoIlMiKSwiVHJhbnNwYXJlbmN5Iikpe2QuaXNvbGF0ZWQ9Zi5nZXQoIkkiKXx8ITE7ZC5rbm9ja291dD1mLmdldCgiSyIpfHwhMTtpZihmLmhhcygiQ1MiKSl7Y29uc3QgYT10aGlzLl9nZXRDb2xvclNwYWNlKGYuZ2V0UmF3KCJDUyIpLGUscyk7dD1hIGluc3RhbmNlb2YgQ29sb3JTcGFjZT9hOmF3YWl0IHRoaXMuX2hhbmRsZUNvbG9yU3BhY2UoYSl9fWlmKGE/LmJhY2tkcm9wKXt0fHw9Q29sb3JTcGFjZVV0aWxzLnJnYjthLmJhY2tkcm9wPXQuZ2V0UmdiSGV4KGEuYmFja2Ryb3AsMCl9ci5hZGRPcChJdCxbZF0pfWNvbnN0IGc9W2wmJm5ldyBGbG9hdDMyQXJyYXkobCksIWYmJmgmJm5ldyBGbG9hdDMyQXJyYXkoaCl8fG51bGxdO3IuYWRkT3AodnQsZyk7Y29uc3QgcD1jLmdldCgiUmVzb3VyY2VzIik7YXdhaXQgdGhpcy5nZXRPcGVyYXRvckxpc3Qoe3N0cmVhbTp0LHRhc2s6aSxyZXNvdXJjZXM6cCBpbnN0YW5jZW9mIERpY3Q/cDplLG9wZXJhdG9yTGlzdDpyLGluaXRpYWxTdGF0ZTpuLHByZXZSZWZzOm99KTtyLmFkZE9wKEZ0LFtdKTtmJiZyLmFkZE9wKFR0LFtkXSk7dm9pZCAwIT09dSYmci5hZGRPcChBdCxbXSl9X3NlbmRJbWdEYXRhKGUsdCxhPSExKXtjb25zdCByPXQ/W3QuYml0bWFwfHx0LmRhdGEuYnVmZmVyXTpudWxsO3JldHVybiB0aGlzLnBhcnNpbmdUeXBlM0ZvbnR8fGE/dGhpcy5oYW5kbGVyLnNlbmQoImNvbW1vbm9iaiIsW2UsIkltYWdlIix0XSxyKTp0aGlzLmhhbmRsZXIuc2VuZCgib2JqIixbZSx0aGlzLnBhZ2VJbmRleCwiSW1hZ2UiLHRdLHIpfWFzeW5jIGJ1aWxkUGFpbnRJbWFnZVhPYmplY3Qoe3Jlc291cmNlczplLGltYWdlOnQsaXNJbmxpbmU6YT0hMSxvcGVyYXRvckxpc3Q6cixjYWNoZUtleTppLGxvY2FsSW1hZ2VDYWNoZTpuLGxvY2FsQ29sb3JTcGFjZUNhY2hlOnN9KXtjb25zdHttYXhJbWFnZVNpemU6byxpZ25vcmVFcnJvcnM6Yyxpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDpsfT10aGlzLm9wdGlvbnMse2RpY3Q6aH09dCx1PWgub2JqSWQsZD1oLmdldCgiVyIsIldpZHRoIiksZj1oLmdldCgiSCIsIkhlaWdodCIpO2lmKCFkfHwibnVtYmVyIiE9dHlwZW9mIGR8fCFmfHwibnVtYmVyIiE9dHlwZW9mIGYpe3dhcm4oIkltYWdlIGRpbWVuc2lvbnMgYXJlIG1pc3NpbmcsIG9yIG5vdCBudW1iZXJzLiIpO3JldHVybn1pZigtMSE9PW8mJmQqZj5vKXtjb25zdCBlPSJJbWFnZSBleGNlZWRlZCBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBhbmQgd2FzIHJlbW92ZWQuIjtpZighYyl0aHJvdyBuZXcgRXJyb3IoZSk7d2FybihlKTtyZXR1cm59bGV0IGc7aC5oYXMoIk9DIikmJihnPWF3YWl0IHRoaXMucGFyc2VNYXJrZWRDb250ZW50UHJvcHMoaC5nZXQoIk9DIiksZSkpO2xldCBwLG0sYjtpZihoLmdldCgiSU0iLCJJbWFnZU1hc2siKXx8ITEpe3A9YXdhaXQgUERGSW1hZ2UuY3JlYXRlTWFzayh7aW1hZ2U6dCxpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDpsJiYhdGhpcy5wYXJzaW5nVHlwZTNGb250fSk7aWYocC5pc1NpbmdsZU9wYXF1ZVBpeGVsKXttPWp0O2I9W107ci5hZGRJbWFnZU9wcyhtLGIsZyk7aWYoaSl7Y29uc3QgZT17Zm46bSxhcmdzOmIsb3B0aW9uYWxDb250ZW50Omd9O24uc2V0KGksdSxlKTt1JiZ0aGlzLl9yZWdpb25hbEltYWdlQ2FjaGUuc2V0KG51bGwsdSxlKX1yZXR1cm59aWYodGhpcy5wYXJzaW5nVHlwZTNGb250KXtiPWZ1bmN0aW9uIGNvbXBpbGVUeXBlM0dseXBoKHtkYXRhOmUsd2lkdGg6dCxoZWlnaHQ6YX0pe2lmKHQ+MWUzfHxhPjFlMylyZXR1cm4gbnVsbDtjb25zdCByPW5ldyBVaW50OEFycmF5KFswLDIsNCwwLDEsMCw1LDQsOCwxMCwwLDgsMCwyLDEsMF0pLGk9dCsxLG49bmV3IFVpbnQ4QXJyYXkoaSooYSsxKSk7bGV0IHMsbyxjO2NvbnN0IGw9dCs3Ji04LGg9bmV3IFVpbnQ4QXJyYXkobCphKTtsZXQgdT0wO2Zvcihjb25zdCB0IG9mIGUpe2xldCBlPTEyODtmb3IoO2U+MDspe2hbdSsrXT10JmU/MDoyNTU7ZT4+PTF9fWxldCBkPTA7dT0wO2lmKDAhPT1oW3VdKXtuWzBdPTE7KytkfWZvcihvPTE7bzx0O28rKyl7aWYoaFt1XSE9PWhbdSsxXSl7bltvXT1oW3VdPzI6MTsrK2R9dSsrfWlmKDAhPT1oW3VdKXtuW29dPTI7KytkfWZvcihzPTE7czxhO3MrKyl7dT1zKmw7Yz1zKmk7aWYoaFt1LWxdIT09aFt1XSl7bltjXT1oW3VdPzE6ODsrK2R9bGV0IGU9KGhbdV0/NDowKSsoaFt1LWxdPzg6MCk7Zm9yKG89MTtvPHQ7bysrKXtlPShlPj4yKSsoaFt1KzFdPzQ6MCkrKGhbdS1sKzFdPzg6MCk7aWYocltlXSl7bltjK29dPXJbZV07KytkfXUrK31pZihoW3UtbF0hPT1oW3VdKXtuW2Mrb109aFt1XT8yOjQ7KytkfWlmKGQ+MWUzKXJldHVybiBudWxsfXU9bCooYS0xKTtjPXMqaTtpZigwIT09aFt1XSl7bltjXT04OysrZH1mb3Iobz0xO288dDtvKyspe2lmKGhbdV0hPT1oW3UrMV0pe25bYytvXT1oW3VdPzQ6ODsrK2R9dSsrfWlmKDAhPT1oW3VdKXtuW2Mrb109NDsrK2R9aWYoZD4xZTMpcmV0dXJuIG51bGw7Y29uc3QgZj1uZXcgSW50MzJBcnJheShbMCxpLC0xLDAsLWksMCwwLDAsMV0pLGc9W10se2E6cCxiOm0sYzpiLGQ6eSxlOncsZjp4fT0obmV3IERPTU1hdHJpeCkuc2NhbGVTZWxmKDEvdCwtMS9hKS50cmFuc2xhdGVTZWxmKDAsLWEpO2ZvcihzPTA7ZCYmczw9YTtzKyspe2xldCBlPXMqaTtjb25zdCBhPWUrdDtmb3IoO2U8YSYmIW5bZV07KWUrKztpZihlPT09YSljb250aW51ZTtsZXQgcj1lJWksbz1zO2cucHVzaChIdCxwKnIrYipvK3csbSpyK3kqbyt4KTtjb25zdCBjPWU7bGV0IGw9bltlXTtkb3tjb25zdCB0PWZbbF07ZG97ZSs9dH13aGlsZSghbltlXSk7Y29uc3QgYT1uW2VdO2lmKDUhPT1hJiYxMCE9PWEpe2w9YTtuW2VdPTB9ZWxzZXtsPWEmNTEqbD4+NDtuW2VdJj1sPj4yfGw8PDJ9cj1lJWk7bz1lL2l8MDtnLnB1c2goV3QscCpyK2Iqbyt3LG0qcit5Km8reCk7bltlXXx8LS1kfXdoaWxlKGMhPT1lKTstLXN9cmV0dXJuW3F0LFtuZXcgRmxvYXQzMkFycmF5KGcpXSxuZXcgRmxvYXQzMkFycmF5KFswLDAsdCxhXSldfShwKTtpZihiKXtyLmFkZEltYWdlT3BzKF90LGIsZyk7cmV0dXJufXdhcm4oIkNhbm5vdCBjb21waWxlIFR5cGUzIGdseXBoLiIpO3IuYWRkSW1hZ2VPcHMoRHQsW3BdLGcpO3JldHVybn1jb25zdCBlPWBtYXNrXyR7dGhpcy5pZEZhY3RvcnkuY3JlYXRlT2JqSWQoKX1gO3IuYWRkRGVwZW5kZW5jeShlKTtwLmRhdGFMZW49cC5iaXRtYXA/cC53aWR0aCpwLmhlaWdodCo0OnAuZGF0YS5sZW5ndGg7dGhpcy5fc2VuZEltZ0RhdGEoZSxwKTttPUR0O2I9W3tkYXRhOmUsd2lkdGg6cC53aWR0aCxoZWlnaHQ6cC5oZWlnaHQsaW50ZXJwb2xhdGU6cC5pbnRlcnBvbGF0ZSxjb3VudDoxfV07ci5hZGRJbWFnZU9wcyhtLGIsZyk7aWYoaSl7Y29uc3QgdD17b2JqSWQ6ZSxmbjptLGFyZ3M6YixvcHRpb25hbENvbnRlbnQ6Z307bi5zZXQoaSx1LHQpO3UmJnRoaXMuX3JlZ2lvbmFsSW1hZ2VDYWNoZS5zZXQobnVsbCx1LHQpfXJldHVybn1jb25zdCB5PWguaGFzKCJTTWFzayIpfHxoLmhhcygiTWFzayIpO2lmKGEmJmQrZjwyMDAmJiF5KXt0cnl7Y29uc3QgaT1uZXcgUERGSW1hZ2Uoe3hyZWY6dGhpcy54cmVmLHJlczplLGltYWdlOnQsaXNJbmxpbmU6YSxwZGZGdW5jdGlvbkZhY3Rvcnk6dGhpcy5fcGRmRnVuY3Rpb25GYWN0b3J5LGdsb2JhbENvbG9yU3BhY2VDYWNoZTp0aGlzLmdsb2JhbENvbG9yU3BhY2VDYWNoZSxsb2NhbENvbG9yU3BhY2VDYWNoZTpzfSk7cD1hd2FpdCBpLmNyZWF0ZUltYWdlRGF0YSghMCwhMSk7ci5hZGRJbWFnZU9wcyhOdCxbcF0sZyl9Y2F0Y2goZSl7Y29uc3QgdD1gVW5hYmxlIHRvIGRlY29kZSBpbmxpbmUgaW1hZ2U6ICIke2V9Ii5gO2lmKCFjKXRocm93IG5ldyBFcnJvcih0KTt3YXJuKHQpfXJldHVybn1sZXQgdz1gaW1nXyR7dGhpcy5pZEZhY3RvcnkuY3JlYXRlT2JqSWQoKX1gLHg9ITEsUz1udWxsO2lmKHRoaXMucGFyc2luZ1R5cGUzRm9udCl3PWAke3RoaXMuaWRGYWN0b3J5LmdldERvY0lkKCl9X3R5cGUzXyR7d31gO2Vsc2UgaWYoaSYmdSl7eD10aGlzLmdsb2JhbEltYWdlQ2FjaGUuc2hvdWxkQ2FjaGUodSx0aGlzLnBhZ2VJbmRleCk7aWYoeCl7YXNzZXJ0KCFhLCJDYW5ub3QgY2FjaGUgYW4gaW5saW5lIGltYWdlIGdsb2JhbGx5LiIpO3c9YCR7dGhpcy5pZEZhY3RvcnkuZ2V0RG9jSWQoKX1fJHt3fWB9fXIuYWRkRGVwZW5kZW5jeSh3KTttPVJ0O2I9W3csZCxmXTtyLmFkZEltYWdlT3BzKG0sYixnLHkpO2lmKHgpe1M9e29iaklkOncsZm46bSxhcmdzOmIsb3B0aW9uYWxDb250ZW50OmcsaGFzTWFzazp5LGJ5dGVTaXplOjB9O2lmKHRoaXMuZ2xvYmFsSW1hZ2VDYWNoZS5oYXNEZWNvZGVGYWlsZWQodSkpe3RoaXMuZ2xvYmFsSW1hZ2VDYWNoZS5zZXREYXRhKHUsUyk7dGhpcy5fc2VuZEltZ0RhdGEodyxudWxsLHgpO3JldHVybn1pZihkKmY+MjVlNHx8eSl7Y29uc3QgZT1hd2FpdCB0aGlzLmhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKCJjb21tb25vYmoiLFt3LCJDb3B5TG9jYWxJbWFnZSIse2ltYWdlUmVmOnV9XSk7aWYoZSl7dGhpcy5nbG9iYWxJbWFnZUNhY2hlLnNldERhdGEodSxTKTt0aGlzLmdsb2JhbEltYWdlQ2FjaGUuYWRkQnl0ZVNpemUodSxlKTtyZXR1cm59fX1QREZJbWFnZS5idWlsZEltYWdlKHt4cmVmOnRoaXMueHJlZixyZXM6ZSxpbWFnZTp0LGlzSW5saW5lOmEscGRmRnVuY3Rpb25GYWN0b3J5OnRoaXMuX3BkZkZ1bmN0aW9uRmFjdG9yeSxnbG9iYWxDb2xvclNwYWNlQ2FjaGU6dGhpcy5nbG9iYWxDb2xvclNwYWNlQ2FjaGUsbG9jYWxDb2xvclNwYWNlQ2FjaGU6c30pLnRoZW4oKGFzeW5jIGU9PntwPWF3YWl0IGUuY3JlYXRlSW1hZ2VEYXRhKCExLGwpO3AuZGF0YUxlbj1wLmJpdG1hcD9wLndpZHRoKnAuaGVpZ2h0KjQ6cC5kYXRhLmxlbmd0aDtwLnJlZj11O3gmJnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZS5hZGRCeXRlU2l6ZSh1LHAuZGF0YUxlbik7cmV0dXJuIHRoaXMuX3NlbmRJbWdEYXRhKHcscCx4KX0pKS5jYXRjaCgoZT0+e3dhcm4oYFVuYWJsZSB0byBkZWNvZGUgaW1hZ2UgIiR7d30iOiAiJHtlfSIuYCk7dSYmdGhpcy5nbG9iYWxJbWFnZUNhY2hlLmFkZERlY29kZUZhaWxlZCh1KTtyZXR1cm4gdGhpcy5fc2VuZEltZ0RhdGEodyxudWxsLHgpfSkpO2lmKGkpe2NvbnN0IGU9e29iaklkOncsZm46bSxhcmdzOmIsb3B0aW9uYWxDb250ZW50OmcsaGFzTWFzazp5fTtuLnNldChpLHUsZSk7aWYodSl7dGhpcy5fcmVnaW9uYWxJbWFnZUNhY2hlLnNldChudWxsLHUsZSk7aWYoeCl7YXNzZXJ0KFMsIlRoZSBnbG9iYWwgY2FjaGUtZGF0YSBtdXN0IGJlIGF2YWlsYWJsZS4iKTt0aGlzLmdsb2JhbEltYWdlQ2FjaGUuc2V0RGF0YSh1LFMpfX19fWhhbmRsZVNNYXNrKGUsdCxhLHIsaSxuLHMpe2NvbnN0IG89ZS5nZXQoIkciKSxjPXtzdWJ0eXBlOmUuZ2V0KCJTIikubmFtZSxiYWNrZHJvcDplLmdldCgiQkMiKX0sbD1lLmdldCgiVFIiKTtpZihpc1BERkZ1bmN0aW9uKGwpKXtjb25zdCBlPXRoaXMuX3BkZkZ1bmN0aW9uRmFjdG9yeS5jcmVhdGUobCksdD1uZXcgVWludDhBcnJheSgyNTYpLGE9bmV3IEZsb2F0MzJBcnJheSgxKTtmb3IobGV0IHI9MDtyPDI1NjtyKyspe2FbMF09ci8yNTU7ZShhLDAsYSwwKTt0W3JdPTI1NSphWzBdfDB9Yy50cmFuc2Zlck1hcD10fXJldHVybiB0aGlzLmJ1aWxkRm9ybVhPYmplY3QodCxvLGMsYSxyLGkuc3RhdGUuY2xvbmUoe25ld1BhdGg6ITB9KSxuLHMpfWhhbmRsZVRyYW5zZmVyRnVuY3Rpb24oZSl7bGV0IHQ7aWYoQXJyYXkuaXNBcnJheShlKSl0PWU7ZWxzZXtpZighaXNQREZGdW5jdGlvbihlKSlyZXR1cm4gbnVsbDt0PVtlXX1jb25zdCBhPVtdO2xldCByPTAsaT0wO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9dGhpcy54cmVmLmZldGNoSWZSZWYoZSk7cisrO2lmKGlzTmFtZSh0LCJJZGVudGl0eSIpKXthLnB1c2gobnVsbCk7Y29udGludWV9aWYoIWlzUERGRnVuY3Rpb24odCkpcmV0dXJuIG51bGw7Y29uc3Qgbj10aGlzLl9wZGZGdW5jdGlvbkZhY3RvcnkuY3JlYXRlKHQpLHM9bmV3IFVpbnQ4QXJyYXkoMjU2KSxvPW5ldyBGbG9hdDMyQXJyYXkoMSk7Zm9yKGxldCBlPTA7ZTwyNTY7ZSsrKXtvWzBdPWUvMjU1O24obywwLG8sMCk7c1tlXT0yNTUqb1swXXwwfWEucHVzaChzKTtpKyt9cmV0dXJuIDEhPT1yJiY0IT09cnx8MD09PWk/bnVsbDphfWhhbmRsZVRpbGluZ1R5cGUoZSx0LGEscixpLG4scyxvKXtjb25zdCBjPW5ldyBPcGVyYXRvckxpc3QsbD1EaWN0Lm1lcmdlKHt4cmVmOnRoaXMueHJlZixkaWN0QXJyYXk6W2kuZ2V0KCJSZXNvdXJjZXMiKSxhXX0pO3JldHVybiB0aGlzLmdldE9wZXJhdG9yTGlzdCh7c3RyZWFtOnIsdGFzazpzLHJlc291cmNlczpsLG9wZXJhdG9yTGlzdDpjfSkudGhlbigoZnVuY3Rpb24oKXtjb25zdCBhPWMuZ2V0SVIoKSxyPWdldFRpbGluZ1BhdHRlcm5JUihhLGksdCk7bi5hZGREZXBlbmRlbmNpZXMoYy5kZXBlbmRlbmNpZXMpO24uYWRkT3AoZSxyKTtpLm9iaklkJiZvLnNldChudWxsLGkub2JqSWQse29wZXJhdG9yTGlzdElSOmEsZGljdDppfSl9KSkuY2F0Y2goKGU9PntpZighKGUgaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbikpe2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IGU7d2FybihgaGFuZGxlVGlsaW5nVHlwZSAtIGlnbm9yaW5nIHBhdHRlcm46ICIke2V9Ii5gKX19KSl9YXN5bmMgaGFuZGxlU2V0Rm9udChlLHQsYSxyLGksbixzPW51bGwsbz1udWxsKXtjb25zdCBjPXQ/LlswXWluc3RhbmNlb2YgTmFtZT90WzBdLm5hbWU6bnVsbCxsPWF3YWl0IHRoaXMubG9hZEZvbnQoYyxhLGUsaSxzLG8pO2wuZm9udC5pc1R5cGUzRm9udCYmci5hZGREZXBlbmRlbmNpZXMobC50eXBlM0RlcGVuZGVuY2llcyk7bi5mb250PWwuZm9udDtsLnNlbmQodGhpcy5oYW5kbGVyKTtyZXR1cm4gbC5sb2FkZWROYW1lfWhhbmRsZVRleHQoZSx0KXtjb25zdCBhPXQuZm9udCxyPWEuY2hhcnNUb0dseXBocyhlKTtpZihhLmRhdGEpeyghISh0LnRleHRSZW5kZXJpbmdNb2RlJlMpfHwiUGF0dGVybiI9PT10LmZpbGxDb2xvclNwYWNlLm5hbWV8fGEuZGlzYWJsZUZvbnRGYWNlKSYmUGFydGlhbEV2YWx1YXRvci5idWlsZEZvbnRQYXRocyhhLHIsdGhpcy5oYW5kbGVyLHRoaXMub3B0aW9ucyl9cmV0dXJuIHJ9ZW5zdXJlU3RhdGVGb250KGUpe2lmKGUuZm9udClyZXR1cm47Y29uc3QgdD1uZXcgRm9ybWF0RXJyb3IoIk1pc3Npbmcgc2V0Rm9udCAoVGYpIG9wZXJhdG9yIGJlZm9yZSB0ZXh0IHJlbmRlcmluZyBvcGVyYXRvci4iKTtpZighdGhpcy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyB0O3dhcm4oYGVuc3VyZVN0YXRlRm9udDogIiR7dH0iLmApfWFzeW5jIHNldEdTdGF0ZSh7cmVzb3VyY2VzOmUsZ1N0YXRlOnQsb3BlcmF0b3JMaXN0OmEsY2FjaGVLZXk6cix0YXNrOmksc3RhdGVNYW5hZ2VyOm4sbG9jYWxHU3RhdGVDYWNoZTpzLGxvY2FsQ29sb3JTcGFjZUNhY2hlOm8sc2VlblJlZnM6Y30pe2NvbnN0IGw9dC5vYmpJZDtsZXQgaD0hMDtjb25zdCB1PVtdO2xldCBkPVByb21pc2UucmVzb2x2ZSgpO2Zvcihjb25zdFtyLHNdb2YgdClzd2l0Y2gocil7Y2FzZSJUeXBlIjpicmVhaztjYXNlIkxXIjppZigibnVtYmVyIiE9dHlwZW9mIHMpe3dhcm4oYEludmFsaWQgTFcgKGxpbmUgd2lkdGgpOiAke3N9YCk7YnJlYWt9dS5wdXNoKFtyLE1hdGguYWJzKHMpXSk7YnJlYWs7Y2FzZSJMQyI6Y2FzZSJMSiI6Y2FzZSJNTCI6Y2FzZSJEIjpjYXNlIlJJIjpjYXNlIkZMIjpjYXNlIkNBIjpjYXNlImNhIjp1LnB1c2goW3Isc10pO2JyZWFrO2Nhc2UiRm9udCI6aD0hMTtkPWQudGhlbigoKCk9PnRoaXMuaGFuZGxlU2V0Rm9udChlLG51bGwsc1swXSxhLGksbi5zdGF0ZSkudGhlbigoZnVuY3Rpb24oZSl7YS5hZGREZXBlbmRlbmN5KGUpO3UucHVzaChbcixbZSxzWzFdXV0pfSkpKSk7YnJlYWs7Y2FzZSJCTSI6dS5wdXNoKFtyLG5vcm1hbGl6ZUJsZW5kTW9kZShzKV0pO2JyZWFrO2Nhc2UiU01hc2siOmlmKGlzTmFtZShzLCJOb25lIikpe3UucHVzaChbciwhMV0pO2JyZWFrfWlmKHMgaW5zdGFuY2VvZiBEaWN0KXtoPSExO2Q9ZC50aGVuKCgoKT0+dGhpcy5oYW5kbGVTTWFzayhzLGUsYSxpLG4sbyxjKSkpO3UucHVzaChbciwhMF0pfWVsc2Ugd2FybigiVW5zdXBwb3J0ZWQgU01hc2sgdHlwZSIpO2JyZWFrO2Nhc2UiVFIiOmNvbnN0IHQ9dGhpcy5oYW5kbGVUcmFuc2ZlckZ1bmN0aW9uKHMpO3UucHVzaChbcix0XSk7YnJlYWs7Y2FzZSJPUCI6Y2FzZSJvcCI6Y2FzZSJPUE0iOmNhc2UiQkciOmNhc2UiQkcyIjpjYXNlIlVDUiI6Y2FzZSJVQ1IyIjpjYXNlIlRSMiI6Y2FzZSJIVCI6Y2FzZSJTTSI6Y2FzZSJTQSI6Y2FzZSJBSVMiOmNhc2UiVEsiOmluZm8oImdyYXBoaWMgc3RhdGUgb3BlcmF0b3IgIityKTticmVhaztkZWZhdWx0OmluZm8oIlVua25vd24gZ3JhcGhpYyBzdGF0ZSBvcGVyYXRvciAiK3IpfWF3YWl0IGQ7dS5sZW5ndGg+MCYmYS5hZGRPcChnZSxbdV0pO2gmJnMuc2V0KHIsbCx1KX1sb2FkRm9udChlLHQsYSxyLGk9bnVsbCxuPW51bGwpe2NvbnN0IGVycm9yRm9udD1hc3luYygpPT5uZXcgVHJhbnNsYXRlZEZvbnQoe2xvYWRlZE5hbWU6ImdfZm9udF9lcnJvciIsZm9udDpuZXcgRXJyb3JGb250KGBGb250ICIke2V9IiBpcyBub3QgYXZhaWxhYmxlLmApLGRpY3Q6dH0pO2xldCBzO2lmKHQpdCBpbnN0YW5jZW9mIFJlZiYmKHM9dCk7ZWxzZXtjb25zdCB0PWEuZ2V0KCJGb250Iik7dCYmKHM9dC5nZXRSYXcoZSkpfWlmKHMpe2lmKHRoaXMudHlwZTNGb250UmVmcz8uaGFzKHMpKXJldHVybiBlcnJvckZvbnQoKTtpZih0aGlzLmZvbnRDYWNoZS5oYXMocykpcmV0dXJuIHRoaXMuZm9udENhY2hlLmdldChzKTt0cnl7dD10aGlzLnhyZWYuZmV0Y2hJZlJlZihzKX1jYXRjaChlKXt3YXJuKGBsb2FkRm9udCAtIGxvb2t1cCBmYWlsZWQ6ICIke2V9Ii5gKX19aWYoISh0IGluc3RhbmNlb2YgRGljdCkpe2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzJiYhdGhpcy5wYXJzaW5nVHlwZTNGb250KXt3YXJuKGBGb250ICIke2V9IiBpcyBub3QgYXZhaWxhYmxlLmApO3JldHVybiBlcnJvckZvbnQoKX13YXJuKGBGb250ICIke2V9IiBpcyBub3QgYXZhaWxhYmxlIC0tIGF0dGVtcHRpbmcgdG8gZmFsbGJhY2sgdG8gYSBkZWZhdWx0IGZvbnQuYCk7dD1pfHxQYXJ0aWFsRXZhbHVhdG9yLmZhbGxiYWNrRm9udERpY3R9aWYodC5jYWNoZUtleSYmdGhpcy5mb250Q2FjaGUuaGFzKHQuY2FjaGVLZXkpKXJldHVybiB0aGlzLmZvbnRDYWNoZS5nZXQodC5jYWNoZUtleSk7Y29uc3R7cHJvbWlzZTpvLHJlc29sdmU6Y309UHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7bGV0IGw7dHJ5e2w9dGhpcy5wcmVFdmFsdWF0ZUZvbnQodCk7bC5jc3NGb250SW5mbz1ufWNhdGNoKGUpe3dhcm4oYGxvYWRGb250IC0gcHJlRXZhbHVhdGVGb250IGZhaWxlZDogIiR7ZX0iLmApO3JldHVybiBlcnJvckZvbnQoKX1jb25zdHtkZXNjcmlwdG9yOmgsaGFzaDp1fT1sLGQ9cyBpbnN0YW5jZW9mIFJlZjtsZXQgZjtpZih1JiZoIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgZT1oLmZvbnRBbGlhc2VzfHw9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihlW3VdKXtjb25zdCB0PWVbdV0uYWxpYXNSZWY7aWYoZCYmdCYmdGhpcy5mb250Q2FjaGUuaGFzKHQpKXt0aGlzLmZvbnRDYWNoZS5wdXRBbGlhcyhzLHQpO3JldHVybiB0aGlzLmZvbnRDYWNoZS5nZXQocyl9fWVsc2UgZVt1XT17Zm9udElEOnRoaXMuaWRGYWN0b3J5LmNyZWF0ZUZvbnRJZCgpfTtkJiYoZVt1XS5hbGlhc1JlZj1zKTtmPWVbdV0uZm9udElEfWVsc2UgZj10aGlzLmlkRmFjdG9yeS5jcmVhdGVGb250SWQoKTthc3NlcnQoZj8uc3RhcnRzV2l0aCgiZiIpLCdUaGUgImZvbnRJRCIgbXVzdCBiZSAoY29ycmVjdGx5KSBkZWZpbmVkLicpO2lmKGQpdGhpcy5mb250Q2FjaGUucHV0KHMsbyk7ZWxzZXt0LmNhY2hlS2V5PWBjYWNoZUtleV8ke2Z9YDt0aGlzLmZvbnRDYWNoZS5wdXQodC5jYWNoZUtleSxvKX10LmxvYWRlZE5hbWU9YCR7dGhpcy5pZEZhY3RvcnkuZ2V0RG9jSWQoKX1fJHtmfWA7dGhpcy50cmFuc2xhdGVGb250KGwpLnRoZW4oKGFzeW5jIGU9Pntjb25zdCBpPW5ldyBUcmFuc2xhdGVkRm9udCh7bG9hZGVkTmFtZTp0LmxvYWRlZE5hbWUsZm9udDplLGRpY3Q6dH0pO2lmKGUuaXNUeXBlM0ZvbnQpdHJ5e2F3YWl0IGkubG9hZFR5cGUzRGF0YSh0aGlzLGEscil9Y2F0Y2goZSl7dGhyb3cgbmV3IEVycm9yKGBUeXBlMyBmb250IGxvYWQgZXJyb3I6ICR7ZX1gKX1jKGkpfSkpLmNhdGNoKChlPT57d2FybihgbG9hZEZvbnQgLSB0cmFuc2xhdGVGb250IGZhaWxlZDogIiR7ZX0iLmApO2MobmV3IFRyYW5zbGF0ZWRGb250KHtsb2FkZWROYW1lOnQubG9hZGVkTmFtZSxmb250Om5ldyBFcnJvckZvbnQoZT8ubWVzc2FnZSksZGljdDp0fSkpfSkpO3JldHVybiBvfWJ1aWxkUGF0aChlLHQsYSl7Y29uc3R7cGF0aE1pbk1heDpyLHBhdGhCdWZmZXI6aX09YTtzd2l0Y2goMHxlKXtjYXNlIENlOntjb25zdCBlPWEuY3VycmVudFBvaW50WD10WzBdLG49YS5jdXJyZW50UG9pbnRZPXRbMV0scz10WzJdLG89dFszXSxjPWUrcyxsPW4rbzswPT09c3x8MD09PW8/aS5wdXNoKEh0LGUsbixXdCxjLGwsJHQpOmkucHVzaChIdCxlLG4sV3QsYyxuLFd0LGMsbCxXdCxlLGwsJHQpO1V0aWwucmVjdEJvdW5kaW5nQm94KGUsbixjLGwscik7YnJlYWt9Y2FzZSB5ZTp7Y29uc3QgZT1hLmN1cnJlbnRQb2ludFg9dFswXSxuPWEuY3VycmVudFBvaW50WT10WzFdO2kucHVzaChIdCxlLG4pO1V0aWwucG9pbnRCb3VuZGluZ0JveChlLG4scik7YnJlYWt9Y2FzZSB3ZTp7Y29uc3QgZT1hLmN1cnJlbnRQb2ludFg9dFswXSxuPWEuY3VycmVudFBvaW50WT10WzFdO2kucHVzaChXdCxlLG4pO1V0aWwucG9pbnRCb3VuZGluZ0JveChlLG4scik7YnJlYWt9Y2FzZSB4ZTp7Y29uc3QgZT1hLmN1cnJlbnRQb2ludFgsbj1hLmN1cnJlbnRQb2ludFksW3MsbyxjLGwsaCx1XT10O2EuY3VycmVudFBvaW50WD1oO2EuY3VycmVudFBvaW50WT11O2kucHVzaCh6dCxzLG8sYyxsLGgsdSk7VXRpbC5iZXppZXJCb3VuZGluZ0JveChlLG4scyxvLGMsbCxoLHUscik7YnJlYWt9Y2FzZSBTZTp7Y29uc3QgZT1hLmN1cnJlbnRQb2ludFgsbj1hLmN1cnJlbnRQb2ludFksW3MsbyxjLGxdPXQ7YS5jdXJyZW50UG9pbnRYPWM7YS5jdXJyZW50UG9pbnRZPWw7aS5wdXNoKHp0LGUsbixzLG8sYyxsKTtVdGlsLmJlemllckJvdW5kaW5nQm94KGUsbixlLG4scyxvLGMsbCxyKTticmVha31jYXNlIEFlOntjb25zdCBlPWEuY3VycmVudFBvaW50WCxuPWEuY3VycmVudFBvaW50WSxbcyxvLGMsbF09dDthLmN1cnJlbnRQb2ludFg9YzthLmN1cnJlbnRQb2ludFk9bDtpLnB1c2goenQscyxvLGMsbCxjLGwpO1V0aWwuYmV6aWVyQm91bmRpbmdCb3goZSxuLHMsbyxjLGwsYyxsLHIpO2JyZWFrfWNhc2Uga2U6aS5wdXNoKCR0KX19X2dldENvbG9yU3BhY2UoZSx0LGEpe3JldHVybiBDb2xvclNwYWNlVXRpbHMucGFyc2Uoe2NzOmUseHJlZjp0aGlzLnhyZWYscmVzb3VyY2VzOnQscGRmRnVuY3Rpb25GYWN0b3J5OnRoaXMuX3BkZkZ1bmN0aW9uRmFjdG9yeSxnbG9iYWxDb2xvclNwYWNlQ2FjaGU6dGhpcy5nbG9iYWxDb2xvclNwYWNlQ2FjaGUsbG9jYWxDb2xvclNwYWNlQ2FjaGU6YSxhc3luY0lmTm90Q2FjaGVkOiEwfSl9YXN5bmMgX2hhbmRsZUNvbG9yU3BhY2UoZSl7dHJ5e3JldHVybiBhd2FpdCBlfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbilyZXR1cm4gbnVsbDtpZih0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXt3YXJuKGBfaGFuZGxlQ29sb3JTcGFjZSAtIGlnbm9yaW5nIENvbG9yU3BhY2U6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH10aHJvdyBlfX1wYXJzZVNoYWRpbmcoe3NoYWRpbmc6ZSxyZXNvdXJjZXM6dCxsb2NhbENvbG9yU3BhY2VDYWNoZTphLGxvY2FsU2hhZGluZ1BhdHRlcm5DYWNoZTpyfSl7bGV0IGksbj1yLmdldChlKTtpZihuKXJldHVybiBuO3RyeXtpPVBhdHRlcm4ucGFyc2VTaGFkaW5nKGUsdGhpcy54cmVmLHQsdGhpcy5fcGRmRnVuY3Rpb25GYWN0b3J5LHRoaXMuZ2xvYmFsQ29sb3JTcGFjZUNhY2hlLGEpLmdldElSKCl9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uKXJldHVybiBudWxsO2lmKHRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpe3dhcm4oYHBhcnNlU2hhZGluZyAtIGlnbm9yaW5nIHNoYWRpbmc6ICIke3R9Ii5gKTtyLnNldChlLG51bGwpO3JldHVybiBudWxsfXRocm93IHR9bj1gcGF0dGVybl8ke3RoaXMuaWRGYWN0b3J5LmNyZWF0ZU9iaklkKCl9YDt0aGlzLnBhcnNpbmdUeXBlM0ZvbnQmJihuPWAke3RoaXMuaWRGYWN0b3J5LmdldERvY0lkKCl9X3R5cGUzXyR7bn1gKTtyLnNldChlLG4pO3RoaXMucGFyc2luZ1R5cGUzRm9udD90aGlzLmhhbmRsZXIuc2VuZCgiY29tbW9ub2JqIixbbiwiUGF0dGVybiIsaV0pOnRoaXMuaGFuZGxlci5zZW5kKCJvYmoiLFtuLHRoaXMucGFnZUluZGV4LCJQYXR0ZXJuIixpXSk7cmV0dXJuIG59aGFuZGxlQ29sb3JOKGUsdCxhLHIsaSxuLHMsbyxjLGwpe2NvbnN0IGg9YS5wb3AoKTtpZihoIGluc3RhbmNlb2YgTmFtZSl7Y29uc3QgdT1pLmdldFJhdyhoLm5hbWUpLGQ9dSBpbnN0YW5jZW9mIFJlZiYmYy5nZXRCeVJlZih1KTtpZihkKXRyeXtjb25zdCBpPXIuYmFzZT9yLmJhc2UuZ2V0UmdiSGV4KGEsMCk6bnVsbCxuPWdldFRpbGluZ1BhdHRlcm5JUihkLm9wZXJhdG9yTGlzdElSLGQuZGljdCxpKTtlLmFkZE9wKHQsbik7cmV0dXJufWNhdGNoe31jb25zdCBmPXRoaXMueHJlZi5mZXRjaElmUmVmKHUpO2lmKGYpe2NvbnN0IGk9ZiBpbnN0YW5jZW9mIEJhc2VTdHJlYW0/Zi5kaWN0OmYsaD1pLmdldCgiUGF0dGVyblR5cGUiKTtpZihoPT09bW4pe2NvbnN0IG89ci5iYXNlP3IuYmFzZS5nZXRSZ2JIZXgoYSwwKTpudWxsO3JldHVybiB0aGlzLmhhbmRsZVRpbGluZ1R5cGUodCxvLG4sZixpLGUscyxjKX1pZihoPT09Ym4pe2NvbnN0IGE9aS5nZXQoIlNoYWRpbmciKSxyPXRoaXMucGFyc2VTaGFkaW5nKHtzaGFkaW5nOmEscmVzb3VyY2VzOm4sbG9jYWxDb2xvclNwYWNlQ2FjaGU6byxsb2NhbFNoYWRpbmdQYXR0ZXJuQ2FjaGU6bH0pO2lmKHIpe2NvbnN0IGE9bG9va3VwTWF0cml4KGkuZ2V0QXJyYXkoIk1hdHJpeCIpLG51bGwpO2UuYWRkT3AodCxbIlNoYWRpbmciLHIsYV0pfXJldHVybn10aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVua25vd24gUGF0dGVyblR5cGU6ICR7aH1gKX19dGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbmtub3duIFBhdHRlcm5OYW1lOiAke2h9YCl9X3BhcnNlVmlzaWJpbGl0eUV4cHJlc3Npb24oZSx0LGEpe2lmKCsrdD4xMCl7d2FybigiVmlzaWJpbGl0eSBleHByZXNzaW9uIGlzIHRvbyBkZWVwbHkgbmVzdGVkIik7cmV0dXJufWNvbnN0IHI9ZS5sZW5ndGgsaT10aGlzLnhyZWYuZmV0Y2hJZlJlZihlWzBdKTtpZighKHI8MikmJmkgaW5zdGFuY2VvZiBOYW1lKXtzd2l0Y2goaS5uYW1lKXtjYXNlIkFuZCI6Y2FzZSJPciI6Y2FzZSJOb3QiOmEucHVzaChpLm5hbWUpO2JyZWFrO2RlZmF1bHQ6d2FybihgSW52YWxpZCBvcGVyYXRvciAke2kubmFtZX0gaW4gdmlzaWJpbGl0eSBleHByZXNzaW9uYCk7cmV0dXJufWZvcihsZXQgaT0xO2k8cjtpKyspe2NvbnN0IHI9ZVtpXSxuPXRoaXMueHJlZi5mZXRjaElmUmVmKHIpO2lmKEFycmF5LmlzQXJyYXkobikpe2NvbnN0IGU9W107YS5wdXNoKGUpO3RoaXMuX3BhcnNlVmlzaWJpbGl0eUV4cHJlc3Npb24obix0LGUpfWVsc2UgciBpbnN0YW5jZW9mIFJlZiYmYS5wdXNoKHIudG9TdHJpbmcoKSl9fWVsc2Ugd2FybigiSW52YWxpZCB2aXNpYmlsaXR5IGV4cHJlc3Npb24iKX1hc3luYyBwYXJzZU1hcmtlZENvbnRlbnRQcm9wcyhlLHQpe2xldCBhO2lmKGUgaW5zdGFuY2VvZiBOYW1lKXthPXQuZ2V0KCJQcm9wZXJ0aWVzIikuZ2V0KGUubmFtZSl9ZWxzZXtpZighKGUgaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk9wdGlvbmFsIGNvbnRlbnQgcHJvcGVydGllcyBtYWxmb3JtZWQuIik7YT1lfWNvbnN0IHI9YS5nZXQoIlR5cGUiKT8ubmFtZTtpZigiT0NHIj09PXIpcmV0dXJue3R5cGU6cixpZDphLm9iaklkfTtpZigiT0NNRCI9PT1yKXtjb25zdCBlPWEuZ2V0KCJWRSIpO2lmKEFycmF5LmlzQXJyYXkoZSkpe2NvbnN0IHQ9W107dGhpcy5fcGFyc2VWaXNpYmlsaXR5RXhwcmVzc2lvbihlLDAsdCk7aWYodC5sZW5ndGg+MClyZXR1cm57dHlwZToiT0NNRCIsZXhwcmVzc2lvbjp0fX1jb25zdCB0PWEuZ2V0KCJPQ0dzIik7aWYoQXJyYXkuaXNBcnJheSh0KXx8dCBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9W107aWYoQXJyYXkuaXNBcnJheSh0KSlmb3IoY29uc3QgYSBvZiB0KWUucHVzaChhLnRvU3RyaW5nKCkpO2Vsc2UgZS5wdXNoKHQub2JqSWQpO3JldHVybnt0eXBlOnIsaWRzOmUscG9saWN5OmEuZ2V0KCJQIilpbnN0YW5jZW9mIE5hbWU/YS5nZXQoIlAiKS5uYW1lOm51bGwsZXhwcmVzc2lvbjpudWxsfX1pZih0IGluc3RhbmNlb2YgUmVmKXJldHVybnt0eXBlOnIsaWQ6dC50b1N0cmluZygpfX1yZXR1cm4gbnVsbH1nZXRPcGVyYXRvckxpc3Qoe3N0cmVhbTplLHRhc2s6dCxyZXNvdXJjZXM6YSxvcGVyYXRvckxpc3Q6cixpbml0aWFsU3RhdGU6aT1udWxsLGZhbGxiYWNrRm9udERpY3Q6bj1udWxsLHByZXZSZWZzOnM9bnVsbH0pe2NvbnN0IG89ZS5kaWN0Py5vYmpJZCxjPW5ldyBSZWZTZXQocyk7aWYobyl7aWYocz8uaGFzKG8pKXRocm93IG5ldyBFcnJvcihgZ2V0T3BlcmF0b3JMaXN0IC0gaWdub3JpbmcgY2lyY3VsYXIgcmVmZXJlbmNlOiAke299YCk7Yy5wdXQobyl9YXx8PURpY3QuZW1wdHk7aXx8PW5ldyBFdmFsU3RhdGU7aWYoIXIpdGhyb3cgbmV3IEVycm9yKCdnZXRPcGVyYXRvckxpc3Q6IG1pc3NpbmcgIm9wZXJhdG9yTGlzdCIgcGFyYW1ldGVyJyk7Y29uc3QgbD10aGlzLGg9dGhpcy54cmVmLHU9bmV3IExvY2FsSW1hZ2VDYWNoZSxkPW5ldyBMb2NhbENvbG9yU3BhY2VDYWNoZSxmPW5ldyBMb2NhbEdTdGF0ZUNhY2hlLGc9bmV3IExvY2FsVGlsaW5nUGF0dGVybkNhY2hlLHA9bmV3IE1hcCxtPWEuZ2V0KCJYT2JqZWN0Iil8fERpY3QuZW1wdHksYj1hLmdldCgiUGF0dGVybiIpfHxEaWN0LmVtcHR5LHk9bmV3IFN0YXRlTWFuYWdlcihpKSx3PW5ldyBFdmFsdWF0b3JQcmVwcm9jZXNzb3IoZSxoLHkpLHg9bmV3IFRpbWVTbG90TWFuYWdlcjtmdW5jdGlvbiBjbG9zZVBlbmRpbmdSZXN0b3JlT1BTKGUpe2ZvcihsZXQgZT0wLHQ9dy5zYXZlZFN0YXRlc0RlcHRoO2U8dDtlKyspci5hZGRPcChtZSxbXSl9cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbiBwcm9taXNlQm9keShlLGkpe2NvbnN0IG5leHQ9ZnVuY3Rpb24odCl7UHJvbWlzZS5hbGwoW3Qsci5yZWFkeV0pLnRoZW4oKGZ1bmN0aW9uKCl7dHJ5e3Byb21pc2VCb2R5KGUsaSl9Y2F0Y2goZSl7aShlKX19KSxpKX07dC5lbnN1cmVOb3RUZXJtaW5hdGVkKCk7eC5yZXNldCgpO2NvbnN0IHM9e307bGV0IG8sUyxrLEMsdixGO2Zvcig7IShvPXguY2hlY2soKSk7KXtzLmFyZ3M9bnVsbDtpZighdy5yZWFkKHMpKWJyZWFrO2xldCBlPXMuYXJncyxpPXMuZm47c3dpdGNoKDB8aSl7Y2FzZSBidDpGPWVbMF1pbnN0YW5jZW9mIE5hbWU7dj1lWzBdLm5hbWU7aWYoRil7Y29uc3QgdD11LmdldEJ5TmFtZSh2KTtpZih0KXthZGRDYWNoZWRJbWFnZU9wcyhyLHQpO2U9bnVsbDtjb250aW51ZX19bmV4dChuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSxpKXtpZighRil0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlhPYmplY3QgbXVzdCBiZSByZWZlcnJlZCB0byBieSBuYW1lLiIpO2xldCBuPW0uZ2V0UmF3KHYpO2lmKG4gaW5zdGFuY2VvZiBSZWYpe2NvbnN0IHQ9dS5nZXRCeVJlZihuKXx8bC5fcmVnaW9uYWxJbWFnZUNhY2hlLmdldEJ5UmVmKG4pfHxsLmdsb2JhbEltYWdlQ2FjaGUuZ2V0RGF0YShuLGwucGFnZUluZGV4KTtpZih0KXthZGRDYWNoZWRJbWFnZU9wcyhyLHQpO2UoKTtyZXR1cm59bj1oLmZldGNoKG4pfWlmKCEobiBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pKXRocm93IG5ldyBGb3JtYXRFcnJvcigiWE9iamVjdCBzaG91bGQgYmUgYSBzdHJlYW0iKTtjb25zdCBzPW4uZGljdC5nZXQoIlN1YnR5cGUiKTtpZighKHMgaW5zdGFuY2VvZiBOYW1lKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlhPYmplY3Qgc2hvdWxkIGhhdmUgYSBOYW1lIHN1YnR5cGUiKTtpZigiRm9ybSIhPT1zLm5hbWUpaWYoIkltYWdlIiE9PXMubmFtZSl7aWYoIlBTIiE9PXMubmFtZSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVuaGFuZGxlZCBYT2JqZWN0IHN1YnR5cGUgJHtzLm5hbWV9YCk7aW5mbygiSWdub3JlZCBYT2JqZWN0IHN1YnR5cGUgUFMiKTtlKCl9ZWxzZSBsLmJ1aWxkUGFpbnRJbWFnZVhPYmplY3Qoe3Jlc291cmNlczphLGltYWdlOm4sb3BlcmF0b3JMaXN0OnIsY2FjaGVLZXk6dixsb2NhbEltYWdlQ2FjaGU6dSxsb2NhbENvbG9yU3BhY2VDYWNoZTpkfSkudGhlbihlLGkpO2Vsc2V7eS5zYXZlKCk7bC5idWlsZEZvcm1YT2JqZWN0KGEsbixudWxsLHIsdCx5LnN0YXRlLmNsb25lKHtuZXdQYXRoOiEwfSksZCxjKS50aGVuKChmdW5jdGlvbigpe3kucmVzdG9yZSgpO2UoKX0pLGkpfX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24pKXtpZighbC5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO3dhcm4oYGdldE9wZXJhdG9yTGlzdCAtIGlnbm9yaW5nIFhPYmplY3Q6ICIke2V9Ii5gKX19KSkpO3JldHVybjtjYXNlIHFlOmNvbnN0IHM9ZVsxXTtuZXh0KGwuaGFuZGxlU2V0Rm9udChhLGUsbnVsbCxyLHQseS5zdGF0ZSxuKS50aGVuKChmdW5jdGlvbihlKXtyLmFkZERlcGVuZGVuY3koZSk7ci5hZGRPcChxZSxbZSxzXSl9KSkpO3JldHVybjtjYXNlIG10OmNvbnN0IG89ZVswXS5jYWNoZUtleTtpZihvKXtjb25zdCB0PXUuZ2V0QnlOYW1lKG8pO2lmKHQpe2FkZENhY2hlZEltYWdlT3BzKHIsdCk7ZT1udWxsO2NvbnRpbnVlfX1uZXh0KGwuYnVpbGRQYWludEltYWdlWE9iamVjdCh7cmVzb3VyY2VzOmEsaW1hZ2U6ZVswXSxpc0lubGluZTohMCxvcGVyYXRvckxpc3Q6cixjYWNoZUtleTpvLGxvY2FsSW1hZ2VDYWNoZTp1LGxvY2FsQ29sb3JTcGFjZUNhY2hlOmR9KSk7cmV0dXJuO2Nhc2UgS2U6aWYoIXkuc3RhdGUuZm9udCl7bC5lbnN1cmVTdGF0ZUZvbnQoeS5zdGF0ZSk7Y29udGludWV9ZVswXT1sLmhhbmRsZVRleHQoZVswXSx5LnN0YXRlKTticmVhaztjYXNlIEplOmlmKCF5LnN0YXRlLmZvbnQpe2wuZW5zdXJlU3RhdGVGb250KHkuc3RhdGUpO2NvbnRpbnVlfWNvbnN0IHc9W10seD15LnN0YXRlO2Zvcihjb25zdCB0IG9mIGVbMF0pInN0cmluZyI9PXR5cGVvZiB0P3cucHVzaCguLi5sLmhhbmRsZVRleHQodCx4KSk6Im51bWJlciI9PXR5cGVvZiB0JiZ3LnB1c2godCk7ZVswXT13O2k9S2U7YnJlYWs7Y2FzZSBZZTppZigheS5zdGF0ZS5mb250KXtsLmVuc3VyZVN0YXRlRm9udCh5LnN0YXRlKTtjb250aW51ZX1yLmFkZE9wKFZlKTtlWzBdPWwuaGFuZGxlVGV4dChlWzBdLHkuc3RhdGUpO2k9S2U7YnJlYWs7Y2FzZSBaZTppZigheS5zdGF0ZS5mb250KXtsLmVuc3VyZVN0YXRlRm9udCh5LnN0YXRlKTtjb250aW51ZX1yLmFkZE9wKFZlKTtyLmFkZE9wKF9lLFtlLnNoaWZ0KCldKTtyLmFkZE9wKGplLFtlLnNoaWZ0KCldKTtlWzBdPWwuaGFuZGxlVGV4dChlWzBdLHkuc3RhdGUpO2k9S2U7YnJlYWs7Y2FzZSBIZTp5LnN0YXRlLnRleHRSZW5kZXJpbmdNb2RlPWVbMF07YnJlYWs7Y2FzZSBhdDp7Y29uc3QgdD1sLl9nZXRDb2xvclNwYWNlKGVbMF0sYSxkKTtpZih0IGluc3RhbmNlb2YgQ29sb3JTcGFjZSl7eS5zdGF0ZS5maWxsQ29sb3JTcGFjZT10O2NvbnRpbnVlfW5leHQobC5faGFuZGxlQ29sb3JTcGFjZSh0KS50aGVuKChlPT57eS5zdGF0ZS5maWxsQ29sb3JTcGFjZT1lfHxDb2xvclNwYWNlVXRpbHMuZ3JheX0pKSk7cmV0dXJufWNhc2UgdHQ6e2NvbnN0IHQ9bC5fZ2V0Q29sb3JTcGFjZShlWzBdLGEsZCk7aWYodCBpbnN0YW5jZW9mIENvbG9yU3BhY2Upe3kuc3RhdGUuc3Ryb2tlQ29sb3JTcGFjZT10O2NvbnRpbnVlfW5leHQobC5faGFuZGxlQ29sb3JTcGFjZSh0KS50aGVuKChlPT57eS5zdGF0ZS5zdHJva2VDb2xvclNwYWNlPWV8fENvbG9yU3BhY2VVdGlscy5ncmF5fSkpKTtyZXR1cm59Y2FzZSBudDpDPXkuc3RhdGUuZmlsbENvbG9yU3BhY2U7ZT1bQy5nZXRSZ2JIZXgoZSwwKV07aT1odDticmVhaztjYXNlIHJ0OkM9eS5zdGF0ZS5zdHJva2VDb2xvclNwYWNlO2U9W0MuZ2V0UmdiSGV4KGUsMCldO2k9bHQ7YnJlYWs7Y2FzZSBjdDp5LnN0YXRlLmZpbGxDb2xvclNwYWNlPUNvbG9yU3BhY2VVdGlscy5ncmF5O2U9W0NvbG9yU3BhY2VVdGlscy5ncmF5LmdldFJnYkhleChlLDApXTtpPWh0O2JyZWFrO2Nhc2Ugb3Q6eS5zdGF0ZS5zdHJva2VDb2xvclNwYWNlPUNvbG9yU3BhY2VVdGlscy5ncmF5O2U9W0NvbG9yU3BhY2VVdGlscy5ncmF5LmdldFJnYkhleChlLDApXTtpPWx0O2JyZWFrO2Nhc2UgZHQ6eS5zdGF0ZS5maWxsQ29sb3JTcGFjZT1Db2xvclNwYWNlVXRpbHMuY215aztlPVtDb2xvclNwYWNlVXRpbHMuY215ay5nZXRSZ2JIZXgoZSwwKV07aT1odDticmVhaztjYXNlIHV0Onkuc3RhdGUuc3Ryb2tlQ29sb3JTcGFjZT1Db2xvclNwYWNlVXRpbHMuY215aztlPVtDb2xvclNwYWNlVXRpbHMuY215ay5nZXRSZ2JIZXgoZSwwKV07aT1sdDticmVhaztjYXNlIGh0Onkuc3RhdGUuZmlsbENvbG9yU3BhY2U9Q29sb3JTcGFjZVV0aWxzLnJnYjtlPVtDb2xvclNwYWNlVXRpbHMucmdiLmdldFJnYkhleChlLDApXTticmVhaztjYXNlIGx0Onkuc3RhdGUuc3Ryb2tlQ29sb3JTcGFjZT1Db2xvclNwYWNlVXRpbHMucmdiO2U9W0NvbG9yU3BhY2VVdGlscy5yZ2IuZ2V0UmdiSGV4KGUsMCldO2JyZWFrO2Nhc2Ugc3Q6Qz15LnN0YXRlLnBhdHRlcm5GaWxsQ29sb3JTcGFjZTtpZighQyl7aWYoaXNOdW1iZXJBcnJheShlLG51bGwpKXtlPVtDb2xvclNwYWNlVXRpbHMuZ3JheS5nZXRSZ2JIZXgoZSwwKV07aT1odDticmVha31lPVtdO2k9WHQ7YnJlYWt9aWYoIlBhdHRlcm4iPT09Qy5uYW1lKXtuZXh0KGwuaGFuZGxlQ29sb3JOKHIsc3QsZSxDLGIsYSx0LGQsZyxwKSk7cmV0dXJufWU9W0MuZ2V0UmdiSGV4KGUsMCldO2k9aHQ7YnJlYWs7Y2FzZSBpdDpDPXkuc3RhdGUucGF0dGVyblN0cm9rZUNvbG9yU3BhY2U7aWYoIUMpe2lmKGlzTnVtYmVyQXJyYXkoZSxudWxsKSl7ZT1bQ29sb3JTcGFjZVV0aWxzLmdyYXkuZ2V0UmdiSGV4KGUsMCldO2k9bHQ7YnJlYWt9ZT1bXTtpPVV0O2JyZWFrfWlmKCJQYXR0ZXJuIj09PUMubmFtZSl7bmV4dChsLmhhbmRsZUNvbG9yTihyLGl0LGUsQyxiLGEsdCxkLGcscCkpO3JldHVybn1lPVtDLmdldFJnYkhleChlLDApXTtpPWx0O2JyZWFrO2Nhc2UgZnQ6bGV0IFQ7dHJ5e2NvbnN0IHQ9YS5nZXQoIlNoYWRpbmciKTtpZighdCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk5vIHNoYWRpbmcgcmVzb3VyY2UgZm91bmQiKTtUPXQuZ2V0KGVbMF0ubmFtZSk7aWYoIVQpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJObyBzaGFkaW5nIG9iamVjdCBmb3VuZCIpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbiljb250aW51ZTtpZihsLm9wdGlvbnMuaWdub3JlRXJyb3JzKXt3YXJuKGBnZXRPcGVyYXRvckxpc3QgLSBpZ25vcmluZyBTaGFkaW5nOiAiJHtlfSIuYCk7Y29udGludWV9dGhyb3cgZX1jb25zdCBPPWwucGFyc2VTaGFkaW5nKHtzaGFkaW5nOlQscmVzb3VyY2VzOmEsbG9jYWxDb2xvclNwYWNlQ2FjaGU6ZCxsb2NhbFNoYWRpbmdQYXR0ZXJuQ2FjaGU6cH0pO2lmKCFPKWNvbnRpbnVlO2U9W09dO2k9ZnQ7YnJlYWs7Y2FzZSBnZTpGPWVbMF1pbnN0YW5jZW9mIE5hbWU7dj1lWzBdLm5hbWU7aWYoRil7Y29uc3QgdD1mLmdldEJ5TmFtZSh2KTtpZih0KXt0Lmxlbmd0aD4wJiZyLmFkZE9wKGdlLFt0XSk7ZT1udWxsO2NvbnRpbnVlfX1uZXh0KG5ldyBQcm9taXNlKChmdW5jdGlvbihlLGkpe2lmKCFGKXRocm93IG5ldyBGb3JtYXRFcnJvcigiR1N0YXRlIG11c3QgYmUgcmVmZXJyZWQgdG8gYnkgbmFtZS4iKTtjb25zdCBuPWEuZ2V0KCJFeHRHU3RhdGUiKTtpZighKG4gaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkV4dEdTdGF0ZSBzaG91bGQgYmUgYSBkaWN0aW9uYXJ5LiIpO2NvbnN0IHM9bi5nZXQodik7aWYoIShzIGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJHU3RhdGUgc2hvdWxkIGJlIGEgZGljdGlvbmFyeS4iKTtsLnNldEdTdGF0ZSh7cmVzb3VyY2VzOmEsZ1N0YXRlOnMsb3BlcmF0b3JMaXN0OnIsY2FjaGVLZXk6dix0YXNrOnQsc3RhdGVNYW5hZ2VyOnksbG9jYWxHU3RhdGVDYWNoZTpmLGxvY2FsQ29sb3JTcGFjZUNhY2hlOmQsc2VlblJlZnM6Y30pLnRoZW4oZSxpKX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24pKXtpZighbC5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO3dhcm4oYGdldE9wZXJhdG9yTGlzdCAtIGlnbm9yaW5nIEV4dEdTdGF0ZTogIiR7ZX0iLmApfX0pKSk7cmV0dXJuO2Nhc2Ugb2U6e2NvbnN0W3RdPWU7aWYoIm51bWJlciIhPXR5cGVvZiB0KXt3YXJuKGBJbnZhbGlkIHNldExpbmVXaWR0aDogJHt0fWApO2NvbnRpbnVlfWVbMF09TWF0aC5hYnModCk7YnJlYWt9Y2FzZSB1ZTp7Y29uc3QgdD1lWzFdO2lmKCJudW1iZXIiIT10eXBlb2YgdCl7d2FybihgSW52YWxpZCBzZXREYXNoOiAke3R9YCk7Y29udGludWV9Y29uc3QgYT1lWzBdO2lmKCFBcnJheS5pc0FycmF5KGEpKXt3YXJuKGBJbnZhbGlkIHNldERhc2g6ICR7YX1gKTtjb250aW51ZX1hLnNvbWUoKGU9PiJudW1iZXIiIT10eXBlb2YgZSkpJiYoZVswXT1hLmZpbHRlcigoZT0+Im51bWJlciI9PXR5cGVvZiBlKSkpO2JyZWFrfWNhc2UgeWU6Y2FzZSB3ZTpjYXNlIHhlOmNhc2UgU2U6Y2FzZSBBZTpjYXNlIGtlOmNhc2UgQ2U6bC5idWlsZFBhdGgoaSxlLHkuc3RhdGUpO2NvbnRpbnVlO2Nhc2UgdmU6Y2FzZSBGZTpjYXNlIEllOmNhc2UgVGU6Y2FzZSBPZTpjYXNlIE1lOmNhc2UgRGU6Y2FzZSBCZTpjYXNlIFJlOntjb25zdHtzdGF0ZTp7cGF0aEJ1ZmZlcjplLHBhdGhNaW5NYXg6dH19PXk7aSE9PUZlJiZpIT09RGUmJmkhPT1CZXx8ZS5wdXNoKCR0KTtpZigwPT09ZS5sZW5ndGgpci5hZGRPcChfdCxbaSxbbnVsbF0sbnVsbF0pO2Vsc2V7ci5hZGRPcChfdCxbaSxbbmV3IEZsb2F0MzJBcnJheShlKV0sdC5zbGljZSgpXSk7ZS5sZW5ndGg9MDt0LnNldChbMS8wLDEvMCwtMS8wLC0xLzBdLDApfWNvbnRpbnVlfWNhc2UgR2U6ci5hZGRPcChpLFtuZXcgRmxvYXQzMkFycmF5KGUpXSk7Y29udGludWU7Y2FzZSB5dDpjYXNlIHd0OmNhc2Uga3Q6Y2FzZSBDdDpjb250aW51ZTtjYXNlIFN0OmlmKCEoZVswXWluc3RhbmNlb2YgTmFtZSkpe3dhcm4oYEV4cGVjdGVkIG5hbWUgZm9yIGJlZ2luTWFya2VkQ29udGVudFByb3BzIGFyZzA9JHtlWzBdfWApO3IuYWRkT3AoU3QsWyJPQyIsbnVsbF0pO2NvbnRpbnVlfWlmKCJPQyI9PT1lWzBdLm5hbWUpe25leHQobC5wYXJzZU1hcmtlZENvbnRlbnRQcm9wcyhlWzFdLGEpLnRoZW4oKGU9PntyLmFkZE9wKFN0LFsiT0MiLGVdKX0pKS5jYXRjaCgoZT0+e2lmKCEoZSBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uKSl7aWYoIWwub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTt3YXJuKGBnZXRPcGVyYXRvckxpc3QgLSBpZ25vcmluZyBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogIiR7ZX0iLmApO3IuYWRkT3AoU3QsWyJPQyIsbnVsbF0pfX0pKSk7cmV0dXJufWU9W2VbMF0ubmFtZSxlWzFdaW5zdGFuY2VvZiBEaWN0P2VbMV0uZ2V0KCJNQ0lEIik6bnVsbF07YnJlYWs7ZGVmYXVsdDppZihudWxsIT09ZSl7Zm9yKFM9MCxrPWUubGVuZ3RoO1M8ayYmIShlW1NdaW5zdGFuY2VvZiBEaWN0KTtTKyspO2lmKFM8ayl7d2FybigiZ2V0T3BlcmF0b3JMaXN0IC0gaWdub3Jpbmcgb3BlcmF0b3I6ICIraSk7Y29udGludWV9fX1yLmFkZE9wKGksZSl9aWYobyluZXh0KHluKTtlbHNle2Nsb3NlUGVuZGluZ1Jlc3RvcmVPUFMoKTtlKCl9fSkpLmNhdGNoKChlPT57aWYoIShlIGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24pKXtpZighdGhpcy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO3dhcm4oYGdldE9wZXJhdG9yTGlzdCAtIGlnbm9yaW5nIGVycm9ycyBkdXJpbmcgIiR7dC5uYW1lfSIgdGFzazogIiR7ZX0iLmApO2Nsb3NlUGVuZGluZ1Jlc3RvcmVPUFMoKX19KSl9Z2V0VGV4dENvbnRlbnQoe3N0cmVhbTplLHRhc2s6YSxyZXNvdXJjZXM6cixzdGF0ZU1hbmFnZXI6aT1udWxsLGluY2x1ZGVNYXJrZWRDb250ZW50Om49ITEsc2luazpzLHNlZW5TdHlsZXM6bz1uZXcgU2V0LHZpZXdCb3g6YyxsYW5nOmw9bnVsbCxtYXJrZWRDb250ZW50RGF0YTpoPW51bGwsZGlzYWJsZU5vcm1hbGl6YXRpb246dT0hMSxrZWVwV2hpdGVTcGFjZTpkPSExLHByZXZSZWZzOmY9bnVsbCxpbnRlcnNlY3RvcjpnPW51bGx9KXtjb25zdCBwPWUuZGljdD8ub2JqSWQsbT1uZXcgUmVmU2V0KGYpO2lmKHApe2lmKGY/LmhhcyhwKSl0aHJvdyBuZXcgRXJyb3IoYGdldFRleHRDb250ZW50IC0gaWdub3JpbmcgY2lyY3VsYXIgcmVmZXJlbmNlOiAke3B9YCk7bS5wdXQocCl9cnx8PURpY3QuZW1wdHk7aXx8PW5ldyBTdGF0ZU1hbmFnZXIobmV3IFRleHRTdGF0ZSk7biYmKGh8fD17bGV2ZWw6MH0pO2NvbnN0IGI9e2l0ZW1zOltdLHN0eWxlczpPYmplY3QuY3JlYXRlKG51bGwpLGxhbmc6bH0seT17aW5pdGlhbGl6ZWQ6ITEsc3RyOltdLHRvdGFsV2lkdGg6MCx0b3RhbEhlaWdodDowLHdpZHRoOjAsaGVpZ2h0OjAsdmVydGljYWw6ITEscHJldlRyYW5zZm9ybTpudWxsLHRleHRBZHZhbmNlU2NhbGU6MCxzcGFjZUluRmxvd01pbjowLHNwYWNlSW5GbG93TWF4OjAsdHJhY2tpbmdTcGFjZU1pbjoxLzAsbmVnYXRpdmVTcGFjZU1heDotMS8wLG5vdEFTcGFjZTotMS8wLHRyYW5zZm9ybTpudWxsLGZvbnROYW1lOm51bGwsaGFzRU9MOiExfSx3PVsiICIsIiAiXTtsZXQgeD0wO2Z1bmN0aW9uIHNhdmVMYXN0Q2hhcihlKXtjb25zdCB0PSh4KzEpJTIsYT0iICIhPT13W3hdJiYiICI9PT13W3RdO3dbeF09ZTt4PXQ7cmV0dXJuIWQmJmF9ZnVuY3Rpb24gc2hvdWxkQWRkV2hpdGVwc2FjZSgpe3JldHVybiFkJiYiICIhPT13W3hdJiYiICI9PT13Wyh4KzEpJTJdfWZ1bmN0aW9uIHJlc2V0TGFzdENoYXJzKCl7d1swXT13WzFdPSIgIjt4PTB9Y29uc3QgUz10aGlzLGs9dGhpcy54cmVmLEM9W107bGV0IHY9bnVsbDtjb25zdCBGPW5ldyBMb2NhbEltYWdlQ2FjaGUsVD1uZXcgTG9jYWxHU3RhdGVDYWNoZSxPPW5ldyBFdmFsdWF0b3JQcmVwcm9jZXNzb3IoZSxrLGkpO2xldCBNO2Z1bmN0aW9uIHB1c2hXaGl0ZXNwYWNlKHt3aWR0aDplPTAsaGVpZ2h0OnQ9MCx0cmFuc2Zvcm06YT15LnByZXZUcmFuc2Zvcm0sZm9udE5hbWU6cj15LmZvbnROYW1lfSl7Zz8uYWRkRXh0cmFDaGFyKCIgIik7Yi5pdGVtcy5wdXNoKHtzdHI6IiAiLGRpcjoibHRyIix3aWR0aDplLGhlaWdodDp0LHRyYW5zZm9ybTphLGZvbnROYW1lOnIsaGFzRU9MOiExfSl9ZnVuY3Rpb24gZ2V0Q3VycmVudFRleHRUcmFuc2Zvcm0oKXtjb25zdCBlPU0uZm9udCxhPVtNLmZvbnRTaXplKk0udGV4dEhTY2FsZSwwLDAsTS5mb250U2l6ZSwwLE0udGV4dFJpc2VdO2lmKGUuaXNUeXBlM0ZvbnQmJihNLmZvbnRTaXplPD0xfHxlLmlzQ2hhckJCb3gpJiYhaXNBcnJheUVxdWFsKE0uZm9udE1hdHJpeCx0KSl7Y29uc3QgdD1lLmJib3hbM10tZS5iYm94WzFdO3Q+MCYmKGFbM10qPXQqTS5mb250TWF0cml4WzNdKX1yZXR1cm4gVXRpbC50cmFuc2Zvcm0oTS5jdG0sVXRpbC50cmFuc2Zvcm0oTS50ZXh0TWF0cml4LGEpKX1mdW5jdGlvbiBlbnN1cmVUZXh0Q29udGVudEl0ZW0oKXtpZih5LmluaXRpYWxpemVkKXJldHVybiB5O2NvbnN0e2ZvbnQ6ZSxsb2FkZWROYW1lOnR9PU07aWYoIW8uaGFzKHQpKXtvLmFkZCh0KTtiLnN0eWxlc1t0XT17Zm9udEZhbWlseTplLmZhbGxiYWNrTmFtZSxhc2NlbnQ6ZS5hc2NlbnQsZGVzY2VudDplLmRlc2NlbnQsdmVydGljYWw6ZS52ZXJ0aWNhbH07aWYoUy5vcHRpb25zLmZvbnRFeHRyYVByb3BlcnRpZXMmJmUuc3lzdGVtRm9udEluZm8pe2NvbnN0IGE9Yi5zdHlsZXNbdF07YS5mb250U3Vic3RpdHV0aW9uPWUuc3lzdGVtRm9udEluZm8uY3NzO2EuZm9udFN1YnN0aXR1dGlvbkxvYWRlZE5hbWU9ZS5zeXN0ZW1Gb250SW5mby5sb2FkZWROYW1lfX15LmZvbnROYW1lPXQ7Y29uc3QgYT15LnRyYW5zZm9ybT1nZXRDdXJyZW50VGV4dFRyYW5zZm9ybSgpO2lmKGUudmVydGljYWwpe3kud2lkdGg9eS50b3RhbFdpZHRoPU1hdGguaHlwb3QoYVswXSxhWzFdKTt5LmhlaWdodD15LnRvdGFsSGVpZ2h0PTA7eS52ZXJ0aWNhbD0hMH1lbHNle3kud2lkdGg9eS50b3RhbFdpZHRoPTA7eS5oZWlnaHQ9eS50b3RhbEhlaWdodD1NYXRoLmh5cG90KGFbMl0sYVszXSk7eS52ZXJ0aWNhbD0hMX1jb25zdCByPU1hdGguaHlwb3QoTS50ZXh0TGluZU1hdHJpeFswXSxNLnRleHRMaW5lTWF0cml4WzFdKSxpPU1hdGguaHlwb3QoTS5jdG1bMF0sTS5jdG1bMV0pO3kudGV4dEFkdmFuY2VTY2FsZT1pKnI7Y29uc3R7Zm9udFNpemU6bn09TTt5LnRyYWNraW5nU3BhY2VNaW49LjEwMipuO3kubm90QVNwYWNlPS4wMypuO3kubmVnYXRpdmVTcGFjZU1heD0tLjIqbjt5LnNwYWNlSW5GbG93TWluPS4xMDIqbjt5LnNwYWNlSW5GbG93TWF4PS42Km47eS5oYXNFT0w9ITE7eS5pbml0aWFsaXplZD0hMDtyZXR1cm4geX1mdW5jdGlvbiB1cGRhdGVBZHZhbmNlU2NhbGUoKXtpZigheS5pbml0aWFsaXplZClyZXR1cm47Y29uc3QgZT1NYXRoLmh5cG90KE0udGV4dExpbmVNYXRyaXhbMF0sTS50ZXh0TGluZU1hdHJpeFsxXSksdD1NYXRoLmh5cG90KE0uY3RtWzBdLE0uY3RtWzFdKSplO2lmKHQhPT15LnRleHRBZHZhbmNlU2NhbGUpe2lmKHkudmVydGljYWwpe3kudG90YWxIZWlnaHQrPXkuaGVpZ2h0KnkudGV4dEFkdmFuY2VTY2FsZTt5LmhlaWdodD0wfWVsc2V7eS50b3RhbFdpZHRoKz15LndpZHRoKnkudGV4dEFkdmFuY2VTY2FsZTt5LndpZHRoPTB9eS50ZXh0QWR2YW5jZVNjYWxlPXR9fWZ1bmN0aW9uIHJ1bkJpZGlUcmFuc2Zvcm0oZSl7bGV0IHQ9ZS5zdHIuam9pbigiIik7dXx8KHQ9ZnVuY3Rpb24gbm9ybWFsaXplVW5pY29kZShlKXtpZighUXQpe1F0PS8oW1x1MDBhMFx1MDBiNVx1MDM3ZVx1MGViM1x1MjAwMC1cdTIwMGFcdTIwMmZcdTIxMjZcdWZiMDAtXHVmYjA0XHVmYjA2XHVmYjIwLVx1ZmIzNlx1ZmIzOC1cdWZiM2NcdWZiM2VcdWZiNDAtXHVmYjQxXHVmYjQzLVx1ZmI0NFx1ZmI0Ni1cdWZiYTFcdWZiYTQtXHVmYmE5XHVmYmFlLVx1ZmJiMVx1ZmJkMy1cdWZiZGNcdWZiZGUtXHVmYmU3XHVmYmVhLVx1ZmJmOFx1ZmJmYy1cdWZiZmRcdWZjMDAtXHVmYzVkXHVmYzY0LVx1ZmNmMVx1ZmNmNS1cdWZkM2RcdWZkODhcdWZkZjRcdWZkZmEtXHVmZGZiXHVmZTcxXHVmZTc3XHVmZTc5XHVmZTdiXHVmZTdkXSspfChcdWZiMDUrKS9ndTtlYT1uZXcgTWFwKFtbIu+shSIsIsW/dCJdXSl9cmV0dXJuIGUucmVwbGFjZUFsbChRdCwoKGUsdCxhKT0+dD90Lm5vcm1hbGl6ZSgiTkZLQyIpOmVhLmdldChhKSkpfSh0KSk7Y29uc3QgYT1iaWRpKHQsLTEsZS52ZXJ0aWNhbCk7cmV0dXJue3N0cjphLnN0cixkaXI6YS5kaXIsd2lkdGg6TWF0aC5hYnMoZS50b3RhbFdpZHRoKSxoZWlnaHQ6TWF0aC5hYnMoZS50b3RhbEhlaWdodCksdHJhbnNmb3JtOmUudHJhbnNmb3JtLGZvbnROYW1lOmUuZm9udE5hbWUsaGFzRU9MOmUuaGFzRU9MfX1hc3luYyBmdW5jdGlvbiBoYW5kbGVTZXRGb250KGUsaSl7Y29uc3Qgbj1hd2FpdCBTLmxvYWRGb250KGUsaSxyLGEpO00ubG9hZGVkTmFtZT1uLmxvYWRlZE5hbWU7TS5mb250PW4uZm9udDtNLmZvbnRNYXRyaXg9bi5mb250LmZvbnRNYXRyaXh8fHR9ZnVuY3Rpb24gYXBwbHlJbnZlcnNlUm90YXRpb24oZSx0LGEpe2NvbnN0IHI9TWF0aC5oeXBvdChhWzBdLGFbMV0pO3JldHVyblsoYVswXSplK2FbMV0qdCkvciwoYVsyXSplK2FbM10qdCkvcl19ZnVuY3Rpb24gY29tcGFyZVdpdGhMYXN0UG9zaXRpb24oZSl7Y29uc3QgdD1nZXRDdXJyZW50VGV4dFRyYW5zZm9ybSgpO2xldCBhPXRbNF0scj10WzVdO2lmKE0uZm9udD8udmVydGljYWwpe2lmKGE8Y1swXXx8YT5jWzJdfHxyK2U8Y1sxXXx8cj5jWzNdKXJldHVybiExfWVsc2UgaWYoYStlPGNbMF18fGE+Y1syXXx8cjxjWzFdfHxyPmNbM10pcmV0dXJuITE7aWYoIU0uZm9udHx8IXkucHJldlRyYW5zZm9ybSlyZXR1cm4hMDtsZXQgaT15LnByZXZUcmFuc2Zvcm1bNF0sbj15LnByZXZUcmFuc2Zvcm1bNV07aWYoaT09PWEmJm49PT1yKXJldHVybiEwO2xldCBzPS0xO3RbMF0mJjA9PT10WzFdJiYwPT09dFsyXT9zPXRbMF0+MD8wOjE4MDp0WzFdJiYwPT09dFswXSYmMD09PXRbM10mJihzPXRbMV0+MD85MDoyNzApO3N3aXRjaChzKXtjYXNlIDA6YnJlYWs7Y2FzZSA5MDpbYSxyXT1bcixhXTtbaSxuXT1bbixpXTticmVhaztjYXNlIDE4MDpbYSxyLGksbl09Wy1hLC1yLC1pLC1uXTticmVhaztjYXNlIDI3MDpbYSxyXT1bLXIsLWFdO1tpLG5dPVstbiwtaV07YnJlYWs7ZGVmYXVsdDpbYSxyXT1hcHBseUludmVyc2VSb3RhdGlvbihhLHIsdCk7W2ksbl09YXBwbHlJbnZlcnNlUm90YXRpb24oaSxuLHkucHJldlRyYW5zZm9ybSl9aWYoTS5mb250LnZlcnRpY2FsKXtjb25zdCBlPShuLXIpL3kudGV4dEFkdmFuY2VTY2FsZSx0PWEtaSxzPU1hdGguc2lnbih5LmhlaWdodCk7aWYoZTxzKnkubmVnYXRpdmVTcGFjZU1heCl7aWYoTWF0aC5hYnModCk+LjUqeS53aWR0aCl7YXBwZW5kRU9MKCk7cmV0dXJuITB9cmVzZXRMYXN0Q2hhcnMoKTtmbHVzaFRleHRDb250ZW50SXRlbSgpO3JldHVybiEwfWlmKE1hdGguYWJzKHQpPnkud2lkdGgpe2FwcGVuZEVPTCgpO3JldHVybiEwfWU8PXMqeS5ub3RBU3BhY2UmJnJlc2V0TGFzdENoYXJzKCk7aWYoZTw9cyp5LnRyYWNraW5nU3BhY2VNaW4paWYoc2hvdWxkQWRkV2hpdGVwc2FjZSgpKXtyZXNldExhc3RDaGFycygpO2ZsdXNoVGV4dENvbnRlbnRJdGVtKCk7cHVzaFdoaXRlc3BhY2Uoe2hlaWdodDpNYXRoLmFicyhlKX0pfWVsc2UgeS5oZWlnaHQrPWU7ZWxzZSBpZighYWRkRmFrZVNwYWNlcyhlLHkucHJldlRyYW5zZm9ybSxzKSlpZigwPT09eS5zdHIubGVuZ3RoKXtyZXNldExhc3RDaGFycygpO3B1c2hXaGl0ZXNwYWNlKHtoZWlnaHQ6TWF0aC5hYnMoZSl9KX1lbHNlIHkuaGVpZ2h0Kz1lO01hdGguYWJzKHQpPi4yNSp5LndpZHRoJiZmbHVzaFRleHRDb250ZW50SXRlbSgpO3JldHVybiEwfWNvbnN0IG89KGEtaSkveS50ZXh0QWR2YW5jZVNjYWxlLGw9ci1uLGg9TWF0aC5zaWduKHkud2lkdGgpO2lmKG88aCp5Lm5lZ2F0aXZlU3BhY2VNYXgpe2lmKE1hdGguYWJzKGwpPi41KnkuaGVpZ2h0KXthcHBlbmRFT0woKTtyZXR1cm4hMH1yZXNldExhc3RDaGFycygpO2ZsdXNoVGV4dENvbnRlbnRJdGVtKCk7cmV0dXJuITB9aWYoTWF0aC5hYnMobCk+eS5oZWlnaHQpe2FwcGVuZEVPTCgpO3JldHVybiEwfW88PWgqeS5ub3RBU3BhY2UmJnJlc2V0TGFzdENoYXJzKCk7aWYobzw9aCp5LnRyYWNraW5nU3BhY2VNaW4paWYoc2hvdWxkQWRkV2hpdGVwc2FjZSgpKXtyZXNldExhc3RDaGFycygpO2ZsdXNoVGV4dENvbnRlbnRJdGVtKCk7cHVzaFdoaXRlc3BhY2Uoe3dpZHRoOk1hdGguYWJzKG8pfSl9ZWxzZSB5LndpZHRoKz1vO2Vsc2UgaWYoIWFkZEZha2VTcGFjZXMobyx5LnByZXZUcmFuc2Zvcm0saCkpaWYoMD09PXkuc3RyLmxlbmd0aCl7cmVzZXRMYXN0Q2hhcnMoKTtwdXNoV2hpdGVzcGFjZSh7d2lkdGg6TWF0aC5hYnMobyl9KX1lbHNlIHkud2lkdGgrPW87TWF0aC5hYnMobCk+LjI1KnkuaGVpZ2h0JiZmbHVzaFRleHRDb250ZW50SXRlbSgpO3JldHVybiEwfWZ1bmN0aW9uIGJ1aWxkVGV4dENvbnRlbnRJdGVtKHtjaGFyczplLGV4dHJhU3BhY2luZzp0fSl7Y29uc3QgYT1NLmZvbnQ7aWYoIWUpe2NvbnN0IGU9TS5jaGFyU3BhY2luZyt0O2UmJihhLnZlcnRpY2FsP00udHJhbnNsYXRlVGV4dE1hdHJpeCgwLC1lKTpNLnRyYW5zbGF0ZVRleHRNYXRyaXgoZSpNLnRleHRIU2NhbGUsMCkpO2QmJmNvbXBhcmVXaXRoTGFzdFBvc2l0aW9uKDApO3JldHVybn1jb25zdCByPWEuY2hhcnNUb0dseXBocyhlKSxpPU0uZm9udE1hdHJpeFswXSpNLmZvbnRTaXplO2ZvcihsZXQgZT0wLG49ci5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgcz1yW2VdLHtjYXRlZ29yeTpvfT1zO2lmKG8uaXNJbnZpc2libGVGb3JtYXRNYXJrKWNvbnRpbnVlO2xldCBjPU0uY2hhclNwYWNpbmcrKGUrMT09PW4/dDowKSxsPXMud2lkdGg7YS52ZXJ0aWNhbCYmKGw9cy52bWV0cmljP3Mudm1ldHJpY1swXTotbCk7bGV0IGg9bCppO2lmKCFkJiZvLmlzV2hpdGVzcGFjZSl7aWYoYS52ZXJ0aWNhbCl7Yys9LWgrTS53b3JkU3BhY2luZztNLnRyYW5zbGF0ZVRleHRNYXRyaXgoMCwtYyl9ZWxzZXtjKz1oK00ud29yZFNwYWNpbmc7TS50cmFuc2xhdGVUZXh0TWF0cml4KGMqTS50ZXh0SFNjYWxlLDApfXNhdmVMYXN0Q2hhcigiICIpO2NvbnRpbnVlfWlmKCFvLmlzWmVyb1dpZHRoRGlhY3JpdGljJiYhY29tcGFyZVdpdGhMYXN0UG9zaXRpb24oaCkpe2EudmVydGljYWw/TS50cmFuc2xhdGVUZXh0TWF0cml4KDAsaCk6TS50cmFuc2xhdGVUZXh0TWF0cml4KGgqTS50ZXh0SFNjYWxlLDApO2NvbnRpbnVlfWNvbnN0IHU9ZW5zdXJlVGV4dENvbnRlbnRJdGVtKCk7by5pc1plcm9XaWR0aERpYWNyaXRpYyYmKGg9MCk7aWYoYS52ZXJ0aWNhbCl7Zz8uYWRkR2x5cGgoZ2V0Q3VycmVudFRleHRUcmFuc2Zvcm0oKSwwLGgscy51bmljb2RlKTtNLnRyYW5zbGF0ZVRleHRNYXRyaXgoMCxoKTtoPU1hdGguYWJzKGgpO3UuaGVpZ2h0Kz1ofWVsc2V7aCo9TS50ZXh0SFNjYWxlO2c/LmFkZEdseXBoKGdldEN1cnJlbnRUZXh0VHJhbnNmb3JtKCksaCwwLHMudW5pY29kZSk7TS50cmFuc2xhdGVUZXh0TWF0cml4KGgsMCk7dS53aWR0aCs9aH1oJiYodS5wcmV2VHJhbnNmb3JtPWdldEN1cnJlbnRUZXh0VHJhbnNmb3JtKCkpO2NvbnN0IGY9cy51bmljb2RlO2lmKHNhdmVMYXN0Q2hhcihmKSl7dS5zdHIucHVzaCgiICIpO2c/LmFkZEV4dHJhQ2hhcigiICIpfWd8fHUuc3RyLnB1c2goZik7YyYmKGEudmVydGljYWw/TS50cmFuc2xhdGVUZXh0TWF0cml4KDAsLWMpOk0udHJhbnNsYXRlVGV4dE1hdHJpeChjKk0udGV4dEhTY2FsZSwwKSl9fWZ1bmN0aW9uIGFwcGVuZEVPTCgpe2c/LmFkZEV4dHJhQ2hhcigiXG4iKTtyZXNldExhc3RDaGFycygpO2lmKHkuaW5pdGlhbGl6ZWQpe3kuaGFzRU9MPSEwO2ZsdXNoVGV4dENvbnRlbnRJdGVtKCl9ZWxzZSBiLml0ZW1zLnB1c2goe3N0cjoiIixkaXI6Imx0ciIsd2lkdGg6MCxoZWlnaHQ6MCx0cmFuc2Zvcm06Z2V0Q3VycmVudFRleHRUcmFuc2Zvcm0oKSxmb250TmFtZTpNLmxvYWRlZE5hbWUsaGFzRU9MOiEwfSl9ZnVuY3Rpb24gYWRkRmFrZVNwYWNlcyhlLHQsYSl7aWYoYSp5LnNwYWNlSW5GbG93TWluPD1lJiZlPD1hKnkuc3BhY2VJbkZsb3dNYXgpe2lmKHkuaW5pdGlhbGl6ZWQpe3Jlc2V0TGFzdENoYXJzKCk7eS5zdHIucHVzaCgiICIpO2c/LmFkZEV4dHJhQ2hhcigiICIpfXJldHVybiExfWNvbnN0IHI9eS5mb250TmFtZTtsZXQgaT0wO2lmKHkudmVydGljYWwpe2k9ZTtlPTB9Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtyZXNldExhc3RDaGFycygpO3B1c2hXaGl0ZXNwYWNlKHt3aWR0aDpNYXRoLmFicyhlKSxoZWlnaHQ6TWF0aC5hYnMoaSksdHJhbnNmb3JtOnR8fGdldEN1cnJlbnRUZXh0VHJhbnNmb3JtKCksZm9udE5hbWU6cn0pO3JldHVybiEwfWZ1bmN0aW9uIGZsdXNoVGV4dENvbnRlbnRJdGVtKCl7aWYoeS5pbml0aWFsaXplZCYmeS5zdHIpe3kudmVydGljYWw/eS50b3RhbEhlaWdodCs9eS5oZWlnaHQqeS50ZXh0QWR2YW5jZVNjYWxlOnkudG90YWxXaWR0aCs9eS53aWR0aCp5LnRleHRBZHZhbmNlU2NhbGU7Yi5pdGVtcy5wdXNoKHJ1bkJpZGlUcmFuc2Zvcm0oeSkpO3kuaW5pdGlhbGl6ZWQ9ITE7eS5zdHIubGVuZ3RoPTB9fWZ1bmN0aW9uIGVucXVldWVDaHVuayhlPSExKXtjb25zdCB0PWIuaXRlbXMubGVuZ3RoO2lmKDAhPT10JiYhKGUmJnQ8MTApKXtzPy5lbnF1ZXVlKGIsdCk7Yi5pdGVtcz1bXTtiLnN0eWxlcz1PYmplY3QuY3JlYXRlKG51bGwpfX1jb25zdCBEPW5ldyBUaW1lU2xvdE1hbmFnZXI7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbiBwcm9taXNlQm9keShlLHQpe2NvbnN0IG5leHQ9ZnVuY3Rpb24oYSl7ZW5xdWV1ZUNodW5rKCEwKTtQcm9taXNlLmFsbChbYSxzPy5yZWFkeV0pLnRoZW4oKGZ1bmN0aW9uKCl7dHJ5e3Byb21pc2VCb2R5KGUsdCl9Y2F0Y2goZSl7dChlKX19KSx0KX07YS5lbnN1cmVOb3RUZXJtaW5hdGVkKCk7RC5yZXNldCgpO2NvbnN0IGY9e307bGV0IGcscCx5LHc9W107Zm9yKDshKGc9RC5jaGVjaygpKTspe3cubGVuZ3RoPTA7Zi5hcmdzPXc7aWYoIU8ucmVhZChmKSlicmVhaztjb25zdCBlPU07TT1pLnN0YXRlO2NvbnN0IHQ9Zi5mbjt3PWYuYXJncztzd2l0Y2goMHx0KXtjYXNlIHFlOmNvbnN0IHQ9d1swXS5uYW1lLGY9d1sxXTtpZihNLmZvbnQmJnQ9PT1NLmZvbnROYW1lJiZmPT09TS5mb250U2l6ZSlicmVhaztmbHVzaFRleHRDb250ZW50SXRlbSgpO00uZm9udE5hbWU9dDtNLmZvbnRTaXplPWY7bmV4dChoYW5kbGVTZXRGb250KHQsbnVsbCkpO3JldHVybjtjYXNlIFdlOk0udGV4dFJpc2U9d1swXTticmVhaztjYXNlIFVlOk0udGV4dEhTY2FsZT13WzBdLzEwMDticmVhaztjYXNlIFhlOk0ubGVhZGluZz13WzBdO2JyZWFrO2Nhc2UgemU6TS50cmFuc2xhdGVUZXh0TGluZU1hdHJpeCh3WzBdLHdbMV0pO00udGV4dE1hdHJpeD1NLnRleHRMaW5lTWF0cml4LnNsaWNlKCk7YnJlYWs7Y2FzZSAkZTpNLmxlYWRpbmc9LXdbMV07TS50cmFuc2xhdGVUZXh0TGluZU1hdHJpeCh3WzBdLHdbMV0pO00udGV4dE1hdHJpeD1NLnRleHRMaW5lTWF0cml4LnNsaWNlKCk7YnJlYWs7Y2FzZSBWZTpNLmNhcnJpYWdlUmV0dXJuKCk7YnJlYWs7Y2FzZSBHZTpNLnNldFRleHRNYXRyaXgod1swXSx3WzFdLHdbMl0sd1szXSx3WzRdLHdbNV0pO00uc2V0VGV4dExpbmVNYXRyaXgod1swXSx3WzFdLHdbMl0sd1szXSx3WzRdLHdbNV0pO3VwZGF0ZUFkdmFuY2VTY2FsZSgpO2JyZWFrO2Nhc2UgamU6TS5jaGFyU3BhY2luZz13WzBdO2JyZWFrO2Nhc2UgX2U6TS53b3JkU3BhY2luZz13WzBdO2JyZWFrO2Nhc2UgUGU6TS50ZXh0TWF0cml4PWxhLnNsaWNlKCk7TS50ZXh0TGluZU1hdHJpeD1sYS5zbGljZSgpO2JyZWFrO2Nhc2UgSmU6aWYoIWkuc3RhdGUuZm9udCl7Uy5lbnN1cmVTdGF0ZUZvbnQoaS5zdGF0ZSk7Y29udGludWV9Y29uc3QgZz0oTS5mb250LnZlcnRpY2FsPzE6LTEpKk0uZm9udFNpemUvMWUzLHg9d1swXTtmb3IobGV0IGU9MCx0PXgubGVuZ3RoO2U8dDtlKyspe2NvbnN0IHQ9eFtlXTtpZigic3RyaW5nIj09dHlwZW9mIHQpQy5wdXNoKHQpO2Vsc2UgaWYoIm51bWJlciI9PXR5cGVvZiB0JiYwIT09dCl7Y29uc3QgZT1DLmpvaW4oIiIpO0MubGVuZ3RoPTA7YnVpbGRUZXh0Q29udGVudEl0ZW0oe2NoYXJzOmUsZXh0cmFTcGFjaW5nOnQqZ30pfX1pZihDLmxlbmd0aD4wKXtjb25zdCBlPUMuam9pbigiIik7Qy5sZW5ndGg9MDtidWlsZFRleHRDb250ZW50SXRlbSh7Y2hhcnM6ZSxleHRyYVNwYWNpbmc6MH0pfWJyZWFrO2Nhc2UgS2U6aWYoIWkuc3RhdGUuZm9udCl7Uy5lbnN1cmVTdGF0ZUZvbnQoaS5zdGF0ZSk7Y29udGludWV9YnVpbGRUZXh0Q29udGVudEl0ZW0oe2NoYXJzOndbMF0sZXh0cmFTcGFjaW5nOjB9KTticmVhaztjYXNlIFllOmlmKCFpLnN0YXRlLmZvbnQpe1MuZW5zdXJlU3RhdGVGb250KGkuc3RhdGUpO2NvbnRpbnVlfU0uY2FycmlhZ2VSZXR1cm4oKTtidWlsZFRleHRDb250ZW50SXRlbSh7Y2hhcnM6d1swXSxleHRyYVNwYWNpbmc6MH0pO2JyZWFrO2Nhc2UgWmU6aWYoIWkuc3RhdGUuZm9udCl7Uy5lbnN1cmVTdGF0ZUZvbnQoaS5zdGF0ZSk7Y29udGludWV9TS53b3JkU3BhY2luZz13WzBdO00uY2hhclNwYWNpbmc9d1sxXTtNLmNhcnJpYWdlUmV0dXJuKCk7YnVpbGRUZXh0Q29udGVudEl0ZW0oe2NoYXJzOndbMl0sZXh0cmFTcGFjaW5nOjB9KTticmVhaztjYXNlIGJ0OmZsdXNoVGV4dENvbnRlbnRJdGVtKCk7dj8/PXIuZ2V0KCJYT2JqZWN0Iil8fERpY3QuZW1wdHk7eT13WzBdaW5zdGFuY2VvZiBOYW1lO3A9d1swXS5uYW1lO2lmKHkmJkYuZ2V0QnlOYW1lKHApKWJyZWFrO25leHQobmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7aWYoIXkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJYT2JqZWN0IG11c3QgYmUgcmVmZXJyZWQgdG8gYnkgbmFtZS4iKTtsZXQgZj12LmdldFJhdyhwKTtpZihmIGluc3RhbmNlb2YgUmVmKXtpZihGLmdldEJ5UmVmKGYpKXtlKCk7cmV0dXJufWlmKFMuZ2xvYmFsSW1hZ2VDYWNoZS5nZXREYXRhKGYsUy5wYWdlSW5kZXgpKXtlKCk7cmV0dXJufWY9ay5mZXRjaChmKX1pZighKGYgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlhPYmplY3Qgc2hvdWxkIGJlIGEgc3RyZWFtIik7Y29uc3R7ZGljdDpnfT1mLGI9Zy5nZXQoIlN1YnR5cGUiKTtpZighKGIgaW5zdGFuY2VvZiBOYW1lKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlhPYmplY3Qgc2hvdWxkIGhhdmUgYSBOYW1lIHN1YnR5cGUiKTtpZigiRm9ybSIhPT1iLm5hbWUpe0Yuc2V0KHAsZy5vYmpJZCwhMCk7ZSgpO3JldHVybn1jb25zdCB3PWkuc3RhdGUuY2xvbmUoKSx4PW5ldyBTdGF0ZU1hbmFnZXIodyksQz1sb29rdXBNYXRyaXgoZy5nZXRBcnJheSgiTWF0cml4IiksbnVsbCk7QyYmeC50cmFuc2Zvcm0oQyk7Y29uc3QgVD1nLmdldCgiUmVzb3VyY2VzIik7ZW5xdWV1ZUNodW5rKCk7Y29uc3QgTz17ZW5xdWV1ZUludm9rZWQ6ITEsZW5xdWV1ZShlLHQpe3RoaXMuZW5xdWV1ZUludm9rZWQ9ITA7cy5lbnF1ZXVlKGUsdCl9LGdldCBkZXNpcmVkU2l6ZSgpe3JldHVybiBzLmRlc2lyZWRTaXplPz8wfSxnZXQgcmVhZHkoKXtyZXR1cm4gcy5yZWFkeX19O1MuZ2V0VGV4dENvbnRlbnQoe3N0cmVhbTpmLHRhc2s6YSxyZXNvdXJjZXM6VCBpbnN0YW5jZW9mIERpY3Q/VDpyLHN0YXRlTWFuYWdlcjp4LGluY2x1ZGVNYXJrZWRDb250ZW50Om4sc2luazpzJiZPLHNlZW5TdHlsZXM6byx2aWV3Qm94OmMsbGFuZzpsLG1hcmtlZENvbnRlbnREYXRhOmgsZGlzYWJsZU5vcm1hbGl6YXRpb246dSxrZWVwV2hpdGVTcGFjZTpkLHByZXZSZWZzOm19KS50aGVuKChmdW5jdGlvbigpe08uZW5xdWV1ZUludm9rZWR8fEYuc2V0KHAsZy5vYmpJZCwhMCk7ZSgpfSksdCl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uKSl7aWYoIVMub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTt3YXJuKGBnZXRUZXh0Q29udGVudCAtIGlnbm9yaW5nIFhPYmplY3Q6ICIke2V9Ii5gKX19KSkpO3JldHVybjtjYXNlIGdlOnk9d1swXWluc3RhbmNlb2YgTmFtZTtwPXdbMF0ubmFtZTtpZih5JiZULmdldEJ5TmFtZShwKSlicmVhaztuZXh0KG5ldyBQcm9taXNlKChmdW5jdGlvbihlLHQpe2lmKCF5KXRocm93IG5ldyBGb3JtYXRFcnJvcigiR1N0YXRlIG11c3QgYmUgcmVmZXJyZWQgdG8gYnkgbmFtZS4iKTtjb25zdCBhPXIuZ2V0KCJFeHRHU3RhdGUiKTtpZighKGEgaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkV4dEdTdGF0ZSBzaG91bGQgYmUgYSBkaWN0aW9uYXJ5LiIpO2NvbnN0IGk9YS5nZXQocCk7aWYoIShpIGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJHU3RhdGUgc2hvdWxkIGJlIGEgZGljdGlvbmFyeS4iKTtjb25zdCBuPWkuZ2V0KCJGb250Iik7aWYobil7Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtNLmZvbnROYW1lPW51bGw7TS5mb250U2l6ZT1uWzFdO2hhbmRsZVNldEZvbnQobnVsbCxuWzBdKS50aGVuKGUsdCl9ZWxzZXtULnNldChwLGkub2JqSWQsITApO2UoKX19KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uKSl7aWYoIVMub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTt3YXJuKGBnZXRUZXh0Q29udGVudCAtIGlnbm9yaW5nIEV4dEdTdGF0ZTogIiR7ZX0iLmApfX0pKSk7cmV0dXJuO2Nhc2UgeHQ6Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtpZihuKXtoLmxldmVsKys7Yi5pdGVtcy5wdXNoKHt0eXBlOiJiZWdpbk1hcmtlZENvbnRlbnQiLHRhZzp3WzBdaW5zdGFuY2VvZiBOYW1lP3dbMF0ubmFtZTpudWxsfSl9YnJlYWs7Y2FzZSBTdDpmbHVzaFRleHRDb250ZW50SXRlbSgpO2lmKG4pe2gubGV2ZWwrKztsZXQgZT1udWxsO3dbMV1pbnN0YW5jZW9mIERpY3QmJihlPXdbMV0uZ2V0KCJNQ0lEIikpO2IuaXRlbXMucHVzaCh7dHlwZToiYmVnaW5NYXJrZWRDb250ZW50UHJvcHMiLGlkOk51bWJlci5pc0ludGVnZXIoZSk/YCR7Uy5pZEZhY3RvcnkuZ2V0UGFnZU9iaklkKCl9X21jJHtlfWA6bnVsbCx0YWc6d1swXWluc3RhbmNlb2YgTmFtZT93WzBdLm5hbWU6bnVsbH0pfWJyZWFrO2Nhc2UgQXQ6Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtpZihuKXtpZigwPT09aC5sZXZlbClicmVhaztoLmxldmVsLS07Yi5pdGVtcy5wdXNoKHt0eXBlOiJlbmRNYXJrZWRDb250ZW50In0pfWJyZWFrO2Nhc2UgbWU6IWV8fGUuZm9udD09PU0uZm9udCYmZS5mb250U2l6ZT09PU0uZm9udFNpemUmJmUuZm9udE5hbWU9PT1NLmZvbnROYW1lfHxmbHVzaFRleHRDb250ZW50SXRlbSgpfWlmKGIuaXRlbXMubGVuZ3RoPj0ocz8uZGVzaXJlZFNpemU/PzEpKXtnPSEwO2JyZWFrfX1pZihnKW5leHQoeW4pO2Vsc2V7Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtlbnF1ZXVlQ2h1bmsoKTtlKCl9fSkpLmNhdGNoKChlPT57aWYoIShlIGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24pKXtpZighdGhpcy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO3dhcm4oYGdldFRleHRDb250ZW50IC0gaWdub3JpbmcgZXJyb3JzIGR1cmluZyAiJHthLm5hbWV9IiB0YXNrOiAiJHtlfSIuYCk7Zmx1c2hUZXh0Q29udGVudEl0ZW0oKTtlbnF1ZXVlQ2h1bmsoKX19KSl9YXN5bmMgZXh0cmFjdERhdGFTdHJ1Y3R1cmVzKGUsdCl7Y29uc3QgYT10aGlzLnhyZWY7bGV0IHI7Y29uc3QgaT10aGlzLnJlYWRUb1VuaWNvZGUodC50b1VuaWNvZGUpO2lmKHQuY29tcG9zaXRlKXtjb25zdCBhPWUuZ2V0KCJDSURTeXN0ZW1JbmZvIik7YSBpbnN0YW5jZW9mIERpY3QmJih0LmNpZFN5c3RlbUluZm89e3JlZ2lzdHJ5OnN0cmluZ1RvUERGU3RyaW5nKGEuZ2V0KCJSZWdpc3RyeSIpKSxvcmRlcmluZzpzdHJpbmdUb1BERlN0cmluZyhhLmdldCgiT3JkZXJpbmciKSksc3VwcGxlbWVudDphLmdldCgiU3VwcGxlbWVudCIpfSk7dHJ5e2NvbnN0IHQ9ZS5nZXQoIkNJRFRvR0lETWFwIik7dCBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJihyPXQuZ2V0Qnl0ZXMoKSl9Y2F0Y2goZSl7aWYoIXRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTt3YXJuKGBleHRyYWN0RGF0YVN0cnVjdHVyZXMgLSBpZ25vcmluZyBDSURUb0dJRE1hcCBkYXRhOiAiJHtlfSIuYCl9fWNvbnN0IG49W107bGV0IHMsbz1udWxsO2lmKGUuaGFzKCJFbmNvZGluZyIpKXtzPWUuZ2V0KCJFbmNvZGluZyIpO2lmKHMgaW5zdGFuY2VvZiBEaWN0KXtvPXMuZ2V0KCJCYXNlRW5jb2RpbmciKTtvPW8gaW5zdGFuY2VvZiBOYW1lP28ubmFtZTpudWxsO2lmKHMuaGFzKCJEaWZmZXJlbmNlcyIpKXtjb25zdCBlPXMuZ2V0KCJEaWZmZXJlbmNlcyIpO2xldCB0PTA7Zm9yKGNvbnN0IHIgb2YgZSl7Y29uc3QgZT1hLmZldGNoSWZSZWYocik7aWYoIm51bWJlciI9PXR5cGVvZiBlKXQ9ZTtlbHNle2lmKCEoZSBpbnN0YW5jZW9mIE5hbWUpKXRocm93IG5ldyBGb3JtYXRFcnJvcihgSW52YWxpZCBlbnRyeSBpbiAnRGlmZmVyZW5jZXMnIGFycmF5OiAke2V9YCk7blt0KytdPWUubmFtZX19fX1lbHNlIGlmKHMgaW5zdGFuY2VvZiBOYW1lKW89cy5uYW1lO2Vsc2V7Y29uc3QgZT0iRW5jb2RpbmcgaXMgbm90IGEgTmFtZSBub3IgYSBEaWN0IjtpZighdGhpcy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoZSk7d2FybihlKX0iTWFjUm9tYW5FbmNvZGluZyIhPT1vJiYiTWFjRXhwZXJ0RW5jb2RpbmciIT09byYmIldpbkFuc2lFbmNvZGluZyIhPT1vJiYobz1udWxsKX1jb25zdCBjPSF0LmZpbGV8fHQuaXNJbnRlcm5hbEZvbnQsbD1McigpW3QubmFtZV07byYmYyYmbCYmKG89bnVsbCk7aWYobyl0LmRlZmF1bHRFbmNvZGluZz1nZXRFbmNvZGluZyhvKTtlbHNle2NvbnN0IGU9ISEodC5mbGFncyZ5ciksYT0hISh0LmZsYWdzJndyKTtzPW5yOyJUcnVlVHlwZSIhPT10LnR5cGV8fGF8fChzPXNyKTtpZihlfHxsKXtzPWlyO2MmJigvU3ltYm9sL2kudGVzdCh0Lm5hbWUpP3M9b3I6L0RpbmdiYXRzL2kudGVzdCh0Lm5hbWUpP3M9Y3I6L1dpbmdkaW5ncy9pLnRlc3QodC5uYW1lKSYmKHM9c3IpKX10LmRlZmF1bHRFbmNvZGluZz1zfXQuZGlmZmVyZW5jZXM9bjt0LmJhc2VFbmNvZGluZ05hbWU9bzt0Lmhhc0VuY29kaW5nPSEhb3x8bi5sZW5ndGg+MDt0LmRpY3Q9ZTt0LnRvVW5pY29kZT1hd2FpdCBpO2NvbnN0IGg9YXdhaXQgdGhpcy5idWlsZFRvVW5pY29kZSh0KTt0LnRvVW5pY29kZT1oO3ImJih0LmNpZFRvR2lkTWFwPXRoaXMucmVhZENpZFRvR2lkTWFwKHIsaCkpO3JldHVybiB0fV9zaW1wbGVGb250VG9Vbmljb2RlKGUsdD0hMSl7YXNzZXJ0KCFlLmNvbXBvc2l0ZSwiTXVzdCBiZSBhIHNpbXBsZSBmb250LiIpO2NvbnN0IGE9W10scj1lLmRlZmF1bHRFbmNvZGluZy5zbGljZSgpLGk9ZS5iYXNlRW5jb2RpbmdOYW1lLG49ZS5kaWZmZXJlbmNlcztmb3IoY29uc3QgZSBpbiBuKXtjb25zdCB0PW5bZV07Ii5ub3RkZWYiIT09dCYmKHJbZV09dCl9Y29uc3Qgcz1scigpO2Zvcihjb25zdCBuIGluIHIpe2xldCBvPXJbbl07aWYoIiI9PT1vKWNvbnRpbnVlO2xldCBjPXNbb107aWYodm9pZCAwIT09Yyl7YVtuXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGMpO2NvbnRpbnVlfWxldCBsPTA7c3dpdGNoKG9bMF0pe2Nhc2UiRyI6Mz09PW8ubGVuZ3RoJiYobD1wYXJzZUludChvLnN1YnN0cmluZygxKSwxNikpO2JyZWFrO2Nhc2UiZyI6NT09PW8ubGVuZ3RoJiYobD1wYXJzZUludChvLnN1YnN0cmluZygxKSwxNikpO2JyZWFrO2Nhc2UiQyI6Y2FzZSJjIjppZihvLmxlbmd0aD49MyYmby5sZW5ndGg8PTQpe2NvbnN0IGE9by5zdWJzdHJpbmcoMSk7aWYodCl7bD1wYXJzZUludChhLDE2KTticmVha31sPSthO2lmKE51bWJlci5pc05hTihsKSYmTnVtYmVyLmlzSW50ZWdlcihwYXJzZUludChhLDE2KSkpcmV0dXJuIHRoaXMuX3NpbXBsZUZvbnRUb1VuaWNvZGUoZSwhMCl9YnJlYWs7Y2FzZSJ1IjpjPWdldFVuaWNvZGVGb3JHbHlwaChvLHMpOy0xIT09YyYmKGw9Yyk7YnJlYWs7ZGVmYXVsdDpzd2l0Y2gobyl7Y2FzZSJmX2giOmNhc2UiZl90IjpjYXNlIlRfaCI6YVtuXT1vLnJlcGxhY2VBbGwoIl8iLCIiKTtjb250aW51ZX19aWYobD4wJiZsPD0xMTE0MTExJiZOdW1iZXIuaXNJbnRlZ2VyKGwpKXtpZihpJiZsPT09K24pe2NvbnN0IGU9Z2V0RW5jb2RpbmcoaSk7aWYoZSYmKG89ZVtuXSkpe2Fbbl09U3RyaW5nLmZyb21DaGFyQ29kZShzW29dKTtjb250aW51ZX19YVtuXT1TdHJpbmcuZnJvbUNvZGVQb2ludChsKX19cmV0dXJuIGF9YXN5bmMgYnVpbGRUb1VuaWNvZGUoZSl7ZS5oYXNJbmNsdWRlZFRvVW5pY29kZU1hcD1lLnRvVW5pY29kZT8ubGVuZ3RoPjA7aWYoZS5oYXNJbmNsdWRlZFRvVW5pY29kZU1hcCl7IWUuY29tcG9zaXRlJiZlLmhhc0VuY29kaW5nJiYoZS5mYWxsYmFja1RvVW5pY29kZT10aGlzLl9zaW1wbGVGb250VG9Vbmljb2RlKGUpKTtyZXR1cm4gZS50b1VuaWNvZGV9aWYoIWUuY29tcG9zaXRlKXJldHVybiBuZXcgVG9Vbmljb2RlTWFwKHRoaXMuX3NpbXBsZUZvbnRUb1VuaWNvZGUoZSkpO2lmKGUuY29tcG9zaXRlJiYoZS5jTWFwLmJ1aWx0SW5DTWFwJiYhKGUuY01hcCBpbnN0YW5jZW9mIElkZW50aXR5Q01hcCl8fCJBZG9iZSI9PT1lLmNpZFN5c3RlbUluZm8/LnJlZ2lzdHJ5JiYoIkdCMSI9PT1lLmNpZFN5c3RlbUluZm8ub3JkZXJpbmd8fCJDTlMxIj09PWUuY2lkU3lzdGVtSW5mby5vcmRlcmluZ3x8IkphcGFuMSI9PT1lLmNpZFN5c3RlbUluZm8ub3JkZXJpbmd8fCJLb3JlYTEiPT09ZS5jaWRTeXN0ZW1JbmZvLm9yZGVyaW5nKSkpe2NvbnN0e3JlZ2lzdHJ5OnQsb3JkZXJpbmc6YX09ZS5jaWRTeXN0ZW1JbmZvLHI9TmFtZS5nZXQoYCR7dH0tJHthfS1VQ1MyYCksaT1hd2FpdCBDTWFwRmFjdG9yeS5jcmVhdGUoe2VuY29kaW5nOnIsZmV0Y2hCdWlsdEluQ01hcDp0aGlzLl9mZXRjaEJ1aWx0SW5DTWFwQm91bmQsdXNlQ01hcDpudWxsfSksbj1bXSxzPVtdO2UuY01hcC5mb3JFYWNoKChmdW5jdGlvbihlLHQpe2lmKHQ+NjU1MzUpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJNYXggc2l6ZSBvZiBDSUQgaXMgNjUsNTM1Iik7Y29uc3QgYT1pLmxvb2t1cCh0KTtpZihhKXtzLmxlbmd0aD0wO2ZvcihsZXQgZT0wLHQ9YS5sZW5ndGg7ZTx0O2UrPTIpcy5wdXNoKChhLmNoYXJDb2RlQXQoZSk8PDgpK2EuY2hhckNvZGVBdChlKzEpKTtuW2VdPVN0cmluZy5mcm9tQ2hhckNvZGUoLi4ucyl9fSkpO3JldHVybiBuZXcgVG9Vbmljb2RlTWFwKG4pfXJldHVybiBuZXcgSWRlbnRpdHlUb1VuaWNvZGVNYXAoZS5maXJzdENoYXIsZS5sYXN0Q2hhcil9YXN5bmMgcmVhZFRvVW5pY29kZShlKXtpZighZSlyZXR1cm4gbnVsbDtpZihlIGluc3RhbmNlb2YgTmFtZSl7Y29uc3QgdD1hd2FpdCBDTWFwRmFjdG9yeS5jcmVhdGUoe2VuY29kaW5nOmUsZmV0Y2hCdWlsdEluQ01hcDp0aGlzLl9mZXRjaEJ1aWx0SW5DTWFwQm91bmQsdXNlQ01hcDpudWxsfSk7cmV0dXJuIHQgaW5zdGFuY2VvZiBJZGVudGl0eUNNYXA/bmV3IElkZW50aXR5VG9Vbmljb2RlTWFwKDAsNjU1MzUpOm5ldyBUb1VuaWNvZGVNYXAodC5nZXRNYXAoKSl9aWYoZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pdHJ5e2NvbnN0IHQ9YXdhaXQgQ01hcEZhY3RvcnkuY3JlYXRlKHtlbmNvZGluZzplLGZldGNoQnVpbHRJbkNNYXA6dGhpcy5fZmV0Y2hCdWlsdEluQ01hcEJvdW5kLHVzZUNNYXA6bnVsbH0pO2lmKHQgaW5zdGFuY2VvZiBJZGVudGl0eUNNYXApcmV0dXJuIG5ldyBJZGVudGl0eVRvVW5pY29kZU1hcCgwLDY1NTM1KTtjb25zdCBhPW5ldyBBcnJheSh0Lmxlbmd0aCk7dC5mb3JFYWNoKChmdW5jdGlvbihlLHQpe2lmKCJudW1iZXIiPT10eXBlb2YgdCl7YVtlXT1TdHJpbmcuZnJvbUNvZGVQb2ludCh0KTtyZXR1cm59dC5sZW5ndGglMiE9MCYmKHQ9IlwwIit0KTtjb25zdCByPVtdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSs9Mil7Y29uc3QgYT10LmNoYXJDb2RlQXQoZSk8PDh8dC5jaGFyQ29kZUF0KGUrMSk7aWYoNTUyOTYhPSg2MzQ4OCZhKSl7ci5wdXNoKGEpO2NvbnRpbnVlfWUrPTI7Y29uc3QgaT10LmNoYXJDb2RlQXQoZSk8PDh8dC5jaGFyQ29kZUF0KGUrMSk7ci5wdXNoKCgoMTAyMyZhKTw8MTApKygxMDIzJmkpKzY1NTM2KX1hW2VdPVN0cmluZy5mcm9tQ29kZVBvaW50KC4uLnIpfSkpO3JldHVybiBuZXcgVG9Vbmljb2RlTWFwKGEpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbilyZXR1cm4gbnVsbDtpZih0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXt3YXJuKGByZWFkVG9Vbmljb2RlIC0gaWdub3JpbmcgVG9Vbmljb2RlIGRhdGE6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH10aHJvdyBlfXJldHVybiBudWxsfXJlYWRDaWRUb0dpZE1hcChlLHQpe2NvbnN0IGE9W107Zm9yKGxldCByPTAsaT1lLmxlbmd0aDtyPGk7cisrKXtjb25zdCBpPWVbcisrXTw8OHxlW3JdLG49cj4+MTsoMCE9PWl8fHQuaGFzKG4pKSYmKGFbbl09aSl9cmV0dXJuIGF9ZXh0cmFjdFdpZHRocyhlLHQsYSl7Y29uc3Qgcj10aGlzLnhyZWY7bGV0IGk9W10sbj0wO2NvbnN0IHM9W107bGV0IG87aWYoYS5jb21wb3NpdGUpe2NvbnN0IHQ9ZS5nZXQoIkRXIik7bj0ibnVtYmVyIj09dHlwZW9mIHQ/TWF0aC5jZWlsKHQpOjFlMztjb25zdCBjPWUuZ2V0KCJXIik7aWYoQXJyYXkuaXNBcnJheShjKSlmb3IobGV0IGU9MCx0PWMubGVuZ3RoO2U8dDtlKyspe2xldCB0PXIuZmV0Y2hJZlJlZihjW2UrK10pO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHQpKWJyZWFrO2NvbnN0IGE9ci5mZXRjaElmUmVmKGNbZV0pO2lmKEFycmF5LmlzQXJyYXkoYSkpZm9yKGNvbnN0IGUgb2YgYSl7Y29uc3QgYT1yLmZldGNoSWZSZWYoZSk7Im51bWJlciI9PXR5cGVvZiBhJiYoaVt0XT1hKTt0Kyt9ZWxzZXtpZighTnVtYmVyLmlzSW50ZWdlcihhKSlicmVhazt7Y29uc3Qgbj1yLmZldGNoSWZSZWYoY1srK2VdKTtpZigibnVtYmVyIiE9dHlwZW9mIG4pY29udGludWU7Zm9yKGxldCBlPXQ7ZTw9YTtlKyspaVtlXT1ufX19aWYoYS52ZXJ0aWNhbCl7Y29uc3QgdD1lLmdldEFycmF5KCJEVzIiKTtsZXQgYT1pc051bWJlckFycmF5KHQsMik/dDpbODgwLC0xZTNdO289W2FbMV0sLjUqbixhWzBdXTthPWUuZ2V0KCJXMiIpO2lmKEFycmF5LmlzQXJyYXkoYSkpZm9yKGxldCBlPTAsdD1hLmxlbmd0aDtlPHQ7ZSsrKXtsZXQgdD1yLmZldGNoSWZSZWYoYVtlKytdKTtpZighTnVtYmVyLmlzSW50ZWdlcih0KSlicmVhaztjb25zdCBpPXIuZmV0Y2hJZlJlZihhW2VdKTtpZihBcnJheS5pc0FycmF5KGkpKWZvcihsZXQgZT0wLGE9aS5sZW5ndGg7ZTxhO2UrKyl7Y29uc3QgYT1bci5mZXRjaElmUmVmKGlbZSsrXSksci5mZXRjaElmUmVmKGlbZSsrXSksci5mZXRjaElmUmVmKGlbZV0pXTtpc051bWJlckFycmF5KGEsbnVsbCkmJihzW3RdPWEpO3QrK31lbHNle2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGkpKWJyZWFrO3tjb25zdCBuPVtyLmZldGNoSWZSZWYoYVsrK2VdKSxyLmZldGNoSWZSZWYoYVsrK2VdKSxyLmZldGNoSWZSZWYoYVsrK2VdKV07aWYoIWlzTnVtYmVyQXJyYXkobixudWxsKSljb250aW51ZTtmb3IobGV0IGU9dDtlPD1pO2UrKylzW2VdPW59fX19fWVsc2V7Y29uc3Qgcz1lLmdldCgiV2lkdGhzIik7aWYoQXJyYXkuaXNBcnJheShzKSl7bGV0IGU9YS5maXJzdENoYXI7Zm9yKGNvbnN0IHQgb2Ygcyl7Y29uc3QgYT1yLmZldGNoSWZSZWYodCk7Im51bWJlciI9PXR5cGVvZiBhJiYoaVtlXT1hKTtlKyt9Y29uc3Qgbz10LmdldCgiTWlzc2luZ1dpZHRoIik7bj0ibnVtYmVyIj09dHlwZW9mIG8/bzowfWVsc2V7Y29uc3QgdD1lLmdldCgiQmFzZUZvbnQiKTtpZih0IGluc3RhbmNlb2YgTmFtZSl7Y29uc3QgZT10aGlzLmdldEJhc2VGb250TWV0cmljcyh0Lm5hbWUpO2k9dGhpcy5idWlsZENoYXJDb2RlVG9XaWR0aChlLndpZHRocyxhKTtuPWUuZGVmYXVsdFdpZHRofX19bGV0IGM9ITAsbD1uO2Zvcihjb25zdCBlIGluIGkpe2NvbnN0IHQ9aVtlXTtpZih0KWlmKGwpe2lmKGwhPT10KXtjPSExO2JyZWFrfX1lbHNlIGw9dH1jP2EuZmxhZ3N8PW1yOmEuZmxhZ3MmPX5tcjthLmRlZmF1bHRXaWR0aD1uO2Eud2lkdGhzPWk7YS5kZWZhdWx0Vk1ldHJpY3M9bzthLnZtZXRyaWNzPXN9aXNTZXJpZkZvbnQoZSl7Y29uc3QgdD1lLnNwbGl0KCItIiwxKVswXTtyZXR1cm4gdCBpbiBQcigpfHwvc2VyaWYvZ2kudGVzdCh0KX1nZXRCYXNlRm9udE1ldHJpY3MoZSl7bGV0IHQ9MCxhPU9iamVjdC5jcmVhdGUobnVsbCkscj0hMTtsZXQgaT1ScigpW2VdfHxlO2NvbnN0IG49WHIoKTtpIGluIG58fChpPXRoaXMuaXNTZXJpZkZvbnQoZSk/IlRpbWVzLVJvbWFuIjoiSGVsdmV0aWNhIik7Y29uc3Qgcz1uW2ldO2lmKCJudW1iZXIiPT10eXBlb2Ygcyl7dD1zO3I9ITB9ZWxzZSBhPXMoKTtyZXR1cm57ZGVmYXVsdFdpZHRoOnQsbW9ub3NwYWNlOnIsd2lkdGhzOmF9fWJ1aWxkQ2hhckNvZGVUb1dpZHRoKGUsdCl7Y29uc3QgYT1PYmplY3QuY3JlYXRlKG51bGwpLHI9dC5kaWZmZXJlbmNlcyxpPXQuZGVmYXVsdEVuY29kaW5nO2ZvcihsZXQgdD0wO3Q8MjU2O3QrKyl0IGluIHImJmVbclt0XV0/YVt0XT1lW3JbdF1dOnQgaW4gaSYmZVtpW3RdXSYmKGFbdF09ZVtpW3RdXSk7cmV0dXJuIGF9cHJlRXZhbHVhdGVGb250KGUpe2NvbnN0IHQ9ZTtsZXQgYT1lLmdldCgiU3VidHlwZSIpO2lmKCEoYSBpbnN0YW5jZW9mIE5hbWUpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiaW52YWxpZCBmb250IFN1YnR5cGUiKTtsZXQgcixpPSExO2lmKCJUeXBlMCI9PT1hLm5hbWUpe2NvbnN0IHQ9ZS5nZXQoIkRlc2NlbmRhbnRGb250cyIpO2lmKCF0KXRocm93IG5ldyBGb3JtYXRFcnJvcigiRGVzY2VuZGFudCBmb250cyBhcmUgbm90IHNwZWNpZmllZCIpO2lmKCEoKGU9QXJyYXkuaXNBcnJheSh0KT90aGlzLnhyZWYuZmV0Y2hJZlJlZih0WzBdKTp0KWluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJEZXNjZW5kYW50IGZvbnQgaXMgbm90IGEgZGljdGlvbmFyeS4iKTthPWUuZ2V0KCJTdWJ0eXBlIik7aWYoIShhIGluc3RhbmNlb2YgTmFtZSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJpbnZhbGlkIGZvbnQgU3VidHlwZSIpO2k9ITB9bGV0IG49ZS5nZXQoIkZpcnN0Q2hhciIpO051bWJlci5pc0ludGVnZXIobil8fChuPTApO2xldCBzPWUuZ2V0KCJMYXN0Q2hhciIpO051bWJlci5pc0ludGVnZXIocyl8fChzPWk/NjU1MzU6MjU1KTtjb25zdCBvPWUuZ2V0KCJGb250RGVzY3JpcHRvciIpLGM9ZS5nZXQoIlRvVW5pY29kZSIpfHx0LmdldCgiVG9Vbmljb2RlIik7aWYobyl7cj1uZXcgTXVybXVySGFzaDNfNjQ7Y29uc3QgYT10LmdldFJhdygiRW5jb2RpbmciKTtpZihhIGluc3RhbmNlb2YgTmFtZSlyLnVwZGF0ZShhLm5hbWUpO2Vsc2UgaWYoYSBpbnN0YW5jZW9mIFJlZilyLnVwZGF0ZShhLnRvU3RyaW5nKCkpO2Vsc2UgaWYoYSBpbnN0YW5jZW9mIERpY3QpZm9yKGNvbnN0IGUgb2YgYS5nZXRSYXdWYWx1ZXMoKSlpZihlIGluc3RhbmNlb2YgTmFtZSlyLnVwZGF0ZShlLm5hbWUpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIFJlZilyLnVwZGF0ZShlLnRvU3RyaW5nKCkpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3QgdD1lLmxlbmd0aCxhPW5ldyBBcnJheSh0KTtmb3IobGV0IHI9MDtyPHQ7cisrKXtjb25zdCB0PWVbcl07dCBpbnN0YW5jZW9mIE5hbWU/YVtyXT10Lm5hbWU6KCJudW1iZXIiPT10eXBlb2YgdHx8dCBpbnN0YW5jZW9mIFJlZikmJihhW3JdPXQudG9TdHJpbmcoKSl9ci51cGRhdGUoYS5qb2luKCkpfXIudXBkYXRlKGAke259LSR7c31gKTtpZihjIGluc3RhbmNlb2YgQmFzZVN0cmVhbSl7Y29uc3QgZT1jLnN0cnx8Yyx0PWUuYnVmZmVyP25ldyBVaW50OEFycmF5KGUuYnVmZmVyLmJ1ZmZlciwwLGUuYnVmZmVyTGVuZ3RoKTpuZXcgVWludDhBcnJheShlLmJ5dGVzLmJ1ZmZlcixlLnN0YXJ0LGUuZW5kLWUuc3RhcnQpO3IudXBkYXRlKHQpfWVsc2UgYyBpbnN0YW5jZW9mIE5hbWUmJnIudXBkYXRlKGMubmFtZSk7Y29uc3Qgbz1lLmdldCgiV2lkdGhzIil8fHQuZ2V0KCJXaWR0aHMiKTtpZihBcnJheS5pc0FycmF5KG8pKXtjb25zdCBlPVtdO2Zvcihjb25zdCB0IG9mIG8pKCJudW1iZXIiPT10eXBlb2YgdHx8dCBpbnN0YW5jZW9mIFJlZikmJmUucHVzaCh0LnRvU3RyaW5nKCkpO3IudXBkYXRlKGUuam9pbigpKX1pZihpKXtyLnVwZGF0ZSgiY29tcG9zaXRlRm9udCIpO2NvbnN0IGE9ZS5nZXQoIlciKXx8dC5nZXQoIlciKTtpZihBcnJheS5pc0FycmF5KGEpKXtjb25zdCBlPVtdO2Zvcihjb25zdCB0IG9mIGEpaWYoIm51bWJlciI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgUmVmKWUucHVzaCh0LnRvU3RyaW5nKCkpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0KSl7Y29uc3QgYT1bXTtmb3IoY29uc3QgZSBvZiB0KSgibnVtYmVyIj09dHlwZW9mIGV8fGUgaW5zdGFuY2VvZiBSZWYpJiZhLnB1c2goZS50b1N0cmluZygpKTtlLnB1c2goYFske2Euam9pbigpfV1gKX1yLnVwZGF0ZShlLmpvaW4oKSl9Y29uc3QgaT1lLmdldFJhdygiQ0lEVG9HSURNYXAiKXx8dC5nZXRSYXcoIkNJRFRvR0lETWFwIik7aSBpbnN0YW5jZW9mIE5hbWU/ci51cGRhdGUoaS5uYW1lKTppIGluc3RhbmNlb2YgUmVmP3IudXBkYXRlKGkudG9TdHJpbmcoKSk6aSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJnIudXBkYXRlKGkucGVla0J5dGVzKCkpfX1yZXR1cm57ZGVzY3JpcHRvcjpvLGRpY3Q6ZSxiYXNlRGljdDp0LGNvbXBvc2l0ZTppLHR5cGU6YS5uYW1lLGZpcnN0Q2hhcjpuLGxhc3RDaGFyOnMsdG9Vbmljb2RlOmMsaGFzaDpyP3IuaGV4ZGlnZXN0KCk6IiJ9fWFzeW5jIHRyYW5zbGF0ZUZvbnQoe2Rlc2NyaXB0b3I6ZSxkaWN0OmEsYmFzZURpY3Q6cixjb21wb3NpdGU6aSx0eXBlOm4sZmlyc3RDaGFyOnMsbGFzdENoYXI6byx0b1VuaWNvZGU6Yyxjc3NGb250SW5mbzpsfSl7Y29uc3QgaD0iVHlwZTMiPT09bjtpZighZSl7aWYoIWgpe2xldCBlPWEuZ2V0KCJCYXNlRm9udCIpO2lmKCEoZSBpbnN0YW5jZW9mIE5hbWUpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiQmFzZSBmb250IGlzIG5vdCBzcGVjaWZpZWQiKTtlPWUubmFtZS5yZXBsYWNlQWxsKC9bLF9dL2csIi0iKTtjb25zdCB0PXRoaXMuZ2V0QmFzZUZvbnRNZXRyaWNzKGUpLGk9ZS5zcGxpdCgiLSIsMSlbMF0sbD0odGhpcy5pc1NlcmlmRm9udChpKT9icjowKXwodC5tb25vc3BhY2U/bXI6MCl8KExyKClbaV0/eXI6d3IpLHU9e3R5cGU6bixuYW1lOmUsbG9hZGVkTmFtZTpyLmxvYWRlZE5hbWUsc3lzdGVtRm9udEluZm86bnVsbCx3aWR0aHM6dC53aWR0aHMsZGVmYXVsdFdpZHRoOnQuZGVmYXVsdFdpZHRoLGlzU2ltdWxhdGVkRmxhZ3M6ITAsZmxhZ3M6bCxmaXJzdENoYXI6cyxsYXN0Q2hhcjpvLHRvVW5pY29kZTpjLHhIZWlnaHQ6MCxjYXBIZWlnaHQ6MCxpdGFsaWNBbmdsZTowLGlzVHlwZTNGb250Omh9LGQ9YS5nZXQoIldpZHRocyIpLGY9Z2V0U3RhbmRhcmRGb250TmFtZShlKTtsZXQgZz1udWxsO2lmKGYpe2c9YXdhaXQgdGhpcy5mZXRjaFN0YW5kYXJkRm9udERhdGEoZik7dS5pc0ludGVybmFsRm9udD0hIWd9IXUuaXNJbnRlcm5hbEZvbnQmJnRoaXMub3B0aW9ucy51c2VTeXN0ZW1Gb250cyYmKHUuc3lzdGVtRm9udEluZm89Z2V0Rm9udFN1YnN0aXR1dGlvbih0aGlzLnN5c3RlbUZvbnRDYWNoZSx0aGlzLmlkRmFjdG9yeSx0aGlzLm9wdGlvbnMuc3RhbmRhcmRGb250RGF0YVVybCxlLGYsbikpO2NvbnN0IHA9YXdhaXQgdGhpcy5leHRyYWN0RGF0YVN0cnVjdHVyZXMoYSx1KTtpZihBcnJheS5pc0FycmF5KGQpKXtjb25zdCBlPVtdO2xldCB0PXM7Zm9yKGNvbnN0IGEgb2YgZCl7Y29uc3Qgcj10aGlzLnhyZWYuZmV0Y2hJZlJlZihhKTsibnVtYmVyIj09dHlwZW9mIHImJihlW3RdPXIpO3QrK31wLndpZHRocz1lfWVsc2UgcC53aWR0aHM9dGhpcy5idWlsZENoYXJDb2RlVG9XaWR0aCh0LndpZHRocyxwKTtyZXR1cm4gbmV3IEZvbnQoZSxnLHAsdGhpcy5vcHRpb25zKX1lPURpY3QuZW1wdHl9bGV0IHU9ZS5nZXQoIkZvbnROYW1lIiksZD1hLmdldCgiQmFzZUZvbnQiKTsic3RyaW5nIj09dHlwZW9mIHUmJih1PU5hbWUuZ2V0KHUpKTsic3RyaW5nIj09dHlwZW9mIGQmJihkPU5hbWUuZ2V0KGQpKTtjb25zdCBmPXU/Lm5hbWUsZz1kPy5uYW1lO2lmKGgpZnx8KHU9TmFtZS5nZXQobikpO2Vsc2UgaWYoZiE9PWcpe2luZm8oYFRoZSBGb250RGVzY3JpcHRvcidzIEZvbnROYW1lIGlzICIke2Z9IiBidXQgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSBGb250J3MgQmFzZUZvbnQgIiR7Z30iLmApO2YmJmcmJihnLnN0YXJ0c1dpdGgoZil8fCFpc0tub3duRm9udE5hbWUoZikmJmlzS25vd25Gb250TmFtZShnKSkmJih1PW51bGwpO3V8fD1kfWlmKCEodSBpbnN0YW5jZW9mIE5hbWUpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiaW52YWxpZCBmb250IG5hbWUiKTtsZXQgcCxtLGIseSx3O3RyeXtwPWUuZ2V0KCJGb250RmlsZSIsIkZvbnRGaWxlMiIsIkZvbnRGaWxlMyIpO2lmKHApe2lmKCEocCBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pKXRocm93IG5ldyBGb3JtYXRFcnJvcigiRm9udEZpbGUgc2hvdWxkIGJlIGEgc3RyZWFtIik7aWYocC5pc0VtcHR5KXRocm93IG5ldyBGb3JtYXRFcnJvcigiRm9udEZpbGUgaXMgZW1wdHkiKX19Y2F0Y2goZSl7aWYoIXRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTt3YXJuKGB0cmFuc2xhdGVGb250IC0gZmV0Y2hpbmcgIiR7dS5uYW1lfSIgZm9udCBmaWxlOiAiJHtlfSIuYCk7cD1udWxsfWxldCB4PSExLFM9bnVsbCxrPW51bGw7aWYocCl7aWYocC5kaWN0KXtjb25zdCBlPXAuZGljdC5nZXQoIlN1YnR5cGUiKTtlIGluc3RhbmNlb2YgTmFtZSYmKG09ZS5uYW1lKTtiPXAuZGljdC5nZXQoIkxlbmd0aDEiKTt5PXAuZGljdC5nZXQoIkxlbmd0aDIiKTt3PXAuZGljdC5nZXQoIkxlbmd0aDMiKX19ZWxzZSBpZihsKXtjb25zdCBlPWdldFhmYUZvbnROYW1lKHUubmFtZSk7aWYoZSl7bC5mb250RmFtaWx5PWAke2wuZm9udEZhbWlseX0tUGRmSlMtWEZBYDtsLm1ldHJpY3M9ZS5tZXRyaWNzfHxudWxsO1M9ZS5mYWN0b3JzfHxudWxsO3A9YXdhaXQgdGhpcy5mZXRjaFN0YW5kYXJkRm9udERhdGEoZS5uYW1lKTt4PSEhcDtyPWE9Z2V0WGZhRm9udERpY3QodS5uYW1lKTtpPSEwfX1lbHNlIGlmKCFoKXtjb25zdCBlPWdldFN0YW5kYXJkRm9udE5hbWUodS5uYW1lKTtpZihlKXtwPWF3YWl0IHRoaXMuZmV0Y2hTdGFuZGFyZEZvbnREYXRhKGUpO3g9ISFwfSF4JiZ0aGlzLm9wdGlvbnMudXNlU3lzdGVtRm9udHMmJihrPWdldEZvbnRTdWJzdGl0dXRpb24odGhpcy5zeXN0ZW1Gb250Q2FjaGUsdGhpcy5pZEZhY3RvcnksdGhpcy5vcHRpb25zLnN0YW5kYXJkRm9udERhdGFVcmwsdS5uYW1lLGUsbikpfWNvbnN0IEM9bG9va3VwTWF0cml4KGEuZ2V0QXJyYXkoIkZvbnRNYXRyaXgiKSx0KSx2PWxvb2t1cE5vcm1hbFJlY3QoZS5nZXRBcnJheSgiRm9udEJCb3giKXx8YS5nZXRBcnJheSgiRm9udEJCb3giKSxoP1swLDAsMCwwXTp2b2lkIDApO2xldCBGPWUuZ2V0KCJBc2NlbnQiKTsibnVtYmVyIiE9dHlwZW9mIEYmJihGPXZvaWQgMCk7bGV0IFQ9ZS5nZXQoIkRlc2NlbnQiKTsibnVtYmVyIiE9dHlwZW9mIFQmJihUPXZvaWQgMCk7bGV0IE89ZS5nZXQoIlhIZWlnaHQiKTsibnVtYmVyIiE9dHlwZW9mIE8mJihPPTApO2xldCBNPWUuZ2V0KCJDYXBIZWlnaHQiKTsibnVtYmVyIiE9dHlwZW9mIE0mJihNPTApO2xldCBEPWUuZ2V0KCJGbGFncyIpO051bWJlci5pc0ludGVnZXIoRCl8fChEPTApO2xldCBSPWUuZ2V0KCJJdGFsaWNBbmdsZSIpOyJudW1iZXIiIT10eXBlb2YgUiYmKFI9MCk7Y29uc3QgTj17dHlwZTpuLG5hbWU6dS5uYW1lLHN1YnR5cGU6bSxmaWxlOnAsbGVuZ3RoMTpiLGxlbmd0aDI6eSxsZW5ndGgzOncsaXNJbnRlcm5hbEZvbnQ6eCxsb2FkZWROYW1lOnIubG9hZGVkTmFtZSxjb21wb3NpdGU6aSxmaXhlZFBpdGNoOiExLGZvbnRNYXRyaXg6QyxmaXJzdENoYXI6cyxsYXN0Q2hhcjpvLHRvVW5pY29kZTpjLGJib3g6dixhc2NlbnQ6RixkZXNjZW50OlQseEhlaWdodDpPLGNhcEhlaWdodDpNLGZsYWdzOkQsaXRhbGljQW5nbGU6Uixpc1R5cGUzRm9udDpoLGNzc0ZvbnRJbmZvOmwsc2NhbGVGYWN0b3JzOlMsc3lzdGVtRm9udEluZm86a307aWYoaSl7Y29uc3QgZT1yLmdldCgiRW5jb2RpbmciKTtlIGluc3RhbmNlb2YgTmFtZSYmKE4uY2lkRW5jb2Rpbmc9ZS5uYW1lKTtjb25zdCB0PWF3YWl0IENNYXBGYWN0b3J5LmNyZWF0ZSh7ZW5jb2Rpbmc6ZSxmZXRjaEJ1aWx0SW5DTWFwOnRoaXMuX2ZldGNoQnVpbHRJbkNNYXBCb3VuZCx1c2VDTWFwOm51bGx9KTtOLmNNYXA9dDtOLnZlcnRpY2FsPU4uY01hcC52ZXJ0aWNhbH1jb25zdCBFPWF3YWl0IHRoaXMuZXh0cmFjdERhdGFTdHJ1Y3R1cmVzKGEsTik7dGhpcy5leHRyYWN0V2lkdGhzKGEsZSxFKTtyZXR1cm4gbmV3IEZvbnQodS5uYW1lLHAsRSx0aGlzLm9wdGlvbnMpfXN0YXRpYyBidWlsZEZvbnRQYXRocyhlLHQsYSxyKXtmdW5jdGlvbiBidWlsZFBhdGgodCl7Y29uc3QgaT1gJHtlLmxvYWRlZE5hbWV9X3BhdGhfJHt0fWA7dHJ5e2lmKGUucmVuZGVyZXIuaGFzQnVpbHRQYXRoKHQpKXJldHVybjthLnNlbmQoImNvbW1vbm9iaiIsW2ksIkZvbnRQYXRoIixlLnJlbmRlcmVyLmdldFBhdGhKcyh0KV0pfWNhdGNoKGUpe2lmKHIuaWdub3JlRXJyb3JzKXt3YXJuKGBidWlsZEZvbnRQYXRocyAtIGlnbm9yaW5nICR7aX0gZ2x5cGg6ICIke2V9Ii5gKTtyZXR1cm59dGhyb3cgZX19Zm9yKGNvbnN0IGUgb2YgdCl7YnVpbGRQYXRoKGUuZm9udENoYXIpO2NvbnN0IHQ9ZS5hY2NlbnQ7dD8uZm9udENoYXImJmJ1aWxkUGF0aCh0LmZvbnRDaGFyKX19c3RhdGljIGdldCBmYWxsYmFja0ZvbnREaWN0KCl7Y29uc3QgZT1uZXcgRGljdDtlLnNldCgiQmFzZUZvbnQiLE5hbWUuZ2V0KCJIZWx2ZXRpY2EiKSk7ZS5zZXQoIlR5cGUiLE5hbWUuZ2V0KCJGYWxsYmFja1R5cGUiKSk7ZS5zZXQoIlN1YnR5cGUiLE5hbWUuZ2V0KCJGYWxsYmFja1R5cGUiKSk7ZS5zZXQoIkVuY29kaW5nIixOYW1lLmdldCgiV2luQW5zaUVuY29kaW5nIikpO3JldHVybiBzaGFkb3codGhpcywiZmFsbGJhY2tGb250RGljdCIsZSl9fWNsYXNzIFRyYW5zbGF0ZWRGb250eyNHPSExOyNWPW51bGw7Y29uc3RydWN0b3Ioe2xvYWRlZE5hbWU6ZSxmb250OnQsZGljdDphfSl7dGhpcy5sb2FkZWROYW1lPWU7dGhpcy5mb250PXQ7dGhpcy5kaWN0PWE7dGhpcy50eXBlM0RlcGVuZGVuY2llcz10LmlzVHlwZTNGb250P25ldyBTZXQ6bnVsbH1zZW5kKGUpe2lmKCF0aGlzLiNHKXt0aGlzLiNHPSEwO2Uuc2VuZCgiY29tbW9ub2JqIixbdGhpcy5sb2FkZWROYW1lLCJGb250Iix0aGlzLmZvbnQuZXhwb3J0RGF0YSgpXSl9fWZhbGxiYWNrKGUsdCl7aWYodGhpcy5mb250LmRhdGEpe3RoaXMuZm9udC5kaXNhYmxlRm9udEZhY2U9ITA7UGFydGlhbEV2YWx1YXRvci5idWlsZEZvbnRQYXRocyh0aGlzLmZvbnQsdGhpcy5mb250LmdseXBoQ2FjaGVWYWx1ZXMsZSx0KX19bG9hZFR5cGUzRGF0YShlLHQsYSl7aWYodGhpcy4jVilyZXR1cm4gdGhpcy4jVjtjb25zdHtmb250OnIsdHlwZTNEZXBlbmRlbmNpZXM6aX09dGhpczthc3NlcnQoci5pc1R5cGUzRm9udCwiTXVzdCBiZSBhIFR5cGUzIGZvbnQuIik7Y29uc3Qgbj1lLmNsb25lKHtpZ25vcmVFcnJvcnM6ITF9KSxzPW5ldyBSZWZTZXQoZS50eXBlM0ZvbnRSZWZzKTt0aGlzLmRpY3Qub2JqSWQmJiFzLmhhcyh0aGlzLmRpY3Qub2JqSWQpJiZzLnB1dCh0aGlzLmRpY3Qub2JqSWQpO24udHlwZTNGb250UmVmcz1zO2xldCBvPVByb21pc2UucmVzb2x2ZSgpO2NvbnN0IGM9dGhpcy5kaWN0LmdldCgiQ2hhclByb2NzIiksbD10aGlzLmRpY3QuZ2V0KCJSZXNvdXJjZXMiKXx8dCxoPU9iamVjdC5jcmVhdGUobnVsbCksW3UsZCxmLGddPXIuYmJveCxwPWYtdSxtPWctZCxiPU1hdGguaHlwb3QocCxtKTtmb3IoY29uc3QgZSBvZiBjLmdldEtleXMoKSlvPW8udGhlbigoKCk9Pntjb25zdCB0PWMuZ2V0KGUpLHI9bmV3IE9wZXJhdG9yTGlzdDtyZXR1cm4gbi5nZXRPcGVyYXRvckxpc3Qoe3N0cmVhbTp0LHRhc2s6YSxyZXNvdXJjZXM6bCxvcGVyYXRvckxpc3Q6cn0pLnRoZW4oKCgpPT57c3dpdGNoKHIuZm5BcnJheVswXSl7Y2FzZSBldDp0aGlzLiNLKHIsYik7YnJlYWs7Y2FzZSBRZTpifHx0aGlzLiNKKHIpfWhbZV09ci5nZXRJUigpO2Zvcihjb25zdCBlIG9mIHIuZGVwZW5kZW5jaWVzKWkuYWRkKGUpfSkpLmNhdGNoKChmdW5jdGlvbih0KXt3YXJuKGBUeXBlMyBmb250IHJlc291cmNlICIke2V9IiBpcyBub3QgYXZhaWxhYmxlLmApO2NvbnN0IGE9bmV3IE9wZXJhdG9yTGlzdDtoW2VdPWEuZ2V0SVIoKX0pKX0pKTt0aGlzLiNWPW8udGhlbigoKCk9PntyLmNoYXJQcm9jT3BlcmF0b3JMaXN0PWg7aWYodGhpcy5fYmJveCl7ci5pc0NoYXJCQm94PSEwO3IuYmJveD10aGlzLl9iYm94fX0pKTtyZXR1cm4gdGhpcy4jVn0jSyhlLHQ9TmFOKXtjb25zdCBhPVV0aWwubm9ybWFsaXplUmVjdChlLmFyZ3NBcnJheVswXS5zbGljZSgyKSkscj1hWzJdLWFbMF0saT1hWzNdLWFbMV0sbj1NYXRoLmh5cG90KHIsaSk7aWYoMD09PXJ8fDA9PT1pKXtlLmZuQXJyYXkuc3BsaWNlKDAsMSk7ZS5hcmdzQXJyYXkuc3BsaWNlKDAsMSl9ZWxzZSBpZigwPT09dHx8TWF0aC5yb3VuZChuL3QpPj0xMCl7dGhpcy5fYmJveD8/PVsxLzAsMS8wLC0xLzAsLTEvMF07VXRpbC5yZWN0Qm91bmRpbmdCb3goLi4uYSx0aGlzLl9iYm94KX1sZXQgcz0wLG89ZS5sZW5ndGg7Zm9yKDtzPG87KXtzd2l0Y2goZS5mbkFycmF5W3NdKXtjYXNlIGV0OmJyZWFrO2Nhc2UgdHQ6Y2FzZSBhdDpjYXNlIHJ0OmNhc2UgaXQ6Y2FzZSBudDpjYXNlIHN0OmNhc2Ugb3Q6Y2FzZSBjdDpjYXNlIGx0OmNhc2UgaHQ6Y2FzZSB1dDpjYXNlIGR0OmNhc2UgZnQ6Y2FzZSBkZTplLmZuQXJyYXkuc3BsaWNlKHMsMSk7ZS5hcmdzQXJyYXkuc3BsaWNlKHMsMSk7by0tO2NvbnRpbnVlO2Nhc2UgZ2U6Y29uc3RbdF09ZS5hcmdzQXJyYXlbc107bGV0IGE9MCxyPXQubGVuZ3RoO2Zvcig7YTxyOyl7Y29uc3RbZV09dFthXTtzd2l0Y2goZSl7Y2FzZSJUUiI6Y2FzZSJUUjIiOmNhc2UiSFQiOmNhc2UiQkciOmNhc2UiQkcyIjpjYXNlIlVDUiI6Y2FzZSJVQ1IyIjp0LnNwbGljZShhLDEpO3ItLTtjb250aW51ZX1hKyt9fXMrK319I0ooZSl7bGV0IHQ9MTtjb25zdCBhPWUubGVuZ3RoO2Zvcig7dDxhOyl7aWYoZS5mbkFycmF5W3RdPT09X3Qpe2NvbnN0IGE9ZS5hcmdzQXJyYXlbdF1bMl07dGhpcy5fYmJveD8/PVsxLzAsMS8wLC0xLzAsLTEvMF07VXRpbC5yZWN0Qm91bmRpbmdCb3goLi4uYSx0aGlzLl9iYm94KX10Kyt9fX1jbGFzcyBTdGF0ZU1hbmFnZXJ7Y29uc3RydWN0b3IoZT1uZXcgRXZhbFN0YXRlKXt0aGlzLnN0YXRlPWU7dGhpcy5zdGF0ZVN0YWNrPVtdfXNhdmUoKXtjb25zdCBlPXRoaXMuc3RhdGU7dGhpcy5zdGF0ZVN0YWNrLnB1c2godGhpcy5zdGF0ZSk7dGhpcy5zdGF0ZT1lLmNsb25lKCl9cmVzdG9yZSgpe2NvbnN0IGU9dGhpcy5zdGF0ZVN0YWNrLnBvcCgpO2UmJih0aGlzLnN0YXRlPWUpfXRyYW5zZm9ybShlKXt0aGlzLnN0YXRlLmN0bT1VdGlsLnRyYW5zZm9ybSh0aGlzLnN0YXRlLmN0bSxlKX19Y2xhc3MgVGV4dFN0YXRle2NvbnN0cnVjdG9yKCl7dGhpcy5jdG09bmV3IEZsb2F0MzJBcnJheShsYSk7dGhpcy5mb250TmFtZT1udWxsO3RoaXMuZm9udFNpemU9MDt0aGlzLmxvYWRlZE5hbWU9bnVsbDt0aGlzLmZvbnQ9bnVsbDt0aGlzLmZvbnRNYXRyaXg9dDt0aGlzLnRleHRNYXRyaXg9bGEuc2xpY2UoKTt0aGlzLnRleHRMaW5lTWF0cml4PWxhLnNsaWNlKCk7dGhpcy5jaGFyU3BhY2luZz0wO3RoaXMud29yZFNwYWNpbmc9MDt0aGlzLmxlYWRpbmc9MDt0aGlzLnRleHRIU2NhbGU9MTt0aGlzLnRleHRSaXNlPTB9c2V0VGV4dE1hdHJpeChlLHQsYSxyLGksbil7Y29uc3Qgcz10aGlzLnRleHRNYXRyaXg7c1swXT1lO3NbMV09dDtzWzJdPWE7c1szXT1yO3NbNF09aTtzWzVdPW59c2V0VGV4dExpbmVNYXRyaXgoZSx0LGEscixpLG4pe2NvbnN0IHM9dGhpcy50ZXh0TGluZU1hdHJpeDtzWzBdPWU7c1sxXT10O3NbMl09YTtzWzNdPXI7c1s0XT1pO3NbNV09bn10cmFuc2xhdGVUZXh0TWF0cml4KGUsdCl7Y29uc3QgYT10aGlzLnRleHRNYXRyaXg7YVs0XT1hWzBdKmUrYVsyXSp0K2FbNF07YVs1XT1hWzFdKmUrYVszXSp0K2FbNV19dHJhbnNsYXRlVGV4dExpbmVNYXRyaXgoZSx0KXtjb25zdCBhPXRoaXMudGV4dExpbmVNYXRyaXg7YVs0XT1hWzBdKmUrYVsyXSp0K2FbNF07YVs1XT1hWzFdKmUrYVszXSp0K2FbNV19Y2FycmlhZ2VSZXR1cm4oKXt0aGlzLnRyYW5zbGF0ZVRleHRMaW5lTWF0cml4KDAsLXRoaXMubGVhZGluZyk7dGhpcy50ZXh0TWF0cml4PXRoaXMudGV4dExpbmVNYXRyaXguc2xpY2UoKX1jbG9uZSgpe2NvbnN0IGU9T2JqZWN0LmNyZWF0ZSh0aGlzKTtlLnRleHRNYXRyaXg9dGhpcy50ZXh0TWF0cml4LnNsaWNlKCk7ZS50ZXh0TGluZU1hdHJpeD10aGlzLnRleHRMaW5lTWF0cml4LnNsaWNlKCk7ZS5mb250TWF0cml4PXRoaXMuZm9udE1hdHJpeC5zbGljZSgpO3JldHVybiBlfX1jbGFzcyBFdmFsU3RhdGV7Y29uc3RydWN0b3IoKXt0aGlzLmN0bT1uZXcgRmxvYXQzMkFycmF5KGxhKTt0aGlzLmZvbnQ9bnVsbDt0aGlzLnRleHRSZW5kZXJpbmdNb2RlPXg7dGhpcy5fZmlsbENvbG9yU3BhY2U9dGhpcy5fc3Ryb2tlQ29sb3JTcGFjZT1Db2xvclNwYWNlVXRpbHMuZ3JheTt0aGlzLnBhdHRlcm5GaWxsQ29sb3JTcGFjZT1udWxsO3RoaXMucGF0dGVyblN0cm9rZUNvbG9yU3BhY2U9bnVsbDt0aGlzLmN1cnJlbnRQb2ludFg9dGhpcy5jdXJyZW50UG9pbnRZPTA7dGhpcy5wYXRoTWluTWF4PW5ldyBGbG9hdDMyQXJyYXkoWzEvMCwxLzAsLTEvMCwtMS8wXSk7dGhpcy5wYXRoQnVmZmVyPVtdfWdldCBmaWxsQ29sb3JTcGFjZSgpe3JldHVybiB0aGlzLl9maWxsQ29sb3JTcGFjZX1zZXQgZmlsbENvbG9yU3BhY2UoZSl7dGhpcy5fZmlsbENvbG9yU3BhY2U9dGhpcy5wYXR0ZXJuRmlsbENvbG9yU3BhY2U9ZX1nZXQgc3Ryb2tlQ29sb3JTcGFjZSgpe3JldHVybiB0aGlzLl9zdHJva2VDb2xvclNwYWNlfXNldCBzdHJva2VDb2xvclNwYWNlKGUpe3RoaXMuX3N0cm9rZUNvbG9yU3BhY2U9dGhpcy5wYXR0ZXJuU3Ryb2tlQ29sb3JTcGFjZT1lfWNsb25lKHtuZXdQYXRoOmU9ITF9PXt9KXtjb25zdCB0PU9iamVjdC5jcmVhdGUodGhpcyk7aWYoZSl7dC5wYXRoQnVmZmVyPVtdO3QucGF0aE1pbk1heD1uZXcgRmxvYXQzMkFycmF5KFsxLzAsMS8wLC0xLzAsLTEvMF0pfXJldHVybiB0fX1jbGFzcyBFdmFsdWF0b3JQcmVwcm9jZXNzb3J7c3RhdGljIGdldCBvcE1hcCgpe3JldHVybiBzaGFkb3codGhpcywib3BNYXAiLE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7dzp7aWQ6b2UsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sSjp7aWQ6Y2UsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sajp7aWQ6bGUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sTTp7aWQ6aGUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sZDp7aWQ6dWUsbnVtQXJnczoyLHZhcmlhYmxlQXJnczohMX0scmk6e2lkOmRlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LGk6e2lkOmZlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LGdzOntpZDpnZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxxOntpZDpwZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxROntpZDptZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxjbTp7aWQ6YmUsbnVtQXJnczo2LHZhcmlhYmxlQXJnczohMX0sbTp7aWQ6eWUsbnVtQXJnczoyLHZhcmlhYmxlQXJnczohMX0sbDp7aWQ6d2UsbnVtQXJnczoyLHZhcmlhYmxlQXJnczohMX0sYzp7aWQ6eGUsbnVtQXJnczo2LHZhcmlhYmxlQXJnczohMX0sdjp7aWQ6U2UsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX0seTp7aWQ6QWUsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX0saDp7aWQ6a2UsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX0scmU6e2lkOkNlLG51bUFyZ3M6NCx2YXJpYWJsZUFyZ3M6ITF9LFM6e2lkOnZlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LHM6e2lkOkZlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LGY6e2lkOkllLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LEY6e2lkOkllLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LCJmKiI6e2lkOlRlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LEI6e2lkOk9lLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LCJCKiI6e2lkOk1lLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LGI6e2lkOkRlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LCJiKiI6e2lkOkJlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LG46e2lkOlJlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LFc6e2lkOk5lLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LCJXKiI6e2lkOkVlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LEJUOntpZDpQZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxFVDp7aWQ6TGUsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX0sVGM6e2lkOmplLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LFR3OntpZDpfZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxUejp7aWQ6VWUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sVEw6e2lkOlhlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LFRmOntpZDpxZSxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfSxUcjp7aWQ6SGUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sVHM6e2lkOldlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LFRkOntpZDp6ZSxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfSxURDp7aWQ6JGUsbnVtQXJnczoyLHZhcmlhYmxlQXJnczohMX0sVG06e2lkOkdlLG51bUFyZ3M6Nix2YXJpYWJsZUFyZ3M6ITF9LCJUKiI6e2lkOlZlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LFRqOntpZDpLZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxUSjp7aWQ6SmUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sIiciOntpZDpZZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSwnIic6e2lkOlplLG51bUFyZ3M6Myx2YXJpYWJsZUFyZ3M6ITF9LGQwOntpZDpRZSxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfSxkMTp7aWQ6ZXQsbnVtQXJnczo2LHZhcmlhYmxlQXJnczohMX0sQ1M6e2lkOnR0LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LGNzOntpZDphdCxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxTQzp7aWQ6cnQsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMH0sU0NOOntpZDppdCxudW1BcmdzOjMzLHZhcmlhYmxlQXJnczohMH0sc2M6e2lkOm50LG51bUFyZ3M6NCx2YXJpYWJsZUFyZ3M6ITB9LHNjbjp7aWQ6c3QsbnVtQXJnczozMyx2YXJpYWJsZUFyZ3M6ITB9LEc6e2lkOm90LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LGc6e2lkOmN0LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LFJHOntpZDpsdCxudW1BcmdzOjMsdmFyaWFibGVBcmdzOiExfSxyZzp7aWQ6aHQsbnVtQXJnczozLHZhcmlhYmxlQXJnczohMX0sSzp7aWQ6dXQsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX0sazp7aWQ6ZHQsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX0sc2g6e2lkOmZ0LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LEJJOntpZDpndCxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxJRDp7aWQ6cHQsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX0sRUk6e2lkOm10LG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LERvOntpZDpidCxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxNUDp7aWQ6eXQsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sRFA6e2lkOnd0LG51bUFyZ3M6Mix2YXJpYWJsZUFyZ3M6ITF9LEJNQzp7aWQ6eHQsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sQkRDOntpZDpTdCxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfSxFTUM6e2lkOkF0LG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LEJYOntpZDprdCxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxFWDp7aWQ6Q3QsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX0sQk06bnVsbCxCRDpudWxsLHRydWU6bnVsbCxmYTpudWxsLGZhbDpudWxsLGZhbHM6bnVsbCxmYWxzZTpudWxsLG51Om51bGwsbnVsOm51bGwsbnVsbDpudWxsfSkpfXN0YXRpYyBNQVhfSU5WQUxJRF9QQVRIX09QUz0xMDtjb25zdHJ1Y3RvcihlLHQsYT1uZXcgU3RhdGVNYW5hZ2VyKXt0aGlzLnBhcnNlcj1uZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIoZSxFdmFsdWF0b3JQcmVwcm9jZXNzb3Iub3BNYXApLHhyZWY6dH0pO3RoaXMuc3RhdGVNYW5hZ2VyPWE7dGhpcy5ub25Qcm9jZXNzZWRBcmdzPVtdO3RoaXMuX2lzUGF0aE9wPSExO3RoaXMuX251bUludmFsaWRQYXRoT1BTPTB9Z2V0IHNhdmVkU3RhdGVzRGVwdGgoKXtyZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuc3RhdGVTdGFjay5sZW5ndGh9cmVhZChlKXtsZXQgdD1lLmFyZ3M7Zm9yKDs7KXtjb25zdCBhPXRoaXMucGFyc2VyLmdldE9iaigpO2lmKGEgaW5zdGFuY2VvZiBDbWQpe2NvbnN0IHI9YS5jbWQsaT1FdmFsdWF0b3JQcmVwcm9jZXNzb3Iub3BNYXBbcl07aWYoIWkpe3dhcm4oYFVua25vd24gY29tbWFuZCAiJHtyfSIuYCk7Y29udGludWV9Y29uc3Qgbj1pLmlkLHM9aS5udW1BcmdzO2xldCBvPW51bGwhPT10P3QubGVuZ3RoOjA7dGhpcy5faXNQYXRoT3B8fCh0aGlzLl9udW1JbnZhbGlkUGF0aE9QUz0wKTt0aGlzLl9pc1BhdGhPcD1uPj15ZSYmbjw9UmU7aWYoaS52YXJpYWJsZUFyZ3Mpbz5zJiZpbmZvKGBDb21tYW5kICR7cn06IGV4cGVjdGVkIFswLCAke3N9XSBhcmdzLCBidXQgcmVjZWl2ZWQgJHtvfSBhcmdzLmApO2Vsc2V7aWYobyE9PXMpe2NvbnN0IGU9dGhpcy5ub25Qcm9jZXNzZWRBcmdzO2Zvcig7bz5zOyl7ZS5wdXNoKHQuc2hpZnQoKSk7by0tfWZvcig7bzxzJiYwIT09ZS5sZW5ndGg7KXtudWxsPT09dCYmKHQ9W10pO3QudW5zaGlmdChlLnBvcCgpKTtvKyt9fWlmKG88cyl7Y29uc3QgZT1gY29tbWFuZCAke3J9OiBleHBlY3RlZCAke3N9IGFyZ3MsIGJ1dCByZWNlaXZlZCAke299IGFyZ3MuYDtpZih0aGlzLl9pc1BhdGhPcCYmKyt0aGlzLl9udW1JbnZhbGlkUGF0aE9QUz5FdmFsdWF0b3JQcmVwcm9jZXNzb3IuTUFYX0lOVkFMSURfUEFUSF9PUFMpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkICR7ZX1gKTt3YXJuKGBTa2lwcGluZyAke2V9YCk7bnVsbCE9PXQmJih0Lmxlbmd0aD0wKTtjb250aW51ZX19dGhpcy5wcmVwcm9jZXNzQ29tbWFuZChuLHQpO2UuZm49bjtlLmFyZ3M9dDtyZXR1cm4hMH1pZihhPT09YWEpcmV0dXJuITE7aWYobnVsbCE9PWEpe251bGw9PT10JiYodD1bXSk7dC5wdXNoKGEpO2lmKHQubGVuZ3RoPjMzKXRocm93IG5ldyBGb3JtYXRFcnJvcigiVG9vIG1hbnkgYXJndW1lbnRzIil9fX1wcmVwcm9jZXNzQ29tbWFuZChlLHQpe3N3aXRjaCgwfGUpe2Nhc2UgcGU6dGhpcy5zdGF0ZU1hbmFnZXIuc2F2ZSgpO2JyZWFrO2Nhc2UgbWU6dGhpcy5zdGF0ZU1hbmFnZXIucmVzdG9yZSgpO2JyZWFrO2Nhc2UgYmU6dGhpcy5zdGF0ZU1hbmFnZXIudHJhbnNmb3JtKHQpfX19Y2xhc3MgRGVmYXVsdEFwcGVhcmFuY2VFdmFsdWF0b3IgZXh0ZW5kcyBFdmFsdWF0b3JQcmVwcm9jZXNzb3J7Y29uc3RydWN0b3IoZSl7c3VwZXIobmV3IFN0cmluZ1N0cmVhbShlKSl9cGFyc2UoKXtjb25zdCBlPXtmbjowLGFyZ3M6W119LHQ9e2ZvbnRTaXplOjAsZm9udE5hbWU6IiIsZm9udENvbG9yOm5ldyBVaW50OENsYW1wZWRBcnJheSgzKX07dHJ5e2Zvcig7Oyl7ZS5hcmdzLmxlbmd0aD0wO2lmKCF0aGlzLnJlYWQoZSkpYnJlYWs7aWYoMCE9PXRoaXMuc2F2ZWRTdGF0ZXNEZXB0aCljb250aW51ZTtjb25zdHtmbjphLGFyZ3M6cn09ZTtzd2l0Y2goMHxhKXtjYXNlIHFlOmNvbnN0W2UsYV09cjtlIGluc3RhbmNlb2YgTmFtZSYmKHQuZm9udE5hbWU9ZS5uYW1lKTsibnVtYmVyIj09dHlwZW9mIGEmJmE+MCYmKHQuZm9udFNpemU9YSk7YnJlYWs7Y2FzZSBodDpDb2xvclNwYWNlVXRpbHMucmdiLmdldFJnYkl0ZW0ociwwLHQuZm9udENvbG9yLDApO2JyZWFrO2Nhc2UgY3Q6Q29sb3JTcGFjZVV0aWxzLmdyYXkuZ2V0UmdiSXRlbShyLDAsdC5mb250Q29sb3IsMCk7YnJlYWs7Y2FzZSBkdDpDb2xvclNwYWNlVXRpbHMuY215ay5nZXRSZ2JJdGVtKHIsMCx0LmZvbnRDb2xvciwwKX19fWNhdGNoKGUpe3dhcm4oYHBhcnNlRGVmYXVsdEFwcGVhcmFuY2UgLSBpZ25vcmluZyBlcnJvcnM6ICIke2V9Ii5gKX1yZXR1cm4gdH19ZnVuY3Rpb24gcGFyc2VEZWZhdWx0QXBwZWFyYW5jZShlKXtyZXR1cm4gbmV3IERlZmF1bHRBcHBlYXJhbmNlRXZhbHVhdG9yKGUpLnBhcnNlKCl9Y2xhc3MgQXBwZWFyYW5jZVN0cmVhbUV2YWx1YXRvciBleHRlbmRzIEV2YWx1YXRvclByZXByb2Nlc3Nvcntjb25zdHJ1Y3RvcihlLHQsYSxyKXtzdXBlcihlKTt0aGlzLnN0cmVhbT1lO3RoaXMuZXZhbHVhdG9yT3B0aW9ucz10O3RoaXMueHJlZj1hO3RoaXMuZ2xvYmFsQ29sb3JTcGFjZUNhY2hlPXI7dGhpcy5yZXNvdXJjZXM9ZS5kaWN0Py5nZXQoIlJlc291cmNlcyIpfXBhcnNlKCl7Y29uc3QgZT17Zm46MCxhcmdzOltdfTtsZXQgdD17c2NhbGVGYWN0b3I6MSxmb250U2l6ZTowLGZvbnROYW1lOiIiLGZvbnRDb2xvcjpuZXcgVWludDhDbGFtcGVkQXJyYXkoMyksZmlsbENvbG9yU3BhY2U6Q29sb3JTcGFjZVV0aWxzLmdyYXl9LGE9ITE7Y29uc3Qgcj1bXTt0cnl7Zm9yKDs7KXtlLmFyZ3MubGVuZ3RoPTA7aWYoYXx8IXRoaXMucmVhZChlKSlicmVhaztjb25zdHtmbjppLGFyZ3M6bn09ZTtzd2l0Y2goMHxpKXtjYXNlIHBlOnIucHVzaCh7c2NhbGVGYWN0b3I6dC5zY2FsZUZhY3Rvcixmb250U2l6ZTp0LmZvbnRTaXplLGZvbnROYW1lOnQuZm9udE5hbWUsZm9udENvbG9yOnQuZm9udENvbG9yLnNsaWNlKCksZmlsbENvbG9yU3BhY2U6dC5maWxsQ29sb3JTcGFjZX0pO2JyZWFrO2Nhc2UgbWU6dD1yLnBvcCgpfHx0O2JyZWFrO2Nhc2UgR2U6dC5zY2FsZUZhY3Rvcio9TWF0aC5oeXBvdChuWzBdLG5bMV0pO2JyZWFrO2Nhc2UgcWU6Y29uc3RbZSxpXT1uO2UgaW5zdGFuY2VvZiBOYW1lJiYodC5mb250TmFtZT1lLm5hbWUpOyJudW1iZXIiPT10eXBlb2YgaSYmaT4wJiYodC5mb250U2l6ZT1pKnQuc2NhbGVGYWN0b3IpO2JyZWFrO2Nhc2UgYXQ6dC5maWxsQ29sb3JTcGFjZT1Db2xvclNwYWNlVXRpbHMucGFyc2Uoe2NzOm5bMF0seHJlZjp0aGlzLnhyZWYscmVzb3VyY2VzOnRoaXMucmVzb3VyY2VzLHBkZkZ1bmN0aW9uRmFjdG9yeTp0aGlzLl9wZGZGdW5jdGlvbkZhY3RvcnksZ2xvYmFsQ29sb3JTcGFjZUNhY2hlOnRoaXMuZ2xvYmFsQ29sb3JTcGFjZUNhY2hlLGxvY2FsQ29sb3JTcGFjZUNhY2hlOnRoaXMuX2xvY2FsQ29sb3JTcGFjZUNhY2hlfSk7YnJlYWs7Y2FzZSBudDp0LmZpbGxDb2xvclNwYWNlLmdldFJnYkl0ZW0obiwwLHQuZm9udENvbG9yLDApO2JyZWFrO2Nhc2UgaHQ6Q29sb3JTcGFjZVV0aWxzLnJnYi5nZXRSZ2JJdGVtKG4sMCx0LmZvbnRDb2xvciwwKTticmVhaztjYXNlIGN0OkNvbG9yU3BhY2VVdGlscy5ncmF5LmdldFJnYkl0ZW0obiwwLHQuZm9udENvbG9yLDApO2JyZWFrO2Nhc2UgZHQ6Q29sb3JTcGFjZVV0aWxzLmNteWsuZ2V0UmdiSXRlbShuLDAsdC5mb250Q29sb3IsMCk7YnJlYWs7Y2FzZSBLZTpjYXNlIEplOmNhc2UgWWU6Y2FzZSBaZTphPSEwfX19Y2F0Y2goZSl7d2FybihgcGFyc2VBcHBlYXJhbmNlU3RyZWFtIC0gaWdub3JpbmcgZXJyb3JzOiAiJHtlfSIuYCl9dGhpcy5zdHJlYW0ucmVzZXQoKTtkZWxldGUgdC5zY2FsZUZhY3RvcjtkZWxldGUgdC5maWxsQ29sb3JTcGFjZTtyZXR1cm4gdH1nZXQgX2xvY2FsQ29sb3JTcGFjZUNhY2hlKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJfbG9jYWxDb2xvclNwYWNlQ2FjaGUiLG5ldyBMb2NhbENvbG9yU3BhY2VDYWNoZSl9Z2V0IF9wZGZGdW5jdGlvbkZhY3RvcnkoKXtyZXR1cm4gc2hhZG93KHRoaXMsIl9wZGZGdW5jdGlvbkZhY3RvcnkiLG5ldyBQREZGdW5jdGlvbkZhY3Rvcnkoe3hyZWY6dGhpcy54cmVmLGlzRXZhbFN1cHBvcnRlZDp0aGlzLmV2YWx1YXRvck9wdGlvbnMuaXNFdmFsU3VwcG9ydGVkfSkpfX1mdW5jdGlvbiBnZXRQZGZDb2xvcihlLHQpe2lmKGVbMF09PT1lWzFdJiZlWzFdPT09ZVsyXSl7cmV0dXJuYCR7bnVtYmVyVG9TdHJpbmcoZVswXS8yNTUpfSAke3Q/ImciOiJHIn1gfXJldHVybiBBcnJheS5mcm9tKGUsKGU9Pm51bWJlclRvU3RyaW5nKGUvMjU1KSkpLmpvaW4oIiAiKSsiICIrKHQ/InJnIjoiUkciKX1jbGFzcyBGYWtlVW5pY29kZUZvbnR7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnhyZWY9ZTt0aGlzLndpZHRocz1udWxsO3RoaXMuZmlyc3RDaGFyPTEvMDt0aGlzLmxhc3RDaGFyPS0xLzA7dGhpcy5mb250RmFtaWx5PXQ7Y29uc3QgYT1uZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7dGhpcy5jdHhNZWFzdXJlPWEuZ2V0Q29udGV4dCgiMmQiLHt3aWxsUmVhZEZyZXF1ZW50bHk6ITB9KTtGYWtlVW5pY29kZUZvbnQuX2ZvbnROYW1lSWR8fChGYWtlVW5pY29kZUZvbnQuX2ZvbnROYW1lSWQ9MSk7dGhpcy5mb250TmFtZT1OYW1lLmdldChgSW52YWxpZFBERmpzRm9udF8ke3R9XyR7RmFrZVVuaWNvZGVGb250Ll9mb250TmFtZUlkKyt9YCl9Z2V0IGZvbnREZXNjcmlwdG9yUmVmKCl7aWYoIUZha2VVbmljb2RlRm9udC5fZm9udERlc2NyaXB0b3JSZWYpe2NvbnN0IGU9bmV3IERpY3QodGhpcy54cmVmKTtlLnNldElmTmFtZSgiVHlwZSIsIkZvbnREZXNjcmlwdG9yIik7ZS5zZXQoIkZvbnROYW1lIix0aGlzLmZvbnROYW1lKTtlLnNldCgiRm9udEZhbWlseSIsIk15cmlhZFBybyBSZWd1bGFyIik7ZS5zZXQoIkZvbnRCQm94IixbMCwwLDAsMF0pO2Uuc2V0SWZOYW1lKCJGb250U3RyZXRjaCIsIk5vcm1hbCIpO2Uuc2V0KCJGb250V2VpZ2h0Iiw0MDApO2Uuc2V0KCJJdGFsaWNBbmdsZSIsMCk7RmFrZVVuaWNvZGVGb250Ll9mb250RGVzY3JpcHRvclJlZj10aGlzLnhyZWYuZ2V0TmV3UGVyc2lzdGVudFJlZihlKX1yZXR1cm4gRmFrZVVuaWNvZGVGb250Ll9mb250RGVzY3JpcHRvclJlZn1nZXQgZGVzY2VuZGFudEZvbnRSZWYoKXtjb25zdCBlPW5ldyBEaWN0KHRoaXMueHJlZik7ZS5zZXQoIkJhc2VGb250Iix0aGlzLmZvbnROYW1lKTtlLnNldElmTmFtZSgiVHlwZSIsIkZvbnQiKTtlLnNldElmTmFtZSgiU3VidHlwZSIsIkNJREZvbnRUeXBlMCIpO2Uuc2V0SWZOYW1lKCJDSURUb0dJRE1hcCIsIklkZW50aXR5Iik7ZS5zZXQoIkZpcnN0Q2hhciIsdGhpcy5maXJzdENoYXIpO2Uuc2V0KCJMYXN0Q2hhciIsdGhpcy5sYXN0Q2hhcik7ZS5zZXQoIkZvbnREZXNjcmlwdG9yIix0aGlzLmZvbnREZXNjcmlwdG9yUmVmKTtlLnNldCgiRFciLDFlMyk7Y29uc3QgdD1bXSxhPVsuLi50aGlzLndpZHRocy5lbnRyaWVzKCldLnNvcnQoKTtsZXQgcj1udWxsLGk9bnVsbDtmb3IoY29uc3RbZSxuXW9mIGEpaWYocilpZihlPT09citpLmxlbmd0aClpLnB1c2gobik7ZWxzZXt0LnB1c2gocixpKTtyPWU7aT1bbl19ZWxzZXtyPWU7aT1bbl19ciYmdC5wdXNoKHIsaSk7ZS5zZXQoIlciLHQpO2NvbnN0IG49bmV3IERpY3QodGhpcy54cmVmKTtuLnNldCgiT3JkZXJpbmciLCJJZGVudGl0eSIpO24uc2V0KCJSZWdpc3RyeSIsIkFkb2JlIik7bi5zZXQoIlN1cHBsZW1lbnQiLDApO2Uuc2V0KCJDSURTeXN0ZW1JbmZvIixuKTtyZXR1cm4gdGhpcy54cmVmLmdldE5ld1BlcnNpc3RlbnRSZWYoZSl9Z2V0IGJhc2VGb250UmVmKCl7Y29uc3QgZT1uZXcgRGljdCh0aGlzLnhyZWYpO2Uuc2V0KCJCYXNlRm9udCIsdGhpcy5mb250TmFtZSk7ZS5zZXRJZk5hbWUoIlR5cGUiLCJGb250Iik7ZS5zZXRJZk5hbWUoIlN1YnR5cGUiLCJUeXBlMCIpO2Uuc2V0SWZOYW1lKCJFbmNvZGluZyIsIklkZW50aXR5LUgiKTtlLnNldCgiRGVzY2VuZGFudEZvbnRzIixbdGhpcy5kZXNjZW5kYW50Rm9udFJlZl0pO2Uuc2V0SWZOYW1lKCJUb1VuaWNvZGUiLCJJZGVudGl0eS1IIik7cmV0dXJuIHRoaXMueHJlZi5nZXROZXdQZXJzaXN0ZW50UmVmKGUpfWdldCByZXNvdXJjZXMoKXtjb25zdCBlPW5ldyBEaWN0KHRoaXMueHJlZiksdD1uZXcgRGljdCh0aGlzLnhyZWYpO3Quc2V0KHRoaXMuZm9udE5hbWUubmFtZSx0aGlzLmJhc2VGb250UmVmKTtlLnNldCgiRm9udCIsdCk7cmV0dXJuIGV9X2NyZWF0ZUNvbnRleHQoKXt0aGlzLndpZHRocz1uZXcgTWFwO3RoaXMuY3R4TWVhc3VyZS5mb250PWAxMDAwcHggJHt0aGlzLmZvbnRGYW1pbHl9YDtyZXR1cm4gdGhpcy5jdHhNZWFzdXJlfWNyZWF0ZUZvbnRSZXNvdXJjZXMoZSl7Y29uc3QgdD10aGlzLl9jcmVhdGVDb250ZXh0KCk7Zm9yKGNvbnN0IGEgb2YgZS5zcGxpdCgvXHJcbj98XG4vKSlmb3IoY29uc3QgZSBvZiBhLnNwbGl0KCIiKSl7Y29uc3QgYT1lLmNoYXJDb2RlQXQoMCk7aWYodGhpcy53aWR0aHMuaGFzKGEpKWNvbnRpbnVlO2NvbnN0IHI9dC5tZWFzdXJlVGV4dChlKSxpPU1hdGguY2VpbChyLndpZHRoKTt0aGlzLndpZHRocy5zZXQoYSxpKTt0aGlzLmZpcnN0Q2hhcj1NYXRoLm1pbihhLHRoaXMuZmlyc3RDaGFyKTt0aGlzLmxhc3RDaGFyPU1hdGgubWF4KGEsdGhpcy5sYXN0Q2hhcil9cmV0dXJuIHRoaXMucmVzb3VyY2VzfXN0YXRpYyBnZXRGaXJzdFBvc2l0aW9uSW5mbyhlLHQsaSl7Y29uc3RbbixzLG8sY109ZTtsZXQgbD1vLW4saD1jLXM7dCUxODAhPTAmJihbbCxoXT1baCxsXSk7Y29uc3QgdT1hKmk7cmV0dXJue2Nvb3JkczpbMCxoK3IqaS11XSxiYm94OlswLDAsbCxoXSxtYXRyaXg6MCE9PXQ/Z2V0Um90YXRpb25NYXRyaXgodCxoLHUpOnZvaWQgMH19Y3JlYXRlQXBwZWFyYW5jZShlLHQsaSxuLHMsbyl7Y29uc3QgYz10aGlzLl9jcmVhdGVDb250ZXh0KCksbD1bXTtsZXQgaD0tMS8wO2Zvcihjb25zdCB0IG9mIGUuc3BsaXQoL1xyXG4/fFxuLykpe2wucHVzaCh0KTtjb25zdCBlPWMubWVhc3VyZVRleHQodCkud2lkdGg7aD1NYXRoLm1heChoLGUpO2Zvcihjb25zdCBlIG9mIGNvZGVQb2ludEl0ZXIodCkpe2NvbnN0IHQ9U3RyaW5nLmZyb21Db2RlUG9pbnQoZSk7bGV0IGE9dGhpcy53aWR0aHMuZ2V0KGUpO2lmKHZvaWQgMD09PWEpe2NvbnN0IHI9Yy5tZWFzdXJlVGV4dCh0KTthPU1hdGguY2VpbChyLndpZHRoKTt0aGlzLndpZHRocy5zZXQoZSxhKTt0aGlzLmZpcnN0Q2hhcj1NYXRoLm1pbihlLHRoaXMuZmlyc3RDaGFyKTt0aGlzLmxhc3RDaGFyPU1hdGgubWF4KGUsdGhpcy5sYXN0Q2hhcil9fX1oKj1uLzFlMztjb25zdFt1LGQsZixnXT10O2xldCBwPWYtdSxtPWctZDtpJTE4MCE9MCYmKFtwLG1dPVttLHBdKTtsZXQgYj0xO2g+cCYmKGI9cC9oKTtsZXQgeT0xO2NvbnN0IHc9YSpuLHg9cipuLFM9dypsLmxlbmd0aDtTPm0mJih5PW0vUyk7Y29uc3Qgaz1uKk1hdGgubWluKGIseSksQz1bInEiLGAwIDAgJHtudW1iZXJUb1N0cmluZyhwKX0gJHtudW1iZXJUb1N0cmluZyhtKX0gcmUgVyBuYCwiQlQiLGAxIDAgMCAxIDAgJHtudW1iZXJUb1N0cmluZyhtK3gpfSBUbSAwIFRjICR7Z2V0UGRmQ29sb3IocywhMCl9YCxgLyR7dGhpcy5mb250TmFtZS5uYW1lfSAke251bWJlclRvU3RyaW5nKGspfSBUZmBdLHtyZXNvdXJjZXM6dn09dGhpcztpZigxIT09KG89Im51bWJlciI9PXR5cGVvZiBvJiZvPj0wJiZvPD0xP286MSkpe0MucHVzaCgiL1IwIGdzIik7Y29uc3QgZT1uZXcgRGljdCh0aGlzLnhyZWYpLHQ9bmV3IERpY3QodGhpcy54cmVmKTt0LnNldCgiY2EiLG8pO3Quc2V0KCJDQSIsbyk7dC5zZXRJZk5hbWUoIlR5cGUiLCJFeHRHU3RhdGUiKTtlLnNldCgiUjAiLHQpO3Yuc2V0KCJFeHRHU3RhdGUiLGUpfWNvbnN0IEY9bnVtYmVyVG9TdHJpbmcodyk7Zm9yKGNvbnN0IGUgb2YgbClDLnB1c2goYDAgLSR7Rn0gVGQgPCR7c3RyaW5nVG9VVEYxNkhleFN0cmluZyhlKX0+IFRqYCk7Qy5wdXNoKCJFVCIsIlEiKTtjb25zdCBUPUMuam9pbigiXG4iKSxPPW5ldyBEaWN0KHRoaXMueHJlZik7Ty5zZXRJZk5hbWUoIlN1YnR5cGUiLCJGb3JtIik7Ty5zZXRJZk5hbWUoIlR5cGUiLCJYT2JqZWN0Iik7Ty5zZXQoIkJCb3giLFswLDAscCxtXSk7Ty5zZXQoIkxlbmd0aCIsVC5sZW5ndGgpO08uc2V0KCJSZXNvdXJjZXMiLHYpO2lmKGkpe2NvbnN0IGU9Z2V0Um90YXRpb25NYXRyaXgoaSxwLG0pO08uc2V0KCJNYXRyaXgiLGUpfWNvbnN0IE09bmV3IFN0cmluZ1N0cmVhbShUKTtNLmRpY3Q9TztyZXR1cm4gTX19Y29uc3Qgd249WyJtL2QiLCJtL2QveXkiLCJtbS9kZC95eSIsIm1tL3l5IiwiZC1tbW0iLCJkLW1tbS15eSIsImRkLW1tbS15eSIsInl5LW1tLWRkIiwibW1tLXl5IiwibW1tbS15eSIsIm1tbSBkLCB5eXl5IiwibW1tbSBkLCB5eXl5IiwibS9kL3l5IGg6TU0gdHQiLCJtL2QveXkgSEg6TU0iXSx4bj1bIkhIOk1NIiwiaDpNTSB0dCIsIkhIOk1NOnNzIiwiaDpNTTpzcyB0dCJdO2NsYXNzIE5hbWVPck51bWJlclRyZWV7Y29uc3RydWN0b3IoZSx0LGEpe3RoaXMucm9vdD1lO3RoaXMueHJlZj10O3RoaXMuX3R5cGU9YX1nZXRBbGwoKXtjb25zdCBlPW5ldyBNYXA7aWYoIXRoaXMucm9vdClyZXR1cm4gZTtjb25zdCB0PXRoaXMueHJlZixhPW5ldyBSZWZTZXQ7YS5wdXQodGhpcy5yb290KTtjb25zdCByPVt0aGlzLnJvb3RdO2Zvcig7ci5sZW5ndGg+MDspe2NvbnN0IGk9dC5mZXRjaElmUmVmKHIuc2hpZnQoKSk7aWYoIShpIGluc3RhbmNlb2YgRGljdCkpY29udGludWU7aWYoaS5oYXMoIktpZHMiKSl7Y29uc3QgZT1pLmdldCgiS2lkcyIpO2lmKCFBcnJheS5pc0FycmF5KGUpKWNvbnRpbnVlO2Zvcihjb25zdCB0IG9mIGUpe2lmKGEuaGFzKHQpKXRocm93IG5ldyBGb3JtYXRFcnJvcihgRHVwbGljYXRlIGVudHJ5IGluICIke3RoaXMuX3R5cGV9IiB0cmVlLmApO3IucHVzaCh0KTthLnB1dCh0KX1jb250aW51ZX1jb25zdCBuPWkuZ2V0KHRoaXMuX3R5cGUpO2lmKEFycmF5LmlzQXJyYXkobikpZm9yKGxldCBhPTAscj1uLmxlbmd0aDthPHI7YSs9MillLnNldCh0LmZldGNoSWZSZWYoblthXSksdC5mZXRjaElmUmVmKG5bYSsxXSkpfXJldHVybiBlfWdldFJhdyhlKXtpZighdGhpcy5yb290KXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy54cmVmO2xldCBhPXQuZmV0Y2hJZlJlZih0aGlzLnJvb3QpLHI9MDtmb3IoO2EuaGFzKCJLaWRzIik7KXtpZigrK3I+MTApe3dhcm4oYFNlYXJjaCBkZXB0aCBsaW1pdCByZWFjaGVkIGZvciAiJHt0aGlzLl90eXBlfSIgdHJlZS5gKTtyZXR1cm4gbnVsbH1jb25zdCBpPWEuZ2V0KCJLaWRzIik7aWYoIUFycmF5LmlzQXJyYXkoaSkpcmV0dXJuIG51bGw7bGV0IG49MCxzPWkubGVuZ3RoLTE7Zm9yKDtuPD1zOyl7Y29uc3Qgcj1uK3M+PjEsbz10LmZldGNoSWZSZWYoaVtyXSksYz1vLmdldCgiTGltaXRzIik7aWYoZTx0LmZldGNoSWZSZWYoY1swXSkpcz1yLTE7ZWxzZXtpZighKGU+dC5mZXRjaElmUmVmKGNbMV0pKSl7YT1vO2JyZWFrfW49cisxfX1pZihuPnMpcmV0dXJuIG51bGx9Y29uc3QgaT1hLmdldCh0aGlzLl90eXBlKTtpZihBcnJheS5pc0FycmF5KGkpKXtsZXQgYT0wLHI9aS5sZW5ndGgtMjtmb3IoO2E8PXI7KXtjb25zdCBuPWErcj4+MSxzPW4rKDEmbiksbz10LmZldGNoSWZSZWYoaVtzXSk7aWYoZTxvKXI9cy0yO2Vsc2V7aWYoIShlPm8pKXJldHVybiBpW3MrMV07YT1zKzJ9fX1yZXR1cm4gbnVsbH1nZXQoZSl7cmV0dXJuIHRoaXMueHJlZi5mZXRjaElmUmVmKHRoaXMuZ2V0UmF3KGUpKX19Y2xhc3MgTmFtZVRyZWUgZXh0ZW5kcyBOYW1lT3JOdW1iZXJUcmVle2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSx0LCJOYW1lcyIpfX1jbGFzcyBOdW1iZXJUcmVlIGV4dGVuZHMgTmFtZU9yTnVtYmVyVHJlZXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKGUsdCwiTnVtcyIpfX1mdW5jdGlvbiBjbGVhckdsb2JhbENhY2hlcygpeyFmdW5jdGlvbiBjbGVhclBhdHRlcm5DYWNoZXMoKXtoaT1PYmplY3QuY3JlYXRlKG51bGwpfSgpOyFmdW5jdGlvbiBjbGVhclByaW1pdGl2ZUNhY2hlcygpe3JhPU9iamVjdC5jcmVhdGUobnVsbCk7aWE9T2JqZWN0LmNyZWF0ZShudWxsKTtuYT1PYmplY3QuY3JlYXRlKG51bGwpfSgpOyFmdW5jdGlvbiBjbGVhclVuaWNvZGVDYWNoZXMoKXtnci5jbGVhcigpfSgpO0pweEltYWdlLmNsZWFudXAoKX1mdW5jdGlvbiBwaWNrUGxhdGZvcm1JdGVtKGUpe3JldHVybiBlIGluc3RhbmNlb2YgRGljdD9lLmhhcygiVUYiKT9lLmdldCgiVUYiKTplLmhhcygiRiIpP2UuZ2V0KCJGIik6ZS5oYXMoIlVuaXgiKT9lLmdldCgiVW5peCIpOmUuaGFzKCJNYWMiKT9lLmdldCgiTWFjIik6ZS5oYXMoIkRPUyIpP2UuZ2V0KCJET1MiKTpudWxsOm51bGx9Y2xhc3MgRmlsZVNwZWN7I1k9ITE7Y29uc3RydWN0b3IoZSx0LGE9ITEpe2lmKGUgaW5zdGFuY2VvZiBEaWN0KXt0aGlzLnhyZWY9dDt0aGlzLnJvb3Q9ZTtlLmhhcygiRlMiKSYmKHRoaXMuZnM9ZS5nZXQoIkZTIikpO2UuaGFzKCJSRiIpJiZ3YXJuKCJSZWxhdGVkIGZpbGUgc3BlY2lmaWNhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQiKTthfHwoZS5oYXMoIkVGIik/dGhpcy4jWT0hMDp3YXJuKCJOb24tZW1iZWRkZWQgZmlsZSBzcGVjaWZpY2F0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCIpKX19Z2V0IGZpbGVuYW1lKCl7bGV0IGU9IiI7Y29uc3QgdD1waWNrUGxhdGZvcm1JdGVtKHRoaXMucm9vdCk7dCYmInN0cmluZyI9PXR5cGVvZiB0JiYoZT1zdHJpbmdUb1BERlN0cmluZyh0LCEwKS5yZXBsYWNlQWxsKCJcXFxcIiwiXFwiKS5yZXBsYWNlQWxsKCJcXC8iLCIvIikucmVwbGFjZUFsbCgiXFwiLCIvIikpO3JldHVybiBzaGFkb3codGhpcywiZmlsZW5hbWUiLGV8fCJ1bm5hbWVkIil9Z2V0IGNvbnRlbnQoKXtpZighdGhpcy4jWSlyZXR1cm4gbnVsbDt0aGlzLl9jb250ZW50UmVmfHw9cGlja1BsYXRmb3JtSXRlbSh0aGlzLnJvb3Q/LmdldCgiRUYiKSk7bGV0IGU9bnVsbDtpZih0aGlzLl9jb250ZW50UmVmKXtjb25zdCB0PXRoaXMueHJlZi5mZXRjaElmUmVmKHRoaXMuX2NvbnRlbnRSZWYpO3QgaW5zdGFuY2VvZiBCYXNlU3RyZWFtP2U9dC5nZXRCeXRlcygpOndhcm4oIkVtYmVkZGVkIGZpbGUgc3BlY2lmaWNhdGlvbiBwb2ludHMgdG8gbm9uLWV4aXN0aW5nL2ludmFsaWQgY29udGVudCIpfWVsc2Ugd2FybigiRW1iZWRkZWQgZmlsZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGhhdmUgYW55IGNvbnRlbnQiKTtyZXR1cm4gZX1nZXQgZGVzY3JpcHRpb24oKXtsZXQgZT0iIjtjb25zdCB0PXRoaXMucm9vdD8uZ2V0KCJEZXNjIik7dCYmInN0cmluZyI9PXR5cGVvZiB0JiYoZT1zdHJpbmdUb1BERlN0cmluZyh0KSk7cmV0dXJuIHNoYWRvdyh0aGlzLCJkZXNjcmlwdGlvbiIsZSl9Z2V0IHNlcmlhbGl6YWJsZSgpe3JldHVybntyYXdGaWxlbmFtZTp0aGlzLmZpbGVuYW1lLGZpbGVuYW1lOihlPXRoaXMuZmlsZW5hbWUsZS5zdWJzdHJpbmcoZS5sYXN0SW5kZXhPZigiLyIpKzEpKSxjb250ZW50OnRoaXMuY29udGVudCxkZXNjcmlwdGlvbjp0aGlzLmRlc2NyaXB0aW9ufTt2YXIgZX19Y29uc3QgU249MCxBbj0tMixrbj0tMyxDbj0tNCx2bj0tNSxGbj0tNixJbj0tOTtmdW5jdGlvbiBpc1doaXRlc3BhY2UoZSx0KXtjb25zdCBhPWVbdF07cmV0dXJuIiAiPT09YXx8IlxuIj09PWF8fCJcciI9PT1hfHwiXHQiPT09YX1jbGFzcyBYTUxQYXJzZXJCYXNle19yZXNvbHZlRW50aXRpZXMoZSl7cmV0dXJuIGUucmVwbGFjZUFsbCgvJihbXjtdKyk7L2csKChlLHQpPT57aWYoIiN4Ij09PXQuc3Vic3RyaW5nKDAsMikpcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KHQuc3Vic3RyaW5nKDIpLDE2KSk7aWYoIiMiPT09dC5zdWJzdHJpbmcoMCwxKSlyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQodC5zdWJzdHJpbmcoMSksMTApKTtzd2l0Y2godCl7Y2FzZSJsdCI6cmV0dXJuIjwiO2Nhc2UiZ3QiOnJldHVybiI+IjtjYXNlImFtcCI6cmV0dXJuIiYiO2Nhc2UicXVvdCI6cmV0dXJuJyInO2Nhc2UiYXBvcyI6cmV0dXJuIicifXJldHVybiB0aGlzLm9uUmVzb2x2ZUVudGl0eSh0KX0pKX1fcGFyc2VDb250ZW50KGUsdCl7Y29uc3QgYT1bXTtsZXQgcj10O2Z1bmN0aW9uIHNraXBXcygpe2Zvcig7cjxlLmxlbmd0aCYmaXNXaGl0ZXNwYWNlKGUscik7KSsrcn1mb3IoO3I8ZS5sZW5ndGgmJiFpc1doaXRlc3BhY2UoZSxyKSYmIj4iIT09ZVtyXSYmIi8iIT09ZVtyXTspKytyO2NvbnN0IGk9ZS5zdWJzdHJpbmcodCxyKTtza2lwV3MoKTtmb3IoO3I8ZS5sZW5ndGgmJiI+IiE9PWVbcl0mJiIvIiE9PWVbcl0mJiI/IiE9PWVbcl07KXtza2lwV3MoKTtsZXQgdD0iIixpPSIiO2Zvcig7cjxlLmxlbmd0aCYmIWlzV2hpdGVzcGFjZShlLHIpJiYiPSIhPT1lW3JdOyl7dCs9ZVtyXTsrK3J9c2tpcFdzKCk7aWYoIj0iIT09ZVtyXSlyZXR1cm4gbnVsbDsrK3I7c2tpcFdzKCk7Y29uc3Qgbj1lW3JdO2lmKCciJyE9PW4mJiInIiE9PW4pcmV0dXJuIG51bGw7Y29uc3Qgcz1lLmluZGV4T2YobiwrK3IpO2lmKHM8MClyZXR1cm4gbnVsbDtpPWUuc3Vic3RyaW5nKHIscyk7YS5wdXNoKHtuYW1lOnQsdmFsdWU6dGhpcy5fcmVzb2x2ZUVudGl0aWVzKGkpfSk7cj1zKzE7c2tpcFdzKCl9cmV0dXJue25hbWU6aSxhdHRyaWJ1dGVzOmEscGFyc2VkOnItdH19X3BhcnNlUHJvY2Vzc2luZ0luc3RydWN0aW9uKGUsdCl7bGV0IGE9dDtmb3IoO2E8ZS5sZW5ndGgmJiFpc1doaXRlc3BhY2UoZSxhKSYmIj4iIT09ZVthXSYmIj8iIT09ZVthXSYmIi8iIT09ZVthXTspKythO2NvbnN0IHI9ZS5zdWJzdHJpbmcodCxhKTshZnVuY3Rpb24gc2tpcFdzKCl7Zm9yKDthPGUubGVuZ3RoJiZpc1doaXRlc3BhY2UoZSxhKTspKythfSgpO2NvbnN0IGk9YTtmb3IoO2E8ZS5sZW5ndGgmJigiPyIhPT1lW2FdfHwiPiIhPT1lW2ErMV0pOykrK2E7cmV0dXJue25hbWU6cix2YWx1ZTplLnN1YnN0cmluZyhpLGEpLHBhcnNlZDphLXR9fXBhcnNlWG1sKGUpe2xldCB0PTA7Zm9yKDt0PGUubGVuZ3RoOyl7bGV0IGE9dDtpZigiPCI9PT1lW3RdKXsrK2E7bGV0IHQ7c3dpdGNoKGVbYV0pe2Nhc2UiLyI6KythO3Q9ZS5pbmRleE9mKCI+IixhKTtpZih0PDApe3RoaXMub25FcnJvcihJbik7cmV0dXJufXRoaXMub25FbmRFbGVtZW50KGUuc3Vic3RyaW5nKGEsdCkpO2E9dCsxO2JyZWFrO2Nhc2UiPyI6KythO2NvbnN0IHI9dGhpcy5fcGFyc2VQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oZSxhKTtpZigiPz4iIT09ZS5zdWJzdHJpbmcoYStyLnBhcnNlZCxhK3IucGFyc2VkKzIpKXt0aGlzLm9uRXJyb3Ioa24pO3JldHVybn10aGlzLm9uUGkoci5uYW1lLHIudmFsdWUpO2ErPXIucGFyc2VkKzI7YnJlYWs7Y2FzZSIhIjppZigiLS0iPT09ZS5zdWJzdHJpbmcoYSsxLGErMykpe3Q9ZS5pbmRleE9mKCItLVx4M2UiLGErMyk7aWYodDwwKXt0aGlzLm9uRXJyb3Iodm4pO3JldHVybn10aGlzLm9uQ29tbWVudChlLnN1YnN0cmluZyhhKzMsdCkpO2E9dCszfWVsc2UgaWYoIltDREFUQVsiPT09ZS5zdWJzdHJpbmcoYSsxLGErOCkpe3Q9ZS5pbmRleE9mKCJdXT4iLGErOCk7aWYodDwwKXt0aGlzLm9uRXJyb3IoQW4pO3JldHVybn10aGlzLm9uQ2RhdGEoZS5zdWJzdHJpbmcoYSs4LHQpKTthPXQrM31lbHNle2lmKCJET0NUWVBFIiE9PWUuc3Vic3RyaW5nKGErMSxhKzgpKXt0aGlzLm9uRXJyb3IoRm4pO3JldHVybn17Y29uc3Qgcj1lLmluZGV4T2YoIlsiLGErOCk7bGV0IGk9ITE7dD1lLmluZGV4T2YoIj4iLGErOCk7aWYodDwwKXt0aGlzLm9uRXJyb3IoQ24pO3JldHVybn1pZihyPjAmJnQ+cil7dD1lLmluZGV4T2YoIl0+IixhKzgpO2lmKHQ8MCl7dGhpcy5vbkVycm9yKENuKTtyZXR1cm59aT0hMH1jb25zdCBuPWUuc3Vic3RyaW5nKGErOCx0KyhpPzE6MCkpO3RoaXMub25Eb2N0eXBlKG4pO2E9dCsoaT8yOjEpfX1icmVhaztkZWZhdWx0OmNvbnN0IGk9dGhpcy5fcGFyc2VDb250ZW50KGUsYSk7aWYobnVsbD09PWkpe3RoaXMub25FcnJvcihGbik7cmV0dXJufWxldCBuPSExO2lmKCIvPiI9PT1lLnN1YnN0cmluZyhhK2kucGFyc2VkLGEraS5wYXJzZWQrMikpbj0hMDtlbHNlIGlmKCI+IiE9PWUuc3Vic3RyaW5nKGEraS5wYXJzZWQsYStpLnBhcnNlZCsxKSl7dGhpcy5vbkVycm9yKEluKTtyZXR1cm59dGhpcy5vbkJlZ2luRWxlbWVudChpLm5hbWUsaS5hdHRyaWJ1dGVzLG4pO2ErPWkucGFyc2VkKyhuPzI6MSl9fWVsc2V7Zm9yKDthPGUubGVuZ3RoJiYiPCIhPT1lW2FdOylhKys7Y29uc3Qgcj1lLnN1YnN0cmluZyh0LGEpO3RoaXMub25UZXh0KHRoaXMuX3Jlc29sdmVFbnRpdGllcyhyKSl9dD1hfX1vblJlc29sdmVFbnRpdHkoZSl7cmV0dXJuYCYke2V9O2B9b25QaShlLHQpe31vbkNvbW1lbnQoZSl7fW9uQ2RhdGEoZSl7fW9uRG9jdHlwZShlKXt9b25UZXh0KGUpe31vbkJlZ2luRWxlbWVudChlLHQsYSl7fW9uRW5kRWxlbWVudChlKXt9b25FcnJvcihlKXt9fWNsYXNzIFNpbXBsZURPTU5vZGV7Y29uc3RydWN0b3IoZSx0KXt0aGlzLm5vZGVOYW1lPWU7dGhpcy5ub2RlVmFsdWU9dDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFyZW50Tm9kZSIse3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9KX1nZXQgZmlyc3RDaGlsZCgpe3JldHVybiB0aGlzLmNoaWxkTm9kZXM/LlswXX1nZXQgbmV4dFNpYmxpbmcoKXtjb25zdCBlPXRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO2lmKCFlKXJldHVybjtjb25zdCB0PWUuaW5kZXhPZih0aGlzKTtyZXR1cm4tMSE9PXQ/ZVt0KzFdOnZvaWQgMH1nZXQgdGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5jaGlsZE5vZGVzP3RoaXMuY2hpbGROb2Rlcy5tYXAoKGU9PmUudGV4dENvbnRlbnQpKS5qb2luKCIiKTp0aGlzLm5vZGVWYWx1ZXx8IiJ9Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXMuY2hpbGROb2Rlc3x8W119aGFzQ2hpbGROb2Rlcygpe3JldHVybiB0aGlzLmNoaWxkTm9kZXM/Lmxlbmd0aD4wfXNlYXJjaE5vZGUoZSx0KXtpZih0Pj1lLmxlbmd0aClyZXR1cm4gdGhpcztjb25zdCBhPWVbdF07aWYoYS5uYW1lLnN0YXJ0c1dpdGgoIiMiKSYmdDxlLmxlbmd0aC0xKXJldHVybiB0aGlzLnNlYXJjaE5vZGUoZSx0KzEpO2NvbnN0IHI9W107bGV0IGk9dGhpcztmb3IoOzspe2lmKGEubmFtZT09PWkubm9kZU5hbWUpe2lmKDAhPT1hLnBvcyl7aWYoMD09PXIubGVuZ3RoKXJldHVybiBudWxsO3tjb25zdFtuXT1yLnBvcCgpO2xldCBzPTA7Zm9yKGNvbnN0IHIgb2Ygbi5jaGlsZE5vZGVzKWlmKGEubmFtZT09PXIubm9kZU5hbWUpe2lmKHM9PT1hLnBvcylyZXR1cm4gci5zZWFyY2hOb2RlKGUsdCsxKTtzKyt9cmV0dXJuIGkuc2VhcmNoTm9kZShlLHQrMSl9fXtjb25zdCBhPWkuc2VhcmNoTm9kZShlLHQrMSk7aWYobnVsbCE9PWEpcmV0dXJuIGF9fWlmKGkuY2hpbGROb2Rlcz8ubGVuZ3RoPjApe3IucHVzaChbaSwwXSk7aT1pLmNoaWxkTm9kZXNbMF19ZWxzZXtpZigwPT09ci5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKDswIT09ci5sZW5ndGg7KXtjb25zdFtlLHRdPXIucG9wKCksYT10KzE7aWYoYTxlLmNoaWxkTm9kZXMubGVuZ3RoKXtyLnB1c2goW2UsYV0pO2k9ZS5jaGlsZE5vZGVzW2FdO2JyZWFrfX1pZigwPT09ci5sZW5ndGgpcmV0dXJuIG51bGx9fX1kdW1wKGUpe2lmKCIjdGV4dCIhPT10aGlzLm5vZGVOYW1lKXtlLnB1c2goYDwke3RoaXMubm9kZU5hbWV9YCk7aWYodGhpcy5hdHRyaWJ1dGVzKWZvcihjb25zdCB0IG9mIHRoaXMuYXR0cmlidXRlcyllLnB1c2goYCAke3QubmFtZX09IiR7ZW5jb2RlVG9YbWxTdHJpbmcodC52YWx1ZSl9ImApO2lmKHRoaXMuaGFzQ2hpbGROb2RlcygpKXtlLnB1c2goIj4iKTtmb3IoY29uc3QgdCBvZiB0aGlzLmNoaWxkTm9kZXMpdC5kdW1wKGUpO2UucHVzaChgPC8ke3RoaXMubm9kZU5hbWV9PmApfWVsc2UgdGhpcy5ub2RlVmFsdWU/ZS5wdXNoKGA+JHtlbmNvZGVUb1htbFN0cmluZyh0aGlzLm5vZGVWYWx1ZSl9PC8ke3RoaXMubm9kZU5hbWV9PmApOmUucHVzaCgiLz4iKX1lbHNlIGUucHVzaChlbmNvZGVUb1htbFN0cmluZyh0aGlzLm5vZGVWYWx1ZSkpfX1jbGFzcyBTaW1wbGVYTUxQYXJzZXIgZXh0ZW5kcyBYTUxQYXJzZXJCYXNle2NvbnN0cnVjdG9yKHtoYXNBdHRyaWJ1dGVzOmU9ITEsbG93ZXJDYXNlTmFtZTp0PSExfSl7c3VwZXIoKTt0aGlzLl9jdXJyZW50RnJhZ21lbnQ9bnVsbDt0aGlzLl9zdGFjaz1udWxsO3RoaXMuX2Vycm9yQ29kZT1Tbjt0aGlzLl9oYXNBdHRyaWJ1dGVzPWU7dGhpcy5fbG93ZXJDYXNlTmFtZT10fXBhcnNlRnJvbVN0cmluZyhlKXt0aGlzLl9jdXJyZW50RnJhZ21lbnQ9W107dGhpcy5fc3RhY2s9W107dGhpcy5fZXJyb3JDb2RlPVNuO3RoaXMucGFyc2VYbWwoZSk7aWYodGhpcy5fZXJyb3JDb2RlIT09U24pcmV0dXJuO2NvbnN0W3RdPXRoaXMuX2N1cnJlbnRGcmFnbWVudDtyZXR1cm4gdD97ZG9jdW1lbnRFbGVtZW50OnR9OnZvaWQgMH1vblRleHQoZSl7aWYoZnVuY3Rpb24gaXNXaGl0ZXNwYWNlU3RyaW5nKGUpe2ZvcihsZXQgdD0wLGE9ZS5sZW5ndGg7dDxhO3QrKylpZighaXNXaGl0ZXNwYWNlKGUsdCkpcmV0dXJuITE7cmV0dXJuITB9KGUpKXJldHVybjtjb25zdCB0PW5ldyBTaW1wbGVET01Ob2RlKCIjdGV4dCIsZSk7dGhpcy5fY3VycmVudEZyYWdtZW50LnB1c2godCl9b25DZGF0YShlKXtjb25zdCB0PW5ldyBTaW1wbGVET01Ob2RlKCIjdGV4dCIsZSk7dGhpcy5fY3VycmVudEZyYWdtZW50LnB1c2godCl9b25CZWdpbkVsZW1lbnQoZSx0LGEpe3RoaXMuX2xvd2VyQ2FzZU5hbWUmJihlPWUudG9Mb3dlckNhc2UoKSk7Y29uc3Qgcj1uZXcgU2ltcGxlRE9NTm9kZShlKTtyLmNoaWxkTm9kZXM9W107dGhpcy5faGFzQXR0cmlidXRlcyYmKHIuYXR0cmlidXRlcz10KTt0aGlzLl9jdXJyZW50RnJhZ21lbnQucHVzaChyKTtpZighYSl7dGhpcy5fc3RhY2sucHVzaCh0aGlzLl9jdXJyZW50RnJhZ21lbnQpO3RoaXMuX2N1cnJlbnRGcmFnbWVudD1yLmNoaWxkTm9kZXN9fW9uRW5kRWxlbWVudChlKXt0aGlzLl9jdXJyZW50RnJhZ21lbnQ9dGhpcy5fc3RhY2sucG9wKCl8fFtdO2NvbnN0IHQ9dGhpcy5fY3VycmVudEZyYWdtZW50LmF0KC0xKTtpZighdClyZXR1cm4gbnVsbDtmb3IoY29uc3QgZSBvZiB0LmNoaWxkTm9kZXMpZS5wYXJlbnROb2RlPXQ7cmV0dXJuIHR9b25FcnJvcihlKXt0aGlzLl9lcnJvckNvZGU9ZX19Y2xhc3MgTWV0YWRhdGFQYXJzZXJ7Y29uc3RydWN0b3IoZSl7ZT10aGlzLl9yZXBhaXIoZSk7Y29uc3QgdD1uZXcgU2ltcGxlWE1MUGFyc2VyKHtsb3dlckNhc2VOYW1lOiEwfSkucGFyc2VGcm9tU3RyaW5nKGUpO3RoaXMuX21ldGFkYXRhTWFwPW5ldyBNYXA7dGhpcy5fZGF0YT1lO3QmJnRoaXMuX3BhcnNlKHQpfV9yZXBhaXIoZSl7cmV0dXJuIGUucmVwbGFjZSgvXltePF0rLywiIikucmVwbGFjZUFsbCgvPlxcMzc2XFwzNzcoW148XSspL2csKGZ1bmN0aW9uKGUsdCl7Y29uc3QgYT10LnJlcGxhY2VBbGwoL1xcKFswLTNdKShbMC03XSkoWzAtN10pL2csKGZ1bmN0aW9uKGUsdCxhLHIpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY0KnQrOCphKzEqcil9KSkucmVwbGFjZUFsbCgvJihhbXB8YXBvc3xndHxsdHxxdW90KTsvZywoZnVuY3Rpb24oZSx0KXtzd2l0Y2godCl7Y2FzZSJhbXAiOnJldHVybiImIjtjYXNlImFwb3MiOnJldHVybiInIjtjYXNlImd0IjpyZXR1cm4iPiI7Y2FzZSJsdCI6cmV0dXJuIjwiO2Nhc2UicXVvdCI6cmV0dXJuJyInfXRocm93IG5ldyBFcnJvcihgX3JlcGFpcjogJHt0fSBpc24ndCBkZWZpbmVkLmApfSkpLHI9WyI+Il07Zm9yKGxldCBlPTAsdD1hLmxlbmd0aDtlPHQ7ZSs9Mil7Y29uc3QgdD0yNTYqYS5jaGFyQ29kZUF0KGUpK2EuY2hhckNvZGVBdChlKzEpO3Q+PTMyJiZ0PDEyNyYmNjAhPT10JiY2MiE9PXQmJjM4IT09dD9yLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh0KSk6ci5wdXNoKCImI3giKyg2NTUzNit0KS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpKyI7Iil9cmV0dXJuIHIuam9pbigiIil9KSl9X2dldFNlcXVlbmNlKGUpe2NvbnN0IHQ9ZS5ub2RlTmFtZTtyZXR1cm4icmRmOmJhZyIhPT10JiYicmRmOnNlcSIhPT10JiYicmRmOmFsdCIhPT10P251bGw6ZS5jaGlsZE5vZGVzLmZpbHRlcigoZT0+InJkZjpsaSI9PT1lLm5vZGVOYW1lKSl9X3BhcnNlQXJyYXkoZSl7aWYoIWUuaGFzQ2hpbGROb2RlcygpKXJldHVybjtjb25zdFt0XT1lLmNoaWxkTm9kZXMsYT10aGlzLl9nZXRTZXF1ZW5jZSh0KXx8W107dGhpcy5fbWV0YWRhdGFNYXAuc2V0KGUubm9kZU5hbWUsYS5tYXAoKGU9PmUudGV4dENvbnRlbnQudHJpbSgpKSkpfV9wYXJzZShlKXtsZXQgdD1lLmRvY3VtZW50RWxlbWVudDtpZigicmRmOnJkZiIhPT10Lm5vZGVOYW1lKXt0PXQuZmlyc3RDaGlsZDtmb3IoO3QmJiJyZGY6cmRmIiE9PXQubm9kZU5hbWU7KXQ9dC5uZXh0U2libGluZ31pZih0JiYicmRmOnJkZiI9PT10Lm5vZGVOYW1lJiZ0Lmhhc0NoaWxkTm9kZXMoKSlmb3IoY29uc3QgZSBvZiB0LmNoaWxkTm9kZXMpaWYoInJkZjpkZXNjcmlwdGlvbiI9PT1lLm5vZGVOYW1lKWZvcihjb25zdCB0IG9mIGUuY2hpbGROb2Rlcyl7Y29uc3QgZT10Lm5vZGVOYW1lO3N3aXRjaChlKXtjYXNlIiN0ZXh0Ijpjb250aW51ZTtjYXNlImRjOmNyZWF0b3IiOmNhc2UiZGM6c3ViamVjdCI6dGhpcy5fcGFyc2VBcnJheSh0KTtjb250aW51ZX10aGlzLl9tZXRhZGF0YU1hcC5zZXQoZSx0LnRleHRDb250ZW50LnRyaW0oKSl9fWdldCBzZXJpYWxpemFibGUoKXtyZXR1cm57cGFyc2VkRGF0YTp0aGlzLl9tZXRhZGF0YU1hcCxyYXdEYXRhOnRoaXMuX2RhdGF9fX1jb25zdCBUbj0xLE9uPTIsTW49MyxEbj00LEJuPTU7Y2xhc3MgU3RydWN0VHJlZVJvb3R7Y29uc3RydWN0b3IoZSx0LGEpe3RoaXMueHJlZj1lO3RoaXMuZGljdD10O3RoaXMucmVmPWEgaW5zdGFuY2VvZiBSZWY/YTpudWxsO3RoaXMucm9sZU1hcD1uZXcgTWFwO3RoaXMuc3RydWN0UGFyZW50SWRzPW51bGx9aW5pdCgpe3RoaXMucmVhZFJvbGVNYXAoKX0jWihlLHQsYSl7aWYoIShlIGluc3RhbmNlb2YgUmVmKXx8dDwwKXJldHVybjt0aGlzLnN0cnVjdFBhcmVudElkc3x8PW5ldyBSZWZTZXRDYWNoZTtsZXQgcj10aGlzLnN0cnVjdFBhcmVudElkcy5nZXQoZSk7aWYoIXIpe3I9W107dGhpcy5zdHJ1Y3RQYXJlbnRJZHMucHV0KGUscil9ci5wdXNoKFt0LGFdKX1hZGRBbm5vdGF0aW9uSWRUb1BhZ2UoZSx0KXt0aGlzLiNaKGUsdCxEbil9cmVhZFJvbGVNYXAoKXtjb25zdCBlPXRoaXMuZGljdC5nZXQoIlJvbGVNYXAiKTtpZihlIGluc3RhbmNlb2YgRGljdClmb3IoY29uc3RbdCxhXW9mIGUpYSBpbnN0YW5jZW9mIE5hbWUmJnRoaXMucm9sZU1hcC5zZXQodCxhLm5hbWUpfXN0YXRpYyBhc3luYyBjYW5DcmVhdGVTdHJ1Y3R1cmVUcmVlKHtjYXRhbG9nUmVmOmUscGRmTWFuYWdlcjp0LG5ld0Fubm90YXRpb25zQnlQYWdlOmF9KXtpZighKGUgaW5zdGFuY2VvZiBSZWYpKXt3YXJuKCJDYW5ub3Qgc2F2ZSB0aGUgc3RydWN0IHRyZWU6IG5vIGNhdGFsb2cgcmVmZXJlbmNlLiIpO3JldHVybiExfWxldCByPTAsaT0hMDtmb3IoY29uc3RbZSxuXW9mIGEpe2NvbnN0e3JlZjphfT1hd2FpdCB0LmdldFBhZ2UoZSk7aWYoIShhIGluc3RhbmNlb2YgUmVmKSl7d2FybihgQ2Fubm90IHNhdmUgdGhlIHN0cnVjdCB0cmVlOiBwYWdlICR7ZX0gaGFzIG5vIHJlZi5gKTtpPSEwO2JyZWFrfWZvcihjb25zdCBlIG9mIG4paWYoZS5hY2Nlc3NpYmlsaXR5RGF0YT8udHlwZSl7ZS5wYXJlbnRUcmVlSWQ9cisrO2k9ITF9fWlmKGkpe2Zvcihjb25zdCBlIG9mIGEudmFsdWVzKCkpZm9yKGNvbnN0IHQgb2YgZSlkZWxldGUgdC5wYXJlbnRUcmVlSWQ7cmV0dXJuITF9cmV0dXJuITB9c3RhdGljIGFzeW5jIGNyZWF0ZVN0cnVjdHVyZVRyZWUoe25ld0Fubm90YXRpb25zQnlQYWdlOmUseHJlZjp0LGNhdGFsb2dSZWY6YSxwZGZNYW5hZ2VyOnIsY2hhbmdlczppfSl7Y29uc3Qgbj1hd2FpdCByLmVuc3VyZUNhdGFsb2coImNsb25lRGljdCIpLHM9bmV3IFJlZlNldENhY2hlO3MucHV0KGEsbik7Y29uc3Qgbz10LmdldE5ld1RlbXBvcmFyeVJlZigpO24uc2V0KCJTdHJ1Y3RUcmVlUm9vdCIsbyk7Y29uc3QgYz1uZXcgRGljdCh0KTtjLnNldCgiVHlwZSIsTmFtZS5nZXQoIlN0cnVjdFRyZWVSb290IikpO2NvbnN0IGw9dC5nZXROZXdUZW1wb3JhcnlSZWYoKTtjLnNldCgiUGFyZW50VHJlZSIsbCk7Y29uc3QgaD1bXTtjLnNldCgiSyIsaCk7cy5wdXQobyxjKTtjb25zdCB1PW5ldyBEaWN0KHQpLGQ9W107dS5zZXQoIk51bXMiLGQpO2NvbnN0IGY9YXdhaXQgdGhpcy4jUSh7bmV3QW5ub3RhdGlvbnNCeVBhZ2U6ZSxzdHJ1Y3RUcmVlUm9vdFJlZjpvLHN0cnVjdFRyZWVSb290Om51bGwsa2lkczpoLG51bXM6ZCx4cmVmOnQscGRmTWFuYWdlcjpyLGNoYW5nZXM6aSxjYWNoZTpzfSk7Yy5zZXQoIlBhcmVudFRyZWVOZXh0S2V5IixmKTtzLnB1dChsLHUpO2Zvcihjb25zdFtlLHRdb2Ygcy5pdGVtcygpKWkucHV0KGUse2RhdGE6dH0pfWFzeW5jIGNhblVwZGF0ZVN0cnVjdFRyZWUoe3BkZk1hbmFnZXI6ZSxuZXdBbm5vdGF0aW9uc0J5UGFnZTp0fSl7aWYoIXRoaXMucmVmKXt3YXJuKCJDYW5ub3QgdXBkYXRlIHRoZSBzdHJ1Y3QgdHJlZTogbm8gcm9vdCByZWZlcmVuY2UuIik7cmV0dXJuITF9bGV0IGE9dGhpcy5kaWN0LmdldCgiUGFyZW50VHJlZU5leHRLZXkiKTtpZighTnVtYmVyLmlzSW50ZWdlcihhKXx8YTwwKXt3YXJuKCJDYW5ub3QgdXBkYXRlIHRoZSBzdHJ1Y3QgdHJlZTogaW52YWxpZCBuZXh0IGtleS4iKTtyZXR1cm4hMX1jb25zdCByPXRoaXMuZGljdC5nZXQoIlBhcmVudFRyZWUiKTtpZighKHIgaW5zdGFuY2VvZiBEaWN0KSl7d2FybigiQ2Fubm90IHVwZGF0ZSB0aGUgc3RydWN0IHRyZWU6IFBhcmVudFRyZWUgaXNuJ3QgYSBkaWN0LiIpO3JldHVybiExfWNvbnN0IGk9ci5nZXQoIk51bXMiKTtpZighQXJyYXkuaXNBcnJheShpKSl7d2FybigiQ2Fubm90IHVwZGF0ZSB0aGUgc3RydWN0IHRyZWU6IG51bXMgaXNuJ3QgYW4gYXJyYXkuIik7cmV0dXJuITF9Y29uc3Qgbj1uZXcgTnVtYmVyVHJlZShyLHRoaXMueHJlZik7Zm9yKGNvbnN0IGEgb2YgdC5rZXlzKCkpe2NvbnN0e3BhZ2VEaWN0OnR9PWF3YWl0IGUuZ2V0UGFnZShhKTtpZighdC5oYXMoIlN0cnVjdFBhcmVudHMiKSljb250aW51ZTtjb25zdCByPXQuZ2V0KCJTdHJ1Y3RQYXJlbnRzIik7aWYoIU51bWJlci5pc0ludGVnZXIocil8fCFBcnJheS5pc0FycmF5KG4uZ2V0KHIpKSl7d2FybihgQ2Fubm90IHNhdmUgdGhlIHN0cnVjdCB0cmVlOiBwYWdlICR7YX0gaGFzIGEgd3JvbmcgaWQuYCk7cmV0dXJuITF9fWxldCBzPSEwO2Zvcihjb25zdFtyLGldb2YgdCl7Y29uc3R7cGFnZURpY3Q6dH09YXdhaXQgZS5nZXRQYWdlKHIpO1N0cnVjdFRyZWVSb290LiNlZSh7ZWxlbWVudHM6aSx4cmVmOnRoaXMueHJlZixwYWdlRGljdDp0LG51bWJlclRyZWU6bn0pO2Zvcihjb25zdCBlIG9mIGkpaWYoZS5hY2Nlc3NpYmlsaXR5RGF0YT8udHlwZSl7ZS5hY2Nlc3NpYmlsaXR5RGF0YS5zdHJ1Y3RQYXJlbnQ+PTB8fChlLnBhcmVudFRyZWVJZD1hKyspO3M9ITF9fWlmKHMpe2Zvcihjb25zdCBlIG9mIHQudmFsdWVzKCkpZm9yKGNvbnN0IHQgb2YgZSl7ZGVsZXRlIHQucGFyZW50VHJlZUlkO2RlbGV0ZSB0LnN0cnVjdFRyZWVQYXJlbnR9cmV0dXJuITF9cmV0dXJuITB9YXN5bmMgdXBkYXRlU3RydWN0dXJlVHJlZSh7bmV3QW5ub3RhdGlvbnNCeVBhZ2U6ZSxwZGZNYW5hZ2VyOnQsY2hhbmdlczphfSl7Y29uc3R7cmVmOnIseHJlZjppfT10aGlzLG49dGhpcy5kaWN0LmNsb25lKCkscz1uZXcgUmVmU2V0Q2FjaGU7cy5wdXQocixuKTtsZXQgbyxjPW4uZ2V0UmF3KCJQYXJlbnRUcmVlIik7aWYoYyBpbnN0YW5jZW9mIFJlZilvPWkuZmV0Y2goYyk7ZWxzZXtvPWM7Yz1pLmdldE5ld1RlbXBvcmFyeVJlZigpO24uc2V0KCJQYXJlbnRUcmVlIixjKX1vPW8uY2xvbmUoKTtzLnB1dChjLG8pO2xldCBsPW8uZ2V0UmF3KCJOdW1zIiksaD1udWxsO2lmKGwgaW5zdGFuY2VvZiBSZWYpe2g9bDtsPWkuZmV0Y2goaCl9bD1sLnNsaWNlKCk7aHx8by5zZXQoIk51bXMiLGwpO2NvbnN0IHU9YXdhaXQgU3RydWN0VHJlZVJvb3QuI1Eoe25ld0Fubm90YXRpb25zQnlQYWdlOmUsc3RydWN0VHJlZVJvb3RSZWY6cixzdHJ1Y3RUcmVlUm9vdDp0aGlzLGtpZHM6bnVsbCxudW1zOmwseHJlZjppLHBkZk1hbmFnZXI6dCxjaGFuZ2VzOmEsY2FjaGU6c30pO2lmKC0xIT09dSl7bi5zZXQoIlBhcmVudFRyZWVOZXh0S2V5Iix1KTtoJiZzLnB1dChoLGwpO2Zvcihjb25zdFtlLHRdb2Ygcy5pdGVtcygpKWEucHV0KGUse2RhdGE6dH0pfX1zdGF0aWMgYXN5bmMjUSh7bmV3QW5ub3RhdGlvbnNCeVBhZ2U6ZSxzdHJ1Y3RUcmVlUm9vdFJlZjp0LHN0cnVjdFRyZWVSb290OmEsa2lkczpyLG51bXM6aSx4cmVmOm4scGRmTWFuYWdlcjpzLGNoYW5nZXM6byxjYWNoZTpjfSl7Y29uc3QgbD1OYW1lLmdldCgiT0JKUiIpO2xldCBoLHU9LTE7Zm9yKGNvbnN0W2QsZl1vZiBlKXtjb25zdCBlPWF3YWl0IHMuZ2V0UGFnZShkKSx7cmVmOmd9PWUscD1nIGluc3RhbmNlb2YgUmVmO2Zvcihjb25zdHthY2Nlc3NpYmlsaXR5RGF0YTpzLHJlZjptLHBhcmVudFRyZWVJZDpiLHN0cnVjdFRyZWVQYXJlbnQ6eX1vZiBmKXtpZighcz8udHlwZSljb250aW51ZTtjb25zdHtzdHJ1Y3RQYXJlbnQ6Zn09cztpZihhJiZOdW1iZXIuaXNJbnRlZ2VyKGYpJiZmPj0wKXtsZXQgdD0oaHx8PW5ldyBNYXApLmdldChkKTtpZih2b2lkIDA9PT10KXt0PW5ldyBTdHJ1Y3RUcmVlUGFnZShhLGUucGFnZURpY3QpLmNvbGxlY3RPYmplY3RzKGcpO2guc2V0KGQsdCl9Y29uc3Qgcj10Py5nZXQoZik7aWYocil7Y29uc3QgZT1uLmZldGNoKHIpLmNsb25lKCk7U3RydWN0VHJlZVJvb3QuI3RlKGUscyk7by5wdXQocix7ZGF0YTplfSk7Y29udGludWV9fXU9TWF0aC5tYXgodSxiKTtjb25zdCB3PW4uZ2V0TmV3VGVtcG9yYXJ5UmVmKCkseD1uZXcgRGljdChuKTtTdHJ1Y3RUcmVlUm9vdC4jdGUoeCxzKTthd2FpdCB0aGlzLiNhZSh7c3RydWN0VHJlZVBhcmVudDp5LHRhZ0RpY3Q6eCxuZXdUYWdSZWY6dyxzdHJ1Y3RUcmVlUm9vdFJlZjp0LGZhbGxiYWNrS2lkczpyLHhyZWY6bixjYWNoZTpjfSk7Y29uc3QgUz1uZXcgRGljdChuKTt4LnNldCgiSyIsUyk7Uy5zZXQoIlR5cGUiLGwpO3AmJlMuc2V0KCJQZyIsZyk7Uy5zZXQoIk9iaiIsbSk7Yy5wdXQodyx4KTtpLnB1c2goYix3KX19cmV0dXJuIHUrMX1zdGF0aWMjdGUoZSx7dHlwZTp0LHRpdGxlOmEsbGFuZzpyLGFsdDppLGV4cGFuZGVkOm4sYWN0dWFsVGV4dDpzfSl7ZS5zZXQoIlMiLE5hbWUuZ2V0KHQpKTthJiZlLnNldCgiVCIsc3RyaW5nVG9Bc2NpaU9yVVRGMTZCRShhKSk7ciYmZS5zZXQoIkxhbmciLHN0cmluZ1RvQXNjaWlPclVURjE2QkUocikpO2kmJmUuc2V0KCJBbHQiLHN0cmluZ1RvQXNjaWlPclVURjE2QkUoaSkpO24mJmUuc2V0KCJFIixzdHJpbmdUb0FzY2lpT3JVVEYxNkJFKG4pKTtzJiZlLnNldCgiQWN0dWFsVGV4dCIsc3RyaW5nVG9Bc2NpaU9yVVRGMTZCRShzKSl9c3RhdGljI2VlKHtlbGVtZW50czplLHhyZWY6dCxwYWdlRGljdDphLG51bWJlclRyZWU6cn0pe2NvbnN0IGk9bmV3IE1hcDtmb3IoY29uc3QgdCBvZiBlKWlmKHQuc3RydWN0VHJlZVBhcmVudElkKXtjb25zdCBlPXBhcnNlSW50KHQuc3RydWN0VHJlZVBhcmVudElkLnNwbGl0KCJfbWMiKVsxXSwxMCk7bGV0IGE9aS5nZXQoZSk7aWYoIWEpe2E9W107aS5zZXQoZSxhKX1hLnB1c2godCl9Y29uc3Qgbj1hLmdldCgiU3RydWN0UGFyZW50cyIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXJldHVybjtjb25zdCBzPXIuZ2V0KG4pLHVwZGF0ZUVsZW1lbnQ9KGUsYSxyKT0+e2NvbnN0IG49aS5nZXQoZSk7aWYobil7Y29uc3QgZT1hLmdldFJhdygiUCIpLGk9dC5mZXRjaElmUmVmKGUpO2lmKGUgaW5zdGFuY2VvZiBSZWYmJmkgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBlPXtyZWY6cixkaWN0OmF9O2Zvcihjb25zdCB0IG9mIG4pdC5zdHJ1Y3RUcmVlUGFyZW50PWV9cmV0dXJuITB9cmV0dXJuITF9O2Zvcihjb25zdCBlIG9mIHMpe2lmKCEoZSBpbnN0YW5jZW9mIFJlZikpY29udGludWU7Y29uc3QgYT10LmZldGNoKGUpLHI9YS5nZXQoIksiKTtpZihOdW1iZXIuaXNJbnRlZ2VyKHIpKXVwZGF0ZUVsZW1lbnQocixhLGUpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShyKSlmb3IobGV0IGkgb2Ygcil7aT10LmZldGNoSWZSZWYoaSk7aWYoTnVtYmVyLmlzSW50ZWdlcihpKSYmdXBkYXRlRWxlbWVudChpLGEsZSkpYnJlYWs7aWYoIShpIGluc3RhbmNlb2YgRGljdCkpY29udGludWU7aWYoIWlzTmFtZShpLmdldCgiVHlwZSIpLCJNQ1IiKSlicmVhaztjb25zdCByPWkuZ2V0KCJNQ0lEIik7aWYoTnVtYmVyLmlzSW50ZWdlcihyKSYmdXBkYXRlRWxlbWVudChyLGEsZSkpYnJlYWt9fX1zdGF0aWMgYXN5bmMjYWUoe3N0cnVjdFRyZWVQYXJlbnQ6ZSx0YWdEaWN0OnQsbmV3VGFnUmVmOmEsc3RydWN0VHJlZVJvb3RSZWY6cixmYWxsYmFja0tpZHM6aSx4cmVmOm4sY2FjaGU6c30pe2xldCBvLGM9bnVsbDtpZihlKXsoe3JlZjpjfT1lKTtvPWUuZGljdC5nZXRSYXcoIlAiKXx8cn1lbHNlIG89cjt0LnNldCgiUCIsbyk7Y29uc3QgbD1uLmZldGNoSWZSZWYobyk7aWYoIWwpe2kucHVzaChhKTtyZXR1cm59bGV0IGg9cy5nZXQobyk7aWYoIWgpe2g9bC5jbG9uZSgpO3MucHV0KG8saCl9Y29uc3QgdT1oLmdldFJhdygiSyIpO2xldCBkPXUgaW5zdGFuY2VvZiBSZWY/cy5nZXQodSk6bnVsbDtpZighZCl7ZD1uLmZldGNoSWZSZWYodSk7ZD1BcnJheS5pc0FycmF5KGQpP2Quc2xpY2UoKTpbdV07Y29uc3QgZT1uLmdldE5ld1RlbXBvcmFyeVJlZigpO2guc2V0KCJLIixlKTtzLnB1dChlLGQpfWNvbnN0IGY9ZC5pbmRleE9mKGMpO2Quc3BsaWNlKGY+PTA/ZisxOmQubGVuZ3RoLDAsYSl9fWNsYXNzIFN0cnVjdEVsZW1lbnROb2Rle2NvbnN0cnVjdG9yKGUsdCl7dGhpcy50cmVlPWU7dGhpcy54cmVmPWUueHJlZjt0aGlzLmRpY3Q9dDt0aGlzLmtpZHM9W107dGhpcy5wYXJzZUtpZHMoKX1nZXQgcm9sZSgpe2NvbnN0IGU9dGhpcy5kaWN0LmdldCgiUyIpLHQ9ZSBpbnN0YW5jZW9mIE5hbWU/ZS5uYW1lOiIiLHtyb290OmF9PXRoaXMudHJlZTtyZXR1cm4gYS5yb2xlTWFwLmdldCh0KT8/dH1wYXJzZUtpZHMoKXtsZXQgZT1udWxsO2NvbnN0IHQ9dGhpcy5kaWN0LmdldFJhdygiUGciKTt0IGluc3RhbmNlb2YgUmVmJiYoZT10LnRvU3RyaW5nKCkpO2NvbnN0IGE9dGhpcy5kaWN0LmdldCgiSyIpO2lmKEFycmF5LmlzQXJyYXkoYSkpZm9yKGNvbnN0IHQgb2YgYSl7Y29uc3QgYT10aGlzLnBhcnNlS2lkKGUsdGhpcy54cmVmLmZldGNoSWZSZWYodCkpO2EmJnRoaXMua2lkcy5wdXNoKGEpfWVsc2V7Y29uc3QgdD10aGlzLnBhcnNlS2lkKGUsYSk7dCYmdGhpcy5raWRzLnB1c2godCl9fXBhcnNlS2lkKGUsdCl7aWYoTnVtYmVyLmlzSW50ZWdlcih0KSlyZXR1cm4gdGhpcy50cmVlLnBhZ2VEaWN0Lm9iaklkIT09ZT9udWxsOm5ldyBTdHJ1Y3RFbGVtZW50KHt0eXBlOlRuLG1jaWQ6dCxwYWdlT2JqSWQ6ZX0pO2lmKCEodCBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBudWxsO2NvbnN0IGE9dC5nZXRSYXcoIlBnIik7YSBpbnN0YW5jZW9mIFJlZiYmKGU9YS50b1N0cmluZygpKTtjb25zdCByPXQuZ2V0KCJUeXBlIilpbnN0YW5jZW9mIE5hbWU/dC5nZXQoIlR5cGUiKS5uYW1lOm51bGw7aWYoIk1DUiI9PT1yKXtpZih0aGlzLnRyZWUucGFnZURpY3Qub2JqSWQhPT1lKXJldHVybiBudWxsO2NvbnN0IGE9dC5nZXRSYXcoIlN0bSIpO3JldHVybiBuZXcgU3RydWN0RWxlbWVudCh7dHlwZTpPbixyZWZPYmpJZDphIGluc3RhbmNlb2YgUmVmP2EudG9TdHJpbmcoKTpudWxsLHBhZ2VPYmpJZDplLG1jaWQ6dC5nZXQoIk1DSUQiKX0pfWlmKCJPQkpSIj09PXIpe2lmKHRoaXMudHJlZS5wYWdlRGljdC5vYmpJZCE9PWUpcmV0dXJuIG51bGw7Y29uc3QgYT10LmdldFJhdygiT2JqIik7cmV0dXJuIG5ldyBTdHJ1Y3RFbGVtZW50KHt0eXBlOk1uLHJlZk9iaklkOmEgaW5zdGFuY2VvZiBSZWY/YS50b1N0cmluZygpOm51bGwscGFnZU9iaklkOmV9KX1yZXR1cm4gbmV3IFN0cnVjdEVsZW1lbnQoe3R5cGU6Qm4sZGljdDp0fSl9fWNsYXNzIFN0cnVjdEVsZW1lbnR7Y29uc3RydWN0b3Ioe3R5cGU6ZSxkaWN0OnQ9bnVsbCxtY2lkOmE9bnVsbCxwYWdlT2JqSWQ6cj1udWxsLHJlZk9iaklkOmk9bnVsbH0pe3RoaXMudHlwZT1lO3RoaXMuZGljdD10O3RoaXMubWNpZD1hO3RoaXMucGFnZU9iaklkPXI7dGhpcy5yZWZPYmpJZD1pO3RoaXMucGFyZW50Tm9kZT1udWxsfX1jbGFzcyBTdHJ1Y3RUcmVlUGFnZXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMucm9vdD1lO3RoaXMueHJlZj1lPy54cmVmPz9udWxsO3RoaXMucm9vdERpY3Q9ZT8uZGljdD8/bnVsbDt0aGlzLnBhZ2VEaWN0PXQ7dGhpcy5ub2Rlcz1bXX1jb2xsZWN0T2JqZWN0cyhlKXtpZighKHRoaXMucm9vdCYmdGhpcy5yb290RGljdCYmZSBpbnN0YW5jZW9mIFJlZikpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLnJvb3REaWN0LmdldCgiUGFyZW50VHJlZSIpO2lmKCF0KXJldHVybiBudWxsO2NvbnN0IGE9dGhpcy5yb290LnN0cnVjdFBhcmVudElkcz8uZ2V0KGUpO2lmKCFhKXJldHVybiBudWxsO2NvbnN0IHI9bmV3IE1hcCxpPW5ldyBOdW1iZXJUcmVlKHQsdGhpcy54cmVmKTtmb3IoY29uc3RbZV1vZiBhKXtjb25zdCB0PWkuZ2V0UmF3KGUpO3QgaW5zdGFuY2VvZiBSZWYmJnIuc2V0KGUsdCl9cmV0dXJuIHJ9cGFyc2UoZSl7aWYoISh0aGlzLnJvb3QmJnRoaXMucm9vdERpY3QmJmUgaW5zdGFuY2VvZiBSZWYpKXJldHVybjtjb25zdCB0PXRoaXMucm9vdERpY3QuZ2V0KCJQYXJlbnRUcmVlIik7aWYoIXQpcmV0dXJuO2NvbnN0IGE9dGhpcy5wYWdlRGljdC5nZXQoIlN0cnVjdFBhcmVudHMiKSxyPXRoaXMucm9vdC5zdHJ1Y3RQYXJlbnRJZHM/LmdldChlKTtpZighTnVtYmVyLmlzSW50ZWdlcihhKSYmIXIpcmV0dXJuO2NvbnN0IGk9bmV3IE1hcCxuPW5ldyBOdW1iZXJUcmVlKHQsdGhpcy54cmVmKTtpZihOdW1iZXIuaXNJbnRlZ2VyKGEpKXtjb25zdCBlPW4uZ2V0KGEpO2lmKEFycmF5LmlzQXJyYXkoZSkpZm9yKGNvbnN0IHQgb2YgZSl0IGluc3RhbmNlb2YgUmVmJiZ0aGlzLmFkZE5vZGUodGhpcy54cmVmLmZldGNoKHQpLGkpfWlmKHIpZm9yKGNvbnN0W2UsdF1vZiByKXtjb25zdCBhPW4uZ2V0KGUpO2lmKGEpe2NvbnN0IGU9dGhpcy5hZGROb2RlKHRoaXMueHJlZi5mZXRjaElmUmVmKGEpLGkpOzE9PT1lPy5raWRzPy5sZW5ndGgmJmUua2lkc1swXS50eXBlPT09TW4mJihlLmtpZHNbMF0udHlwZT10KX19fWFkZE5vZGUoZSx0LGE9MCl7aWYoYT40MCl7d2FybigiU3RydWN0VHJlZSBNQVhfREVQVEggcmVhY2hlZC4iKTtyZXR1cm4gbnVsbH1pZighKGUgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm4gbnVsbDtpZih0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7Y29uc3Qgcj1uZXcgU3RydWN0RWxlbWVudE5vZGUodGhpcyxlKTt0LnNldChlLHIpO2NvbnN0IGk9ZS5nZXQoIlAiKTtpZighKGkgaW5zdGFuY2VvZiBEaWN0KXx8aXNOYW1lKGkuZ2V0KCJUeXBlIiksIlN0cnVjdFRyZWVSb290Iikpe3RoaXMuYWRkVG9wTGV2ZWxOb2RlKGUscil8fHQuZGVsZXRlKGUpO3JldHVybiByfWNvbnN0IG49dGhpcy5hZGROb2RlKGksdCxhKzEpO2lmKCFuKXJldHVybiByO2xldCBzPSExO2Zvcihjb25zdCB0IG9mIG4ua2lkcylpZih0LnR5cGU9PT1CbiYmdC5kaWN0PT09ZSl7dC5wYXJlbnROb2RlPXI7cz0hMH1zfHx0LmRlbGV0ZShlKTtyZXR1cm4gcn1hZGRUb3BMZXZlbE5vZGUoZSx0KXtjb25zdCBhPXRoaXMucm9vdERpY3QuZ2V0KCJLIik7aWYoIWEpcmV0dXJuITE7aWYoYSBpbnN0YW5jZW9mIERpY3Qpe2lmKGEub2JqSWQhPT1lLm9iaklkKXJldHVybiExO3RoaXMubm9kZXNbMF09dDtyZXR1cm4hMH1pZighQXJyYXkuaXNBcnJheShhKSlyZXR1cm4hMDtsZXQgcj0hMTtmb3IobGV0IGk9MDtpPGEubGVuZ3RoO2krKyl7Y29uc3Qgbj1hW2ldO2lmKG4/LnRvU3RyaW5nKCk9PT1lLm9iaklkKXt0aGlzLm5vZGVzW2ldPXQ7cj0hMH19cmV0dXJuIHJ9Z2V0IHNlcmlhbGl6YWJsZSgpe2Z1bmN0aW9uIG5vZGVUb1NlcmlhbGl6YWJsZShlLHQsYT0wKXtpZihhPjQwKXt3YXJuKCJTdHJ1Y3RUcmVlIHRvbyBkZWVwIHRvIGJlIGZ1bGx5IHNlcmlhbGl6ZWQuIik7cmV0dXJufWNvbnN0IHI9T2JqZWN0LmNyZWF0ZShudWxsKTtyLnJvbGU9ZS5yb2xlO3IuY2hpbGRyZW49W107dC5jaGlsZHJlbi5wdXNoKHIpO2xldCBpPWUuZGljdC5nZXQoIkFsdCIpOyJzdHJpbmciIT10eXBlb2YgaSYmKGk9ZS5kaWN0LmdldCgiQWN0dWFsVGV4dCIpKTsic3RyaW5nIj09dHlwZW9mIGkmJihyLmFsdD1zdHJpbmdUb1BERlN0cmluZyhpKSk7Y29uc3Qgbj1lLmRpY3QuZ2V0KCJBIik7aWYobiBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9bG9va3VwTm9ybWFsUmVjdChuLmdldEFycmF5KCJCQm94IiksbnVsbCk7aWYoZSlyLmJib3g9ZTtlbHNle2NvbnN0IGU9bi5nZXQoIldpZHRoIiksdD1uLmdldCgiSGVpZ2h0Iik7Im51bWJlciI9PXR5cGVvZiBlJiZlPjAmJiJudW1iZXIiPT10eXBlb2YgdCYmdD4wJiYoci5iYm94PVswLDAsZSx0XSl9fWNvbnN0IHM9ZS5kaWN0LmdldCgiTGFuZyIpOyJzdHJpbmciPT10eXBlb2YgcyYmKHIubGFuZz1zdHJpbmdUb1BERlN0cmluZyhzKSk7Zm9yKGNvbnN0IHQgb2YgZS5raWRzKXtjb25zdCBlPXQudHlwZT09PUJuP3QucGFyZW50Tm9kZTpudWxsO2U/bm9kZVRvU2VyaWFsaXphYmxlKGUscixhKzEpOnQudHlwZT09PVRufHx0LnR5cGU9PT1Pbj9yLmNoaWxkcmVuLnB1c2goe3R5cGU6ImNvbnRlbnQiLGlkOmBwJHt0LnBhZ2VPYmpJZH1fbWMke3QubWNpZH1gfSk6dC50eXBlPT09TW4/ci5jaGlsZHJlbi5wdXNoKHt0eXBlOiJvYmplY3QiLGlkOnQucmVmT2JqSWR9KTp0LnR5cGU9PT1EbiYmci5jaGlsZHJlbi5wdXNoKHt0eXBlOiJhbm5vdGF0aW9uIixpZDpgcGRmanNfaW50ZXJuYWxfaWRfJHt0LnJlZk9iaklkfWB9KX19Y29uc3QgZT1PYmplY3QuY3JlYXRlKG51bGwpO2UuY2hpbGRyZW49W107ZS5yb2xlPSJSb290Ijtmb3IoY29uc3QgdCBvZiB0aGlzLm5vZGVzKXQmJm5vZGVUb1NlcmlhbGl6YWJsZSh0LGUpO3JldHVybiBlfX1jb25zdCBSbj1mdW5jdGlvbiBfaXNWYWxpZEV4cGxpY2l0RGVzdChlLHQsYSl7aWYoIUFycmF5LmlzQXJyYXkoYSl8fGEubGVuZ3RoPDIpcmV0dXJuITE7Y29uc3RbcixpLC4uLm5dPWE7aWYoIWUocikmJiFOdW1iZXIuaXNJbnRlZ2VyKHIpKXJldHVybiExO2lmKCF0KGkpKXJldHVybiExO2NvbnN0IHM9bi5sZW5ndGg7bGV0IG89ITA7c3dpdGNoKGkubmFtZSl7Y2FzZSJYWVoiOmlmKHM8Mnx8cz4zKXJldHVybiExO2JyZWFrO2Nhc2UiRml0IjpjYXNlIkZpdEIiOnJldHVybiAwPT09cztjYXNlIkZpdEgiOmNhc2UiRml0QkgiOmNhc2UiRml0ViI6Y2FzZSJGaXRCViI6aWYocz4xKXJldHVybiExO2JyZWFrO2Nhc2UiRml0UiI6aWYoNCE9PXMpcmV0dXJuITE7bz0hMTticmVhaztkZWZhdWx0OnJldHVybiExfWZvcihjb25zdCBlIG9mIG4paWYoISgibnVtYmVyIj09dHlwZW9mIGV8fG8mJm51bGw9PT1lKSlyZXR1cm4hMTtyZXR1cm4hMH0uYmluZChudWxsLChlPT5lIGluc3RhbmNlb2YgUmVmKSxpc05hbWUpO2Z1bmN0aW9uIGZldGNoRGVzdChlKXtlIGluc3RhbmNlb2YgRGljdCYmKGU9ZS5nZXQoIkQiKSk7cmV0dXJuIFJuKGUpP2U6bnVsbH1mdW5jdGlvbiBmZXRjaFJlbW90ZURlc3QoZSl7bGV0IHQ9ZS5nZXQoIkQiKTtpZih0KXt0IGluc3RhbmNlb2YgTmFtZSYmKHQ9dC5uYW1lKTtpZigic3RyaW5nIj09dHlwZW9mIHQpcmV0dXJuIHN0cmluZ1RvUERGU3RyaW5nKHQsITApO2lmKFJuKHQpKXJldHVybiBKU09OLnN0cmluZ2lmeSh0KX1yZXR1cm4gbnVsbH1jbGFzcyBDYXRhbG9neyNyZT1udWxsOyNpZT1udWxsO2J1aWx0SW5DTWFwQ2FjaGU9bmV3IE1hcDtmb250Q2FjaGU9bmV3IFJlZlNldENhY2hlO2dsb2JhbENvbG9yU3BhY2VDYWNoZT1uZXcgR2xvYmFsQ29sb3JTcGFjZUNhY2hlO2dsb2JhbEltYWdlQ2FjaGU9bmV3IEdsb2JhbEltYWdlQ2FjaGU7bm9uQmxlbmRNb2Rlc1NldD1uZXcgUmVmU2V0O3BhZ2VEaWN0Q2FjaGU9bmV3IFJlZlNldENhY2hlO3BhZ2VJbmRleENhY2hlPW5ldyBSZWZTZXRDYWNoZTtwYWdlS2lkc0NvdW50Q2FjaGU9bmV3IFJlZlNldENhY2hlO3N0YW5kYXJkRm9udERhdGFDYWNoZT1uZXcgTWFwO3N5c3RlbUZvbnRDYWNoZT1uZXcgTWFwO2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5wZGZNYW5hZ2VyPWU7dGhpcy54cmVmPXQ7dGhpcy4jaWU9dC5nZXRDYXRhbG9nT2JqKCk7aWYoISh0aGlzLiNpZSBpbnN0YW5jZW9mIERpY3QpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiQ2F0YWxvZyBvYmplY3QgaXMgbm90IGEgZGljdGlvbmFyeS4iKTt0aGlzLnRvcGxldmVsUGFnZXNEaWN0fWNsb25lRGljdCgpe3JldHVybiB0aGlzLiNpZS5jbG9uZSgpfWdldCB2ZXJzaW9uKCl7Y29uc3QgZT10aGlzLiNpZS5nZXQoIlZlcnNpb24iKTtpZihlIGluc3RhbmNlb2YgTmFtZSl7aWYob2EudGVzdChlLm5hbWUpKXJldHVybiBzaGFkb3codGhpcywidmVyc2lvbiIsZS5uYW1lKTt3YXJuKGBJbnZhbGlkIFBERiBjYXRhbG9nIHZlcnNpb246ICR7ZS5uYW1lfWApfXJldHVybiBzaGFkb3codGhpcywidmVyc2lvbiIsbnVsbCl9Z2V0IGxhbmcoKXtjb25zdCBlPXRoaXMuI2llLmdldCgiTGFuZyIpO3JldHVybiBzaGFkb3codGhpcywibGFuZyIsZSYmInN0cmluZyI9PXR5cGVvZiBlP3N0cmluZ1RvUERGU3RyaW5nKGUpOm51bGwpfWdldCBuZWVkc1JlbmRlcmluZygpe2NvbnN0IGU9dGhpcy4jaWUuZ2V0KCJOZWVkc1JlbmRlcmluZyIpO3JldHVybiBzaGFkb3codGhpcywibmVlZHNSZW5kZXJpbmciLCJib29sZWFuIj09dHlwZW9mIGUmJmUpfWdldCBjb2xsZWN0aW9uKCl7bGV0IGU9bnVsbDt0cnl7Y29uc3QgdD10aGlzLiNpZS5nZXQoIkNvbGxlY3Rpb24iKTt0IGluc3RhbmNlb2YgRGljdCYmdC5zaXplPjAmJihlPXQpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlO2luZm8oIkNhbm5vdCBmZXRjaCBDb2xsZWN0aW9uIGVudHJ5OyBhc3N1bWluZyBubyBjb2xsZWN0aW9uIGlzIHByZXNlbnQuIil9cmV0dXJuIHNoYWRvdyh0aGlzLCJjb2xsZWN0aW9uIixlKX1nZXQgYWNyb0Zvcm0oKXtsZXQgZT1udWxsO3RyeXtjb25zdCB0PXRoaXMuI2llLmdldCgiQWNyb0Zvcm0iKTt0IGluc3RhbmNlb2YgRGljdCYmdC5zaXplPjAmJihlPXQpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlO2luZm8oIkNhbm5vdCBmZXRjaCBBY3JvRm9ybSBlbnRyeTsgYXNzdW1pbmcgbm8gZm9ybXMgYXJlIHByZXNlbnQuIil9cmV0dXJuIHNoYWRvdyh0aGlzLCJhY3JvRm9ybSIsZSl9Z2V0IGFjcm9Gb3JtUmVmKCl7Y29uc3QgZT10aGlzLiNpZS5nZXRSYXcoIkFjcm9Gb3JtIik7cmV0dXJuIHNoYWRvdyh0aGlzLCJhY3JvRm9ybVJlZiIsZSBpbnN0YW5jZW9mIFJlZj9lOm51bGwpfWdldCBtZXRhZGF0YSgpe2NvbnN0IGU9dGhpcy4jaWUuZ2V0UmF3KCJNZXRhZGF0YSIpO2lmKCEoZSBpbnN0YW5jZW9mIFJlZikpcmV0dXJuIHNoYWRvdyh0aGlzLCJtZXRhZGF0YSIsbnVsbCk7bGV0IHQ9bnVsbDt0cnl7Y29uc3QgYT10aGlzLnhyZWYuZmV0Y2goZSwhdGhpcy54cmVmLmVuY3J5cHQ/LmVuY3J5cHRNZXRhZGF0YSk7aWYoYSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJmEuZGljdCBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9YS5kaWN0LmdldCgiVHlwZSIpLHI9YS5kaWN0LmdldCgiU3VidHlwZSIpO2lmKGlzTmFtZShlLCJNZXRhZGF0YSIpJiZpc05hbWUociwiWE1MIikpe2NvbnN0IGU9c3RyaW5nVG9VVEY4U3RyaW5nKGEuZ2V0U3RyaW5nKCkpO2UmJih0PW5ldyBNZXRhZGF0YVBhcnNlcihlKS5zZXJpYWxpemFibGUpfX19Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7aW5mbyhgU2tpcHBpbmcgaW52YWxpZCBNZXRhZGF0YTogIiR7ZX0iLmApfXJldHVybiBzaGFkb3codGhpcywibWV0YWRhdGEiLHQpfWdldCBtYXJrSW5mbygpe2xldCBlPW51bGw7dHJ5e2U9dGhpcy4jbmUoKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTt3YXJuKCJVbmFibGUgdG8gcmVhZCBtYXJrIGluZm8uIil9cmV0dXJuIHNoYWRvdyh0aGlzLCJtYXJrSW5mbyIsZSl9I25lKCl7Y29uc3QgZT10aGlzLiNpZS5nZXQoIk1hcmtJbmZvIik7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuIG51bGw7Y29uc3QgdD17TWFya2VkOiExLFVzZXJQcm9wZXJ0aWVzOiExLFN1c3BlY3RzOiExfTtmb3IoY29uc3QgYSBpbiB0KXtjb25zdCByPWUuZ2V0KGEpOyJib29sZWFuIj09dHlwZW9mIHImJih0W2FdPXIpfXJldHVybiB0fWdldCBzdHJ1Y3RUcmVlUm9vdCgpe2xldCBlPW51bGw7dHJ5e2U9dGhpcy4jc2UoKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTt3YXJuKCJVbmFibGUgcmVhZCB0byBzdHJ1Y3RUcmVlUm9vdCBpbmZvLiIpfXJldHVybiBzaGFkb3codGhpcywic3RydWN0VHJlZVJvb3QiLGUpfSNzZSgpe2NvbnN0IGU9dGhpcy4jaWUuZ2V0UmF3KCJTdHJ1Y3RUcmVlUm9vdCIpLHQ9dGhpcy54cmVmLmZldGNoSWZSZWYoZSk7aWYoISh0IGluc3RhbmNlb2YgRGljdCkpcmV0dXJuIG51bGw7Y29uc3QgYT1uZXcgU3RydWN0VHJlZVJvb3QodGhpcy54cmVmLHQsZSk7YS5pbml0KCk7cmV0dXJuIGF9Z2V0IHRvcGxldmVsUGFnZXNEaWN0KCl7Y29uc3QgZT10aGlzLiNpZS5nZXQoIlBhZ2VzIik7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIHRvcC1sZXZlbCBwYWdlcyBkaWN0aW9uYXJ5LiIpO3JldHVybiBzaGFkb3codGhpcywidG9wbGV2ZWxQYWdlc0RpY3QiLGUpfWdldCBkb2N1bWVudE91dGxpbmUoKXtsZXQgZT1udWxsO3RyeXtlPXRoaXMuI29lKCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybigiVW5hYmxlIHRvIHJlYWQgZG9jdW1lbnQgb3V0bGluZS4iKX1yZXR1cm4gc2hhZG93KHRoaXMsImRvY3VtZW50T3V0bGluZSIsZSl9I29lKCl7bGV0IGU9dGhpcy4jaWUuZ2V0KCJPdXRsaW5lcyIpO2lmKCEoZSBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBudWxsO2U9ZS5nZXRSYXcoIkZpcnN0Iik7aWYoIShlIGluc3RhbmNlb2YgUmVmKSlyZXR1cm4gbnVsbDtjb25zdCB0PXtpdGVtczpbXX0sYT1be29iajplLHBhcmVudDp0fV0scj1uZXcgUmVmU2V0O3IucHV0KGUpO2NvbnN0IGk9dGhpcy54cmVmLG49bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMpO2Zvcig7YS5sZW5ndGg+MDspe2NvbnN0IHQ9YS5zaGlmdCgpLHM9aS5mZXRjaElmUmVmKHQub2JqKTtpZihudWxsPT09cyljb250aW51ZTtzLmhhcygiVGl0bGUiKXx8d2FybigiSW52YWxpZCBvdXRsaW5lIGl0ZW0gZW5jb3VudGVyZWQuIik7Y29uc3Qgbz17dXJsOm51bGwsZGVzdDpudWxsLGFjdGlvbjpudWxsfTtDYXRhbG9nLnBhcnNlRGVzdERpY3Rpb25hcnkoe2Rlc3REaWN0OnMscmVzdWx0T2JqOm8sZG9jQmFzZVVybDp0aGlzLmJhc2VVcmwsZG9jQXR0YWNobWVudHM6dGhpcy5hdHRhY2htZW50c30pO2NvbnN0IGM9cy5nZXQoIlRpdGxlIiksbD1zLmdldCgiRiIpfHwwLGg9cy5nZXRBcnJheSgiQyIpLHU9cy5nZXQoIkNvdW50Iik7bGV0IGQ9bjshaXNOdW1iZXJBcnJheShoLDMpfHwwPT09aFswXSYmMD09PWhbMV0mJjA9PT1oWzJdfHwoZD1Db2xvclNwYWNlVXRpbHMucmdiLmdldFJnYihoLDApKTtjb25zdCBmPXthY3Rpb246by5hY3Rpb24sYXR0YWNobWVudDpvLmF0dGFjaG1lbnQsZGVzdDpvLmRlc3QsdXJsOm8udXJsLHVuc2FmZVVybDpvLnVuc2FmZVVybCxuZXdXaW5kb3c6by5uZXdXaW5kb3csc2V0T0NHU3RhdGU6by5zZXRPQ0dTdGF0ZSx0aXRsZToic3RyaW5nIj09dHlwZW9mIGM/c3RyaW5nVG9QREZTdHJpbmcoYyk6IiIsY29sb3I6ZCxjb3VudDpOdW1iZXIuaXNJbnRlZ2VyKHUpP3U6dm9pZCAwLGJvbGQ6ISEoMiZsKSxpdGFsaWM6ISEoMSZsKSxpdGVtczpbXX07dC5wYXJlbnQuaXRlbXMucHVzaChmKTtlPXMuZ2V0UmF3KCJGaXJzdCIpO2lmKGUgaW5zdGFuY2VvZiBSZWYmJiFyLmhhcyhlKSl7YS5wdXNoKHtvYmo6ZSxwYXJlbnQ6Zn0pO3IucHV0KGUpfWU9cy5nZXRSYXcoIk5leHQiKTtpZihlIGluc3RhbmNlb2YgUmVmJiYhci5oYXMoZSkpe2EucHVzaCh7b2JqOmUscGFyZW50OnQucGFyZW50fSk7ci5wdXQoZSl9fXJldHVybiB0Lml0ZW1zLmxlbmd0aD4wP3QuaXRlbXM6bnVsbH1nZXQgcGVybWlzc2lvbnMoKXtsZXQgZT1udWxsO3RyeXtlPXRoaXMuI2NlKCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybigiVW5hYmxlIHRvIHJlYWQgcGVybWlzc2lvbnMuIil9cmV0dXJuIHNoYWRvdyh0aGlzLCJwZXJtaXNzaW9ucyIsZSl9I2NlKCl7Y29uc3QgZT10aGlzLnhyZWYudHJhaWxlci5nZXQoIkVuY3J5cHQiKTtpZighKGUgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm4gbnVsbDtsZXQgdD1lLmdldCgiUCIpO2lmKCJudW1iZXIiIT10eXBlb2YgdClyZXR1cm4gbnVsbDt0Kz0yKiozMjtjb25zdCBhPVtdO2Zvcihjb25zdCBlIGluIHcpe2NvbnN0IHI9d1tlXTt0JnImJmEucHVzaChyKX1yZXR1cm4gYX1nZXQgb3B0aW9uYWxDb250ZW50Q29uZmlnKCl7bGV0IGU9bnVsbDt0cnl7Y29uc3QgdD10aGlzLiNpZS5nZXQoIk9DUHJvcGVydGllcyIpO2lmKCF0KXJldHVybiBzaGFkb3codGhpcywib3B0aW9uYWxDb250ZW50Q29uZmlnIixudWxsKTtjb25zdCBhPXQuZ2V0KCJEIik7aWYoIWEpcmV0dXJuIHNoYWRvdyh0aGlzLCJvcHRpb25hbENvbnRlbnRDb25maWciLG51bGwpO2NvbnN0IHI9dC5nZXQoIk9DR3MiKTtpZighQXJyYXkuaXNBcnJheShyKSlyZXR1cm4gc2hhZG93KHRoaXMsIm9wdGlvbmFsQ29udGVudENvbmZpZyIsbnVsbCk7Y29uc3QgaT1uZXcgUmVmU2V0Q2FjaGU7Zm9yKGNvbnN0IGUgb2YgcillIGluc3RhbmNlb2YgUmVmJiYhaS5oYXMoZSkmJmkucHV0KGUsdGhpcy4jbGUoZSkpO2U9dGhpcy4jaGUoYSxpKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTt3YXJuKGBVbmFibGUgdG8gcmVhZCBvcHRpb25hbCBjb250ZW50IGNvbmZpZzogJHtlfWApfXJldHVybiBzaGFkb3codGhpcywib3B0aW9uYWxDb250ZW50Q29uZmlnIixlKX0jbGUoZSl7Y29uc3QgdD10aGlzLnhyZWYuZmV0Y2goZSksYT17aWQ6ZS50b1N0cmluZygpLG5hbWU6bnVsbCxpbnRlbnQ6bnVsbCx1c2FnZTp7cHJpbnQ6bnVsbCx2aWV3Om51bGx9LHJiR3JvdXBzOltdfSxyPXQuZ2V0KCJOYW1lIik7InN0cmluZyI9PXR5cGVvZiByJiYoYS5uYW1lPXN0cmluZ1RvUERGU3RyaW5nKHIpKTtsZXQgaT10LmdldEFycmF5KCJJbnRlbnQiKTtBcnJheS5pc0FycmF5KGkpfHwoaT1baV0pO2kuZXZlcnkoKGU9PmUgaW5zdGFuY2VvZiBOYW1lKSkmJihhLmludGVudD1pLm1hcCgoZT0+ZS5uYW1lKSkpO2NvbnN0IG49dC5nZXQoIlVzYWdlIik7aWYoIShuIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuIGE7Y29uc3Qgcz1hLnVzYWdlLG89bi5nZXQoIlByaW50Iik7aWYobyBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9by5nZXQoIlByaW50U3RhdGUiKTtpZihlIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goZS5uYW1lKXtjYXNlIk9OIjpjYXNlIk9GRiI6cy5wcmludD17cHJpbnRTdGF0ZTplLm5hbWV9fX1jb25zdCBjPW4uZ2V0KCJWaWV3Iik7aWYoYyBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9Yy5nZXQoIlZpZXdTdGF0ZSIpO2lmKGUgaW5zdGFuY2VvZiBOYW1lKXN3aXRjaChlLm5hbWUpe2Nhc2UiT04iOmNhc2UiT0ZGIjpzLnZpZXc9e3ZpZXdTdGF0ZTplLm5hbWV9fX1yZXR1cm4gYX0jaGUoZSx0KXtmdW5jdGlvbiBwYXJzZU9uT2ZmKGUpe2NvbnN0IGE9W107aWYoQXJyYXkuaXNBcnJheShlKSlmb3IoY29uc3QgciBvZiBlKXIgaW5zdGFuY2VvZiBSZWYmJnQuaGFzKHIpJiZhLnB1c2goci50b1N0cmluZygpKTtyZXR1cm4gYX1mdW5jdGlvbiBwYXJzZU9yZGVyKGUsYT0wKXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gbnVsbDtjb25zdCBpPVtdO2Zvcihjb25zdCBuIG9mIGUpe2lmKG4gaW5zdGFuY2VvZiBSZWYmJnQuaGFzKG4pKXtyLnB1dChuKTtpLnB1c2gobi50b1N0cmluZygpKTtjb250aW51ZX1jb25zdCBlPXBhcnNlTmVzdGVkT3JkZXIobixhKTtlJiZpLnB1c2goZSl9aWYoYT4wKXJldHVybiBpO2NvbnN0IG49W107Zm9yKGNvbnN0W2Vdb2YgdC5pdGVtcygpKXIuaGFzKGUpfHxuLnB1c2goZS50b1N0cmluZygpKTtuLmxlbmd0aCYmaS5wdXNoKHtuYW1lOm51bGwsb3JkZXI6bn0pO3JldHVybiBpfWZ1bmN0aW9uIHBhcnNlTmVzdGVkT3JkZXIoZSx0KXtpZigrK3Q+aSl7d2FybigicGFyc2VOZXN0ZWRPcmRlciAtIHJlYWNoZWQgTUFYX05FU1RFRF9MRVZFTFMuIik7cmV0dXJuIG51bGx9Y29uc3Qgcj1hLmZldGNoSWZSZWYoZSk7aWYoIUFycmF5LmlzQXJyYXkocikpcmV0dXJuIG51bGw7Y29uc3Qgbj1hLmZldGNoSWZSZWYoclswXSk7aWYoInN0cmluZyIhPXR5cGVvZiBuKXJldHVybiBudWxsO2NvbnN0IHM9cGFyc2VPcmRlcihyLnNsaWNlKDEpLHQpO3JldHVybiBzPy5sZW5ndGg/e25hbWU6c3RyaW5nVG9QREZTdHJpbmcobiksb3JkZXI6c306bnVsbH1jb25zdCBhPXRoaXMueHJlZixyPW5ldyBSZWZTZXQsaT0xMDshZnVuY3Rpb24gcGFyc2VSQkdyb3VwcyhlKXtpZihBcnJheS5pc0FycmF5KGUpKWZvcihjb25zdCByIG9mIGUpe2NvbnN0IGU9YS5mZXRjaElmUmVmKHIpO2lmKCFBcnJheS5pc0FycmF5KGUpfHwhZS5sZW5ndGgpY29udGludWU7Y29uc3QgaT1uZXcgU2V0O2Zvcihjb25zdCBhIG9mIGUpaWYoYSBpbnN0YW5jZW9mIFJlZiYmdC5oYXMoYSkmJiFpLmhhcyhhLnRvU3RyaW5nKCkpKXtpLmFkZChhLnRvU3RyaW5nKCkpO3QuZ2V0KGEpLnJiR3JvdXBzLnB1c2goaSl9fX0oZS5nZXQoIlJCR3JvdXBzIikpO3JldHVybntuYW1lOiJzdHJpbmciPT10eXBlb2YgZS5nZXQoIk5hbWUiKT9zdHJpbmdUb1BERlN0cmluZyhlLmdldCgiTmFtZSIpKTpudWxsLGNyZWF0b3I6InN0cmluZyI9PXR5cGVvZiBlLmdldCgiQ3JlYXRvciIpP3N0cmluZ1RvUERGU3RyaW5nKGUuZ2V0KCJDcmVhdG9yIikpOm51bGwsYmFzZVN0YXRlOmUuZ2V0KCJCYXNlU3RhdGUiKWluc3RhbmNlb2YgTmFtZT9lLmdldCgiQmFzZVN0YXRlIikubmFtZTpudWxsLG9uOnBhcnNlT25PZmYoZS5nZXQoIk9OIikpLG9mZjpwYXJzZU9uT2ZmKGUuZ2V0KCJPRkYiKSksb3JkZXI6cGFyc2VPcmRlcihlLmdldCgiT3JkZXIiKSksZ3JvdXBzOlsuLi50XX19c2V0QWN0dWFsTnVtUGFnZXMoZT1udWxsKXt0aGlzLiNyZT1lfWdldCBoYXNBY3R1YWxOdW1QYWdlcygpe3JldHVybiBudWxsIT09dGhpcy4jcmV9Z2V0IF9wYWdlc0NvdW50KCl7Y29uc3QgZT10aGlzLnRvcGxldmVsUGFnZXNEaWN0LmdldCgiQ291bnQiKTtpZighTnVtYmVyLmlzSW50ZWdlcihlKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlBhZ2UgY291bnQgaW4gdG9wLWxldmVsIHBhZ2VzIGRpY3Rpb25hcnkgaXMgbm90IGFuIGludGVnZXIuIik7cmV0dXJuIHNoYWRvdyh0aGlzLCJfcGFnZXNDb3VudCIsZSl9Z2V0IG51bVBhZ2VzKCl7cmV0dXJuIHRoaXMuI3JlPz90aGlzLl9wYWdlc0NvdW50fWdldCBkZXN0aW5hdGlvbnMoKXtjb25zdCBlPXRoaXMuI3VlKCksdD1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdCBhIG9mIGUpaWYoYSBpbnN0YW5jZW9mIE5hbWVUcmVlKWZvcihjb25zdFtlLHJdb2YgYS5nZXRBbGwoKSl7Y29uc3QgYT1mZXRjaERlc3Qocik7YSYmKHRbc3RyaW5nVG9QREZTdHJpbmcoZSwhMCldPWEpfWVsc2UgaWYoYSBpbnN0YW5jZW9mIERpY3QpZm9yKGNvbnN0W2Uscl1vZiBhKXtjb25zdCBhPWZldGNoRGVzdChyKTthJiYodFtzdHJpbmdUb1BERlN0cmluZyhlLCEwKV18fD1hKX1yZXR1cm4gc2hhZG93KHRoaXMsImRlc3RpbmF0aW9ucyIsdCl9Z2V0RGVzdGluYXRpb24oZSl7aWYodGhpcy5oYXNPd25Qcm9wZXJ0eSgiZGVzdGluYXRpb25zIikpcmV0dXJuIHRoaXMuZGVzdGluYXRpb25zW2VdPz9udWxsO2NvbnN0IHQ9dGhpcy4jdWUoKTtmb3IoY29uc3QgYSBvZiB0KWlmKGEgaW5zdGFuY2VvZiBOYW1lVHJlZXx8YSBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IHQ9ZmV0Y2hEZXN0KGEuZ2V0KGUpKTtpZih0KXJldHVybiB0fWlmKHQubGVuZ3RoKXtjb25zdCB0PXRoaXMuZGVzdGluYXRpb25zW2VdO2lmKHQpcmV0dXJuIHR9cmV0dXJuIG51bGx9I3VlKCl7Y29uc3QgZT10aGlzLiNpZS5nZXQoIk5hbWVzIiksdD1bXTtlPy5oYXMoIkRlc3RzIikmJnQucHVzaChuZXcgTmFtZVRyZWUoZS5nZXRSYXcoIkRlc3RzIiksdGhpcy54cmVmKSk7dGhpcy4jaWUuaGFzKCJEZXN0cyIpJiZ0LnB1c2godGhpcy4jaWUuZ2V0KCJEZXN0cyIpKTtyZXR1cm4gdH1nZXQgcGFnZUxhYmVscygpe2xldCBlPW51bGw7dHJ5e2U9dGhpcy4jZGUoKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTt3YXJuKCJVbmFibGUgdG8gcmVhZCBwYWdlIGxhYmVscy4iKX1yZXR1cm4gc2hhZG93KHRoaXMsInBhZ2VMYWJlbHMiLGUpfSNkZSgpe2NvbnN0IGU9dGhpcy4jaWUuZ2V0UmF3KCJQYWdlTGFiZWxzIik7aWYoIWUpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5udW1QYWdlcyk7bGV0IGE9bnVsbCxyPSIiO2NvbnN0IGk9bmV3IE51bWJlclRyZWUoZSx0aGlzLnhyZWYpLmdldEFsbCgpO2xldCBuPSIiLHM9MTtmb3IobGV0IGU9MCxvPXRoaXMubnVtUGFnZXM7ZTxvO2UrKyl7Y29uc3Qgbz1pLmdldChlKTtpZih2b2lkIDAhPT1vKXtpZighKG8gaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlBhZ2VMYWJlbCBpcyBub3QgYSBkaWN0aW9uYXJ5LiIpO2lmKG8uaGFzKCJUeXBlIikmJiFpc05hbWUoby5nZXQoIlR5cGUiKSwiUGFnZUxhYmVsIikpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIHR5cGUgaW4gUGFnZUxhYmVsIGRpY3Rpb25hcnkuIik7aWYoby5oYXMoIlMiKSl7Y29uc3QgZT1vLmdldCgiUyIpO2lmKCEoZSBpbnN0YW5jZW9mIE5hbWUpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBzdHlsZSBpbiBQYWdlTGFiZWwgZGljdGlvbmFyeS4iKTthPWUubmFtZX1lbHNlIGE9bnVsbDtpZihvLmhhcygiUCIpKXtjb25zdCBlPW8uZ2V0KCJQIik7aWYoInN0cmluZyIhPXR5cGVvZiBlKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBwcmVmaXggaW4gUGFnZUxhYmVsIGRpY3Rpb25hcnkuIik7cj1zdHJpbmdUb1BERlN0cmluZyhlKX1lbHNlIHI9IiI7aWYoby5oYXMoIlN0Iikpe2NvbnN0IGU9by5nZXQoIlN0Iik7aWYoIShOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0xKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkludmFsaWQgc3RhcnQgaW4gUGFnZUxhYmVsIGRpY3Rpb25hcnkuIik7cz1lfWVsc2Ugcz0xfXN3aXRjaChhKXtjYXNlIkQiOm49czticmVhaztjYXNlIlIiOmNhc2UiciI6bj10b1JvbWFuTnVtZXJhbHMocywiciI9PT1hKTticmVhaztjYXNlIkEiOmNhc2UiYSI6Y29uc3QgZT0yNix0PSJhIj09PWE/OTc6NjUscj1zLTE7bj1TdHJpbmcuZnJvbUNoYXJDb2RlKHQrciVlKS5yZXBlYXQoTWF0aC5mbG9vcihyL2UpKzEpO2JyZWFrO2RlZmF1bHQ6aWYoYSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgc3R5bGUgIiR7YX0iIGluIFBhZ2VMYWJlbCBkaWN0aW9uYXJ5LmApO249IiJ9dFtlXT1yK247cysrfXJldHVybiB0fWdldCBwYWdlTGF5b3V0KCl7Y29uc3QgZT10aGlzLiNpZS5nZXQoIlBhZ2VMYXlvdXQiKTtsZXQgdD0iIjtpZihlIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goZS5uYW1lKXtjYXNlIlNpbmdsZVBhZ2UiOmNhc2UiT25lQ29sdW1uIjpjYXNlIlR3b0NvbHVtbkxlZnQiOmNhc2UiVHdvQ29sdW1uUmlnaHQiOmNhc2UiVHdvUGFnZUxlZnQiOmNhc2UiVHdvUGFnZVJpZ2h0Ijp0PWUubmFtZX1yZXR1cm4gc2hhZG93KHRoaXMsInBhZ2VMYXlvdXQiLHQpfWdldCBwYWdlTW9kZSgpe2NvbnN0IGU9dGhpcy4jaWUuZ2V0KCJQYWdlTW9kZSIpO2xldCB0PSJVc2VOb25lIjtpZihlIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goZS5uYW1lKXtjYXNlIlVzZU5vbmUiOmNhc2UiVXNlT3V0bGluZXMiOmNhc2UiVXNlVGh1bWJzIjpjYXNlIkZ1bGxTY3JlZW4iOmNhc2UiVXNlT0MiOmNhc2UiVXNlQXR0YWNobWVudHMiOnQ9ZS5uYW1lfXJldHVybiBzaGFkb3codGhpcywicGFnZU1vZGUiLHQpfWdldCB2aWV3ZXJQcmVmZXJlbmNlcygpe2NvbnN0IGU9dGhpcy4jaWUuZ2V0KCJWaWV3ZXJQcmVmZXJlbmNlcyIpO2lmKCEoZSBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBzaGFkb3codGhpcywidmlld2VyUHJlZmVyZW5jZXMiLG51bGwpO2xldCB0PW51bGw7Zm9yKGNvbnN0W2Escl1vZiBlKXtsZXQgZTtzd2l0Y2goYSl7Y2FzZSJIaWRlVG9vbGJhciI6Y2FzZSJIaWRlTWVudWJhciI6Y2FzZSJIaWRlV2luZG93VUkiOmNhc2UiRml0V2luZG93IjpjYXNlIkNlbnRlcldpbmRvdyI6Y2FzZSJEaXNwbGF5RG9jVGl0bGUiOmNhc2UiUGlja1RyYXlCeVBERlNpemUiOiJib29sZWFuIj09dHlwZW9mIHImJihlPXIpO2JyZWFrO2Nhc2UiTm9uRnVsbFNjcmVlblBhZ2VNb2RlIjppZihyIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goci5uYW1lKXtjYXNlIlVzZU5vbmUiOmNhc2UiVXNlT3V0bGluZXMiOmNhc2UiVXNlVGh1bWJzIjpjYXNlIlVzZU9DIjplPXIubmFtZTticmVhaztkZWZhdWx0OmU9IlVzZU5vbmUifWJyZWFrO2Nhc2UiRGlyZWN0aW9uIjppZihyIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goci5uYW1lKXtjYXNlIkwyUiI6Y2FzZSJSMkwiOmU9ci5uYW1lO2JyZWFrO2RlZmF1bHQ6ZT0iTDJSIn1icmVhaztjYXNlIlZpZXdBcmVhIjpjYXNlIlZpZXdDbGlwIjpjYXNlIlByaW50QXJlYSI6Y2FzZSJQcmludENsaXAiOmlmKHIgaW5zdGFuY2VvZiBOYW1lKXN3aXRjaChyLm5hbWUpe2Nhc2UiTWVkaWFCb3giOmNhc2UiQ3JvcEJveCI6Y2FzZSJCbGVlZEJveCI6Y2FzZSJUcmltQm94IjpjYXNlIkFydEJveCI6ZT1yLm5hbWU7YnJlYWs7ZGVmYXVsdDplPSJDcm9wQm94In1icmVhaztjYXNlIlByaW50U2NhbGluZyI6aWYociBpbnN0YW5jZW9mIE5hbWUpc3dpdGNoKHIubmFtZSl7Y2FzZSJOb25lIjpjYXNlIkFwcERlZmF1bHQiOmU9ci5uYW1lO2JyZWFrO2RlZmF1bHQ6ZT0iQXBwRGVmYXVsdCJ9YnJlYWs7Y2FzZSJEdXBsZXgiOmlmKHIgaW5zdGFuY2VvZiBOYW1lKXN3aXRjaChyLm5hbWUpe2Nhc2UiU2ltcGxleCI6Y2FzZSJEdXBsZXhGbGlwU2hvcnRFZGdlIjpjYXNlIkR1cGxleEZsaXBMb25nRWRnZSI6ZT1yLm5hbWU7YnJlYWs7ZGVmYXVsdDplPSJOb25lIn1icmVhaztjYXNlIlByaW50UGFnZVJhbmdlIjppZihBcnJheS5pc0FycmF5KHIpJiZyLmxlbmd0aCUyPT0wKXtyLmV2ZXJ5KCgoZSx0LGEpPT5OdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPjAmJigwPT09dHx8ZT49YVt0LTFdKSYmZTw9dGhpcy5udW1QYWdlcykpJiYoZT1yKX1icmVhaztjYXNlIk51bUNvcGllcyI6TnVtYmVyLmlzSW50ZWdlcihyKSYmcj4wJiYoZT1yKTticmVhaztkZWZhdWx0Ondhcm4oYElnbm9yaW5nIG5vbi1zdGFuZGFyZCBrZXkgaW4gVmlld2VyUHJlZmVyZW5jZXM6ICR7YX0uYCk7Y29udGludWV9aWYodm9pZCAwIT09ZSl7dD8/PU9iamVjdC5jcmVhdGUobnVsbCk7dFthXT1lfWVsc2Ugd2FybihgQmFkIHZhbHVlLCBmb3Iga2V5ICIke2F9IiwgaW4gVmlld2VyUHJlZmVyZW5jZXM6ICR7cn0uYCl9cmV0dXJuIHNoYWRvdyh0aGlzLCJ2aWV3ZXJQcmVmZXJlbmNlcyIsdCl9Z2V0IG9wZW5BY3Rpb24oKXtjb25zdCBlPXRoaXMuI2llLmdldCgiT3BlbkFjdGlvbiIpLHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihlIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgYT1uZXcgRGljdCh0aGlzLnhyZWYpO2Euc2V0KCJBIixlKTtjb25zdCByPXt1cmw6bnVsbCxkZXN0Om51bGwsYWN0aW9uOm51bGx9O0NhdGFsb2cucGFyc2VEZXN0RGljdGlvbmFyeSh7ZGVzdERpY3Q6YSxyZXN1bHRPYmo6cn0pO0FycmF5LmlzQXJyYXkoci5kZXN0KT90LmRlc3Q9ci5kZXN0OnIuYWN0aW9uJiYodC5hY3Rpb249ci5hY3Rpb24pfWVsc2UgUm4oZSkmJih0LmRlc3Q9ZSk7cmV0dXJuIHNoYWRvdyh0aGlzLCJvcGVuQWN0aW9uIixvYmplY3RTaXplKHQpPjA/dDpudWxsKX1nZXQgYXR0YWNobWVudHMoKXtjb25zdCBlPXRoaXMuI2llLmdldCgiTmFtZXMiKTtsZXQgdD1udWxsO2lmKGUgaW5zdGFuY2VvZiBEaWN0JiZlLmhhcygiRW1iZWRkZWRGaWxlcyIpKXtjb25zdCBhPW5ldyBOYW1lVHJlZShlLmdldFJhdygiRW1iZWRkZWRGaWxlcyIpLHRoaXMueHJlZik7Zm9yKGNvbnN0W2Uscl1vZiBhLmdldEFsbCgpKXtjb25zdCBhPW5ldyBGaWxlU3BlYyhyLHRoaXMueHJlZik7dD8/PU9iamVjdC5jcmVhdGUobnVsbCk7dFtzdHJpbmdUb1BERlN0cmluZyhlLCEwKV09YS5zZXJpYWxpemFibGV9fXJldHVybiBzaGFkb3codGhpcywiYXR0YWNobWVudHMiLHQpfWdldCB4ZmFJbWFnZXMoKXtjb25zdCBlPXRoaXMuI2llLmdldCgiTmFtZXMiKTtsZXQgdD1udWxsO2lmKGUgaW5zdGFuY2VvZiBEaWN0JiZlLmhhcygiWEZBSW1hZ2VzIikpe2NvbnN0IGE9bmV3IE5hbWVUcmVlKGUuZ2V0UmF3KCJYRkFJbWFnZXMiKSx0aGlzLnhyZWYpO2Zvcihjb25zdFtlLHJdb2YgYS5nZXRBbGwoKSlpZihyIGluc3RhbmNlb2YgQmFzZVN0cmVhbSl7dD8/PW5ldyBNYXA7dC5zZXQoc3RyaW5nVG9QREZTdHJpbmcoZSwhMCksci5nZXRCeXRlcygpKX19cmV0dXJuIHNoYWRvdyh0aGlzLCJ4ZmFJbWFnZXMiLHQpfSNmZSgpe2NvbnN0IGU9dGhpcy4jaWUuZ2V0KCJOYW1lcyIpO2xldCB0PW51bGw7ZnVuY3Rpb24gYXBwZW5kSWZKYXZhU2NyaXB0RGljdChlLGEpe2lmKCEoYSBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtpZighaXNOYW1lKGEuZ2V0KCJTIiksIkphdmFTY3JpcHQiKSlyZXR1cm47bGV0IHI9YS5nZXQoIkpTIik7aWYociBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pcj1yLmdldFN0cmluZygpO2Vsc2UgaWYoInN0cmluZyIhPXR5cGVvZiByKXJldHVybjtyPXN0cmluZ1RvUERGU3RyaW5nKHIsITApLnJlcGxhY2VBbGwoIlwwIiwiIik7ciYmKHR8fD1uZXcgTWFwKS5zZXQoZSxyKX1pZihlIGluc3RhbmNlb2YgRGljdCYmZS5oYXMoIkphdmFTY3JpcHQiKSl7Y29uc3QgdD1uZXcgTmFtZVRyZWUoZS5nZXRSYXcoIkphdmFTY3JpcHQiKSx0aGlzLnhyZWYpO2Zvcihjb25zdFtlLGFdb2YgdC5nZXRBbGwoKSlhcHBlbmRJZkphdmFTY3JpcHREaWN0KHN0cmluZ1RvUERGU3RyaW5nKGUsITApLGEpfWNvbnN0IGE9dGhpcy4jaWUuZ2V0KCJPcGVuQWN0aW9uIik7YSYmYXBwZW5kSWZKYXZhU2NyaXB0RGljdCgiT3BlbkFjdGlvbiIsYSk7cmV0dXJuIHR9Z2V0IGpzQWN0aW9ucygpe2NvbnN0IGU9dGhpcy4jZmUoKTtsZXQgdD1jb2xsZWN0QWN0aW9ucyh0aGlzLnhyZWYsdGhpcy4jaWUsYWUpO2lmKGUpe3R8fD1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdFthLHJdb2YgZSlhIGluIHQ/dFthXS5wdXNoKHIpOnRbYV09W3JdfXJldHVybiBzaGFkb3codGhpcywianNBY3Rpb25zIix0KX1hc3luYyBjbGVhbnVwKGU9ITEpe2NsZWFyR2xvYmFsQ2FjaGVzKCk7dGhpcy5nbG9iYWxDb2xvclNwYWNlQ2FjaGUuY2xlYXIoKTt0aGlzLmdsb2JhbEltYWdlQ2FjaGUuY2xlYXIoZSk7dGhpcy5wYWdlS2lkc0NvdW50Q2FjaGUuY2xlYXIoKTt0aGlzLnBhZ2VJbmRleENhY2hlLmNsZWFyKCk7dGhpcy5wYWdlRGljdENhY2hlLmNsZWFyKCk7dGhpcy5ub25CbGVuZE1vZGVzU2V0LmNsZWFyKCk7Zm9yKGNvbnN0e2RpY3Q6ZX1vZiBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmZvbnRDYWNoZSkpZGVsZXRlIGUuY2FjaGVLZXk7dGhpcy5mb250Q2FjaGUuY2xlYXIoKTt0aGlzLmJ1aWx0SW5DTWFwQ2FjaGUuY2xlYXIoKTt0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZS5jbGVhcigpO3RoaXMuc3lzdGVtRm9udENhY2hlLmNsZWFyKCl9YXN5bmMgZ2V0UGFnZURpY3QoZSl7Y29uc3QgdD1bdGhpcy50b3BsZXZlbFBhZ2VzRGljdF0sYT1uZXcgUmVmU2V0LHI9dGhpcy4jaWUuZ2V0UmF3KCJQYWdlcyIpO3IgaW5zdGFuY2VvZiBSZWYmJmEucHV0KHIpO2NvbnN0IGk9dGhpcy54cmVmLG49dGhpcy5wYWdlS2lkc0NvdW50Q2FjaGUscz10aGlzLnBhZ2VJbmRleENhY2hlLG89dGhpcy5wYWdlRGljdENhY2hlO2xldCBjPTA7Zm9yKDt0Lmxlbmd0aDspe2NvbnN0IHI9dC5wb3AoKTtpZihyIGluc3RhbmNlb2YgUmVmKXtjb25zdCBsPW4uZ2V0KHIpO2lmKGw+PTAmJmMrbDw9ZSl7Yys9bDtjb250aW51ZX1pZihhLmhhcyhyKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlBhZ2VzIHRyZWUgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlLiIpO2EucHV0KHIpO2NvbnN0IGg9YXdhaXQoby5nZXQocil8fGkuZmV0Y2hBc3luYyhyKSk7aWYoaCBpbnN0YW5jZW9mIERpY3Qpe2xldCB0PWguZ2V0UmF3KCJUeXBlIik7dCBpbnN0YW5jZW9mIFJlZiYmKHQ9YXdhaXQgaS5mZXRjaEFzeW5jKHQpKTtpZihpc05hbWUodCwiUGFnZSIpfHwhaC5oYXMoIktpZHMiKSl7bi5oYXMocil8fG4ucHV0KHIsMSk7cy5oYXMocil8fHMucHV0KHIsYyk7aWYoYz09PWUpcmV0dXJuW2gscl07YysrO2NvbnRpbnVlfX10LnB1c2goaCk7Y29udGludWV9aWYoIShyIGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJQYWdlIGRpY3Rpb25hcnkga2lkIHJlZmVyZW5jZSBwb2ludHMgdG8gd3JvbmcgdHlwZSBvZiBvYmplY3QuIik7Y29uc3R7b2JqSWQ6bH09cjtsZXQgaD1yLmdldFJhdygiQ291bnQiKTtoIGluc3RhbmNlb2YgUmVmJiYoaD1hd2FpdCBpLmZldGNoQXN5bmMoaCkpO2lmKE51bWJlci5pc0ludGVnZXIoaCkmJmg+PTApe2wmJiFuLmhhcyhsKSYmbi5wdXQobCxoKTtpZihjK2g8PWUpe2MrPWg7Y29udGludWV9fWxldCB1PXIuZ2V0UmF3KCJLaWRzIik7dSBpbnN0YW5jZW9mIFJlZiYmKHU9YXdhaXQgaS5mZXRjaEFzeW5jKHUpKTtpZighQXJyYXkuaXNBcnJheSh1KSl7bGV0IHQ9ci5nZXRSYXcoIlR5cGUiKTt0IGluc3RhbmNlb2YgUmVmJiYodD1hd2FpdCBpLmZldGNoQXN5bmModCkpO2lmKGlzTmFtZSh0LCJQYWdlIil8fCFyLmhhcygiS2lkcyIpKXtpZihjPT09ZSlyZXR1cm5bcixudWxsXTtjKys7Y29udGludWV9dGhyb3cgbmV3IEZvcm1hdEVycm9yKCJQYWdlIGRpY3Rpb25hcnkga2lkcyBvYmplY3QgaXMgbm90IGFuIGFycmF5LiIpfWZvcihsZXQgZT11Lmxlbmd0aC0xO2U+PTA7ZS0tKXtjb25zdCBhPXVbZV07dC5wdXNoKGEpO3I9PT10aGlzLnRvcGxldmVsUGFnZXNEaWN0JiZhIGluc3RhbmNlb2YgUmVmJiYhby5oYXMoYSkmJm8ucHV0KGEsaS5mZXRjaEFzeW5jKGEpKX19dGhyb3cgbmV3IEVycm9yKGBQYWdlIGluZGV4ICR7ZX0gbm90IGZvdW5kLmApfWFzeW5jIGdldEFsbFBhZ2VEaWN0cyhlPSExKXtjb25zdHtpZ25vcmVFcnJvcnM6dH09dGhpcy5wZGZNYW5hZ2VyLmV2YWx1YXRvck9wdGlvbnMsYT1be2N1cnJlbnROb2RlOnRoaXMudG9wbGV2ZWxQYWdlc0RpY3QscG9zSW5LaWRzOjB9XSxyPW5ldyBSZWZTZXQsaT10aGlzLiNpZS5nZXRSYXcoIlBhZ2VzIik7aSBpbnN0YW5jZW9mIFJlZiYmci5wdXQoaSk7Y29uc3Qgbj1uZXcgTWFwLHM9dGhpcy54cmVmLG89dGhpcy5wYWdlSW5kZXhDYWNoZTtsZXQgYz0wO2Z1bmN0aW9uIGFkZFBhZ2VEaWN0KGUsdCl7dCYmIW8uaGFzKHQpJiZvLnB1dCh0LGMpO24uc2V0KGMrKyxbZSx0XSl9ZnVuY3Rpb24gYWRkUGFnZUVycm9yKGEpe2lmKGEgaW5zdGFuY2VvZiBYUmVmRW50cnlFeGNlcHRpb24mJiFlKXRocm93IGE7aWYoZSYmdCYmMD09PWMpe3dhcm4oYGdldEFsbFBhZ2VEaWN0cyAtIFNraXBwaW5nIGludmFsaWQgZmlyc3QgcGFnZTogIiR7YX0iLmApO2E9RGljdC5lbXB0eX1uLnNldChjKyssW2EsbnVsbF0pfWZvcig7YS5sZW5ndGg+MDspe2NvbnN0IGU9YS5hdCgtMSkse2N1cnJlbnROb2RlOnQscG9zSW5LaWRzOml9PWU7bGV0IG49dC5nZXRSYXcoIktpZHMiKTtpZihuIGluc3RhbmNlb2YgUmVmKXRyeXtuPWF3YWl0IHMuZmV0Y2hBc3luYyhuKX1jYXRjaChlKXthZGRQYWdlRXJyb3IoZSk7YnJlYWt9aWYoIUFycmF5LmlzQXJyYXkobikpe2FkZFBhZ2VFcnJvcihuZXcgRm9ybWF0RXJyb3IoIlBhZ2UgZGljdGlvbmFyeSBraWRzIG9iamVjdCBpcyBub3QgYW4gYXJyYXkuIikpO2JyZWFrfWlmKGk+PW4ubGVuZ3RoKXthLnBvcCgpO2NvbnRpbnVlfWNvbnN0IG89bltpXTtsZXQgYztpZihvIGluc3RhbmNlb2YgUmVmKXtpZihyLmhhcyhvKSl7YWRkUGFnZUVycm9yKG5ldyBGb3JtYXRFcnJvcigiUGFnZXMgdHJlZSBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2UuIikpO2JyZWFrfXIucHV0KG8pO3RyeXtjPWF3YWl0IHMuZmV0Y2hBc3luYyhvKX1jYXRjaChlKXthZGRQYWdlRXJyb3IoZSk7YnJlYWt9fWVsc2UgYz1vO2lmKCEoYyBpbnN0YW5jZW9mIERpY3QpKXthZGRQYWdlRXJyb3IobmV3IEZvcm1hdEVycm9yKCJQYWdlIGRpY3Rpb25hcnkga2lkIHJlZmVyZW5jZSBwb2ludHMgdG8gd3JvbmcgdHlwZSBvZiBvYmplY3QuIikpO2JyZWFrfWxldCBsPWMuZ2V0UmF3KCJUeXBlIik7aWYobCBpbnN0YW5jZW9mIFJlZil0cnl7bD1hd2FpdCBzLmZldGNoQXN5bmMobCl9Y2F0Y2goZSl7YWRkUGFnZUVycm9yKGUpO2JyZWFrfWlzTmFtZShsLCJQYWdlIil8fCFjLmhhcygiS2lkcyIpP2FkZFBhZ2VEaWN0KGMsbyBpbnN0YW5jZW9mIFJlZj9vOm51bGwpOmEucHVzaCh7Y3VycmVudE5vZGU6Yyxwb3NJbktpZHM6MH0pO2UucG9zSW5LaWRzKyt9cmV0dXJuIG59Z2V0UGFnZUluZGV4KGUpe2NvbnN0IHQ9dGhpcy5wYWdlSW5kZXhDYWNoZS5nZXQoZSk7aWYodm9pZCAwIT09dClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHQpO2NvbnN0IGE9dGhpcy54cmVmO2xldCByPTA7Y29uc3QgbmV4dD10PT5mdW5jdGlvbiBwYWdlc0JlZm9yZVJlZih0KXtsZXQgcixpPTA7cmV0dXJuIGEuZmV0Y2hBc3luYyh0KS50aGVuKChmdW5jdGlvbihhKXtpZihpc1JlZnNFcXVhbCh0LGUpJiYhaXNEaWN0KGEsIlBhZ2UiKSYmIShhIGluc3RhbmNlb2YgRGljdCYmIWEuaGFzKCJUeXBlIikmJmEuaGFzKCJDb250ZW50cyIpKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlRoZSByZWZlcmVuY2UgZG9lcyBub3QgcG9pbnQgdG8gYSAvUGFnZSBkaWN0aW9uYXJ5LiIpO2lmKCFhKXJldHVybiBudWxsO2lmKCEoYSBpbnN0YW5jZW9mIERpY3QpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiTm9kZSBtdXN0IGJlIGEgZGljdGlvbmFyeS4iKTtyPWEuZ2V0UmF3KCJQYXJlbnQiKTtyZXR1cm4gYS5nZXRBc3luYygiUGFyZW50Iil9KSkudGhlbigoZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuIG51bGw7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJQYXJlbnQgbXVzdCBiZSBhIGRpY3Rpb25hcnkuIik7cmV0dXJuIGUuZ2V0QXN5bmMoIktpZHMiKX0pKS50aGVuKChmdW5jdGlvbihlKXtpZighZSlyZXR1cm4gbnVsbDtjb25zdCBuPVtdO2xldCBzPSExO2Zvcihjb25zdCByIG9mIGUpe2lmKCEociBpbnN0YW5jZW9mIFJlZikpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJLaWQgbXVzdCBiZSBhIHJlZmVyZW5jZS4iKTtpZihpc1JlZnNFcXVhbChyLHQpKXtzPSEwO2JyZWFrfW4ucHVzaChhLmZldGNoQXN5bmMocikudGhlbigoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJLaWQgbm9kZSBtdXN0IGJlIGEgZGljdGlvbmFyeS4iKTtlLmhhcygiQ291bnQiKT9pKz1lLmdldCgiQ291bnQiKTppKyt9KSkpfWlmKCFzKXRocm93IG5ldyBGb3JtYXRFcnJvcigiS2lkIHJlZmVyZW5jZSBub3QgZm91bmQgaW4gcGFyZW50J3Mga2lkcy4iKTtyZXR1cm4gUHJvbWlzZS5hbGwobikudGhlbigoKCk9PltpLHJdKSl9KSl9KHQpLnRoZW4oKHQ9PntpZighdCl7dGhpcy5wYWdlSW5kZXhDYWNoZS5wdXQoZSxyKTtyZXR1cm4gcn1jb25zdFthLGldPXQ7cis9YTtyZXR1cm4gbmV4dChpKX0pKTtyZXR1cm4gbmV4dChlKX1nZXQgYmFzZVVybCgpe2NvbnN0IGU9dGhpcy4jaWUuZ2V0KCJVUkkiKTtpZihlIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgdD1lLmdldCgiQmFzZSIpO2lmKCJzdHJpbmciPT10eXBlb2YgdCl7Y29uc3QgZT1jcmVhdGVWYWxpZEFic29sdXRlVXJsKHQsbnVsbCx7dHJ5Q29udmVydEVuY29kaW5nOiEwfSk7aWYoZSlyZXR1cm4gc2hhZG93KHRoaXMsImJhc2VVcmwiLGUuaHJlZil9fXJldHVybiBzaGFkb3codGhpcywiYmFzZVVybCIsdGhpcy5wZGZNYW5hZ2VyLmRvY0Jhc2VVcmwpfXN0YXRpYyBwYXJzZURlc3REaWN0aW9uYXJ5KHtkZXN0RGljdDplLHJlc3VsdE9iajp0LGRvY0Jhc2VVcmw6YT1udWxsLGRvY0F0dGFjaG1lbnRzOnI9bnVsbH0pe2lmKCEoZSBpbnN0YW5jZW9mIERpY3QpKXt3YXJuKCJwYXJzZURlc3REaWN0aW9uYXJ5OiBgZGVzdERpY3RgIG11c3QgYmUgYSBkaWN0aW9uYXJ5LiIpO3JldHVybn1sZXQgaSxuLHM9ZS5nZXQoIkEiKTtpZighKHMgaW5zdGFuY2VvZiBEaWN0KSlpZihlLmhhcygiRGVzdCIpKXM9ZS5nZXQoIkRlc3QiKTtlbHNle3M9ZS5nZXQoIkFBIik7cyBpbnN0YW5jZW9mIERpY3QmJihzLmhhcygiRCIpP3M9cy5nZXQoIkQiKTpzLmhhcygiVSIpJiYocz1zLmdldCgiVSIpKSl9aWYocyBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9cy5nZXQoIlMiKTtpZighKGUgaW5zdGFuY2VvZiBOYW1lKSl7d2FybigicGFyc2VEZXN0RGljdGlvbmFyeTogSW52YWxpZCB0eXBlIGluIEFjdGlvbiBkaWN0aW9uYXJ5LiIpO3JldHVybn1jb25zdCBhPWUubmFtZTtzd2l0Y2goYSl7Y2FzZSJSZXNldEZvcm0iOmNvbnN0IGU9cy5nZXQoIkZsYWdzIiksbz0hKDEmKCJudW1iZXIiPT10eXBlb2YgZT9lOjApKSxjPVtdLGw9W107Zm9yKGNvbnN0IGUgb2Ygcy5nZXQoIkZpZWxkcyIpfHxbXSllIGluc3RhbmNlb2YgUmVmP2wucHVzaChlLnRvU3RyaW5nKCkpOiJzdHJpbmciPT10eXBlb2YgZSYmYy5wdXNoKHN0cmluZ1RvUERGU3RyaW5nKGUpKTt0LnJlc2V0Rm9ybT17ZmllbGRzOmMscmVmczpsLGluY2x1ZGU6b307YnJlYWs7Y2FzZSJVUkkiOmk9cy5nZXQoIlVSSSIpO2kgaW5zdGFuY2VvZiBOYW1lJiYoaT0iLyIraS5uYW1lKTticmVhaztjYXNlIkdvVG8iOm49cy5nZXQoIkQiKTticmVhaztjYXNlIkxhdW5jaCI6Y2FzZSJHb1RvUiI6Y29uc3QgaD1zLmdldCgiRiIpO2lmKGggaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBlPW5ldyBGaWxlU3BlYyhoLG51bGwsITApLHtyYXdGaWxlbmFtZTp0fT1lLnNlcmlhbGl6YWJsZTtpPXR9ZWxzZSJzdHJpbmciPT10eXBlb2YgaCYmKGk9aCk7Y29uc3QgdT1mZXRjaFJlbW90ZURlc3Qocyk7dSYmInN0cmluZyI9PXR5cGVvZiBpJiYoaT1pLnNwbGl0KCIjIiwxKVswXSsiIyIrdSk7Y29uc3QgZD1zLmdldCgiTmV3V2luZG93Iik7ImJvb2xlYW4iPT10eXBlb2YgZCYmKHQubmV3V2luZG93PWQpO2JyZWFrO2Nhc2UiR29Ub0UiOmNvbnN0IGY9cy5nZXQoIlQiKTtsZXQgZztpZihyJiZmIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgZT1mLmdldCgiUiIpLHQ9Zi5nZXQoIk4iKTtpc05hbWUoZSwiQyIpJiYic3RyaW5nIj09dHlwZW9mIHQmJihnPXJbc3RyaW5nVG9QREZTdHJpbmcodCwhMCldKX1pZihnKXt0LmF0dGFjaG1lbnQ9Zztjb25zdCBlPWZldGNoUmVtb3RlRGVzdChzKTtlJiYodC5hdHRhY2htZW50RGVzdD1lKX1lbHNlIHdhcm4oJ3BhcnNlRGVzdERpY3Rpb25hcnkgLSB1bmltcGxlbWVudGVkICJHb1RvRSIgYWN0aW9uLicpO2JyZWFrO2Nhc2UiTmFtZWQiOmNvbnN0IHA9cy5nZXQoIk4iKTtwIGluc3RhbmNlb2YgTmFtZSYmKHQuYWN0aW9uPXAubmFtZSk7YnJlYWs7Y2FzZSJTZXRPQ0dTdGF0ZSI6Y29uc3QgbT1zLmdldCgiU3RhdGUiKSxiPXMuZ2V0KCJQcmVzZXJ2ZVJCIik7aWYoIUFycmF5LmlzQXJyYXkobSl8fDA9PT1tLmxlbmd0aClicmVhaztjb25zdCB5PVtdO2Zvcihjb25zdCBlIG9mIG0paWYoZSBpbnN0YW5jZW9mIE5hbWUpc3dpdGNoKGUubmFtZSl7Y2FzZSJPTiI6Y2FzZSJPRkYiOmNhc2UiVG9nZ2xlIjp5LnB1c2goZS5uYW1lKX1lbHNlIGUgaW5zdGFuY2VvZiBSZWYmJnkucHVzaChlLnRvU3RyaW5nKCkpO2lmKHkubGVuZ3RoIT09bS5sZW5ndGgpYnJlYWs7dC5zZXRPQ0dTdGF0ZT17c3RhdGU6eSxwcmVzZXJ2ZVJCOiJib29sZWFuIiE9dHlwZW9mIGJ8fGJ9O2JyZWFrO2Nhc2UiSmF2YVNjcmlwdCI6Y29uc3Qgdz1zLmdldCgiSlMiKTtsZXQgeDt3IGluc3RhbmNlb2YgQmFzZVN0cmVhbT94PXcuZ2V0U3RyaW5nKCk6InN0cmluZyI9PXR5cGVvZiB3JiYoeD13KTtjb25zdCBTPXgmJnJlY292ZXJKc1VSTChzdHJpbmdUb1BERlN0cmluZyh4LCEwKSk7aWYoUyl7aT1TLnVybDt0Lm5ld1dpbmRvdz1TLm5ld1dpbmRvdzticmVha31kZWZhdWx0OmlmKCJKYXZhU2NyaXB0Ij09PWF8fCJTdWJtaXRGb3JtIj09PWEpYnJlYWs7d2FybihgcGFyc2VEZXN0RGljdGlvbmFyeSAtIHVuc3VwcG9ydGVkIGFjdGlvbjogIiR7YX0iLmApfX1lbHNlIGUuaGFzKCJEZXN0IikmJihuPWUuZ2V0KCJEZXN0IikpO2lmKCJzdHJpbmciPT10eXBlb2YgaSl7Y29uc3QgZT1jcmVhdGVWYWxpZEFic29sdXRlVXJsKGksYSx7YWRkRGVmYXVsdFByb3RvY29sOiEwLHRyeUNvbnZlcnRFbmNvZGluZzohMH0pO2UmJih0LnVybD1lLmhyZWYpO3QudW5zYWZlVXJsPWl9aWYobil7biBpbnN0YW5jZW9mIE5hbWUmJihuPW4ubmFtZSk7InN0cmluZyI9PXR5cGVvZiBuP3QuZGVzdD1zdHJpbmdUb1BERlN0cmluZyhuLCEwKTpSbihuKSYmKHQuZGVzdD1uKX19fWZ1bmN0aW9uIGFkZENoaWxkcmVuKGUsdCl7aWYoZSBpbnN0YW5jZW9mIERpY3QpZT1lLmdldFJhd1ZhbHVlcygpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pZT1lLmRpY3QuZ2V0UmF3VmFsdWVzKCk7ZWxzZSBpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm47Zm9yKGNvbnN0IHIgb2YgZSkoKGE9cilpbnN0YW5jZW9mIFJlZnx8YSBpbnN0YW5jZW9mIERpY3R8fGEgaW5zdGFuY2VvZiBCYXNlU3RyZWFtfHxBcnJheS5pc0FycmF5KGEpKSYmdC5wdXNoKHIpO3ZhciBhfWNsYXNzIE9iamVjdExvYWRlcntyZWZTZXQ9bmV3IFJlZlNldDtjb25zdHJ1Y3RvcihlLHQsYSl7dGhpcy5kaWN0PWU7dGhpcy5rZXlzPXQ7dGhpcy54cmVmPWF9YXN5bmMgbG9hZCgpe2NvbnN0e2tleXM6ZSxkaWN0OnR9PXRoaXMsYT1bXTtmb3IoY29uc3QgciBvZiBlKXtjb25zdCBlPXQuZ2V0UmF3KHIpO3ZvaWQgMCE9PWUmJmEucHVzaChlKX1hd2FpdCB0aGlzLiNnZShhKTt0aGlzLnJlZlNldD1udWxsfWFzeW5jI2dlKGUpe2NvbnN0IHQ9W10sYT1bXTtmb3IoO2UubGVuZ3RoOyl7bGV0IHI9ZS5wb3AoKTtpZihyIGluc3RhbmNlb2YgUmVmKXtpZih0aGlzLnJlZlNldC5oYXMocikpY29udGludWU7dHJ5e3RoaXMucmVmU2V0LnB1dChyKTtyPXRoaXMueHJlZi5mZXRjaChyKX1jYXRjaChlKXtpZighKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbikpe3dhcm4oYE9iamVjdExvYWRlci4jd2FsayAtIHJlcXVlc3RpbmcgYWxsIGRhdGE6ICIke2V9Ii5gKTthd2FpdCB0aGlzLnhyZWYuc3RyZWFtLm1hbmFnZXIucmVxdWVzdEFsbENodW5rcygpO3JldHVybn10LnB1c2gocik7YS5wdXNoKHtiZWdpbjplLmJlZ2luLGVuZDplLmVuZH0pfX1pZihyIGluc3RhbmNlb2YgQmFzZVN0cmVhbSl7Y29uc3QgZT1yLmdldEJhc2VTdHJlYW1zKCk7aWYoZSl7bGV0IGk9ITE7Zm9yKGNvbnN0IHQgb2YgZSlpZighdC5pc0RhdGFMb2FkZWQpe2k9ITA7YS5wdXNoKHtiZWdpbjp0LnN0YXJ0LGVuZDp0LmVuZH0pfWkmJnQucHVzaChyKX19YWRkQ2hpbGRyZW4ocixlKX1pZihhLmxlbmd0aCl7YXdhaXQgdGhpcy54cmVmLnN0cmVhbS5tYW5hZ2VyLnJlcXVlc3RSYW5nZXMoYSk7Zm9yKGNvbnN0IGUgb2YgdCllIGluc3RhbmNlb2YgUmVmJiZ0aGlzLnJlZlNldC5yZW1vdmUoZSk7YXdhaXQgdGhpcy4jZ2UodCl9fXN0YXRpYyBhc3luYyBsb2FkKGUsdCxhKXtpZihhLnN0cmVhbS5pc0RhdGFMb2FkZWQpcmV0dXJuO2NvbnN0IHI9bmV3IE9iamVjdExvYWRlcihlLHQsYSk7YXdhaXQgci5sb2FkKCl9fWNvbnN0IE5uPVN5bWJvbCgpLEVuPVN5bWJvbCgpLFBuPVN5bWJvbCgpLExuPVN5bWJvbCgpLGpuPVN5bWJvbCgpLF9uPVN5bWJvbCgpLFVuPVN5bWJvbCgpLFhuPVN5bWJvbCgpLHFuPVN5bWJvbCgpLEhuPVN5bWJvbCgiY29udGVudCIpLFduPVN5bWJvbCgiZGF0YSIpLHpuPVN5bWJvbCgpLCRuPVN5bWJvbCgiZXh0cmEiKSxHbj1TeW1ib2woKSxWbj1TeW1ib2woKSxLbj1TeW1ib2woKSxKbj1TeW1ib2woKSxZbj1TeW1ib2woKSxabj1TeW1ib2woKSxRbj1TeW1ib2woKSxlcz1TeW1ib2woKSx0cz1TeW1ib2woKSxhcz1TeW1ib2woKSxycz1TeW1ib2woKSxpcz1TeW1ib2woKSxucz1TeW1ib2woKSxzcz1TeW1ib2woKSxvcz1TeW1ib2woKSxjcz1TeW1ib2woKSxscz1TeW1ib2woKSxocz1TeW1ib2woKSx1cz1TeW1ib2woKSxkcz1TeW1ib2woKSxmcz1TeW1ib2woKSxncz1TeW1ib2woKSxwcz1TeW1ib2woKSxtcz1TeW1ib2woKSxicz1TeW1ib2woKSx5cz1TeW1ib2woKSx3cz1TeW1ib2woKSx4cz1TeW1ib2woKSxTcz1TeW1ib2woKSxBcz1TeW1ib2woKSxrcz1TeW1ib2woKSxDcz1TeW1ib2woKSx2cz1TeW1ib2woIm5hbWVzcGFjZUlkIiksRnM9U3ltYm9sKCJub2RlTmFtZSIpLElzPVN5bWJvbCgpLFRzPVN5bWJvbCgpLE9zPVN5bWJvbCgpLE1zPVN5bWJvbCgpLERzPVN5bWJvbCgpLEJzPVN5bWJvbCgpLFJzPVN5bWJvbCgpLE5zPVN5bWJvbCgpLEVzPVN5bWJvbCgicm9vdCIpLExzPVN5bWJvbCgpLGpzPVN5bWJvbCgpLF9zPVN5bWJvbCgpLFVzPVN5bWJvbCgpLFhzPVN5bWJvbCgpLHFzPVN5bWJvbCgpLEhzPVN5bWJvbCgpLFdzPVN5bWJvbCgpLHpzPVN5bWJvbCgpLCRzPVN5bWJvbCgpLEdzPVN5bWJvbCgpLFZzPVN5bWJvbCgidWlkIiksS3M9U3ltYm9sKCksSnM9e2NvbmZpZzp7aWQ6MCxjaGVjazplPT5lLnN0YXJ0c1dpdGgoImh0dHA6Ly93d3cueGZhLm9yZy9zY2hlbWEveGNpLyIpfSxjb25uZWN0aW9uU2V0OntpZDoxLGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtY29ubmVjdGlvbi1zZXQvIil9LGRhdGFzZXRzOntpZDoyLGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtZGF0YS8iKX0sZm9ybTp7aWQ6MyxjaGVjazplPT5lLnN0YXJ0c1dpdGgoImh0dHA6Ly93d3cueGZhLm9yZy9zY2hlbWEveGZhLWZvcm0vIil9LGxvY2FsZVNldDp7aWQ6NCxjaGVjazplPT5lLnN0YXJ0c1dpdGgoImh0dHA6Ly93d3cueGZhLm9yZy9zY2hlbWEveGZhLWxvY2FsZS1zZXQvIil9LHBkZjp7aWQ6NSxjaGVjazplPT4iaHR0cDovL25zLmFkb2JlLmNvbS94ZHAvcGRmLyI9PT1lfSxzaWduYXR1cmU6e2lkOjYsY2hlY2s6ZT0+Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDkveG1sZHNpZyMiPT09ZX0sc291cmNlU2V0OntpZDo3LGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtc291cmNlLXNldC8iKX0sc3R5bGVzaGVldDp7aWQ6OCxjaGVjazplPT4iaHR0cDovL3d3dy53My5vcmcvMTk5OS9YU0wvVHJhbnNmb3JtIj09PWV9LHRlbXBsYXRlOntpZDo5LGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtdGVtcGxhdGUvIil9LHhkYzp7aWQ6MTAsY2hlY2s6ZT0+ZS5zdGFydHNXaXRoKCJodHRwOi8vd3d3LnhmYS5vcmcvc2NoZW1hL3hkYy8iKX0seGRwOntpZDoxMSxjaGVjazplPT4iaHR0cDovL25zLmFkb2JlLmNvbS94ZHAvIj09PWV9LHhmZGY6e2lkOjEyLGNoZWNrOmU9PiJodHRwOi8vbnMuYWRvYmUuY29tL3hmZGYvIj09PWV9LHhodG1sOntpZDoxMyxjaGVjazplPT4iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI9PT1lfSx4bXBtZXRhOntpZDoxNCxjaGVjazplPT4iaHR0cDovL25zLmFkb2JlLmNvbS94bXBtZXRhLyI9PT1lfX0sWXM9e3B0OmU9PmUsY206ZT0+ZS8yLjU0KjcyLG1tOmU9PmUvMjUuNCo3MixpbjplPT43MiplLHB4OmU9PmV9LFpzPS8oWystXT9cZCtcLj9cZCopKC4qKS87ZnVuY3Rpb24gc3RyaXBRdW90ZXMoZSl7cmV0dXJuIGUuc3RhcnRzV2l0aCgiJyIpfHxlLnN0YXJ0c1dpdGgoJyInKT9lLnNsaWNlKDEsLTEpOmV9ZnVuY3Rpb24gZ2V0SW50ZWdlcih7ZGF0YTplLGRlZmF1bHRWYWx1ZTp0LHZhbGlkYXRlOmF9KXtpZighZSlyZXR1cm4gdDtlPWUudHJpbSgpO2NvbnN0IHI9cGFyc2VJbnQoZSwxMCk7cmV0dXJuIWlzTmFOKHIpJiZhKHIpP3I6dH1mdW5jdGlvbiBnZXRGbG9hdCh7ZGF0YTplLGRlZmF1bHRWYWx1ZTp0LHZhbGlkYXRlOmF9KXtpZighZSlyZXR1cm4gdDtlPWUudHJpbSgpO2NvbnN0IHI9cGFyc2VGbG9hdChlKTtyZXR1cm4haXNOYU4ocikmJmEocik/cjp0fWZ1bmN0aW9uIGdldEtleXdvcmQoe2RhdGE6ZSxkZWZhdWx0VmFsdWU6dCx2YWxpZGF0ZTphfSl7cmV0dXJuIGUmJmEoZT1lLnRyaW0oKSk/ZTp0fWZ1bmN0aW9uIGdldFN0cmluZ09wdGlvbihlLHQpe3JldHVybiBnZXRLZXl3b3JkKHtkYXRhOmUsZGVmYXVsdFZhbHVlOnRbMF0sdmFsaWRhdGU6ZT0+dC5pbmNsdWRlcyhlKX0pfWZ1bmN0aW9uIGdldE1lYXN1cmVtZW50KGUsdD0iMCIpe3R8fD0iMCI7aWYoIWUpcmV0dXJuIGdldE1lYXN1cmVtZW50KHQpO2NvbnN0IGE9ZS50cmltKCkubWF0Y2goWnMpO2lmKCFhKXJldHVybiBnZXRNZWFzdXJlbWVudCh0KTtjb25zdFsscixpXT1hLG49cGFyc2VGbG9hdChyKTtpZihpc05hTihuKSlyZXR1cm4gZ2V0TWVhc3VyZW1lbnQodCk7aWYoMD09PW4pcmV0dXJuIDA7Y29uc3Qgcz1Zc1tpXTtyZXR1cm4gcz9zKG4pOm59ZnVuY3Rpb24gZ2V0UmF0aW8oZSl7aWYoIWUpcmV0dXJue251bToxLGRlbjoxfTtjb25zdCB0PWUuc3BsaXQoIjoiLDIpLm1hcCgoZT0+cGFyc2VGbG9hdChlLnRyaW0oKSkpKS5maWx0ZXIoKGU9PiFpc05hTihlKSkpOzE9PT10Lmxlbmd0aCYmdC5wdXNoKDEpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm57bnVtOjEsZGVuOjF9O2NvbnN0W2Escl09dDtyZXR1cm57bnVtOmEsZGVuOnJ9fWZ1bmN0aW9uIGdldFJlbGV2YW50KGUpe3JldHVybiBlP2UudHJpbSgpLnNwbGl0KC9ccysvKS5tYXAoKGU9Pih7ZXhjbHVkZWQ6Ii0iPT09ZVswXSx2aWV3bmFtZTplLnN1YnN0cmluZygxKX0pKSk6W119Y2xhc3MgSFRNTFJlc3VsdHtzdGF0aWMgZ2V0IEZBSUxVUkUoKXtyZXR1cm4gc2hhZG93KHRoaXMsIkZBSUxVUkUiLG5ldyBIVE1MUmVzdWx0KCExLG51bGwsbnVsbCxudWxsKSl9c3RhdGljIGdldCBFTVBUWSgpe3JldHVybiBzaGFkb3codGhpcywiRU1QVFkiLG5ldyBIVE1MUmVzdWx0KCEwLG51bGwsbnVsbCxudWxsKSl9Y29uc3RydWN0b3IoZSx0LGEscil7dGhpcy5zdWNjZXNzPWU7dGhpcy5odG1sPXQ7dGhpcy5iYm94PWE7dGhpcy5icmVha05vZGU9cn1pc0JyZWFrKCl7cmV0dXJuISF0aGlzLmJyZWFrTm9kZX1zdGF0aWMgYnJlYWtOb2RlKGUpe3JldHVybiBuZXcgSFRNTFJlc3VsdCghMSxudWxsLG51bGwsZSl9c3RhdGljIHN1Y2Nlc3MoZSx0PW51bGwpe3JldHVybiBuZXcgSFRNTFJlc3VsdCghMCxlLHQsbnVsbCl9fWNsYXNzIEZvbnRGaW5kZXJ7Y29uc3RydWN0b3IoZSl7dGhpcy5mb250cz1uZXcgTWFwO3RoaXMuY2FjaGU9bmV3IE1hcDt0aGlzLndhcm5lZD1uZXcgU2V0O3RoaXMuZGVmYXVsdEZvbnQ9bnVsbDt0aGlzLmFkZChlKX1hZGQoZSx0PW51bGwpe2Zvcihjb25zdCB0IG9mIGUpdGhpcy5hZGRQZGZGb250KHQpO2Zvcihjb25zdCBlIG9mIHRoaXMuZm9udHMudmFsdWVzKCkpZS5yZWd1bGFyfHwoZS5yZWd1bGFyPWUuaXRhbGljfHxlLmJvbGR8fGUuYm9sZGl0YWxpYyk7aWYoIXR8fDA9PT10LnNpemUpcmV0dXJuO2NvbnN0IGE9dGhpcy5mb250cy5nZXQoIlBkZkpTLUZhbGxiYWNrLVBkZkpTLVhGQSIpO2Zvcihjb25zdCBlIG9mIHQpdGhpcy5mb250cy5zZXQoZSxhKX1hZGRQZGZGb250KGUpe2NvbnN0IHQ9ZS5jc3NGb250SW5mbyxhPXQuZm9udEZhbWlseTtsZXQgcj10aGlzLmZvbnRzLmdldChhKTtpZighcil7cj1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuZm9udHMuc2V0KGEscik7dGhpcy5kZWZhdWx0Rm9udHx8KHRoaXMuZGVmYXVsdEZvbnQ9cil9bGV0IGk9IiI7Y29uc3Qgbj1wYXJzZUZsb2F0KHQuZm9udFdlaWdodCk7MCE9PXBhcnNlRmxvYXQodC5pdGFsaWNBbmdsZSk/aT1uPj03MDA/ImJvbGRpdGFsaWMiOiJpdGFsaWMiOm4+PTcwMCYmKGk9ImJvbGQiKTtpZighaSl7KGUubmFtZS5pbmNsdWRlcygiQm9sZCIpfHxlLnBzTmFtZT8uaW5jbHVkZXMoIkJvbGQiKSkmJihpPSJib2xkIik7KGUubmFtZS5pbmNsdWRlcygiSXRhbGljIil8fGUubmFtZS5lbmRzV2l0aCgiSXQiKXx8ZS5wc05hbWU/LmluY2x1ZGVzKCJJdGFsaWMiKXx8ZS5wc05hbWU/LmVuZHNXaXRoKCJJdCIpKSYmKGkrPSJpdGFsaWMiKX1pfHwoaT0icmVndWxhciIpO3JbaV09ZX1nZXREZWZhdWx0KCl7cmV0dXJuIHRoaXMuZGVmYXVsdEZvbnR9ZmluZChlLHQ9ITApe2xldCBhPXRoaXMuZm9udHMuZ2V0KGUpfHx0aGlzLmNhY2hlLmdldChlKTtpZihhKXJldHVybiBhO2NvbnN0IHI9Lyx8LXxffCB8Ym9sZGl0YWxpY3xib2xkfGl0YWxpY3xyZWd1bGFyfGl0L2dpO2xldCBpPWUucmVwbGFjZUFsbChyLCIiKTthPXRoaXMuZm9udHMuZ2V0KGkpO2lmKGEpe3RoaXMuY2FjaGUuc2V0KGUsYSk7cmV0dXJuIGF9aT1pLnRvTG93ZXJDYXNlKCk7Y29uc3Qgbj1bXTtmb3IoY29uc3RbZSx0XW9mIHRoaXMuZm9udHMuZW50cmllcygpKWUucmVwbGFjZUFsbChyLCIiKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoaSkmJm4ucHVzaCh0KTtpZigwPT09bi5sZW5ndGgpZm9yKGNvbnN0WyxlXW9mIHRoaXMuZm9udHMuZW50cmllcygpKWUucmVndWxhci5uYW1lPy5yZXBsYWNlQWxsKHIsIiIpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChpKSYmbi5wdXNoKGUpO2lmKDA9PT1uLmxlbmd0aCl7aT1pLnJlcGxhY2VBbGwoL3BzbXR8bXQvZ2ksIiIpO2Zvcihjb25zdFtlLHRdb2YgdGhpcy5mb250cy5lbnRyaWVzKCkpZS5yZXBsYWNlQWxsKHIsIiIpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChpKSYmbi5wdXNoKHQpfWlmKDA9PT1uLmxlbmd0aClmb3IoY29uc3QgZSBvZiB0aGlzLmZvbnRzLnZhbHVlcygpKWUucmVndWxhci5uYW1lPy5yZXBsYWNlQWxsKHIsIiIpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChpKSYmbi5wdXNoKGUpO2lmKG4ubGVuZ3RoPj0xKXsxIT09bi5sZW5ndGgmJnQmJndhcm4oYFhGQSAtIFRvbyBtYW55IGNob2ljZXMgdG8gZ3Vlc3MgdGhlIGNvcnJlY3QgZm9udDogJHtlfWApO3RoaXMuY2FjaGUuc2V0KGUsblswXSk7cmV0dXJuIG5bMF19aWYodCYmIXRoaXMud2FybmVkLmhhcyhlKSl7dGhpcy53YXJuZWQuYWRkKGUpO3dhcm4oYFhGQSAtIENhbm5vdCBmaW5kIHRoZSBmb250OiAke2V9YCl9cmV0dXJuIG51bGx9fWZ1bmN0aW9uIHNlbGVjdEZvbnQoZSx0KXtyZXR1cm4iaXRhbGljIj09PWUucG9zdHVyZT8iYm9sZCI9PT1lLndlaWdodD90LmJvbGRpdGFsaWM6dC5pdGFsaWM6ImJvbGQiPT09ZS53ZWlnaHQ/dC5ib2xkOnQucmVndWxhcn1jbGFzcyBGb250SW5mb3tjb25zdHJ1Y3RvcihlLHQsYSxyKXt0aGlzLmxpbmVIZWlnaHQ9YTt0aGlzLnBhcmFNYXJnaW49dHx8e3RvcDowLGJvdHRvbTowLGxlZnQ6MCxyaWdodDowfTtpZighZSl7W3RoaXMucGRmRm9udCx0aGlzLnhmYUZvbnRdPXRoaXMuZGVmYXVsdEZvbnQocik7cmV0dXJufXRoaXMueGZhRm9udD17dHlwZWZhY2U6ZS50eXBlZmFjZSxwb3N0dXJlOmUucG9zdHVyZSx3ZWlnaHQ6ZS53ZWlnaHQsc2l6ZTplLnNpemUsbGV0dGVyU3BhY2luZzplLmxldHRlclNwYWNpbmd9O2NvbnN0IGk9ci5maW5kKGUudHlwZWZhY2UpO2lmKGkpe3RoaXMucGRmRm9udD1zZWxlY3RGb250KGUsaSk7dGhpcy5wZGZGb250fHwoW3RoaXMucGRmRm9udCx0aGlzLnhmYUZvbnRdPXRoaXMuZGVmYXVsdEZvbnQocikpfWVsc2VbdGhpcy5wZGZGb250LHRoaXMueGZhRm9udF09dGhpcy5kZWZhdWx0Rm9udChyKX1kZWZhdWx0Rm9udChlKXtjb25zdCB0PWUuZmluZCgiSGVsdmV0aWNhIiwhMSl8fGUuZmluZCgiTXlyaWFkIFBybyIsITEpfHxlLmZpbmQoIkFyaWFsIiwhMSl8fGUuZ2V0RGVmYXVsdCgpO2lmKHQ/LnJlZ3VsYXIpe2NvbnN0IGU9dC5yZWd1bGFyO3JldHVybltlLHt0eXBlZmFjZTplLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHkscG9zdHVyZToibm9ybWFsIix3ZWlnaHQ6Im5vcm1hbCIsc2l6ZToxMCxsZXR0ZXJTcGFjaW5nOjB9XX1yZXR1cm5bbnVsbCx7dHlwZWZhY2U6IkNvdXJpZXIiLHBvc3R1cmU6Im5vcm1hbCIsd2VpZ2h0OiJub3JtYWwiLHNpemU6MTAsbGV0dGVyU3BhY2luZzowfV19fWNsYXNzIEZvbnRTZWxlY3Rvcntjb25zdHJ1Y3RvcihlLHQsYSxyKXt0aGlzLmZvbnRGaW5kZXI9cjt0aGlzLnN0YWNrPVtuZXcgRm9udEluZm8oZSx0LGEscildfXB1c2hEYXRhKGUsdCxhKXtjb25zdCByPXRoaXMuc3RhY2suYXQoLTEpO2Zvcihjb25zdCB0IG9mWyJ0eXBlZmFjZSIsInBvc3R1cmUiLCJ3ZWlnaHQiLCJzaXplIiwibGV0dGVyU3BhY2luZyJdKWVbdF18fChlW3RdPXIueGZhRm9udFt0XSk7Zm9yKGNvbnN0IGUgb2ZbInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCJdKWlzTmFOKHRbZV0pJiYodFtlXT1yLnBhcmFNYXJnaW5bZV0pO2NvbnN0IGk9bmV3IEZvbnRJbmZvKGUsdCxhfHxyLmxpbmVIZWlnaHQsdGhpcy5mb250RmluZGVyKTtpLnBkZkZvbnR8fChpLnBkZkZvbnQ9ci5wZGZGb250KTt0aGlzLnN0YWNrLnB1c2goaSl9cG9wRm9udCgpe3RoaXMuc3RhY2sucG9wKCl9dG9wRm9udCgpe3JldHVybiB0aGlzLnN0YWNrLmF0KC0xKX19Y2xhc3MgVGV4dE1lYXN1cmV7Y29uc3RydWN0b3IoZSx0LGEscil7dGhpcy5nbHlwaHM9W107dGhpcy5mb250U2VsZWN0b3I9bmV3IEZvbnRTZWxlY3RvcihlLHQsYSxyKTt0aGlzLmV4dHJhSGVpZ2h0PTB9cHVzaERhdGEoZSx0LGEpe3RoaXMuZm9udFNlbGVjdG9yLnB1c2hEYXRhKGUsdCxhKX1wb3BGb250KGUpe3JldHVybiB0aGlzLmZvbnRTZWxlY3Rvci5wb3BGb250KCl9YWRkUGFyYSgpe2NvbnN0IGU9dGhpcy5mb250U2VsZWN0b3IudG9wRm9udCgpO3RoaXMuZXh0cmFIZWlnaHQrPWUucGFyYU1hcmdpbi50b3ArZS5wYXJhTWFyZ2luLmJvdHRvbX1hZGRTdHJpbmcoZSl7aWYoIWUpcmV0dXJuO2NvbnN0IHQ9dGhpcy5mb250U2VsZWN0b3IudG9wRm9udCgpLGE9dC54ZmFGb250LnNpemU7aWYodC5wZGZGb250KXtjb25zdCByPXQueGZhRm9udC5sZXR0ZXJTcGFjaW5nLGk9dC5wZGZGb250LG49aS5saW5lSGVpZ2h0fHwxLjIscz10LmxpbmVIZWlnaHR8fE1hdGgubWF4KDEuMixuKSphLG89bi0odm9pZCAwPT09aS5saW5lR2FwPy4yOmkubGluZUdhcCksYz1NYXRoLm1heCgxLG8pKmEsbD1hLzFlMyxoPWkuZGVmYXVsdFdpZHRofHxpLmNoYXJzVG9HbHlwaHMoIiAiKVswXS53aWR0aDtmb3IoY29uc3QgdCBvZiBlLnNwbGl0KC9bXHUyMDI5XG5dLykpe2NvbnN0IGU9aS5lbmNvZGVTdHJpbmcodCkuam9pbigiIiksYT1pLmNoYXJzVG9HbHlwaHMoZSk7Zm9yKGNvbnN0IGUgb2YgYSl7Y29uc3QgdD1lLndpZHRofHxoO3RoaXMuZ2x5cGhzLnB1c2goW3QqbCtyLHMsYyxlLnVuaWNvZGUsITFdKX10aGlzLmdseXBocy5wdXNoKFswLDAsMCwiXG4iLCEwXSl9dGhpcy5nbHlwaHMucG9wKCl9ZWxzZXtmb3IoY29uc3QgdCBvZiBlLnNwbGl0KC9bXHUyMDI5XG5dLykpe2Zvcihjb25zdCBlIG9mIHQuc3BsaXQoIiIpKXRoaXMuZ2x5cGhzLnB1c2goW2EsMS4yKmEsYSxlLCExXSk7dGhpcy5nbHlwaHMucHVzaChbMCwwLDAsIlxuIiwhMF0pfXRoaXMuZ2x5cGhzLnBvcCgpfX1jb21wdXRlKGUpe2xldCB0PS0xLGE9MCxyPTAsaT0wLG49MCxzPTAsbz0hMSxjPSEwO2ZvcihsZXQgbD0wLGg9dGhpcy5nbHlwaHMubGVuZ3RoO2w8aDtsKyspe2NvbnN0W2gsdSxkLGYsZ109dGhpcy5nbHlwaHNbbF0scD0iICI9PT1mLG09Yz9kOnU7aWYoZyl7cj1NYXRoLm1heChyLG4pO249MDtpKz1zO3M9bTt0PS0xO2E9MDtjPSExfWVsc2UgaWYocClpZihuK2g+ZSl7cj1NYXRoLm1heChyLG4pO249MDtpKz1zO3M9bTt0PS0xO2E9MDtvPSEwO2M9ITF9ZWxzZXtzPU1hdGgubWF4KG0scyk7YT1uO24rPWg7dD1sfWVsc2UgaWYobitoPmUpe2krPXM7cz1tO2lmKC0xIT09dCl7bD10O3I9TWF0aC5tYXgocixhKTtuPTA7dD0tMTthPTB9ZWxzZXtyPU1hdGgubWF4KHIsbik7bj1ofW89ITA7Yz0hMX1lbHNle24rPWg7cz1NYXRoLm1heChtLHMpfX1yPU1hdGgubWF4KHIsbik7aSs9cyt0aGlzLmV4dHJhSGVpZ2h0O3JldHVybnt3aWR0aDoxLjAyKnIsaGVpZ2h0OmksaXNCcm9rZW46b319fWNvbnN0IFFzPS9eW14uW10rLyxlbz0vXlteXF1dKy8sdG89MCxhbz0xLHJvPTIsaW89Myxubz00LHNvPW5ldyBNYXAoW1siJGRhdGEiLChlLHQpPT5lLmRhdGFzZXRzP2UuZGF0YXNldHMuZGF0YTplXSxbIiRyZWNvcmQiLChlLHQpPT4oZS5kYXRhc2V0cz9lLmRhdGFzZXRzLmRhdGE6ZSlbaXNdKClbMF1dLFsiJHRlbXBsYXRlIiwoZSx0KT0+ZS50ZW1wbGF0ZV0sWyIkY29ubmVjdGlvblNldCIsKGUsdCk9PmUuY29ubmVjdGlvblNldF0sWyIkZm9ybSIsKGUsdCk9PmUuZm9ybV0sWyIkbGF5b3V0IiwoZSx0KT0+ZS5sYXlvdXRdLFsiJGhvc3QiLChlLHQpPT5lLmhvc3RdLFsiJGRhdGFXaW5kb3ciLChlLHQpPT5lLmRhdGFXaW5kb3ddLFsiJGV2ZW50IiwoZSx0KT0+ZS5ldmVudF0sWyIhIiwoZSx0KT0+ZS5kYXRhc2V0c10sWyIkeGZhIiwoZSx0KT0+ZV0sWyJ4ZmEiLChlLHQpPT5lXSxbIiQiLChlLHQpPT50XV0pLG9vPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihlLHQsYT0hMCl7bGV0IHI9ZS5tYXRjaChRcyk7aWYoIXIpcmV0dXJuIG51bGw7bGV0W2ldPXI7Y29uc3Qgbj1be25hbWU6aSxjYWNoZU5hbWU6Ii4iK2ksaW5kZXg6MCxqczpudWxsLGZvcm1DYWxjOm51bGwsb3BlcmF0b3I6dG99XTtsZXQgcz1pLmxlbmd0aDtmb3IoO3M8ZS5sZW5ndGg7KXtjb25zdCBjPXM7aWYoIlsiPT09ZS5jaGFyQXQocysrKSl7cj1lLnNsaWNlKHMpLm1hdGNoKGVvKTtpZighcil7d2FybigiWEZBIC0gSW52YWxpZCBpbmRleCBpbiBTT00gZXhwcmVzc2lvbiIpO3JldHVybiBudWxsfW4uYXQoLTEpLmluZGV4PSIqIj09PShvPShvPXJbMF0pLnRyaW0oKSk/MS8wOnBhcnNlSW50KG8sMTApfHwwO3MrPXJbMF0ubGVuZ3RoKzE7Y29udGludWV9bGV0IGw7c3dpdGNoKGUuY2hhckF0KHMpKXtjYXNlIi4iOmlmKCF0KXJldHVybiBudWxsO3MrKztsPWFvO2JyZWFrO2Nhc2UiIyI6cysrO2w9cm87YnJlYWs7Y2FzZSJbIjppZihhKXt3YXJuKCJYRkEgLSBTT00gZXhwcmVzc2lvbiBjb250YWlucyBhIEZvcm1DYWxjIHN1YmV4cHJlc3Npb24gd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBmb3Igbm93LiIpO3JldHVybiBudWxsfWw9aW87YnJlYWs7Y2FzZSIoIjppZihhKXt3YXJuKCJYRkEgLSBTT00gZXhwcmVzc2lvbiBjb250YWlucyBhIEphdmFTY3JpcHQgc3ViZXhwcmVzc2lvbiB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGZvciBub3cuIik7cmV0dXJuIG51bGx9bD1ubzticmVhaztkZWZhdWx0Omw9dG99cj1lLnNsaWNlKHMpLm1hdGNoKFFzKTtpZighcilicmVhaztbaV09cjtzKz1pLmxlbmd0aDtuLnB1c2goe25hbWU6aSxjYWNoZU5hbWU6ZS5zbGljZShjLHMpLG9wZXJhdG9yOmwsaW5kZXg6MCxqczpudWxsLGZvcm1DYWxjOm51bGx9KX12YXIgbztyZXR1cm4gbn1mdW5jdGlvbiBzZWFyY2hOb2RlKGUsdCxhLHI9ITAsaT0hMCl7Y29uc3Qgbj1wYXJzZUV4cHJlc3Npb24oYSxyKTtpZighbilyZXR1cm4gbnVsbDtjb25zdCBzPXNvLmdldChuWzBdLm5hbWUpO2xldCBvLGM9MDtpZihzKXtvPSEwO2U9W3MoZSx0KV07Yz0xfWVsc2V7bz1udWxsPT09dDtlPVt0fHxlXX1mb3IobGV0IGE9bi5sZW5ndGg7YzxhO2MrKyl7Y29uc3R7bmFtZTphLGNhY2hlTmFtZTpyLG9wZXJhdG9yOnMsaW5kZXg6bH09bltjXSxoPVtdO2Zvcihjb25zdCB0IG9mIGUpe2lmKCF0LmlzWEZBT2JqZWN0KWNvbnRpbnVlO2xldCBlLG47aWYoaSl7bj1vby5nZXQodCk7aWYoIW4pe249bmV3IE1hcDtvby5zZXQodCxuKX1lPW4uZ2V0KHIpfWlmKCFlKXtzd2l0Y2gocyl7Y2FzZSB0bzplPXRbUW5dKGEsITEpO2JyZWFrO2Nhc2UgYW86ZT10W1FuXShhLCEwKTticmVhaztjYXNlIHJvOmU9dFtabl0oYSk7ZT1lLmlzWEZBT2JqZWN0QXJyYXk/ZS5jaGlsZHJlbjpbZV19aSYmbi5zZXQocixlKX1lLmxlbmd0aD4wJiZoLnB1c2goZSl9aWYoMCE9PWgubGVuZ3RofHxvfHwwIT09YyllPWlzRmluaXRlKGwpP2guZmlsdGVyKChlPT5sPGUubGVuZ3RoKSkubWFwKChlPT5lW2xdKSk6aC5mbGF0KCk7ZWxzZXtjb25zdCBhPXRbY3NdKCk7aWYoISh0PWEpKXJldHVybiBudWxsO2M9LTE7ZT1bdF19fXJldHVybiAwPT09ZS5sZW5ndGg/bnVsbDplfWZ1bmN0aW9uIGNyZWF0ZURhdGFOb2RlKGUsdCxhKXtjb25zdCByPXBhcnNlRXhwcmVzc2lvbihhKTtpZighcilyZXR1cm4gbnVsbDtpZihyLnNvbWUoKGU9PmUub3BlcmF0b3I9PT1hbykpKXJldHVybiBudWxsO2NvbnN0IGk9c28uZ2V0KHJbMF0ubmFtZSk7bGV0IG49MDtpZihpKXtlPWkoZSx0KTtuPTF9ZWxzZSBlPXR8fGU7Zm9yKGxldCB0PXIubGVuZ3RoO248dDtuKyspe2NvbnN0e25hbWU6dCxvcGVyYXRvcjphLGluZGV4Oml9PXJbbl07aWYoIWlzRmluaXRlKGkpKXtyW25dLmluZGV4PTA7cmV0dXJuIGUuY3JlYXRlTm9kZXMoci5zbGljZShuKSl9bGV0IHM7c3dpdGNoKGEpe2Nhc2UgdG86cz1lW1FuXSh0LCExKTticmVhaztjYXNlIGFvOnM9ZVtRbl0odCwhMCk7YnJlYWs7Y2FzZSBybzpzPWVbWm5dKHQpO3M9cy5pc1hGQU9iamVjdEFycmF5P3MuY2hpbGRyZW46W3NdfWlmKDA9PT1zLmxlbmd0aClyZXR1cm4gZS5jcmVhdGVOb2RlcyhyLnNsaWNlKG4pKTtpZighKGk8cy5sZW5ndGgpKXtyW25dLmluZGV4PWktcy5sZW5ndGg7cmV0dXJuIGUuY3JlYXRlTm9kZXMoci5zbGljZShuKSl9e2NvbnN0IHQ9c1tpXTtpZighdC5pc1hGQU9iamVjdCl7d2FybigiWEZBIC0gQ2Fubm90IGNyZWF0ZSBhIG5vZGUuIik7cmV0dXJuIG51bGx9ZT10fX1yZXR1cm4gbnVsbH1jb25zdCBjbz1TeW1ib2woKSxsbz1TeW1ib2woKSxobz1TeW1ib2woKSx1bz1TeW1ib2woIl9jaGlsZHJlbiIpLGZvPVN5bWJvbCgpLGdvPVN5bWJvbCgpLHBvPVN5bWJvbCgpLG1vPVN5bWJvbCgpLGJvPVN5bWJvbCgpLHlvPVN5bWJvbCgpLHdvPVN5bWJvbCgpLHhvPVN5bWJvbCgpLFNvPVN5bWJvbCgpLEFvPVN5bWJvbCgicGFyZW50Iiksa289U3ltYm9sKCksQ289U3ltYm9sKCksdm89U3ltYm9sKCk7bGV0IEZvPTA7Y29uc3QgSW89SnMuZGF0YXNldHMuaWQ7Y2xhc3MgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUsdCxhPSExKXt0aGlzW3ZzXT1lO3RoaXNbRnNdPXQ7dGhpc1t3b109YTt0aGlzW0FvXT1udWxsO3RoaXNbdW9dPVtdO3RoaXNbVnNdPWAke3R9JHtGbysrfWA7dGhpc1toc109bnVsbH1nZXQgaXNYRkFPYmplY3QoKXtyZXR1cm4hMH1nZXQgaXNYRkFPYmplY3RBcnJheSgpe3JldHVybiExfWNyZWF0ZU5vZGVzKGUpe2xldCB0PXRoaXMsYT1udWxsO2Zvcihjb25zdHtuYW1lOnIsaW5kZXg6aX1vZiBlKXtmb3IobGV0IGU9MCxuPWlzRmluaXRlKGkpP2k6MDtlPD1uO2UrKyl7Y29uc3QgZT10W3ZzXT09PUlvPy0xOnRbdnNdO2E9bmV3IFhtbE9iamVjdChlLHIpO3RbUG5dKGEpfXQ9YX1yZXR1cm4gYX1bVHNdKGUpe2lmKCF0aGlzW3dvXXx8IXRoaXNbT3NdKGUpKXJldHVybiExO2NvbnN0IHQ9ZVtGc10sYT10aGlzW3RdO2lmKCEoYSBpbnN0YW5jZW9mIFhGQU9iamVjdEFycmF5KSl7bnVsbCE9PWEmJnRoaXNbTnNdKGEpO3RoaXNbdF09ZTt0aGlzW1BuXShlKTtyZXR1cm4hMH1pZihhLnB1c2goZSkpe3RoaXNbUG5dKGUpO3JldHVybiEwfWxldCByPSIiO3RoaXMuaWQ/cj1gIChpZDogJHt0aGlzLmlkfSlgOnRoaXMubmFtZSYmKHI9YCAobmFtZTogJHt0aGlzLm5hbWV9ICR7dGhpcy5oLnZhbHVlfSlgKTt3YXJuKGBYRkEgLSBub2RlICIke3RoaXNbRnNdfSIke3J9IGhhcyBhbHJlYWR5IGVub3VnaCAiJHt0fSIhYCk7cmV0dXJuITF9W09zXShlKXtyZXR1cm4gdGhpcy5oYXNPd25Qcm9wZXJ0eShlW0ZzXSkmJmVbdnNdPT09dGhpc1t2c119W3dzXSgpe3JldHVybiExfVtObl0oKXtyZXR1cm4hMX1bcHNdKCl7cmV0dXJuITF9W21zXSgpe3JldHVybiExfVtCc10oKXt0aGlzLnBhcmEmJnRoaXNbbHNdKClbJG5dLnBhcmFTdGFjay5wb3AoKX1bUnNdKCl7dGhpc1tsc10oKVskbl0ucGFyYVN0YWNrLnB1c2godGhpcy5wYXJhKX1bX3NdKGUpe3RoaXMuaWQmJnRoaXNbdnNdPT09SnMudGVtcGxhdGUuaWQmJmUuc2V0KHRoaXMuaWQsdGhpcyl9W2xzXSgpe3JldHVybiB0aGlzW2hzXS50ZW1wbGF0ZX1beHNdKCl7cmV0dXJuITF9W1NzXSgpe3JldHVybiExfVtQbl0oZSl7ZVtBb109dGhpczt0aGlzW3VvXS5wdXNoKGUpOyFlW2hzXSYmdGhpc1toc10mJihlW2hzXT10aGlzW2hzXSl9W05zXShlKXtjb25zdCB0PXRoaXNbdW9dLmluZGV4T2YoZSk7dGhpc1t1b10uc3BsaWNlKHQsMSl9W3VzXSgpe3JldHVybiB0aGlzLmhhc093blByb3BlcnR5KCJ2YWx1ZSIpfVtYc10oZSl7fVtNc10oZSl7fVtHbl0oKXt9W2puXShlKXtkZWxldGUgdGhpc1t3b107aWYodGhpc1tVbl0pe2UuY2xlYW4odGhpc1tVbl0pO2RlbGV0ZSB0aGlzW1VuXX19W2ZzXShlKXtyZXR1cm4gdGhpc1t1b10uaW5kZXhPZihlKX1bZ3NdKGUsdCl7dFtBb109dGhpczt0aGlzW3VvXS5zcGxpY2UoZSwwLHQpOyF0W2hzXSYmdGhpc1toc10mJih0W2hzXT10aGlzW2hzXSl9W0FzXSgpe3JldHVybiF0aGlzLm5hbWV9W0NzXSgpe3JldHVybiIifVtIc10oKXtyZXR1cm4gMD09PXRoaXNbdW9dLmxlbmd0aD90aGlzW0huXTp0aGlzW3VvXS5tYXAoKGU9PmVbSHNdKCkpKS5qb2luKCIiKX1nZXRbaG9dKCl7Y29uc3QgZT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7aWYoIWUuX2F0dHJpYnV0ZXMpe2NvbnN0IHQ9ZS5fYXR0cmlidXRlcz1uZXcgU2V0O2Zvcihjb25zdCBlIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKXtpZihudWxsPT09dGhpc1tlXXx8dGhpc1tlXWluc3RhbmNlb2YgWEZBT2JqZWN0fHx0aGlzW2VdaW5zdGFuY2VvZiBYRkFPYmplY3RBcnJheSlicmVhazt0LmFkZChlKX19cmV0dXJuIHNoYWRvdyh0aGlzLGhvLGUuX2F0dHJpYnV0ZXMpfVt5c10oZSl7bGV0IHQ9dGhpcztmb3IoO3Q7KXtpZih0PT09ZSlyZXR1cm4hMDt0PXRbY3NdKCl9cmV0dXJuITF9W2NzXSgpe3JldHVybiB0aGlzW0FvXX1bb3NdKCl7cmV0dXJuIHRoaXNbY3NdKCl9W2lzXShlPW51bGwpe3JldHVybiBlP3RoaXNbZV06dGhpc1t1b119W3puXSgpe2NvbnN0IGU9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzW0huXSYmKGUuJGNvbnRlbnQ9dGhpc1tIbl0pO2Zvcihjb25zdCB0IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKXtjb25zdCBhPXRoaXNbdF07bnVsbCE9PWEmJihhIGluc3RhbmNlb2YgWEZBT2JqZWN0P2VbdF09YVt6bl0oKTphIGluc3RhbmNlb2YgWEZBT2JqZWN0QXJyYXk/YS5pc0VtcHR5KCl8fChlW3RdPWEuZHVtcCgpKTplW3RdPWEpfXJldHVybiBlfVtHc10oKXtyZXR1cm4gbnVsbH1benNdKCl7cmV0dXJuIEhUTUxSZXN1bHQuRU1QVFl9Kltuc10oKXtmb3IoY29uc3QgZSBvZiB0aGlzW2lzXSgpKXlpZWxkIGV9Klttb10oZSx0KXtmb3IoY29uc3QgYSBvZiB0aGlzW25zXSgpKWlmKCFlfHx0PT09ZS5oYXMoYVtGc10pKXtjb25zdCBlPXRoaXNbWW5dKCksdD1hW3pzXShlKTt0LnN1Y2Nlc3N8fCh0aGlzWyRuXS5mYWlsaW5nTm9kZT1hKTt5aWVsZCB0fX1bVm5dKCl7cmV0dXJuIG51bGx9W0VuXShlLHQpe3RoaXNbJG5dLmNoaWxkcmVuLnB1c2goZSl9W1luXSgpe31bTG5dKHtmaWx0ZXI6ZT1udWxsLGluY2x1ZGU6dD0hMH0pe2lmKHRoaXNbJG5dLmdlbmVyYXRvcil7Y29uc3QgZT10aGlzW1luXSgpLHQ9dGhpc1skbl0uZmFpbGluZ05vZGVbenNdKGUpO2lmKCF0LnN1Y2Nlc3MpcmV0dXJuIHQ7dC5odG1sJiZ0aGlzW0VuXSh0Lmh0bWwsdC5iYm94KTtkZWxldGUgdGhpc1skbl0uZmFpbGluZ05vZGV9ZWxzZSB0aGlzWyRuXS5nZW5lcmF0b3I9dGhpc1ttb10oZSx0KTtmb3IoOzspe2NvbnN0IGU9dGhpc1skbl0uZ2VuZXJhdG9yLm5leHQoKTtpZihlLmRvbmUpYnJlYWs7Y29uc3QgdD1lLnZhbHVlO2lmKCF0LnN1Y2Nlc3MpcmV0dXJuIHQ7dC5odG1sJiZ0aGlzW0VuXSh0Lmh0bWwsdC5iYm94KX10aGlzWyRuXS5nZW5lcmF0b3I9bnVsbDtyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWX1bVXNdKGUpe3RoaXNbQ29dPW5ldyBTZXQoT2JqZWN0LmtleXMoZSkpfVt5b10oZSl7Y29uc3QgdD10aGlzW2hvXSxhPXRoaXNbQ29dO3JldHVyblsuLi5lXS5maWx0ZXIoKGU9PnQuaGFzKGUpJiYhYS5oYXMoZSkpKX1bTHNdKGUsdD1uZXcgU2V0KXtmb3IoY29uc3QgYSBvZiB0aGlzW3VvXSlhW2tvXShlLHQpfVtrb10oZSx0KXtjb25zdCBhPXRoaXNbYm9dKGUsdCk7YT90aGlzW2NvXShhLGUsdCk6dGhpc1tMc10oZSx0KX1bYm9dKGUsdCl7Y29uc3R7dXNlOmEsdXNlaHJlZjpyfT10aGlzO2lmKCFhJiYhcilyZXR1cm4gbnVsbDtsZXQgaT1udWxsLG49bnVsbCxzPW51bGwsbz1hO2lmKHIpe289cjtyLnN0YXJ0c1dpdGgoIiNzb20oIikmJnIuZW5kc1dpdGgoIikiKT9uPXIuc2xpY2UoNSwtMSk6ci5zdGFydHNXaXRoKCIuI3NvbSgiKSYmci5lbmRzV2l0aCgiKSIpP249ci5zbGljZSg2LC0xKTpyLnN0YXJ0c1dpdGgoIiMiKT9zPXIuc2xpY2UoMSk6ci5zdGFydHNXaXRoKCIuIyIpJiYocz1yLnNsaWNlKDIpKX1lbHNlIGEuc3RhcnRzV2l0aCgiIyIpP3M9YS5zbGljZSgxKTpuPWE7dGhpcy51c2U9dGhpcy51c2VocmVmPSIiO2lmKHMpaT1lLmdldChzKTtlbHNle2k9c2VhcmNoTm9kZShlLmdldChFcyksdGhpcyxuLCEwLCExKTtpJiYoaT1pWzBdKX1pZighaSl7d2FybihgWEZBIC0gSW52YWxpZCBwcm90b3R5cGUgcmVmZXJlbmNlOiAke299LmApO3JldHVybiBudWxsfWlmKGlbRnNdIT09dGhpc1tGc10pe3dhcm4oYFhGQSAtIEluY29tcGF0aWJsZSBwcm90b3R5cGU6ICR7aVtGc119ICE9PSAke3RoaXNbRnNdfS5gKTtyZXR1cm4gbnVsbH1pZih0LmhhcyhpKSl7d2FybigiWEZBIC0gQ3ljbGUgZGV0ZWN0ZWQgaW4gcHJvdG90eXBlcyB1c2UuIik7cmV0dXJuIG51bGx9dC5hZGQoaSk7Y29uc3QgYz1pW2JvXShlLHQpO2MmJmlbY29dKGMsZSx0KTtpW0xzXShlLHQpO3QuZGVsZXRlKGkpO3JldHVybiBpfVtjb10oZSx0LGEpe2lmKGEuaGFzKGUpKXt3YXJuKCJYRkEgLSBDeWNsZSBkZXRlY3RlZCBpbiBwcm90b3R5cGVzIHVzZS4iKTtyZXR1cm59IXRoaXNbSG5dJiZlW0huXSYmKHRoaXNbSG5dPWVbSG5dKTtuZXcgU2V0KGEpLmFkZChlKTtmb3IoY29uc3QgdCBvZiB0aGlzW3lvXShlW0NvXSkpe3RoaXNbdF09ZVt0XTt0aGlzW0NvXSYmdGhpc1tDb10uYWRkKHQpfWZvcihjb25zdCByIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKXtpZih0aGlzW2hvXS5oYXMocikpY29udGludWU7Y29uc3QgaT10aGlzW3JdLG49ZVtyXTtpZihpIGluc3RhbmNlb2YgWEZBT2JqZWN0QXJyYXkpe2Zvcihjb25zdCBlIG9mIGlbdW9dKWVba29dKHQsYSk7Zm9yKGxldCByPWlbdW9dLmxlbmd0aCxzPW5bdW9dLmxlbmd0aDtyPHM7cisrKXtjb25zdCBuPWVbdW9dW3JdW1huXSgpO2lmKCFpLnB1c2gobikpYnJlYWs7bltBb109dGhpczt0aGlzW3VvXS5wdXNoKG4pO25ba29dKHQsYSl9fWVsc2UgaWYobnVsbD09PWkpe2lmKG51bGwhPT1uKXtjb25zdCBlPW5bWG5dKCk7ZVtBb109dGhpczt0aGlzW3JdPWU7dGhpc1t1b10ucHVzaChlKTtlW2tvXSh0LGEpfX1lbHNle2lbTHNdKHQsYSk7biYmaVtjb10obix0LGEpfX19c3RhdGljW2ZvXShlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT9lLm1hcCgoZT0+WEZBT2JqZWN0W2ZvXShlKSkpOiJvYmplY3QiPT10eXBlb2YgZSYmbnVsbCE9PWU/T2JqZWN0LmFzc2lnbih7fSxlKTplfVtYbl0oKXtjb25zdCBlPU9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtmb3IoY29uc3QgdCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRoaXMpKXRyeXtlW3RdPXRoaXNbdF19Y2F0Y2h7c2hhZG93KGUsdCx0aGlzW3RdKX1lW1ZzXT1gJHtlW0ZzXX0ke0ZvKyt9YDtlW3VvXT1bXTtmb3IoY29uc3QgdCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7aWYodGhpc1tob10uaGFzKHQpKXtlW3RdPVhGQU9iamVjdFtmb10odGhpc1t0XSk7Y29udGludWV9Y29uc3QgYT10aGlzW3RdO2VbdF09YSBpbnN0YW5jZW9mIFhGQU9iamVjdEFycmF5P25ldyBYRkFPYmplY3RBcnJheShhW3hvXSk6bnVsbH1mb3IoY29uc3QgdCBvZiB0aGlzW3VvXSl7Y29uc3QgYT10W0ZzXSxyPXRbWG5dKCk7ZVt1b10ucHVzaChyKTtyW0FvXT1lO251bGw9PT1lW2FdP2VbYV09cjplW2FdW3VvXS5wdXNoKHIpfXJldHVybiBlfVtpc10oZT1udWxsKXtyZXR1cm4gZT90aGlzW3VvXS5maWx0ZXIoKHQ9PnRbRnNdPT09ZSkpOnRoaXNbdW9dfVtabl0oZSl7cmV0dXJuIHRoaXNbZV19W1FuXShlLHQsYT0hMCl7cmV0dXJuIEFycmF5LmZyb20odGhpc1tlc10oZSx0LGEpKX0qW2VzXShlLHQsYT0hMCl7aWYoInBhcmVudCIhPT1lKXtmb3IoY29uc3QgYSBvZiB0aGlzW3VvXSl7YVtGc109PT1lJiYoeWllbGQgYSk7YS5uYW1lPT09ZSYmKHlpZWxkIGEpOyh0fHxhW0FzXSgpKSYmKHlpZWxkKmFbZXNdKGUsdCwhMSkpfWEmJnRoaXNbaG9dLmhhcyhlKSYmKHlpZWxkIG5ldyBYRkFBdHRyaWJ1dGUodGhpcyxlLHRoaXNbZV0pKX1lbHNlIHlpZWxkIHRoaXNbQW9dfX1jbGFzcyBYRkFPYmplY3RBcnJheXtjb25zdHJ1Y3RvcihlPTEvMCl7dGhpc1t4b109ZTt0aGlzW3VvXT1bXX1nZXQgaXNYRkFPYmplY3QoKXtyZXR1cm4hMX1nZXQgaXNYRkFPYmplY3RBcnJheSgpe3JldHVybiEwfXB1c2goZSl7aWYodGhpc1t1b10ubGVuZ3RoPD10aGlzW3hvXSl7dGhpc1t1b10ucHVzaChlKTtyZXR1cm4hMH13YXJuKGBYRkEgLSBub2RlICIke2VbRnNdfSIgYWNjZXB0cyBubyBtb3JlIHRoYW4gJHt0aGlzW3hvXX0gY2hpbGRyZW5gKTtyZXR1cm4hMX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzW3VvXS5sZW5ndGh9ZHVtcCgpe3JldHVybiAxPT09dGhpc1t1b10ubGVuZ3RoP3RoaXNbdW9dWzBdW3puXSgpOnRoaXNbdW9dLm1hcCgoZT0+ZVt6bl0oKSkpfVtYbl0oKXtjb25zdCBlPW5ldyBYRkFPYmplY3RBcnJheSh0aGlzW3hvXSk7ZVt1b109dGhpc1t1b10ubWFwKChlPT5lW1huXSgpKSk7cmV0dXJuIGV9Z2V0IGNoaWxkcmVuKCl7cmV0dXJuIHRoaXNbdW9dfWNsZWFyKCl7dGhpc1t1b10ubGVuZ3RoPTB9fWNsYXNzIFhGQUF0dHJpYnV0ZXtjb25zdHJ1Y3RvcihlLHQsYSl7dGhpc1tBb109ZTt0aGlzW0ZzXT10O3RoaXNbSG5dPWE7dGhpc1txbl09ITE7dGhpc1tWc109ImF0dHJpYnV0ZSIrRm8rK31bY3NdKCl7cmV0dXJuIHRoaXNbQW9dfVtic10oKXtyZXR1cm4hMH1bdHNdKCl7cmV0dXJuIHRoaXNbSG5dLnRyaW0oKX1bWHNdKGUpe2U9ZS52YWx1ZXx8IiI7dGhpc1tIbl09ZS50b1N0cmluZygpfVtIc10oKXtyZXR1cm4gdGhpc1tIbl19W3lzXShlKXtyZXR1cm4gdGhpc1tBb109PT1lfHx0aGlzW0FvXVt5c10oZSl9fWNsYXNzIFhtbE9iamVjdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlLHQsYT17fSl7c3VwZXIoZSx0KTt0aGlzW0huXT0iIjt0aGlzW2dvXT1udWxsO2lmKCIjdGV4dCIhPT10KXtjb25zdCBlPW5ldyBNYXA7dGhpc1tsb109ZTtmb3IoY29uc3RbdCxyXW9mIE9iamVjdC5lbnRyaWVzKGEpKWUuc2V0KHQsbmV3IFhGQUF0dHJpYnV0ZSh0aGlzLHQscikpO2lmKGEuaGFzT3duUHJvcGVydHkoSXMpKXtjb25zdCBlPWFbSXNdLnhmYS5kYXRhTm9kZTt2b2lkIDAhPT1lJiYoImRhdGFHcm91cCI9PT1lP3RoaXNbZ29dPSExOiJkYXRhVmFsdWUiPT09ZSYmKHRoaXNbZ29dPSEwKSl9fXRoaXNbcW5dPSExfVskc10oZSl7Y29uc3QgdD10aGlzW0ZzXTtpZigiI3RleHQiPT09dCl7ZS5wdXNoKGVuY29kZVRvWG1sU3RyaW5nKHRoaXNbSG5dKSk7cmV0dXJufWNvbnN0IGE9dXRmOFN0cmluZ1RvU3RyaW5nKHQpLHI9dGhpc1t2c109PT1Jbz8ieGZhOiI6IiI7ZS5wdXNoKGA8JHtyfSR7YX1gKTtmb3IoY29uc3RbdCxhXW9mIHRoaXNbbG9dLmVudHJpZXMoKSl7Y29uc3Qgcj11dGY4U3RyaW5nVG9TdHJpbmcodCk7ZS5wdXNoKGAgJHtyfT0iJHtlbmNvZGVUb1htbFN0cmluZyhhW0huXSl9ImApfW51bGwhPT10aGlzW2dvXSYmKHRoaXNbZ29dP2UucHVzaCgnIHhmYTpkYXRhTm9kZT0iZGF0YVZhbHVlIicpOmUucHVzaCgnIHhmYTpkYXRhTm9kZT0iZGF0YUdyb3VwIicpKTtpZih0aGlzW0huXXx8MCE9PXRoaXNbdW9dLmxlbmd0aCl7ZS5wdXNoKCI+Iik7aWYodGhpc1tIbl0pInN0cmluZyI9PXR5cGVvZiB0aGlzW0huXT9lLnB1c2goZW5jb2RlVG9YbWxTdHJpbmcodGhpc1tIbl0pKTp0aGlzW0huXVskc10oZSk7ZWxzZSBmb3IoY29uc3QgdCBvZiB0aGlzW3VvXSl0WyRzXShlKTtlLnB1c2goYDwvJHtyfSR7YX0+YCl9ZWxzZSBlLnB1c2goIi8+Iil9W1RzXShlKXtpZih0aGlzW0huXSl7Y29uc3QgZT1uZXcgWG1sT2JqZWN0KHRoaXNbdnNdLCIjdGV4dCIpO3RoaXNbUG5dKGUpO2VbSG5dPXRoaXNbSG5dO3RoaXNbSG5dPSIifXRoaXNbUG5dKGUpO3JldHVybiEwfVtNc10oZSl7dGhpc1tIbl0rPWV9W0duXSgpe2lmKHRoaXNbSG5dJiZ0aGlzW3VvXS5sZW5ndGg+MCl7Y29uc3QgZT1uZXcgWG1sT2JqZWN0KHRoaXNbdnNdLCIjdGV4dCIpO3RoaXNbUG5dKGUpO2VbSG5dPXRoaXNbSG5dO2RlbGV0ZSB0aGlzW0huXX19W3pzXSgpe3JldHVybiIjdGV4dCI9PT10aGlzW0ZzXT9IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6IiN0ZXh0Iix2YWx1ZTp0aGlzW0huXX0pOkhUTUxSZXN1bHQuRU1QVFl9W2lzXShlPW51bGwpe3JldHVybiBlP3RoaXNbdW9dLmZpbHRlcigodD0+dFtGc109PT1lKSk6dGhpc1t1b119W0puXSgpe3JldHVybiB0aGlzW2xvXX1bWm5dKGUpe2NvbnN0IHQ9dGhpc1tsb10uZ2V0KGUpO3JldHVybiB2b2lkIDAhPT10P3Q6dGhpc1tpc10oZSl9Kltlc10oZSx0KXtjb25zdCBhPXRoaXNbbG9dLmdldChlKTthJiYoeWllbGQgYSk7Zm9yKGNvbnN0IGEgb2YgdGhpc1t1b10pe2FbRnNdPT09ZSYmKHlpZWxkIGEpO3QmJih5aWVsZCphW2VzXShlLHQpKX19KltLbl0oZSx0KXtjb25zdCBhPXRoaXNbbG9dLmdldChlKTshYXx8dCYmYVtxbl18fCh5aWVsZCBhKTtmb3IoY29uc3QgYSBvZiB0aGlzW3VvXSl5aWVsZCphW0tuXShlLHQpfSpbcnNdKGUsdCxhKXtmb3IoY29uc3QgciBvZiB0aGlzW3VvXSl7cltGc10hPT1lfHxhJiZyW3FuXXx8KHlpZWxkIHIpO3QmJih5aWVsZCpyW3JzXShlLHQsYSkpfX1bYnNdKCl7cmV0dXJuIG51bGw9PT10aGlzW2dvXT8wPT09dGhpc1t1b10ubGVuZ3RofHx0aGlzW3VvXVswXVt2c109PT1Kcy54aHRtbC5pZDp0aGlzW2dvXX1bdHNdKCl7cmV0dXJuIG51bGw9PT10aGlzW2dvXT8wPT09dGhpc1t1b10ubGVuZ3RoP3RoaXNbSG5dLnRyaW0oKTp0aGlzW3VvXVswXVt2c109PT1Kcy54aHRtbC5pZD90aGlzW3VvXVswXVtIc10oKS50cmltKCk6bnVsbDp0aGlzW0huXS50cmltKCl9W1hzXShlKXtlPWUudmFsdWV8fCIiO3RoaXNbSG5dPWUudG9TdHJpbmcoKX1bem5dKGU9ITEpe2NvbnN0IHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtlJiYodC4kbnM9dGhpc1t2c10pO3RoaXNbSG5dJiYodC4kY29udGVudD10aGlzW0huXSk7dC4kbmFtZT10aGlzW0ZzXTt0LmNoaWxkcmVuPVtdO2Zvcihjb25zdCBhIG9mIHRoaXNbdW9dKXQuY2hpbGRyZW4ucHVzaChhW3puXShlKSk7dC5hdHRyaWJ1dGVzPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGNvbnN0W2UsYV1vZiB0aGlzW2xvXSl0LmF0dHJpYnV0ZXNbZV09YVtIbl07cmV0dXJuIHR9fWNsYXNzIENvbnRlbnRPYmplY3QgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLHQpO3RoaXNbSG5dPSIifVtNc10oZSl7dGhpc1tIbl0rPWV9W0duXSgpe319Y2xhc3MgT3B0aW9uT2JqZWN0IGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIoZSx0KTt0aGlzW1NvXT1hfVtHbl0oKXt0aGlzW0huXT1nZXRLZXl3b3JkKHtkYXRhOnRoaXNbSG5dLGRlZmF1bHRWYWx1ZTp0aGlzW1NvXVswXSx2YWxpZGF0ZTplPT50aGlzW1NvXS5pbmNsdWRlcyhlKX0pfVtqbl0oZSl7c3VwZXJbam5dKGUpO2RlbGV0ZSB0aGlzW1NvXX19Y2xhc3MgU3RyaW5nT2JqZWN0IGV4dGVuZHMgQ29udGVudE9iamVjdHtbR25dKCl7dGhpc1tIbl09dGhpc1tIbl0udHJpbSgpfX1jbGFzcyBJbnRlZ2VyT2JqZWN0IGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlLHQsYSxyKXtzdXBlcihlLHQpO3RoaXNbcG9dPWE7dGhpc1t2b109cn1bR25dKCl7dGhpc1tIbl09Z2V0SW50ZWdlcih7ZGF0YTp0aGlzW0huXSxkZWZhdWx0VmFsdWU6dGhpc1twb10sdmFsaWRhdGU6dGhpc1t2b119KX1bam5dKGUpe3N1cGVyW2puXShlKTtkZWxldGUgdGhpc1twb107ZGVsZXRlIHRoaXNbdm9dfX1jbGFzcyBPcHRpb24wMSBleHRlbmRzIEludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLHQsMCwoZT0+MT09PWUpKX19Y2xhc3MgT3B0aW9uMTAgZXh0ZW5kcyBJbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSx0LDEsKGU9PjA9PT1lKSl9fWZ1bmN0aW9uIG1lYXN1cmVUb1N0cmluZyhlKXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIGU/IjBweCI6TnVtYmVyLmlzSW50ZWdlcihlKT9gJHtlfXB4YDpgJHtlLnRvRml4ZWQoMil9cHhgfWNvbnN0IE9vPXthbmNob3JUeXBlKGUsdCl7Y29uc3QgYT1lW29zXSgpO2lmKGEmJighYS5sYXlvdXR8fCJwb3NpdGlvbiI9PT1hLmxheW91dCkpeyJ0cmFuc2Zvcm0iaW4gdHx8KHQudHJhbnNmb3JtPSIiKTtzd2l0Y2goZS5hbmNob3JUeXBlKXtjYXNlImJvdHRvbUNlbnRlciI6dC50cmFuc2Zvcm0rPSJ0cmFuc2xhdGUoLTUwJSwgLTEwMCUpIjticmVhaztjYXNlImJvdHRvbUxlZnQiOnQudHJhbnNmb3JtKz0idHJhbnNsYXRlKDAsLTEwMCUpIjticmVhaztjYXNlImJvdHRvbVJpZ2h0Ijp0LnRyYW5zZm9ybSs9InRyYW5zbGF0ZSgtMTAwJSwtMTAwJSkiO2JyZWFrO2Nhc2UibWlkZGxlQ2VudGVyIjp0LnRyYW5zZm9ybSs9InRyYW5zbGF0ZSgtNTAlLC01MCUpIjticmVhaztjYXNlIm1pZGRsZUxlZnQiOnQudHJhbnNmb3JtKz0idHJhbnNsYXRlKDAsLTUwJSkiO2JyZWFrO2Nhc2UibWlkZGxlUmlnaHQiOnQudHJhbnNmb3JtKz0idHJhbnNsYXRlKC0xMDAlLC01MCUpIjticmVhaztjYXNlInRvcENlbnRlciI6dC50cmFuc2Zvcm0rPSJ0cmFuc2xhdGUoLTUwJSwwKSI7YnJlYWs7Y2FzZSJ0b3BSaWdodCI6dC50cmFuc2Zvcm0rPSJ0cmFuc2xhdGUoLTEwMCUsMCkifX19LGRpbWVuc2lvbnMoZSx0KXtjb25zdCBhPWVbb3NdKCk7bGV0IHI9ZS53O2NvbnN0IGk9ZS5oO2lmKGEubGF5b3V0Py5pbmNsdWRlcygicm93Iikpe2NvbnN0IHQ9YVskbl0saT1lLmNvbFNwYW47bGV0IG47aWYoLTE9PT1pKXtuPU1hdGguc3VtUHJlY2lzZSh0LmNvbHVtbldpZHRocy5zbGljZSh0LmN1cnJlbnRDb2x1bW4pKTt0LmN1cnJlbnRDb2x1bW49MH1lbHNle249TWF0aC5zdW1QcmVjaXNlKHQuY29sdW1uV2lkdGhzLnNsaWNlKHQuY3VycmVudENvbHVtbix0LmN1cnJlbnRDb2x1bW4raSkpO3QuY3VycmVudENvbHVtbj0odC5jdXJyZW50Q29sdW1uK2UuY29sU3BhbikldC5jb2x1bW5XaWR0aHMubGVuZ3RofWlzTmFOKG4pfHwocj1lLnc9bil9dC53aWR0aD0iIiE9PXI/bWVhc3VyZVRvU3RyaW5nKHIpOiJhdXRvIjt0LmhlaWdodD0iIiE9PWk/bWVhc3VyZVRvU3RyaW5nKGkpOiJhdXRvIn0scG9zaXRpb24oZSx0KXtjb25zdCBhPWVbb3NdKCk7aWYoIWE/LmxheW91dHx8InBvc2l0aW9uIj09PWEubGF5b3V0KXt0LnBvc2l0aW9uPSJhYnNvbHV0ZSI7dC5sZWZ0PW1lYXN1cmVUb1N0cmluZyhlLngpO3QudG9wPW1lYXN1cmVUb1N0cmluZyhlLnkpfX0scm90YXRlKGUsdCl7aWYoZS5yb3RhdGUpeyJ0cmFuc2Zvcm0iaW4gdHx8KHQudHJhbnNmb3JtPSIiKTt0LnRyYW5zZm9ybSs9YHJvdGF0ZSgtJHtlLnJvdGF0ZX1kZWcpYDt0LnRyYW5zZm9ybU9yaWdpbj0idG9wIGxlZnQifX0scHJlc2VuY2UoZSx0KXtzd2l0Y2goZS5wcmVzZW5jZSl7Y2FzZSJpbnZpc2libGUiOnQudmlzaWJpbGl0eT0iaGlkZGVuIjticmVhaztjYXNlImhpZGRlbiI6Y2FzZSJpbmFjdGl2ZSI6dC5kaXNwbGF5PSJub25lIn19LGhBbGlnbihlLHQpe2lmKCJwYXJhIj09PWVbRnNdKXN3aXRjaChlLmhBbGlnbil7Y2FzZSJqdXN0aWZ5QWxsIjp0LnRleHRBbGlnbj0ianVzdGlmeS1hbGwiO2JyZWFrO2Nhc2UicmFkaXgiOnQudGV4dEFsaWduPSJsZWZ0IjticmVhaztkZWZhdWx0OnQudGV4dEFsaWduPWUuaEFsaWdufWVsc2Ugc3dpdGNoKGUuaEFsaWduKXtjYXNlImxlZnQiOnQuYWxpZ25TZWxmPSJzdGFydCI7YnJlYWs7Y2FzZSJjZW50ZXIiOnQuYWxpZ25TZWxmPSJjZW50ZXIiO2JyZWFrO2Nhc2UicmlnaHQiOnQuYWxpZ25TZWxmPSJlbmQifX0sbWFyZ2luKGUsdCl7ZS5tYXJnaW4mJih0Lm1hcmdpbj1lLm1hcmdpbltHc10oKS5tYXJnaW4pfX07ZnVuY3Rpb24gc2V0TWluTWF4RGltZW5zaW9ucyhlLHQpe2lmKCJwb3NpdGlvbiI9PT1lW29zXSgpLmxheW91dCl7ZS5taW5XPjAmJih0Lm1pbldpZHRoPW1lYXN1cmVUb1N0cmluZyhlLm1pblcpKTtlLm1heFc+MCYmKHQubWF4V2lkdGg9bWVhc3VyZVRvU3RyaW5nKGUubWF4VykpO2UubWluSD4wJiYodC5taW5IZWlnaHQ9bWVhc3VyZVRvU3RyaW5nKGUubWluSCkpO2UubWF4SD4wJiYodC5tYXhIZWlnaHQ9bWVhc3VyZVRvU3RyaW5nKGUubWF4SCkpfX1mdW5jdGlvbiBsYXlvdXRUZXh0KGUsdCxhLHIsaSxuKXtjb25zdCBzPW5ldyBUZXh0TWVhc3VyZSh0LGEscixpKTsic3RyaW5nIj09dHlwZW9mIGU/cy5hZGRTdHJpbmcoZSk6ZVtEc10ocyk7cmV0dXJuIHMuY29tcHV0ZShuKX1mdW5jdGlvbiBsYXlvdXROb2RlKGUsdCl7bGV0IGE9bnVsbCxyPW51bGwsaT0hMTtpZigoIWUud3x8IWUuaCkmJmUudmFsdWUpe2xldCBuPTAscz0wO2lmKGUubWFyZ2luKXtuPWUubWFyZ2luLmxlZnRJbnNldCtlLm1hcmdpbi5yaWdodEluc2V0O3M9ZS5tYXJnaW4udG9wSW5zZXQrZS5tYXJnaW4uYm90dG9tSW5zZXR9bGV0IG89bnVsbCxjPW51bGw7aWYoZS5wYXJhKXtjPU9iamVjdC5jcmVhdGUobnVsbCk7bz0iIj09PWUucGFyYS5saW5lSGVpZ2h0P251bGw6ZS5wYXJhLmxpbmVIZWlnaHQ7Yy50b3A9IiI9PT1lLnBhcmEuc3BhY2VBYm92ZT8wOmUucGFyYS5zcGFjZUFib3ZlO2MuYm90dG9tPSIiPT09ZS5wYXJhLnNwYWNlQmVsb3c/MDplLnBhcmEuc3BhY2VCZWxvdztjLmxlZnQ9IiI9PT1lLnBhcmEubWFyZ2luTGVmdD8wOmUucGFyYS5tYXJnaW5MZWZ0O2MucmlnaHQ9IiI9PT1lLnBhcmEubWFyZ2luUmlnaHQ/MDplLnBhcmEubWFyZ2luUmlnaHR9bGV0IGw9ZS5mb250O2lmKCFsKXtjb25zdCB0PWVbbHNdKCk7bGV0IGE9ZVtjc10oKTtmb3IoO2EmJmEhPT10Oyl7aWYoYS5mb250KXtsPWEuZm9udDticmVha31hPWFbY3NdKCl9fWNvbnN0IGg9KGUud3x8dC53aWR0aCktbix1PWVbaHNdLmZvbnRGaW5kZXI7aWYoZS52YWx1ZS5leERhdGEmJmUudmFsdWUuZXhEYXRhW0huXSYmInRleHQvaHRtbCI9PT1lLnZhbHVlLmV4RGF0YS5jb250ZW50VHlwZSl7Y29uc3QgdD1sYXlvdXRUZXh0KGUudmFsdWUuZXhEYXRhW0huXSxsLGMsbyx1LGgpO3I9dC53aWR0aDthPXQuaGVpZ2h0O2k9dC5pc0Jyb2tlbn1lbHNle2NvbnN0IHQ9ZS52YWx1ZVtIc10oKTtpZih0KXtjb25zdCBlPWxheW91dFRleHQodCxsLGMsbyx1LGgpO3I9ZS53aWR0aDthPWUuaGVpZ2h0O2k9ZS5pc0Jyb2tlbn19bnVsbD09PXJ8fGUud3x8KHIrPW4pO251bGw9PT1hfHxlLmh8fChhKz1zKX1yZXR1cm57dzpyLGg6YSxpc0Jyb2tlbjppfX1mdW5jdGlvbiBjb21wdXRlQmJveChlLHQsYSl7bGV0IHI7aWYoIiIhPT1lLncmJiIiIT09ZS5oKXI9W2UueCxlLnksZS53LGUuaF07ZWxzZXtpZighYSlyZXR1cm4gbnVsbDtsZXQgaT1lLnc7aWYoIiI9PT1pKXtpZigwPT09ZS5tYXhXKXtjb25zdCB0PWVbb3NdKCk7aT0icG9zaXRpb24iPT09dC5sYXlvdXQmJiIiIT09dC53PzA6ZS5taW5XfWVsc2UgaT1NYXRoLm1pbihlLm1heFcsYS53aWR0aCk7dC5hdHRyaWJ1dGVzLnN0eWxlLndpZHRoPW1lYXN1cmVUb1N0cmluZyhpKX1sZXQgbj1lLmg7aWYoIiI9PT1uKXtpZigwPT09ZS5tYXhIKXtjb25zdCB0PWVbb3NdKCk7bj0icG9zaXRpb24iPT09dC5sYXlvdXQmJiIiIT09dC5oPzA6ZS5taW5IfWVsc2Ugbj1NYXRoLm1pbihlLm1heEgsYS5oZWlnaHQpO3QuYXR0cmlidXRlcy5zdHlsZS5oZWlnaHQ9bWVhc3VyZVRvU3RyaW5nKG4pfXI9W2UueCxlLnksaSxuXX1yZXR1cm4gcn1mdW5jdGlvbiBmaXhEaW1lbnNpb25zKGUpe2NvbnN0IHQ9ZVtvc10oKTtpZih0LmxheW91dD8uaW5jbHVkZXMoInJvdyIpKXtjb25zdCBhPXRbJG5dLHI9ZS5jb2xTcGFuO2xldCBpO2k9LTE9PT1yP01hdGguc3VtUHJlY2lzZShhLmNvbHVtbldpZHRocy5zbGljZShhLmN1cnJlbnRDb2x1bW4pKTpNYXRoLnN1bVByZWNpc2UoYS5jb2x1bW5XaWR0aHMuc2xpY2UoYS5jdXJyZW50Q29sdW1uLGEuY3VycmVudENvbHVtbityKSk7aXNOYU4oaSl8fChlLnc9aSl9dC5sYXlvdXQmJiJwb3NpdGlvbiIhPT10LmxheW91dCYmKGUueD1lLnk9MCk7InRhYmxlIj09PWUubGF5b3V0JiYiIj09PWUudyYmQXJyYXkuaXNBcnJheShlLmNvbHVtbldpZHRocykmJihlLnc9TWF0aC5zdW1QcmVjaXNlKGUuY29sdW1uV2lkdGhzKSl9ZnVuY3Rpb24gbGF5b3V0Q2xhc3MoZSl7c3dpdGNoKGUubGF5b3V0KXtjYXNlInBvc2l0aW9uIjpkZWZhdWx0OnJldHVybiJ4ZmFQb3NpdGlvbiI7Y2FzZSJsci10YiI6cmV0dXJuInhmYUxyVGIiO2Nhc2Uicmwtcm93IjpyZXR1cm4ieGZhUmxSb3ciO2Nhc2UicmwtdGIiOnJldHVybiJ4ZmFSbFRiIjtjYXNlInJvdyI6cmV0dXJuInhmYVJvdyI7Y2FzZSJ0YWJsZSI6cmV0dXJuInhmYVRhYmxlIjtjYXNlInRiIjpyZXR1cm4ieGZhVGIifX1mdW5jdGlvbiB0b1N0eWxlKGUsLi4udCl7Y29uc3QgYT1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdCByIG9mIHQpe2NvbnN0IHQ9ZVtyXTtpZihudWxsIT09dClpZihPby5oYXNPd25Qcm9wZXJ0eShyKSlPb1tyXShlLGEpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFhGQU9iamVjdCl7Y29uc3QgZT10W0dzXSgpO2U/T2JqZWN0LmFzc2lnbihhLGUpOndhcm4oYChERUJVRykgLSBYRkEgLSBzdHlsZSBmb3IgJHtyfSBub3QgaW1wbGVtZW50ZWQgeWV0YCl9fXJldHVybiBhfWZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoZSx0KXtjb25zdHthdHRyaWJ1dGVzOmF9PXQse3N0eWxlOnJ9PWEsaT17bmFtZToiZGl2IixhdHRyaWJ1dGVzOntjbGFzczpbInhmYVdyYXBwZXIiXSxzdHlsZTpPYmplY3QuY3JlYXRlKG51bGwpfSxjaGlsZHJlbjpbXX07YS5jbGFzcy5wdXNoKCJ4ZmFXcmFwcGVkIik7aWYoZS5ib3JkZXIpe2NvbnN0e3dpZHRoczphLGluc2V0czpufT1lLmJvcmRlclskbl07bGV0IHMsbyxjPW5bMF0sbD1uWzNdO2NvbnN0IGg9blswXStuWzJdLHU9blsxXStuWzNdO3N3aXRjaChlLmJvcmRlci5oYW5kKXtjYXNlImV2ZW4iOmMtPWFbMF0vMjtsLT1hWzNdLzI7cz1gY2FsYygxMDAlICsgJHsoYVsxXSthWzNdKS8yLXV9cHgpYDtvPWBjYWxjKDEwMCUgKyAkeyhhWzBdK2FbMl0pLzItaH1weClgO2JyZWFrO2Nhc2UibGVmdCI6Yy09YVswXTtsLT1hWzNdO3M9YGNhbGMoMTAwJSArICR7YVsxXSthWzNdLXV9cHgpYDtvPWBjYWxjKDEwMCUgKyAke2FbMF0rYVsyXS1ofXB4KWA7YnJlYWs7Y2FzZSJyaWdodCI6cz11P2BjYWxjKDEwMCUgLSAke3V9cHgpYDoiMTAwJSI7bz1oP2BjYWxjKDEwMCUgLSAke2h9cHgpYDoiMTAwJSJ9Y29uc3QgZD1bInhmYUJvcmRlciJdO2lzUHJpbnRPbmx5KGUuYm9yZGVyKSYmZC5wdXNoKCJ4ZmFQcmludE9ubHkiKTtjb25zdCBmPXtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e2NsYXNzOmQsc3R5bGU6e3RvcDpgJHtjfXB4YCxsZWZ0OmAke2x9cHhgLHdpZHRoOnMsaGVpZ2h0Om99fSxjaGlsZHJlbjpbXX07Zm9yKGNvbnN0IGUgb2ZbImJvcmRlciIsImJvcmRlcldpZHRoIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJSYWRpdXMiLCJib3JkZXJTdHlsZSJdKWlmKHZvaWQgMCE9PXJbZV0pe2YuYXR0cmlidXRlcy5zdHlsZVtlXT1yW2VdO2RlbGV0ZSByW2VdfWkuY2hpbGRyZW4ucHVzaChmLHQpfWVsc2UgaS5jaGlsZHJlbi5wdXNoKHQpO2Zvcihjb25zdCBlIG9mWyJiYWNrZ3JvdW5kIiwiYmFja2dyb3VuZENsaXAiLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwidHJhbnNmb3JtIiwidHJhbnNmb3JtT3JpZ2luIiwidmlzaWJpbGl0eSJdKWlmKHZvaWQgMCE9PXJbZV0pe2kuYXR0cmlidXRlcy5zdHlsZVtlXT1yW2VdO2RlbGV0ZSByW2VdfWkuYXR0cmlidXRlcy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiPT09ci5wb3NpdGlvbj8iYWJzb2x1dGUiOiJyZWxhdGl2ZSI7ZGVsZXRlIHIucG9zaXRpb247aWYoci5hbGlnblNlbGYpe2kuYXR0cmlidXRlcy5zdHlsZS5hbGlnblNlbGY9ci5hbGlnblNlbGY7ZGVsZXRlIHIuYWxpZ25TZWxmfXJldHVybiBpfWZ1bmN0aW9uIGZpeFRleHRJbmRlbnQoZSl7Y29uc3QgdD1nZXRNZWFzdXJlbWVudChlLnRleHRJbmRlbnQsIjBweCIpO2lmKHQ+PTApcmV0dXJuO2NvbnN0IGE9InBhZGRpbmciKygibGVmdCI9PT0oInJpZ2h0Ij09PWUudGV4dEFsaWduPyJyaWdodCI6ImxlZnQiKT8iTGVmdCI6IlJpZ2h0Iikscj1nZXRNZWFzdXJlbWVudChlW2FdLCIwcHgiKTtlW2FdPXItdCsicHgifWZ1bmN0aW9uIHNldEFjY2VzcyhlLHQpe3N3aXRjaChlLmFjY2Vzcyl7Y2FzZSJub25JbnRlcmFjdGl2ZSI6dC5wdXNoKCJ4ZmFOb25JbnRlcmFjdGl2ZSIpO2JyZWFrO2Nhc2UicmVhZE9ubHkiOnQucHVzaCgieGZhUmVhZE9ubHkiKTticmVhaztjYXNlInByb3RlY3RlZCI6dC5wdXNoKCJ4ZmFEaXNhYmxlZCIpfX1mdW5jdGlvbiBpc1ByaW50T25seShlKXtyZXR1cm4gZS5yZWxldmFudC5sZW5ndGg+MCYmIWUucmVsZXZhbnRbMF0uZXhjbHVkZWQmJiJwcmludCI9PT1lLnJlbGV2YW50WzBdLnZpZXduYW1lfWZ1bmN0aW9uIGdldEN1cnJlbnRQYXJhKGUpe2NvbnN0IHQ9ZVtsc10oKVskbl0ucGFyYVN0YWNrO3JldHVybiB0Lmxlbmd0aD90LmF0KC0xKTpudWxsfWZ1bmN0aW9uIHNldFBhcmEoZSx0LGEpe2lmKGEuYXR0cmlidXRlcy5jbGFzcz8uaW5jbHVkZXMoInhmYVJpY2giKSl7aWYodCl7IiI9PT1lLmgmJih0LmhlaWdodD0iYXV0byIpOyIiPT09ZS53JiYodC53aWR0aD0iYXV0byIpfWNvbnN0IHI9Z2V0Q3VycmVudFBhcmEoZSk7aWYocil7Y29uc3QgZT1hLmF0dHJpYnV0ZXMuc3R5bGU7ZS5kaXNwbGF5PSJmbGV4IjtlLmZsZXhEaXJlY3Rpb249ImNvbHVtbiI7c3dpdGNoKHIudkFsaWduKXtjYXNlInRvcCI6ZS5qdXN0aWZ5Q29udGVudD0ic3RhcnQiO2JyZWFrO2Nhc2UiYm90dG9tIjplLmp1c3RpZnlDb250ZW50PSJlbmQiO2JyZWFrO2Nhc2UibWlkZGxlIjplLmp1c3RpZnlDb250ZW50PSJjZW50ZXIifWNvbnN0IHQ9cltHc10oKTtmb3IoY29uc3RbYSxyXW9mIE9iamVjdC5lbnRyaWVzKHQpKWEgaW4gZXx8KGVbYV09cil9fX1mdW5jdGlvbiBzZXRGb250RmFtaWx5KGUsdCxhLHIpe2lmKCFhKXtkZWxldGUgci5mb250RmFtaWx5O3JldHVybn1jb25zdCBpPXN0cmlwUXVvdGVzKGUudHlwZWZhY2UpO3IuZm9udEZhbWlseT1gIiR7aX0iYDtjb25zdCBuPWEuZmluZChpKTtpZihuKXtjb25zdHtmb250RmFtaWx5OmF9PW4ucmVndWxhci5jc3NGb250SW5mbzthIT09aSYmKHIuZm9udEZhbWlseT1gIiR7YX0iYCk7Y29uc3Qgcz1nZXRDdXJyZW50UGFyYSh0KTtpZihzJiYiIiE9PXMubGluZUhlaWdodClyZXR1cm47aWYoci5saW5lSGVpZ2h0KXJldHVybjtjb25zdCBvPXNlbGVjdEZvbnQoZSxuKTtvJiYoci5saW5lSGVpZ2h0PU1hdGgubWF4KDEuMixvLmxpbmVIZWlnaHQpKX19ZnVuY3Rpb24gZml4VVJMKGUpe2NvbnN0IHQ9Y3JlYXRlVmFsaWRBYnNvbHV0ZVVybChlLG51bGwse2FkZERlZmF1bHRQcm90b2NvbDohMCx0cnlDb252ZXJ0RW5jb2Rpbmc6ITB9KTtyZXR1cm4gdD90LmhyZWY6bnVsbH1mdW5jdGlvbiBjcmVhdGVMaW5lKGUsdCl7cmV0dXJue25hbWU6ImRpdiIsYXR0cmlidXRlczp7Y2xhc3M6WyJsci10YiI9PT1lLmxheW91dD8ieGZhTHIiOiJ4ZmFSbCJdfSxjaGlsZHJlbjp0fX1mdW5jdGlvbiBmbHVzaEhUTUwoZSl7aWYoIWVbJG5dKXJldHVybiBudWxsO2NvbnN0IHQ9e25hbWU6ImRpdiIsYXR0cmlidXRlczplWyRuXS5hdHRyaWJ1dGVzLGNoaWxkcmVuOmVbJG5dLmNoaWxkcmVufTtpZihlWyRuXS5mYWlsaW5nTm9kZSl7Y29uc3QgYT1lWyRuXS5mYWlsaW5nTm9kZVtWbl0oKTthJiYoZS5sYXlvdXQuZW5kc1dpdGgoIi10YiIpP3QuY2hpbGRyZW4ucHVzaChjcmVhdGVMaW5lKGUsW2FdKSk6dC5jaGlsZHJlbi5wdXNoKGEpKX1yZXR1cm4gMD09PXQuY2hpbGRyZW4ubGVuZ3RoP251bGw6dH1mdW5jdGlvbiBhZGRIVE1MKGUsdCxhKXtjb25zdCByPWVbJG5dLGk9ci5hdmFpbGFibGVTcGFjZSxbbixzLG8sY109YTtzd2l0Y2goZS5sYXlvdXQpe2Nhc2UicG9zaXRpb24iOnIud2lkdGg9TWF0aC5tYXgoci53aWR0aCxuK28pO3IuaGVpZ2h0PU1hdGgubWF4KHIuaGVpZ2h0LHMrYyk7ci5jaGlsZHJlbi5wdXNoKHQpO2JyZWFrO2Nhc2UibHItdGIiOmNhc2UicmwtdGIiOmlmKCFyLmxpbmV8fDE9PT1yLmF0dGVtcHQpe3IubGluZT1jcmVhdGVMaW5lKGUsW10pO3IuY2hpbGRyZW4ucHVzaChyLmxpbmUpO3IubnVtYmVySW5MaW5lPTB9ci5udW1iZXJJbkxpbmUrPTE7ci5saW5lLmNoaWxkcmVuLnB1c2godCk7aWYoMD09PXIuYXR0ZW1wdCl7ci5jdXJyZW50V2lkdGgrPW87ci5oZWlnaHQ9TWF0aC5tYXgoci5oZWlnaHQsci5wcmV2SGVpZ2h0K2MpfWVsc2V7ci5jdXJyZW50V2lkdGg9bztyLnByZXZIZWlnaHQ9ci5oZWlnaHQ7ci5oZWlnaHQrPWM7ci5hdHRlbXB0PTB9ci53aWR0aD1NYXRoLm1heChyLndpZHRoLHIuY3VycmVudFdpZHRoKTticmVhaztjYXNlInJsLXJvdyI6Y2FzZSJyb3ciOntyLmNoaWxkcmVuLnB1c2godCk7ci53aWR0aCs9bztyLmhlaWdodD1NYXRoLm1heChyLmhlaWdodCxjKTtjb25zdCBlPW1lYXN1cmVUb1N0cmluZyhyLmhlaWdodCk7Zm9yKGNvbnN0IHQgb2Ygci5jaGlsZHJlbil0LmF0dHJpYnV0ZXMuc3R5bGUuaGVpZ2h0PWU7YnJlYWt9Y2FzZSJ0YWJsZSI6Y2FzZSJ0YiI6ci53aWR0aD1NYXRoQ2xhbXAobyxyLndpZHRoLGkud2lkdGgpO3IuaGVpZ2h0Kz1jO3IuY2hpbGRyZW4ucHVzaCh0KX19ZnVuY3Rpb24gZ2V0QXZhaWxhYmxlU3BhY2UoZSl7Y29uc3QgdD1lWyRuXS5hdmFpbGFibGVTcGFjZSxhPWUubWFyZ2luP2UubWFyZ2luLnRvcEluc2V0K2UubWFyZ2luLmJvdHRvbUluc2V0OjAscj1lLm1hcmdpbj9lLm1hcmdpbi5sZWZ0SW5zZXQrZS5tYXJnaW4ucmlnaHRJbnNldDowO3N3aXRjaChlLmxheW91dCl7Y2FzZSJsci10YiI6Y2FzZSJybC10YiI6cmV0dXJuIDA9PT1lWyRuXS5hdHRlbXB0P3t3aWR0aDp0LndpZHRoLXItZVskbl0uY3VycmVudFdpZHRoLGhlaWdodDp0LmhlaWdodC1hLWVbJG5dLnByZXZIZWlnaHR9Ont3aWR0aDp0LndpZHRoLXIsaGVpZ2h0OnQuaGVpZ2h0LWEtZVskbl0uaGVpZ2h0fTtjYXNlInJsLXJvdyI6Y2FzZSJyb3ciOnJldHVybnt3aWR0aDpNYXRoLnN1bVByZWNpc2UoZVskbl0uY29sdW1uV2lkdGhzLnNsaWNlKGVbJG5dLmN1cnJlbnRDb2x1bW4pKSxoZWlnaHQ6dC5oZWlnaHQtcn07Y2FzZSJ0YWJsZSI6Y2FzZSJ0YiI6cmV0dXJue3dpZHRoOnQud2lkdGgtcixoZWlnaHQ6dC5oZWlnaHQtYS1lWyRuXS5oZWlnaHR9O2RlZmF1bHQ6cmV0dXJuIHR9fWZ1bmN0aW9uIGNoZWNrRGltZW5zaW9ucyhlLHQpe2lmKG51bGw9PT1lW2xzXSgpWyRuXS5maXJzdFVuc3BsaXR0YWJsZSlyZXR1cm4hMDtpZigwPT09ZS53fHwwPT09ZS5oKXJldHVybiEwO2NvbnN0IGE9ZVtvc10oKSxyPWFbJG5dPy5hdHRlbXB0fHwwLFssaSxuLHNdPWZ1bmN0aW9uIGdldFRyYW5zZm9ybWVkQkJveChlKXtsZXQgdCxhLHI9IiI9PT1lLnc/TmFOOmUudyxpPSIiPT09ZS5oP05hTjplLmgsW24sc109WzAsMF07c3dpdGNoKGUuYW5jaG9yVHlwZXx8IiIpe2Nhc2UiYm90dG9tQ2VudGVyIjpbbixzXT1bci8yLGldO2JyZWFrO2Nhc2UiYm90dG9tTGVmdCI6W24sc109WzAsaV07YnJlYWs7Y2FzZSJib3R0b21SaWdodCI6W24sc109W3IsaV07YnJlYWs7Y2FzZSJtaWRkbGVDZW50ZXIiOltuLHNdPVtyLzIsaS8yXTticmVhaztjYXNlIm1pZGRsZUxlZnQiOltuLHNdPVswLGkvMl07YnJlYWs7Y2FzZSJtaWRkbGVSaWdodCI6W24sc109W3IsaS8yXTticmVhaztjYXNlInRvcENlbnRlciI6W24sc109W3IvMiwwXTticmVhaztjYXNlInRvcFJpZ2h0IjpbbixzXT1bciwwXX1zd2l0Y2goZS5yb3RhdGV8fDApe2Nhc2UgMDpbdCxhXT1bLW4sLXNdO2JyZWFrO2Nhc2UgOTA6W3QsYV09Wy1zLG5dO1tyLGldPVtpLC1yXTticmVhaztjYXNlIDE4MDpbdCxhXT1bbixzXTtbcixpXT1bLXIsLWldO2JyZWFrO2Nhc2UgMjcwOlt0LGFdPVtzLC1uXTtbcixpXT1bLWkscl19cmV0dXJuW2UueCt0K01hdGgubWluKDAsciksZS55K2ErTWF0aC5taW4oMCxpKSxNYXRoLmFicyhyKSxNYXRoLmFicyhpKV19KGUpO3N3aXRjaChhLmxheW91dCl7Y2FzZSJsci10YiI6Y2FzZSJybC10YiI6cmV0dXJuIDA9PT1yP2VbbHNdKClbJG5dLm5vTGF5b3V0RmFpbHVyZT8iIiE9PWUudz9NYXRoLnJvdW5kKG4tdC53aWR0aCk8PTI6dC53aWR0aD4yOiEoIiIhPT1lLmgmJk1hdGgucm91bmQocy10LmhlaWdodCk+MikmJigiIiE9PWUudz9NYXRoLnJvdW5kKG4tdC53aWR0aCk8PTJ8fDA9PT1hWyRuXS5udW1iZXJJbkxpbmUmJnQuaGVpZ2h0PjI6dC53aWR0aD4yKTohIWVbbHNdKClbJG5dLm5vTGF5b3V0RmFpbHVyZXx8ISgiIiE9PWUuaCYmTWF0aC5yb3VuZChzLXQuaGVpZ2h0KT4yKSYmKCgiIj09PWUud3x8TWF0aC5yb3VuZChuLXQud2lkdGgpPD0yfHwhYVtTc10oKSkmJnQuaGVpZ2h0PjIpO2Nhc2UidGFibGUiOmNhc2UidGIiOnJldHVybiEhZVtsc10oKVskbl0ubm9MYXlvdXRGYWlsdXJlfHwoIiI9PT1lLmh8fGVbeHNdKCk/KCIiPT09ZS53fHxNYXRoLnJvdW5kKG4tdC53aWR0aCk8PTJ8fCFhW1NzXSgpKSYmdC5oZWlnaHQ+MjpNYXRoLnJvdW5kKHMtdC5oZWlnaHQpPD0yKTtjYXNlInBvc2l0aW9uIjppZihlW2xzXSgpWyRuXS5ub0xheW91dEZhaWx1cmUpcmV0dXJuITA7aWYoIiI9PT1lLmh8fE1hdGgucm91bmQocytpLXQuaGVpZ2h0KTw9MilyZXR1cm4hMDtyZXR1cm4gcytpPmVbbHNdKClbJG5dLmN1cnJlbnRDb250ZW50QXJlYS5oO2Nhc2Uicmwtcm93IjpjYXNlInJvdyI6cmV0dXJuISFlW2xzXSgpWyRuXS5ub0xheW91dEZhaWx1cmV8fCgiIj09PWUuaHx8TWF0aC5yb3VuZChzLXQuaGVpZ2h0KTw9Mik7ZGVmYXVsdDpyZXR1cm4hMH19Y29uc3QgTW89SnMudGVtcGxhdGUuaWQsRG89Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIixCbz0vXkgoXGQrKSQvLFJvPW5ldyBTZXQoWyJpbWFnZS9naWYiLCJpbWFnZS9qcGVnIiwiaW1hZ2UvanBnIiwiaW1hZ2UvcGpwZWciLCJpbWFnZS9wbmciLCJpbWFnZS9hcG5nIiwiaW1hZ2UveC1wbmciLCJpbWFnZS9ibXAiLCJpbWFnZS94LW1zLWJtcCIsImltYWdlL3RpZmYiLCJpbWFnZS90aWYiLCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0iXSksTm89W1tbNjYsNzddLCJpbWFnZS9ibXAiXSxbWzI1NSwyMTYsMjU1XSwiaW1hZ2UvanBlZyJdLFtbNzMsNzMsNDIsMF0sImltYWdlL3RpZmYiXSxbWzc3LDc3LDAsNDJdLCJpbWFnZS90aWZmIl0sW1s3MSw3Myw3MCw1Niw1Nyw5N10sImltYWdlL2dpZiJdLFtbMTM3LDgwLDc4LDcxLDEzLDEwLDI2LDEwXSwiaW1hZ2UvcG5nIl1dO2Z1bmN0aW9uIGdldEJvcmRlckRpbXMoZSl7aWYoIWV8fCFlLmJvcmRlcilyZXR1cm57dzowLGg6MH07Y29uc3QgdD1lLmJvcmRlclthc10oKTtyZXR1cm4gdD97dzp0LndpZHRoc1swXSt0LndpZHRoc1syXSt0Lmluc2V0c1swXSt0Lmluc2V0c1syXSxoOnQud2lkdGhzWzFdK3Qud2lkdGhzWzNdK3QuaW5zZXRzWzFdK3QuaW5zZXRzWzNdfTp7dzowLGg6MH19ZnVuY3Rpb24gaGFzTWFyZ2luKGUpe3JldHVybiBlLm1hcmdpbiYmKGUubWFyZ2luLnRvcEluc2V0fHxlLm1hcmdpbi5yaWdodEluc2V0fHxlLm1hcmdpbi5ib3R0b21JbnNldHx8ZS5tYXJnaW4ubGVmdEluc2V0KX1mdW5jdGlvbiBfc2V0VmFsdWUoZSx0KXtpZighZS52YWx1ZSl7Y29uc3QgdD1uZXcgVmFsdWUoe30pO2VbUG5dKHQpO2UudmFsdWU9dH1lLnZhbHVlW1hzXSh0KX1mdW5jdGlvbipnZXRDb250YWluZWRDaGlsZHJlbihlKXtmb3IoY29uc3QgdCBvZiBlW2lzXSgpKXQgaW5zdGFuY2VvZiBTdWJmb3JtU2V0P3lpZWxkKnRbbnNdKCk6eWllbGQgdH1mdW5jdGlvbiBpc1JlcXVpcmVkKGUpe3JldHVybiJlcnJvciI9PT1lLnZhbGlkYXRlPy5udWxsVGVzdH1mdW5jdGlvbiBzZXRUYWJJbmRleChlKXtmb3IoO2U7KXtpZighZS50cmF2ZXJzYWwpe2VbcXNdPWVbY3NdKClbcXNdO3JldHVybn1pZihlW3FzXSlyZXR1cm47bGV0IHQ9bnVsbDtmb3IoY29uc3QgYSBvZiBlLnRyYXZlcnNhbFtpc10oKSlpZigibmV4dCI9PT1hLm9wZXJhdGlvbil7dD1hO2JyZWFrfWlmKCF0fHwhdC5yZWYpe2VbcXNdPWVbY3NdKClbcXNdO3JldHVybn1jb25zdCBhPWVbbHNdKCk7ZVtxc109KythW3FzXTtjb25zdCByPWFbanNdKHQucmVmLGUpO2lmKCFyKXJldHVybjtlPXJbMF19fWZ1bmN0aW9uIGFwcGx5QXNzaXN0KGUsdCl7Y29uc3QgYT1lLmFzc2lzdDtpZihhKXtjb25zdCBlPWFbenNdKCk7ZSYmKHQudGl0bGU9ZSk7Y29uc3Qgcj1hLnJvbGUubWF0Y2goQm8pO2lmKHIpe2NvbnN0IGU9ImhlYWRpbmciLGE9clsxXTt0LnJvbGU9ZTt0WyJhcmlhLWxldmVsIl09YX19aWYoInRhYmxlIj09PWUubGF5b3V0KXQucm9sZT0idGFibGUiO2Vsc2UgaWYoInJvdyI9PT1lLmxheW91dCl0LnJvbGU9InJvdyI7ZWxzZXtjb25zdCBhPWVbY3NdKCk7InJvdyI9PT1hLmxheW91dCYmKHQucm9sZT0iVEgiPT09YS5hc3Npc3Q/LnJvbGU/ImNvbHVtbmhlYWRlciI6ImNlbGwiKX19ZnVuY3Rpb24gYXJpYUxhYmVsKGUpe2lmKCFlLmFzc2lzdClyZXR1cm4gbnVsbDtjb25zdCB0PWUuYXNzaXN0O3JldHVybiB0LnNwZWFrJiYiIiE9PXQuc3BlYWtbSG5dP3Quc3BlYWtbSG5dOnQudG9vbFRpcD90LnRvb2xUaXBbSG5dOm51bGx9ZnVuY3Rpb24gdmFsdWVUb0h0bWwoZSl7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixhdHRyaWJ1dGVzOntjbGFzczpbInhmYVJpY2giXSxzdHlsZTpPYmplY3QuY3JlYXRlKG51bGwpfSxjaGlsZHJlbjpbe25hbWU6InNwYW4iLGF0dHJpYnV0ZXM6e3N0eWxlOk9iamVjdC5jcmVhdGUobnVsbCl9LHZhbHVlOmV9XX0pfWZ1bmN0aW9uIHNldEZpcnN0VW5zcGxpdHRhYmxlKGUpe2NvbnN0IHQ9ZVtsc10oKTtpZihudWxsPT09dFskbl0uZmlyc3RVbnNwbGl0dGFibGUpe3RbJG5dLmZpcnN0VW5zcGxpdHRhYmxlPWU7dFskbl0ubm9MYXlvdXRGYWlsdXJlPSEwfX1mdW5jdGlvbiB1bnNldEZpcnN0VW5zcGxpdHRhYmxlKGUpe2NvbnN0IHQ9ZVtsc10oKTt0WyRuXS5maXJzdFVuc3BsaXR0YWJsZT09PWUmJih0WyRuXS5ub0xheW91dEZhaWx1cmU9ITEpfWZ1bmN0aW9uIGhhbmRsZUJyZWFrKGUpe2lmKGVbJG5dKXJldHVybiExO2VbJG5dPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoImF1dG8iPT09ZS50YXJnZXRUeXBlKXJldHVybiExO2NvbnN0IHQ9ZVtsc10oKTtsZXQgYT1udWxsO2lmKGUudGFyZ2V0KXthPXRbanNdKGUudGFyZ2V0LGVbY3NdKCkpO2lmKCFhKXJldHVybiExO2E9YVswXX1jb25zdHtjdXJyZW50UGFnZUFyZWE6cixjdXJyZW50Q29udGVudEFyZWE6aX09dFskbl07aWYoInBhZ2VBcmVhIj09PWUudGFyZ2V0VHlwZSl7YSBpbnN0YW5jZW9mIFBhZ2VBcmVhfHwoYT1udWxsKTtpZihlLnN0YXJ0TmV3KXtlWyRuXS50YXJnZXQ9YXx8cjtyZXR1cm4hMH1pZihhJiZhIT09cil7ZVskbl0udGFyZ2V0PWE7cmV0dXJuITB9cmV0dXJuITF9YSBpbnN0YW5jZW9mIENvbnRlbnRBcmVhfHwoYT1udWxsKTtjb25zdCBuPWEmJmFbY3NdKCk7bGV0IHMsbz1uO2lmKGUuc3RhcnROZXcpaWYoYSl7Y29uc3QgZT1uLmNvbnRlbnRBcmVhLmNoaWxkcmVuLHQ9ZS5pbmRleE9mKGkpLHI9ZS5pbmRleE9mKGEpOy0xIT09dCYmdDxyJiYobz1udWxsKTtzPXItMX1lbHNlIHM9ci5jb250ZW50QXJlYS5jaGlsZHJlbi5pbmRleE9mKGkpO2Vsc2V7aWYoIWF8fGE9PT1pKXJldHVybiExO3M9bi5jb250ZW50QXJlYS5jaGlsZHJlbi5pbmRleE9mKGEpLTE7bz1uPT09cj9udWxsOm59ZVskbl0udGFyZ2V0PW87ZVskbl0uaW5kZXg9cztyZXR1cm4hMH1mdW5jdGlvbiBoYW5kbGVPdmVyZmxvdyhlLHQsYSl7Y29uc3Qgcj1lW2xzXSgpLGk9clskbl0ubm9MYXlvdXRGYWlsdXJlLG49dFtvc107dFtvc109KCk9PmU7clskbl0ubm9MYXlvdXRGYWlsdXJlPSEwO2NvbnN0IHM9dFt6c10oYSk7ZVtFbl0ocy5odG1sLHMuYmJveCk7clskbl0ubm9MYXlvdXRGYWlsdXJlPWk7dFtvc109bn1jbGFzcyBBcHBlYXJhbmNlRmlsdGVyIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJhcHBlYXJhbmNlRmlsdGVyIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBBcmMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImFyYyIsITApO3RoaXMuY2lyY3VsYXI9Z2V0SW50ZWdlcih7ZGF0YTplLmNpcmN1bGFyLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5oYW5kPWdldFN0cmluZ09wdGlvbihlLmhhbmQsWyJldmVuIiwibGVmdCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5zdGFydEFuZ2xlPWdldEZsb2F0KHtkYXRhOmUuc3RhcnRBbmdsZSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4hMH0pO3RoaXMuc3dlZXBBbmdsZT1nZXRGbG9hdCh7ZGF0YTplLnN3ZWVwQW5nbGUsZGVmYXVsdFZhbHVlOjM2MCx2YWxpZGF0ZTplPT4hMH0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmVkZ2U9bnVsbDt0aGlzLmZpbGw9bnVsbH1benNdKCl7Y29uc3QgZT10aGlzLmVkZ2V8fG5ldyBFZGdlKHt9KSx0PWVbR3NdKCksYT1PYmplY3QuY3JlYXRlKG51bGwpOyJ2aXNpYmxlIj09PXRoaXMuZmlsbD8ucHJlc2VuY2U/T2JqZWN0LmFzc2lnbihhLHRoaXMuZmlsbFtHc10oKSk6YS5maWxsPSJ0cmFuc3BhcmVudCI7YS5zdHJva2VXaWR0aD1tZWFzdXJlVG9TdHJpbmcoInZpc2libGUiPT09ZS5wcmVzZW5jZT9lLnRoaWNrbmVzczowKTthLnN0cm9rZT10LmNvbG9yO2xldCByO2NvbnN0IGk9e3htbG5zOkRvLHN0eWxlOnt3aWR0aDoiMTAwJSIsaGVpZ2h0OiIxMDAlIixvdmVyZmxvdzoidmlzaWJsZSJ9fTtpZigzNjA9PT10aGlzLnN3ZWVwQW5nbGUpcj17bmFtZToiZWxsaXBzZSIsYXR0cmlidXRlczp7eG1sbnM6RG8sY3g6IjUwJSIsY3k6IjUwJSIscng6IjUwJSIscnk6IjUwJSIsc3R5bGU6YX19O2Vsc2V7Y29uc3QgZT10aGlzLnN0YXJ0QW5nbGUqTWF0aC5QSS8xODAsdD10aGlzLnN3ZWVwQW5nbGUqTWF0aC5QSS8xODAsbj10aGlzLnN3ZWVwQW5nbGU+MTgwPzE6MCxbcyxvLGMsbF09WzUwKigxK01hdGguY29zKGUpKSw1MCooMS1NYXRoLnNpbihlKSksNTAqKDErTWF0aC5jb3MoZSt0KSksNTAqKDEtTWF0aC5zaW4oZSt0KSldO3I9e25hbWU6InBhdGgiLGF0dHJpYnV0ZXM6e3htbG5zOkRvLGQ6YE0gJHtzfSAke299IEEgNTAgNTAgMCAke259IDAgJHtjfSAke2x9YCx2ZWN0b3JFZmZlY3Q6Im5vbi1zY2FsaW5nLXN0cm9rZSIsc3R5bGU6YX19O09iamVjdC5hc3NpZ24oaSx7dmlld0JveDoiMCAwIDEwMCAxMDAiLHByZXNlcnZlQXNwZWN0UmF0aW86Im5vbmUifSl9Y29uc3Qgbj17bmFtZToic3ZnIixjaGlsZHJlbjpbcl0sYXR0cmlidXRlczppfTtpZihoYXNNYXJnaW4odGhpc1tjc10oKVtjc10oKSkpcmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixhdHRyaWJ1dGVzOntzdHlsZTp7ZGlzcGxheToiaW5saW5lIix3aWR0aDoiMTAwJSIsaGVpZ2h0OiIxMDAlIn19LGNoaWxkcmVuOltuXX0pO24uYXR0cmlidXRlcy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Mobil9fWNsYXNzIEFyZWEgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImFyZWEiLCEwKTt0aGlzLmNvbFNwYW49Z2V0SW50ZWdlcih7ZGF0YTplLmNvbFNwYW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ZT49MXx8LTE9PT1lfSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLng9Z2V0TWVhc3VyZW1lbnQoZS54LCIwcHQiKTt0aGlzLnk9Z2V0TWVhc3VyZW1lbnQoZS55LCIwcHQiKTt0aGlzLmRlc2M9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMuYXJlYT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kcmF3PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4T2JqZWN0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4Y2xHcm91cD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5maWVsZD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJmb3JtPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm1TZXQ9bmV3IFhGQU9iamVjdEFycmF5fSpbbnNdKCl7eWllbGQqZ2V0Q29udGFpbmVkQ2hpbGRyZW4odGhpcyl9W0FzXSgpe3JldHVybiEwfVttc10oKXtyZXR1cm4hMH1bRW5dKGUsdCl7Y29uc3RbYSxyLGksbl09dDt0aGlzWyRuXS53aWR0aD1NYXRoLm1heCh0aGlzWyRuXS53aWR0aCxhK2kpO3RoaXNbJG5dLmhlaWdodD1NYXRoLm1heCh0aGlzWyRuXS5oZWlnaHQscituKTt0aGlzWyRuXS5jaGlsZHJlbi5wdXNoKGUpfVtZbl0oKXtyZXR1cm4gdGhpc1skbl0uYXZhaWxhYmxlU3BhY2V9W3pzXShlKXtjb25zdCB0PXRvU3R5bGUodGhpcywicG9zaXRpb24iKSxhPXtzdHlsZTp0LGlkOnRoaXNbVnNdLGNsYXNzOlsieGZhQXJlYSJdfTtpc1ByaW50T25seSh0aGlzKSYmYS5jbGFzcy5wdXNoKCJ4ZmFQcmludE9ubHkiKTt0aGlzLm5hbWUmJihhLnhmYU5hbWU9dGhpcy5uYW1lKTtjb25zdCByPVtdO3RoaXNbJG5dPXtjaGlsZHJlbjpyLHdpZHRoOjAsaGVpZ2h0OjAsYXZhaWxhYmxlU3BhY2U6ZX07Y29uc3QgaT10aGlzW0xuXSh7ZmlsdGVyOm5ldyBTZXQoWyJhcmVhIiwiZHJhdyIsImZpZWxkIiwiZXhjbEdyb3VwIiwic3ViZm9ybSIsInN1YmZvcm1TZXQiXSksaW5jbHVkZTohMH0pO2lmKCFpLnN1Y2Nlc3Mpe2lmKGkuaXNCcmVhaygpKXJldHVybiBpO2RlbGV0ZSB0aGlzWyRuXTtyZXR1cm4gSFRNTFJlc3VsdC5GQUlMVVJFfXQud2lkdGg9bWVhc3VyZVRvU3RyaW5nKHRoaXNbJG5dLndpZHRoKTt0LmhlaWdodD1tZWFzdXJlVG9TdHJpbmcodGhpc1skbl0uaGVpZ2h0KTtjb25zdCBuPXtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6YSxjaGlsZHJlbjpyfSxzPVt0aGlzLngsdGhpcy55LHRoaXNbJG5dLndpZHRoLHRoaXNbJG5dLmhlaWdodF07ZGVsZXRlIHRoaXNbJG5dO3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3MobixzKX19Y2xhc3MgQXNzaXN0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJhc3Npc3QiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucm9sZT1lLnJvbGV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnNwZWFrPW51bGw7dGhpcy50b29sVGlwPW51bGx9W3pzXSgpe3JldHVybiB0aGlzLnRvb2xUaXA/LltIbl18fG51bGx9fWNsYXNzIEJhcmNvZGUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImJhcmNvZGUiLCEwKTt0aGlzLmNoYXJFbmNvZGluZz1nZXRLZXl3b3JkKHtkYXRhOmUuY2hhckVuY29kaW5nP2UuY2hhckVuY29kaW5nLnRvTG93ZXJDYXNlKCk6IiIsZGVmYXVsdFZhbHVlOiIiLHZhbGlkYXRlOmU9PlsidXRmLTgiLCJiaWctZml2ZSIsImZvbnRzcGVjaWZpYyIsImdiayIsImdiLTE4MDMwIiwiZ2ItMjMxMiIsImtzYy01NjAxIiwibm9uZSIsInNoaWZ0LWppcyIsInVjcy0yIiwidXRmLTE2Il0uaW5jbHVkZXMoZSl8fGUubWF0Y2goL2lzby04ODU5LVxkezJ9Lyl9KTt0aGlzLmNoZWNrc3VtPWdldFN0cmluZ09wdGlvbihlLmNoZWNrc3VtLFsibm9uZSIsIjFtb2QxMCIsIjFtb2QxMF8xbW9kMTEiLCIybW9kMTAiLCJhdXRvIl0pO3RoaXMuZGF0YUNvbHVtbkNvdW50PWdldEludGVnZXIoe2RhdGE6ZS5kYXRhQ29sdW1uQ291bnQsZGVmYXVsdFZhbHVlOi0xLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLmRhdGFMZW5ndGg9Z2V0SW50ZWdlcih7ZGF0YTplLmRhdGFMZW5ndGgsZGVmYXVsdFZhbHVlOi0xLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLmRhdGFQcmVwPWdldFN0cmluZ09wdGlvbihlLmRhdGFQcmVwLFsibm9uZSIsImZsYXRlQ29tcHJlc3MiXSk7dGhpcy5kYXRhUm93Q291bnQ9Z2V0SW50ZWdlcih7ZGF0YTplLmRhdGFSb3dDb3VudCxkZWZhdWx0VmFsdWU6LTEsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMuZW5kQ2hhcj1lLmVuZENoYXJ8fCIiO3RoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWw9Z2V0SW50ZWdlcih7ZGF0YTplLmVycm9yQ29ycmVjdGlvbkxldmVsLGRlZmF1bHRWYWx1ZTotMSx2YWxpZGF0ZTplPT5lPj0wJiZlPD04fSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm1vZHVsZUhlaWdodD1nZXRNZWFzdXJlbWVudChlLm1vZHVsZUhlaWdodCwiNW1tIik7dGhpcy5tb2R1bGVXaWR0aD1nZXRNZWFzdXJlbWVudChlLm1vZHVsZVdpZHRoLCIwLjI1bW0iKTt0aGlzLnByaW50Q2hlY2tEaWdpdD1nZXRJbnRlZ2VyKHtkYXRhOmUucHJpbnRDaGVja0RpZ2l0LGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5yb3dDb2x1bW5SYXRpbz1nZXRSYXRpbyhlLnJvd0NvbHVtblJhdGlvKTt0aGlzLnN0YXJ0Q2hhcj1lLnN0YXJ0Q2hhcnx8IiI7dGhpcy50ZXh0TG9jYXRpb249Z2V0U3RyaW5nT3B0aW9uKGUudGV4dExvY2F0aW9uLFsiYmVsb3ciLCJhYm92ZSIsImFib3ZlRW1iZWRkZWQiLCJiZWxvd0VtYmVkZGVkIiwibm9uZSJdKTt0aGlzLnRydW5jYXRlPWdldEludGVnZXIoe2RhdGE6ZS50cnVuY2F0ZSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlP2UudHlwZS50b0xvd2VyQ2FzZSgpOiIiLFsiYXp0ZWMiLCJjb2RhYmFyIiwiY29kZTJvZjVpbmR1c3RyaWFsIiwiY29kZTJvZjVpbnRlcmxlYXZlZCIsImNvZGUyb2Y1bWF0cml4IiwiY29kZTJvZjVzdGFuZGFyZCIsImNvZGUzb2Y5IiwiY29kZTNvZjlleHRlbmRlZCIsImNvZGUxMSIsImNvZGU0OSIsImNvZGU5MyIsImNvZGUxMjgiLCJjb2RlMTI4YSIsImNvZGUxMjhiIiwiY29kZTEyOGMiLCJjb2RlMTI4c3NjYyIsImRhdGFtYXRyaXgiLCJlYW44IiwiZWFuOGFkZDIiLCJlYW44YWRkNSIsImVhbjEzIiwiZWFuMTNhZGQyIiwiZWFuMTNhZGQ1IiwiZWFuMTNwd2NkIiwiZmltIiwibG9nbWFycyIsIm1heGljb2RlIiwibXNpIiwicGRmNDE3IiwicGRmNDE3bWFjcm8iLCJwbGVzc2V5IiwicG9zdGF1c2N1c3QyIiwicG9zdGF1c2N1c3QzIiwicG9zdGF1c3JlcGx5cGFpZCIsInBvc3RhdXNzdGFuZGFyZCIsInBvc3R1a3JtNHNjYyIsInBvc3R1c2RwYmMiLCJwb3N0dXNpbWIiLCJwb3N0dXNzdGFuZGFyZCIsInBvc3R1czV6aXAiLCJxcmNvZGUiLCJyZmlkIiwicnNzMTQiLCJyc3MxNGV4cGFuZGVkIiwicnNzMTRsaW1pdGVkIiwicnNzMTRzdGFja2VkIiwicnNzMTRzdGFja2Vkb21uaSIsInJzczE0dHJ1bmNhdGVkIiwidGVsZXBlbiIsInVjYzEyOCIsInVjYzEyOHJhbmRvbSIsInVjYzEyOHNzY2MiLCJ1cGNhIiwidXBjYWFkZDIiLCJ1cGNhYWRkNSIsInVwY2Fwd2NkIiwidXBjZSIsInVwY2VhZGQyIiwidXBjZWFkZDUiLCJ1cGNlYW4yIiwidXBjZWFuNSIsInVwc21heGljb2RlIl0pO3RoaXMudXBzTW9kZT1nZXRTdHJpbmdPcHRpb24oZS51cHNNb2RlLFsidXNDYXJyaWVyIiwiaW50ZXJuYXRpb25hbENhcnJpZXIiLCJzZWN1cmVTeW1ib2wiLCJzdGFuZGFyZFN5bWJvbCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy53aWRlTmFycm93UmF0aW89Z2V0UmF0aW8oZS53aWRlTmFycm93UmF0aW8pO3RoaXMuZW5jcnlwdD1udWxsO3RoaXMuZXh0cmFzPW51bGx9fWNsYXNzIEJpbmQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImJpbmQiLCEwKTt0aGlzLm1hdGNoPWdldFN0cmluZ09wdGlvbihlLm1hdGNoLFsib25jZSIsImRhdGFSZWYiLCJnbG9iYWwiLCJub25lIl0pO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnBpY3R1cmU9bnVsbH19Y2xhc3MgQmluZEl0ZW1zIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJiaW5kSXRlbXMiKTt0aGlzLmNvbm5lY3Rpb249ZS5jb25uZWN0aW9ufHwiIjt0aGlzLmxhYmVsUmVmPWUubGFiZWxSZWZ8fCIiO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnZhbHVlUmVmPWUudmFsdWVSZWZ8fCIifX1jbGFzcyBCb29rZW5kIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJib29rZW5kIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlYWRlcj1lLmxlYWRlcnx8IiI7dGhpcy50cmFpbGVyPWUudHJhaWxlcnx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBCb29sZWFuRWxlbWVudCBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJib29sZWFuIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W3pzXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwoMT09PXRoaXNbSG5dPyIxIjoiMCIpfX1jbGFzcyBCb3JkZXIgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImJvcmRlciIsITApO3RoaXMuYnJlYWs9Z2V0U3RyaW5nT3B0aW9uKGUuYnJlYWssWyJjbG9zZSIsIm9wZW4iXSk7dGhpcy5oYW5kPWdldFN0cmluZ09wdGlvbihlLmhhbmQsWyJldmVuIiwibGVmdCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5wcmVzZW5jZT1nZXRTdHJpbmdPcHRpb24oZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmNvcm5lcj1uZXcgWEZBT2JqZWN0QXJyYXkoNCk7dGhpcy5lZGdlPW5ldyBYRkFPYmplY3RBcnJheSg0KTt0aGlzLmV4dHJhcz1udWxsO3RoaXMuZmlsbD1udWxsO3RoaXMubWFyZ2luPW51bGx9W2FzXSgpe2lmKCF0aGlzWyRuXSl7Y29uc3QgZT10aGlzLmVkZ2UuY2hpbGRyZW4uc2xpY2UoKTtpZihlLmxlbmd0aDw0KXtjb25zdCB0PWUuYXQoLTEpfHxuZXcgRWRnZSh7fSk7Zm9yKGxldCBhPWUubGVuZ3RoO2E8NDthKyspZS5wdXNoKHQpfWNvbnN0IHQ9ZS5tYXAoKGU9PmUudGhpY2tuZXNzKSksYT1bMCwwLDAsMF07aWYodGhpcy5tYXJnaW4pe2FbMF09dGhpcy5tYXJnaW4udG9wSW5zZXQ7YVsxXT10aGlzLm1hcmdpbi5yaWdodEluc2V0O2FbMl09dGhpcy5tYXJnaW4uYm90dG9tSW5zZXQ7YVszXT10aGlzLm1hcmdpbi5sZWZ0SW5zZXR9dGhpc1skbl09e3dpZHRoczp0LGluc2V0czphLGVkZ2VzOmV9fXJldHVybiB0aGlzWyRuXX1bR3NdKCl7Y29uc3R7ZWRnZXM6ZX09dGhpc1thc10oKSx0PWUubWFwKChlPT57Y29uc3QgdD1lW0dzXSgpO3QuY29sb3J8fD0iIzAwMDAwMCI7cmV0dXJuIHR9KSksYT1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMubWFyZ2luJiZPYmplY3QuYXNzaWduKGEsdGhpcy5tYXJnaW5bR3NdKCkpOyJ2aXNpYmxlIj09PXRoaXMuZmlsbD8ucHJlc2VuY2UmJk9iamVjdC5hc3NpZ24oYSx0aGlzLmZpbGxbR3NdKCkpO2lmKHRoaXMuY29ybmVyLmNoaWxkcmVuLnNvbWUoKGU9PjAhPT1lLnJhZGl1cykpKXtjb25zdCBlPXRoaXMuY29ybmVyLmNoaWxkcmVuLm1hcCgoZT0+ZVtHc10oKSkpO2lmKDI9PT1lLmxlbmd0aHx8Mz09PWUubGVuZ3RoKXtjb25zdCB0PWUuYXQoLTEpO2ZvcihsZXQgYT1lLmxlbmd0aDthPDQ7YSsrKWUucHVzaCh0KX1hLmJvcmRlclJhZGl1cz1lLm1hcCgoZT0+ZS5yYWRpdXMpKS5qb2luKCIgIil9c3dpdGNoKHRoaXMucHJlc2VuY2Upe2Nhc2UiaW52aXNpYmxlIjpjYXNlImhpZGRlbiI6YS5ib3JkZXJTdHlsZT0iIjticmVhaztjYXNlImluYWN0aXZlIjphLmJvcmRlclN0eWxlPSJub25lIjticmVhaztkZWZhdWx0OmEuYm9yZGVyU3R5bGU9dC5tYXAoKGU9PmUuc3R5bGUpKS5qb2luKCIgIil9YS5ib3JkZXJXaWR0aD10Lm1hcCgoZT0+ZS53aWR0aCkpLmpvaW4oIiAiKTthLmJvcmRlckNvbG9yPXQubWFwKChlPT5lLmNvbG9yKSkuam9pbigiICIpO3JldHVybiBhfX1jbGFzcyBCcmVhayBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiYnJlYWsiLCEwKTt0aGlzLmFmdGVyPWdldFN0cmluZ09wdGlvbihlLmFmdGVyLFsiYXV0byIsImNvbnRlbnRBcmVhIiwicGFnZUFyZWEiLCJwYWdlRXZlbiIsInBhZ2VPZGQiXSk7dGhpcy5hZnRlclRhcmdldD1lLmFmdGVyVGFyZ2V0fHwiIjt0aGlzLmJlZm9yZT1nZXRTdHJpbmdPcHRpb24oZS5iZWZvcmUsWyJhdXRvIiwiY29udGVudEFyZWEiLCJwYWdlQXJlYSIsInBhZ2VFdmVuIiwicGFnZU9kZCJdKTt0aGlzLmJlZm9yZVRhcmdldD1lLmJlZm9yZVRhcmdldHx8IiI7dGhpcy5ib29rZW5kTGVhZGVyPWUuYm9va2VuZExlYWRlcnx8IiI7dGhpcy5ib29rZW5kVHJhaWxlcj1lLmJvb2tlbmRUcmFpbGVyfHwiIjt0aGlzLmlkPWUuaWR8fCIiO3RoaXMub3ZlcmZsb3dMZWFkZXI9ZS5vdmVyZmxvd0xlYWRlcnx8IiI7dGhpcy5vdmVyZmxvd1RhcmdldD1lLm92ZXJmbG93VGFyZ2V0fHwiIjt0aGlzLm92ZXJmbG93VHJhaWxlcj1lLm92ZXJmbG93VHJhaWxlcnx8IiI7dGhpcy5zdGFydE5ldz1nZXRJbnRlZ2VyKHtkYXRhOmUuc3RhcnROZXcsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbH19Y2xhc3MgQnJlYWtBZnRlciBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiYnJlYWtBZnRlciIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5sZWFkZXI9ZS5sZWFkZXJ8fCIiO3RoaXMuc3RhcnROZXc9Z2V0SW50ZWdlcih7ZGF0YTplLnN0YXJ0TmV3LGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy50YXJnZXQ9ZS50YXJnZXR8fCIiO3RoaXMudGFyZ2V0VHlwZT1nZXRTdHJpbmdPcHRpb24oZS50YXJnZXRUeXBlLFsiYXV0byIsImNvbnRlbnRBcmVhIiwicGFnZUFyZWEiXSk7dGhpcy50cmFpbGVyPWUudHJhaWxlcnx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuc2NyaXB0PW51bGx9fWNsYXNzIEJyZWFrQmVmb3JlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJicmVha0JlZm9yZSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5sZWFkZXI9ZS5sZWFkZXJ8fCIiO3RoaXMuc3RhcnROZXc9Z2V0SW50ZWdlcih7ZGF0YTplLnN0YXJ0TmV3LGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy50YXJnZXQ9ZS50YXJnZXR8fCIiO3RoaXMudGFyZ2V0VHlwZT1nZXRTdHJpbmdPcHRpb24oZS50YXJnZXRUeXBlLFsiYXV0byIsImNvbnRlbnRBcmVhIiwicGFnZUFyZWEiXSk7dGhpcy50cmFpbGVyPWUudHJhaWxlcnx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuc2NyaXB0PW51bGx9W3pzXShlKXt0aGlzWyRuXT17fTtyZXR1cm4gSFRNTFJlc3VsdC5GQUlMVVJFfX1jbGFzcyBCdXR0b24gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImJ1dHRvbiIsITApO3RoaXMuaGlnaGxpZ2h0PWdldFN0cmluZ09wdGlvbihlLmhpZ2hsaWdodCxbImludmVydGVkIiwibm9uZSIsIm91dGxpbmUiLCJwdXNoIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGx9W3pzXShlKXtjb25zdCB0PXRoaXNbY3NdKClbY3NdKCksYT17bmFtZToiYnV0dG9uIixhdHRyaWJ1dGVzOntpZDp0aGlzW1ZzXSxjbGFzczpbInhmYUJ1dHRvbiJdLHN0eWxlOnt9fSxjaGlsZHJlbjpbXX07Zm9yKGNvbnN0IGUgb2YgdC5ldmVudC5jaGlsZHJlbil7aWYoImNsaWNrIiE9PWUuYWN0aXZpdHl8fCFlLnNjcmlwdCljb250aW51ZTtjb25zdCB0PXJlY292ZXJKc1VSTChlLnNjcmlwdFtIbl0pO2lmKCF0KWNvbnRpbnVlO2NvbnN0IHI9Zml4VVJMKHQudXJsKTtyJiZhLmNoaWxkcmVuLnB1c2goe25hbWU6ImEiLGF0dHJpYnV0ZXM6e2lkOiJsaW5rIit0aGlzW1ZzXSxocmVmOnIsbmV3V2luZG93OnQubmV3V2luZG93LGNsYXNzOlsieGZhTGluayJdLHN0eWxlOnt9fSxjaGlsZHJlbjpbXX0pfXJldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3MoYSl9fWNsYXNzIENhbGN1bGF0ZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiY2FsY3VsYXRlIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm92ZXJyaWRlPWdldFN0cmluZ09wdGlvbihlLm92ZXJyaWRlLFsiZGlzYWJsZWQiLCJlcnJvciIsImlnbm9yZSIsIndhcm5pbmciXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tZXNzYWdlPW51bGw7dGhpcy5zY3JpcHQ9bnVsbH19Y2xhc3MgQ2FwdGlvbiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiY2FwdGlvbiIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5wbGFjZW1lbnQ9Z2V0U3RyaW5nT3B0aW9uKGUucGxhY2VtZW50LFsibGVmdCIsImJvdHRvbSIsImlubGluZSIsInJpZ2h0IiwidG9wIl0pO3RoaXMucHJlc2VuY2U9Z2V0U3RyaW5nT3B0aW9uKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5yZXNlcnZlPU1hdGguY2VpbChnZXRNZWFzdXJlbWVudChlLnJlc2VydmUpKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmZvbnQ9bnVsbDt0aGlzLm1hcmdpbj1udWxsO3RoaXMucGFyYT1udWxsO3RoaXMudmFsdWU9bnVsbH1bWHNdKGUpe19zZXRWYWx1ZSh0aGlzLGUpfVthc10oZSl7aWYoIXRoaXNbJG5dKXtsZXR7d2lkdGg6dCxoZWlnaHQ6YX09ZTtzd2l0Y2godGhpcy5wbGFjZW1lbnQpe2Nhc2UibGVmdCI6Y2FzZSJyaWdodCI6Y2FzZSJpbmxpbmUiOnQ9dGhpcy5yZXNlcnZlPD0wP3Q6dGhpcy5yZXNlcnZlO2JyZWFrO2Nhc2UidG9wIjpjYXNlImJvdHRvbSI6YT10aGlzLnJlc2VydmU8PTA/YTp0aGlzLnJlc2VydmV9dGhpc1skbl09bGF5b3V0Tm9kZSh0aGlzLHt3aWR0aDp0LGhlaWdodDphfSl9cmV0dXJuIHRoaXNbJG5dfVt6c10oZSl7aWYoIXRoaXMudmFsdWUpcmV0dXJuIEhUTUxSZXN1bHQuRU1QVFk7dGhpc1tSc10oKTtjb25zdCB0PXRoaXMudmFsdWVbenNdKGUpLmh0bWw7aWYoIXQpe3RoaXNbQnNdKCk7cmV0dXJuIEhUTUxSZXN1bHQuRU1QVFl9Y29uc3QgYT10aGlzLnJlc2VydmU7aWYodGhpcy5yZXNlcnZlPD0wKXtjb25zdHt3OnQsaDphfT10aGlzW2FzXShlKTtzd2l0Y2godGhpcy5wbGFjZW1lbnQpe2Nhc2UibGVmdCI6Y2FzZSJyaWdodCI6Y2FzZSJpbmxpbmUiOnRoaXMucmVzZXJ2ZT10O2JyZWFrO2Nhc2UidG9wIjpjYXNlImJvdHRvbSI6dGhpcy5yZXNlcnZlPWF9fWNvbnN0IHI9W107InN0cmluZyI9PXR5cGVvZiB0P3IucHVzaCh7bmFtZToiI3RleHQiLHZhbHVlOnR9KTpyLnB1c2godCk7Y29uc3QgaT10b1N0eWxlKHRoaXMsImZvbnQiLCJtYXJnaW4iLCJ2aXNpYmlsaXR5Iik7c3dpdGNoKHRoaXMucGxhY2VtZW50KXtjYXNlImxlZnQiOmNhc2UicmlnaHQiOnRoaXMucmVzZXJ2ZT4wJiYoaS53aWR0aD1tZWFzdXJlVG9TdHJpbmcodGhpcy5yZXNlcnZlKSk7YnJlYWs7Y2FzZSJ0b3AiOmNhc2UiYm90dG9tIjp0aGlzLnJlc2VydmU+MCYmKGkuaGVpZ2h0PW1lYXN1cmVUb1N0cmluZyh0aGlzLnJlc2VydmUpKX1zZXRQYXJhKHRoaXMsbnVsbCx0KTt0aGlzW0JzXSgpO3RoaXMucmVzZXJ2ZT1hO3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsYXR0cmlidXRlczp7c3R5bGU6aSxjbGFzczpbInhmYUNhcHRpb24iXX0sY2hpbGRyZW46cn0pfX1jbGFzcyBDZXJ0aWZpY2F0ZSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiY2VydGlmaWNhdGUiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgQ2VydGlmaWNhdGVzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJjZXJ0aWZpY2F0ZXMiLCEwKTt0aGlzLmNyZWRlbnRpYWxTZXJ2ZXJQb2xpY3k9Z2V0U3RyaW5nT3B0aW9uKGUuY3JlZGVudGlhbFNlcnZlclBvbGljeSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVybD1lLnVybHx8IiI7dGhpcy51cmxQb2xpY3k9ZS51cmxQb2xpY3l8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmVuY3J5cHRpb249bnVsbDt0aGlzLmlzc3VlcnM9bnVsbDt0aGlzLmtleVVzYWdlPW51bGw7dGhpcy5vaWRzPW51bGw7dGhpcy5zaWduaW5nPW51bGw7dGhpcy5zdWJqZWN0RE5zPW51bGx9fWNsYXNzIENoZWNrQnV0dG9uIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJjaGVja0J1dHRvbiIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5tYXJrPWdldFN0cmluZ09wdGlvbihlLm1hcmssWyJkZWZhdWx0IiwiY2hlY2siLCJjaXJjbGUiLCJjcm9zcyIsImRpYW1vbmQiLCJzcXVhcmUiLCJzdGFyIl0pO3RoaXMuc2hhcGU9Z2V0U3RyaW5nT3B0aW9uKGUuc2hhcGUsWyJzcXVhcmUiLCJyb3VuZCJdKTt0aGlzLnNpemU9Z2V0TWVhc3VyZW1lbnQoZS5zaXplLCIxMHB0Iik7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsfVt6c10oZSl7Y29uc3QgdD10b1N0eWxlKHRoaXMsIm1hcmdpbiIpLGE9bWVhc3VyZVRvU3RyaW5nKHRoaXMuc2l6ZSk7dC53aWR0aD10LmhlaWdodD1hO2xldCByLGksbjtjb25zdCBzPXRoaXNbY3NdKClbY3NdKCksbz1zLml0ZW1zLmNoaWxkcmVuLmxlbmd0aCYmcy5pdGVtcy5jaGlsZHJlblswXVt6c10oKS5odG1sfHxbXSxjPXtvbjoodm9pZCAwIT09b1swXT9vWzBdOiJvbiIpLnRvU3RyaW5nKCksb2ZmOih2b2lkIDAhPT1vWzFdP29bMV06Im9mZiIpLnRvU3RyaW5nKCl9LGw9KHMudmFsdWU/LltIc10oKXx8Im9mZiIpPT09Yy5vbnx8dm9pZCAwLGg9c1tvc10oKSx1PXNbVnNdO2xldCBkO2lmKGggaW5zdGFuY2VvZiBFeGNsR3JvdXApe249aFtWc107cj0icmFkaW8iO2k9InhmYVJhZGlvIjtkPWhbV25dPy5bVnNdfHxoW1ZzXX1lbHNle3I9ImNoZWNrYm94IjtpPSJ4ZmFDaGVja2JveCI7ZD1zW1duXT8uW1ZzXXx8c1tWc119Y29uc3QgZj17bmFtZToiaW5wdXQiLGF0dHJpYnV0ZXM6e2NsYXNzOltpXSxzdHlsZTp0LGZpZWxkSWQ6dSxkYXRhSWQ6ZCx0eXBlOnIsY2hlY2tlZDpsLHhmYU9uOmMub24seGZhT2ZmOmMub2ZmLCJhcmlhLWxhYmVsIjphcmlhTGFiZWwocyksImFyaWEtcmVxdWlyZWQiOiExfX07biYmKGYuYXR0cmlidXRlcy5uYW1lPW4pO2lmKGlzUmVxdWlyZWQocykpe2YuYXR0cmlidXRlc1siYXJpYS1yZXF1aXJlZCJdPSEwO2YuYXR0cmlidXRlcy5yZXF1aXJlZD0hMH1yZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJsYWJlbCIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFMYWJlbCJdfSxjaGlsZHJlbjpbZl19KX19Y2xhc3MgQ2hvaWNlTGlzdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiY2hvaWNlTGlzdCIsITApO3RoaXMuY29tbWl0T249Z2V0U3RyaW5nT3B0aW9uKGUuY29tbWl0T24sWyJzZWxlY3QiLCJleGl0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vcGVuPWdldFN0cmluZ09wdGlvbihlLm9wZW4sWyJ1c2VyQ29udHJvbCIsImFsd2F5cyIsIm11bHRpU2VsZWN0Iiwib25FbnRyeSJdKTt0aGlzLnRleHRFbnRyeT1nZXRJbnRlZ2VyKHtkYXRhOmUudGV4dEVudHJ5LGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsfVt6c10oZSl7Y29uc3QgdD10b1N0eWxlKHRoaXMsImJvcmRlciIsIm1hcmdpbiIpLGE9dGhpc1tjc10oKVtjc10oKSxyPXtmb250U2l6ZTpgY2FsYygke2EuZm9udD8uc2l6ZXx8MTB9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWB9LGk9W107aWYoYS5pdGVtcy5jaGlsZHJlbi5sZW5ndGg+MCl7Y29uc3QgZT1hLml0ZW1zO2xldCB0PTAsbj0wO2lmKDI9PT1lLmNoaWxkcmVuLmxlbmd0aCl7dD1lLmNoaWxkcmVuWzBdLnNhdmU7bj0xLXR9Y29uc3Qgcz1lLmNoaWxkcmVuW3RdW3pzXSgpLmh0bWwsbz1lLmNoaWxkcmVuW25dW3pzXSgpLmh0bWw7bGV0IGM9ITE7Y29uc3QgbD1hLnZhbHVlPy5bSHNdKCl8fCIiO2ZvcihsZXQgZT0wLHQ9cy5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD17bmFtZToib3B0aW9uIixhdHRyaWJ1dGVzOnt2YWx1ZTpvW2VdfHxzW2VdLHN0eWxlOnJ9LHZhbHVlOnNbZV19O29bZV09PT1sJiYodC5hdHRyaWJ1dGVzLnNlbGVjdGVkPWM9ITApO2kucHVzaCh0KX1jfHxpLnNwbGljZSgwLDAse25hbWU6Im9wdGlvbiIsYXR0cmlidXRlczp7aGlkZGVuOiEwLHNlbGVjdGVkOiEwfSx2YWx1ZToiICJ9KX1jb25zdCBuPXtjbGFzczpbInhmYVNlbGVjdCJdLGZpZWxkSWQ6YVtWc10sZGF0YUlkOmFbV25dPy5bVnNdfHxhW1ZzXSxzdHlsZTp0LCJhcmlhLWxhYmVsIjphcmlhTGFiZWwoYSksImFyaWEtcmVxdWlyZWQiOiExfTtpZihpc1JlcXVpcmVkKGEpKXtuWyJhcmlhLXJlcXVpcmVkIl09ITA7bi5yZXF1aXJlZD0hMH0ibXVsdGlTZWxlY3QiPT09dGhpcy5vcGVuJiYobi5tdWx0aXBsZT0hMCk7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToibGFiZWwiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhTGFiZWwiXX0sY2hpbGRyZW46W3tuYW1lOiJzZWxlY3QiLGNoaWxkcmVuOmksYXR0cmlidXRlczpufV19KX19Y2xhc3MgQ29sb3IgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImNvbG9yIiwhMCk7dGhpcy5jU3BhY2U9Z2V0U3RyaW5nT3B0aW9uKGUuY1NwYWNlLFsiU1JHQiJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnZhbHVlPWUudmFsdWU/ZnVuY3Rpb24gZ2V0Q29sb3IoZSx0PVswLDAsMF0pe2xldFthLHIsaV09dDtpZighZSlyZXR1cm57cjphLGc6cixiOml9O2NvbnN0IG49ZS5zcGxpdCgiLCIsMykubWFwKChlPT5NYXRoQ2xhbXAocGFyc2VJbnQoZS50cmltKCksMTApLDAsMjU1KSkpLm1hcCgoZT0+aXNOYU4oZSk/MDplKSk7aWYobi5sZW5ndGg8MylyZXR1cm57cjphLGc6cixiOml9O1thLHIsaV09bjtyZXR1cm57cjphLGc6cixiOml9fShlLnZhbHVlKToiIjt0aGlzLmV4dHJhcz1udWxsfVt1c10oKXtyZXR1cm4hMX1bR3NdKCl7cmV0dXJuIHRoaXMudmFsdWU/VXRpbC5tYWtlSGV4Q29sb3IodGhpcy52YWx1ZS5yLHRoaXMudmFsdWUuZyx0aGlzLnZhbHVlLmIpOm51bGx9fWNsYXNzIENvbWIgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImNvbWIiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubnVtYmVyT2ZDZWxscz1nZXRJbnRlZ2VyKHtkYXRhOmUubnVtYmVyT2ZDZWxscyxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBDb25uZWN0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJjb25uZWN0IiwhMCk7dGhpcy5jb25uZWN0aW9uPWUuY29ubmVjdGlvbnx8IiI7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnJlZj1lLnJlZnx8IiI7dGhpcy51c2FnZT1nZXRTdHJpbmdPcHRpb24oZS51c2FnZSxbImV4cG9ydEFuZEltcG9ydCIsImV4cG9ydE9ubHkiLCJpbXBvcnRPbmx5Il0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnBpY3R1cmU9bnVsbH19Y2xhc3MgQ29udGVudEFyZWEgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImNvbnRlbnRBcmVhIiwhMCk7dGhpcy5oPWdldE1lYXN1cmVtZW50KGUuaCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnc9Z2V0TWVhc3VyZW1lbnQoZS53KTt0aGlzLng9Z2V0TWVhc3VyZW1lbnQoZS54LCIwcHQiKTt0aGlzLnk9Z2V0TWVhc3VyZW1lbnQoZS55LCIwcHQiKTt0aGlzLmRlc2M9bnVsbDt0aGlzLmV4dHJhcz1udWxsfVt6c10oZSl7Y29uc3QgdD17bGVmdDptZWFzdXJlVG9TdHJpbmcodGhpcy54KSx0b3A6bWVhc3VyZVRvU3RyaW5nKHRoaXMueSksd2lkdGg6bWVhc3VyZVRvU3RyaW5nKHRoaXMudyksaGVpZ2h0Om1lYXN1cmVUb1N0cmluZyh0aGlzLmgpfSxhPVsieGZhQ29udGVudGFyZWEiXTtpc1ByaW50T25seSh0aGlzKSYmYS5wdXNoKCJ4ZmFQcmludE9ubHkiKTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGNoaWxkcmVuOltdLGF0dHJpYnV0ZXM6e3N0eWxlOnQsY2xhc3M6YSxpZDp0aGlzW1ZzXX19KX19Y2xhc3MgQ29ybmVyIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJjb3JuZXIiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMuaW52ZXJ0ZWQ9Z2V0SW50ZWdlcih7ZGF0YTplLmludmVydGVkLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5qb2luPWdldFN0cmluZ09wdGlvbihlLmpvaW4sWyJzcXVhcmUiLCJyb3VuZCJdKTt0aGlzLnByZXNlbmNlPWdldFN0cmluZ09wdGlvbihlLnByZXNlbmNlLFsidmlzaWJsZSIsImhpZGRlbiIsImluYWN0aXZlIiwiaW52aXNpYmxlIl0pO3RoaXMucmFkaXVzPWdldE1lYXN1cmVtZW50KGUucmFkaXVzKTt0aGlzLnN0cm9rZT1nZXRTdHJpbmdPcHRpb24oZS5zdHJva2UsWyJzb2xpZCIsImRhc2hEb3QiLCJkYXNoRG90RG90IiwiZGFzaGVkIiwiZG90dGVkIiwiZW1ib3NzZWQiLCJldGNoZWQiLCJsb3dlcmVkIiwicmFpc2VkIl0pO3RoaXMudGhpY2tuZXNzPWdldE1lYXN1cmVtZW50KGUudGhpY2tuZXNzLCIwLjVwdCIpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmNvbG9yPW51bGw7dGhpcy5leHRyYXM9bnVsbH1bR3NdKCl7Y29uc3QgZT10b1N0eWxlKHRoaXMsInZpc2liaWxpdHkiKTtlLnJhZGl1cz1tZWFzdXJlVG9TdHJpbmcoInNxdWFyZSI9PT10aGlzLmpvaW4/MDp0aGlzLnJhZGl1cyk7cmV0dXJuIGV9fWNsYXNzIERhdGVFbGVtZW50IGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiZGF0ZSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtHbl0oKXtjb25zdCBlPXRoaXNbSG5dLnRyaW0oKTt0aGlzW0huXT1lP25ldyBEYXRlKGUpOm51bGx9W3pzXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwodGhpc1tIbl0/dGhpc1tIbl0udG9TdHJpbmcoKToiIil9fWNsYXNzIERhdGVUaW1lIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiZGF0ZVRpbWUiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn1bR25dKCl7Y29uc3QgZT10aGlzW0huXS50cmltKCk7dGhpc1tIbl09ZT9uZXcgRGF0ZShlKTpudWxsfVt6c10oZSl7cmV0dXJuIHZhbHVlVG9IdG1sKHRoaXNbSG5dP3RoaXNbSG5dLnRvU3RyaW5nKCk6IiIpfX1jbGFzcyBEYXRlVGltZUVkaXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImRhdGVUaW1lRWRpdCIsITApO3RoaXMuaFNjcm9sbFBvbGljeT1nZXRTdHJpbmdPcHRpb24oZS5oU2Nyb2xsUG9saWN5LFsiYXV0byIsIm9mZiIsIm9uIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5waWNrZXI9Z2V0U3RyaW5nT3B0aW9uKGUucGlja2VyLFsiaG9zdCIsIm5vbmUiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5jb21iPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsfVt6c10oZSl7Y29uc3QgdD10b1N0eWxlKHRoaXMsImJvcmRlciIsImZvbnQiLCJtYXJnaW4iKSxhPXRoaXNbY3NdKClbY3NdKCkscj17bmFtZToiaW5wdXQiLGF0dHJpYnV0ZXM6e3R5cGU6InRleHQiLGZpZWxkSWQ6YVtWc10sZGF0YUlkOmFbV25dPy5bVnNdfHxhW1ZzXSxjbGFzczpbInhmYVRleHRmaWVsZCJdLHN0eWxlOnQsImFyaWEtbGFiZWwiOmFyaWFMYWJlbChhKSwiYXJpYS1yZXF1aXJlZCI6ITF9fTtpZihpc1JlcXVpcmVkKGEpKXtyLmF0dHJpYnV0ZXNbImFyaWEtcmVxdWlyZWQiXT0hMDtyLmF0dHJpYnV0ZXMucmVxdWlyZWQ9ITB9cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToibGFiZWwiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhTGFiZWwiXX0sY2hpbGRyZW46W3JdfSl9fWNsYXNzIERlY2ltYWwgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJkZWNpbWFsIik7dGhpcy5mcmFjRGlnaXRzPWdldEludGVnZXIoe2RhdGE6ZS5mcmFjRGlnaXRzLGRlZmF1bHRWYWx1ZToyLHZhbGlkYXRlOmU9PiEwfSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlYWREaWdpdHM9Z2V0SW50ZWdlcih7ZGF0YTplLmxlYWREaWdpdHMsZGVmYXVsdFZhbHVlOi0xLHZhbGlkYXRlOmU9PiEwfSk7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtHbl0oKXtjb25zdCBlPXBhcnNlRmxvYXQodGhpc1tIbl0udHJpbSgpKTt0aGlzW0huXT1pc05hTihlKT9udWxsOmV9W3pzXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwobnVsbCE9PXRoaXNbSG5dP3RoaXNbSG5dLnRvU3RyaW5nKCk6IiIpfX1jbGFzcyBEZWZhdWx0VWkgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImRlZmF1bHRVaSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGx9fWNsYXNzIERlc2MgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImRlc2MiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvb2xlYW49bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlVGltZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kZWNpbWFsPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4RGF0YT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5mbG9hdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbWFnZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbnRlZ2VyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRleHQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGltZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIERpZ2VzdE1ldGhvZCBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiZGlnZXN0TWV0aG9kIixbIiIsIlNIQTEiLCJTSEEyNTYiLCJTSEE1MTIiLCJSSVBFTUQxNjAiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIERpZ2VzdE1ldGhvZHMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImRpZ2VzdE1ldGhvZHMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5kaWdlc3RNZXRob2Q9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBEcmF3IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJkcmF3IiwhMCk7dGhpcy5hbmNob3JUeXBlPWdldFN0cmluZ09wdGlvbihlLmFuY2hvclR5cGUsWyJ0b3BMZWZ0IiwiYm90dG9tQ2VudGVyIiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwibWlkZGxlQ2VudGVyIiwibWlkZGxlTGVmdCIsIm1pZGRsZVJpZ2h0IiwidG9wQ2VudGVyIiwidG9wUmlnaHQiXSk7dGhpcy5jb2xTcGFuPWdldEludGVnZXIoe2RhdGE6ZS5jb2xTcGFuLGRlZmF1bHRWYWx1ZToxLHZhbGlkYXRlOmU9PmU+PTF8fC0xPT09ZX0pO3RoaXMuaD1lLmg/Z2V0TWVhc3VyZW1lbnQoZS5oKToiIjt0aGlzLmhBbGlnbj1nZXRTdHJpbmdPcHRpb24oZS5oQWxpZ24sWyJsZWZ0IiwiY2VudGVyIiwianVzdGlmeSIsImp1c3RpZnlBbGwiLCJyYWRpeCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5sb2NhbGU9ZS5sb2NhbGV8fCIiO3RoaXMubWF4SD1nZXRNZWFzdXJlbWVudChlLm1heEgsIjBwdCIpO3RoaXMubWF4Vz1nZXRNZWFzdXJlbWVudChlLm1heFcsIjBwdCIpO3RoaXMubWluSD1nZXRNZWFzdXJlbWVudChlLm1pbkgsIjBwdCIpO3RoaXMubWluVz1nZXRNZWFzdXJlbWVudChlLm1pblcsIjBwdCIpO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucHJlc2VuY2U9Z2V0U3RyaW5nT3B0aW9uKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5yZWxldmFudD1nZXRSZWxldmFudChlLnJlbGV2YW50KTt0aGlzLnJvdGF0ZT1nZXRJbnRlZ2VyKHtkYXRhOmUucm90YXRlLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PmUlOTA9PTB9KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy53PWUudz9nZXRNZWFzdXJlbWVudChlLncpOiIiO3RoaXMueD1nZXRNZWFzdXJlbWVudChlLngsIjBwdCIpO3RoaXMueT1nZXRNZWFzdXJlbWVudChlLnksIjBwdCIpO3RoaXMuYXNzaXN0PW51bGw7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmNhcHRpb249bnVsbDt0aGlzLmRlc2M9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMuZm9udD1udWxsO3RoaXMua2VlcD1udWxsO3RoaXMubWFyZ2luPW51bGw7dGhpcy5wYXJhPW51bGw7dGhpcy50cmF2ZXJzYWw9bnVsbDt0aGlzLnVpPW51bGw7dGhpcy52YWx1ZT1udWxsO3RoaXMuc2V0UHJvcGVydHk9bmV3IFhGQU9iamVjdEFycmF5fVtYc10oZSl7X3NldFZhbHVlKHRoaXMsZSl9W3pzXShlKXtzZXRUYWJJbmRleCh0aGlzKTtpZigiaGlkZGVuIj09PXRoaXMucHJlc2VuY2V8fCJpbmFjdGl2ZSI9PT10aGlzLnByZXNlbmNlKXJldHVybiBIVE1MUmVzdWx0LkVNUFRZO2ZpeERpbWVuc2lvbnModGhpcyk7dGhpc1tSc10oKTtjb25zdCB0PXRoaXMudyxhPXRoaXMuaCx7dzpyLGg6aSxpc0Jyb2tlbjpufT1sYXlvdXROb2RlKHRoaXMsZSk7aWYociYmIiI9PT10aGlzLncpe2lmKG4mJnRoaXNbb3NdKClbU3NdKCkpe3RoaXNbQnNdKCk7cmV0dXJuIEhUTUxSZXN1bHQuRkFJTFVSRX10aGlzLnc9cn1pJiYiIj09PXRoaXMuaCYmKHRoaXMuaD1pKTtzZXRGaXJzdFVuc3BsaXR0YWJsZSh0aGlzKTtpZighY2hlY2tEaW1lbnNpb25zKHRoaXMsZSkpe3RoaXMudz10O3RoaXMuaD1hO3RoaXNbQnNdKCk7cmV0dXJuIEhUTUxSZXN1bHQuRkFJTFVSRX11bnNldEZpcnN0VW5zcGxpdHRhYmxlKHRoaXMpO2NvbnN0IHM9dG9TdHlsZSh0aGlzLCJmb250IiwiaEFsaWduIiwiZGltZW5zaW9ucyIsInBvc2l0aW9uIiwicHJlc2VuY2UiLCJyb3RhdGUiLCJhbmNob3JUeXBlIiwiYm9yZGVyIiwibWFyZ2luIik7c2V0TWluTWF4RGltZW5zaW9ucyh0aGlzLHMpO2lmKHMubWFyZ2luKXtzLnBhZGRpbmc9cy5tYXJnaW47ZGVsZXRlIHMubWFyZ2lufWNvbnN0IG89WyJ4ZmFEcmF3Il07dGhpcy5mb250JiZvLnB1c2goInhmYUZvbnQiKTtpc1ByaW50T25seSh0aGlzKSYmby5wdXNoKCJ4ZmFQcmludE9ubHkiKTtjb25zdCBjPXtzdHlsZTpzLGlkOnRoaXNbVnNdLGNsYXNzOm99O3RoaXMubmFtZSYmKGMueGZhTmFtZT10aGlzLm5hbWUpO2NvbnN0IGw9e25hbWU6ImRpdiIsYXR0cmlidXRlczpjLGNoaWxkcmVuOltdfTthcHBseUFzc2lzdCh0aGlzLGMpO2NvbnN0IGg9Y29tcHV0ZUJib3godGhpcyxsLGUpLHU9dGhpcy52YWx1ZT90aGlzLnZhbHVlW3pzXShlKS5odG1sOm51bGw7aWYobnVsbD09PXUpe3RoaXMudz10O3RoaXMuaD1hO3RoaXNbQnNdKCk7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhjcmVhdGVXcmFwcGVyKHRoaXMsbCksaCl9bC5jaGlsZHJlbi5wdXNoKHUpO3NldFBhcmEodGhpcyxzLHUpO3RoaXMudz10O3RoaXMuaD1hO3RoaXNbQnNdKCk7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhjcmVhdGVXcmFwcGVyKHRoaXMsbCksaCl9fWNsYXNzIEVkZ2UgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImVkZ2UiLCEwKTt0aGlzLmNhcD1nZXRTdHJpbmdPcHRpb24oZS5jYXAsWyJzcXVhcmUiLCJidXR0Iiwicm91bmQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnByZXNlbmNlPWdldFN0cmluZ09wdGlvbihlLnByZXNlbmNlLFsidmlzaWJsZSIsImhpZGRlbiIsImluYWN0aXZlIiwiaW52aXNpYmxlIl0pO3RoaXMuc3Ryb2tlPWdldFN0cmluZ09wdGlvbihlLnN0cm9rZSxbInNvbGlkIiwiZGFzaERvdCIsImRhc2hEb3REb3QiLCJkYXNoZWQiLCJkb3R0ZWQiLCJlbWJvc3NlZCIsImV0Y2hlZCIsImxvd2VyZWQiLCJyYWlzZWQiXSk7dGhpcy50aGlja25lc3M9Z2V0TWVhc3VyZW1lbnQoZS50aGlja25lc3MsIjAuNXB0Iik7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsfVtHc10oKXtjb25zdCBlPXRvU3R5bGUodGhpcywidmlzaWJpbGl0eSIpO09iamVjdC5hc3NpZ24oZSx7bGluZWNhcDp0aGlzLmNhcCx3aWR0aDptZWFzdXJlVG9TdHJpbmcodGhpcy50aGlja25lc3MpLGNvbG9yOnRoaXMuY29sb3I/dGhpcy5jb2xvcltHc10oKToiIzAwMDAwMCIsc3R5bGU6IiJ9KTtpZigidmlzaWJsZSIhPT10aGlzLnByZXNlbmNlKWUuc3R5bGU9Im5vbmUiO2Vsc2Ugc3dpdGNoKHRoaXMuc3Ryb2tlKXtjYXNlInNvbGlkIjplLnN0eWxlPSJzb2xpZCI7YnJlYWs7Y2FzZSJkYXNoRG90IjpjYXNlImRhc2hEb3REb3QiOmNhc2UiZGFzaGVkIjplLnN0eWxlPSJkYXNoZWQiO2JyZWFrO2Nhc2UiZG90dGVkIjplLnN0eWxlPSJkb3R0ZWQiO2JyZWFrO2Nhc2UiZW1ib3NzZWQiOmUuc3R5bGU9InJpZGdlIjticmVhaztjYXNlImV0Y2hlZCI6ZS5zdHlsZT0iZ3Jvb3ZlIjticmVhaztjYXNlImxvd2VyZWQiOmUuc3R5bGU9Imluc2V0IjticmVhaztjYXNlInJhaXNlZCI6ZS5zdHlsZT0ib3V0c2V0In1yZXR1cm4gZX19Y2xhc3MgRW5jb2RpbmcgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImVuY29kaW5nIixbImFkYmUueDUwOS5yc2Ffc2hhMSIsImFkYmUucGtjczcuZGV0YWNoZWQiLCJhZGJlLnBrY3M3LnNoYTEiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIEVuY29kaW5ncyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiZW5jb2RpbmdzIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZW5jb2Rpbmc9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBFbmNyeXB0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJlbmNyeXB0IiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jZXJ0aWZpY2F0ZT1udWxsfX1jbGFzcyBFbmNyeXB0RGF0YSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiZW5jcnlwdERhdGEiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMub3BlcmF0aW9uPWdldFN0cmluZ09wdGlvbihlLm9wZXJhdGlvbixbImVuY3J5cHQiLCJkZWNyeXB0Il0pO3RoaXMudGFyZ2V0PWUudGFyZ2V0fHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5maWx0ZXI9bnVsbDt0aGlzLm1hbmlmZXN0PW51bGx9fWNsYXNzIEVuY3J5cHRpb24gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImVuY3J5cHRpb24iLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jZXJ0aWZpY2F0ZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEVuY3J5cHRpb25NZXRob2QgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImVuY3J5cHRpb25NZXRob2QiLFsiIiwiQUVTMjU2LUNCQyIsIlRSSVBMRURFUy1DQkMiLCJBRVMxMjgtQ0JDIiwiQUVTMTkyLUNCQyJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgRW5jcnlwdGlvbk1ldGhvZHMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImVuY3J5cHRpb25NZXRob2RzIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZW5jcnlwdGlvbk1ldGhvZD1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEV2ZW50IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJldmVudCIsITApO3RoaXMuYWN0aXZpdHk9Z2V0U3RyaW5nT3B0aW9uKGUuYWN0aXZpdHksWyJjbGljayIsImNoYW5nZSIsImRvY0Nsb3NlIiwiZG9jUmVhZHkiLCJlbnRlciIsImV4aXQiLCJmdWxsIiwiaW5kZXhDaGFuZ2UiLCJpbml0aWFsaXplIiwibW91c2VEb3duIiwibW91c2VFbnRlciIsIm1vdXNlRXhpdCIsIm1vdXNlVXAiLCJwb3N0RXhlY3V0ZSIsInBvc3RPcGVuIiwicG9zdFByaW50IiwicG9zdFNhdmUiLCJwb3N0U2lnbiIsInBvc3RTdWJtaXQiLCJwcmVFeGVjdXRlIiwicHJlT3BlbiIsInByZVByaW50IiwicHJlU2F2ZSIsInByZVNpZ24iLCJwcmVTdWJtaXQiLCJyZWFkeSIsInZhbGlkYXRpb25TdGF0ZSJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubGlzdGVuPWdldFN0cmluZ09wdGlvbihlLmxpc3RlbixbInJlZk9ubHkiLCJyZWZBbmREZXNjZW5kZW50cyJdKTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnJlZj1lLnJlZnx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5lbmNyeXB0RGF0YT1udWxsO3RoaXMuZXhlY3V0ZT1udWxsO3RoaXMuc2NyaXB0PW51bGw7dGhpcy5zaWduRGF0YT1udWxsO3RoaXMuc3VibWl0PW51bGx9fWNsYXNzIEV4RGF0YSBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImV4RGF0YSIpO3RoaXMuY29udGVudFR5cGU9ZS5jb250ZW50VHlwZXx8IiI7dGhpcy5ocmVmPWUuaHJlZnx8IiI7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm1heExlbmd0aD1nZXRJbnRlZ2VyKHtkYXRhOmUubWF4TGVuZ3RoLGRlZmF1bHRWYWx1ZTotMSx2YWxpZGF0ZTplPT5lPj0tMX0pO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmlkPWUucmlkfHwiIjt0aGlzLnRyYW5zZmVyRW5jb2Rpbmc9Z2V0U3RyaW5nT3B0aW9uKGUudHJhbnNmZXJFbmNvZGluZyxbIm5vbmUiLCJiYXNlNjQiLCJwYWNrYWdlIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn1bcHNdKCl7cmV0dXJuInRleHQvaHRtbCI9PT10aGlzLmNvbnRlbnRUeXBlfVtUc10oZSl7aWYoInRleHQvaHRtbCI9PT10aGlzLmNvbnRlbnRUeXBlJiZlW3ZzXT09PUpzLnhodG1sLmlkKXt0aGlzW0huXT1lO3JldHVybiEwfWlmKCJ0ZXh0L3htbCI9PT10aGlzLmNvbnRlbnRUeXBlKXt0aGlzW0huXT1lO3JldHVybiEwfXJldHVybiExfVt6c10oZSl7cmV0dXJuInRleHQvaHRtbCI9PT10aGlzLmNvbnRlbnRUeXBlJiZ0aGlzW0huXT90aGlzW0huXVt6c10oZSk6SFRNTFJlc3VsdC5FTVBUWX19Y2xhc3MgRXhPYmplY3QgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImV4T2JqZWN0IiwhMCk7dGhpcy5hcmNoaXZlPWUuYXJjaGl2ZXx8IiI7dGhpcy5jbGFzc0lkPWUuY2xhc3NJZHx8IiI7dGhpcy5jb2RlQmFzZT1lLmNvZGVCYXNlfHwiIjt0aGlzLmNvZGVUeXBlPWUuY29kZVR5cGV8fCIiO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5ib29sZWFuPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRhdGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZVRpbWU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGVjaW1hbD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5leERhdGE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhPYmplY3Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZmxvYXQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuaW1hZ2U9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuaW50ZWdlcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50ZXh0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRpbWU9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBFeGNsR3JvdXAgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImV4Y2xHcm91cCIsITApO3RoaXMuYWNjZXNzPWdldFN0cmluZ09wdGlvbihlLmFjY2VzcyxbIm9wZW4iLCJub25JbnRlcmFjdGl2ZSIsInByb3RlY3RlZCIsInJlYWRPbmx5Il0pO3RoaXMuYWNjZXNzS2V5PWUuYWNjZXNzS2V5fHwiIjt0aGlzLmFuY2hvclR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUuYW5jaG9yVHlwZSxbInRvcExlZnQiLCJib3R0b21DZW50ZXIiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJtaWRkbGVDZW50ZXIiLCJtaWRkbGVMZWZ0IiwibWlkZGxlUmlnaHQiLCJ0b3BDZW50ZXIiLCJ0b3BSaWdodCJdKTt0aGlzLmNvbFNwYW49Z2V0SW50ZWdlcih7ZGF0YTplLmNvbFNwYW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ZT49MXx8LTE9PT1lfSk7dGhpcy5oPWUuaD9nZXRNZWFzdXJlbWVudChlLmgpOiIiO3RoaXMuaEFsaWduPWdldFN0cmluZ09wdGlvbihlLmhBbGlnbixbImxlZnQiLCJjZW50ZXIiLCJqdXN0aWZ5IiwianVzdGlmeUFsbCIsInJhZGl4IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxheW91dD1nZXRTdHJpbmdPcHRpb24oZS5sYXlvdXQsWyJwb3NpdGlvbiIsImxyLXRiIiwicmwtcm93IiwicmwtdGIiLCJyb3ciLCJ0YWJsZSIsInRiIl0pO3RoaXMubWF4SD1nZXRNZWFzdXJlbWVudChlLm1heEgsIjBwdCIpO3RoaXMubWF4Vz1nZXRNZWFzdXJlbWVudChlLm1heFcsIjBwdCIpO3RoaXMubWluSD1nZXRNZWFzdXJlbWVudChlLm1pbkgsIjBwdCIpO3RoaXMubWluVz1nZXRNZWFzdXJlbWVudChlLm1pblcsIjBwdCIpO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucHJlc2VuY2U9Z2V0U3RyaW5nT3B0aW9uKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5yZWxldmFudD1nZXRSZWxldmFudChlLnJlbGV2YW50KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy53PWUudz9nZXRNZWFzdXJlbWVudChlLncpOiIiO3RoaXMueD1nZXRNZWFzdXJlbWVudChlLngsIjBwdCIpO3RoaXMueT1nZXRNZWFzdXJlbWVudChlLnksIjBwdCIpO3RoaXMuYXNzaXN0PW51bGw7dGhpcy5iaW5kPW51bGw7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmNhbGN1bGF0ZT1udWxsO3RoaXMuY2FwdGlvbj1udWxsO3RoaXMuZGVzYz1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tYXJnaW49bnVsbDt0aGlzLnBhcmE9bnVsbDt0aGlzLnRyYXZlcnNhbD1udWxsO3RoaXMudmFsaWRhdGU9bnVsbDt0aGlzLmNvbm5lY3Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXZlbnQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZmllbGQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc2V0UHJvcGVydHk9bmV3IFhGQU9iamVjdEFycmF5fVttc10oKXtyZXR1cm4hMH1bdXNdKCl7cmV0dXJuITB9W1hzXShlKXtmb3IoY29uc3QgdCBvZiB0aGlzLmZpZWxkLmNoaWxkcmVuKXtpZighdC52YWx1ZSl7Y29uc3QgZT1uZXcgVmFsdWUoe30pO3RbUG5dKGUpO3QudmFsdWU9ZX10LnZhbHVlW1hzXShlKX19W1NzXSgpe3JldHVybiB0aGlzLmxheW91dC5lbmRzV2l0aCgiLXRiIikmJjA9PT10aGlzWyRuXS5hdHRlbXB0JiZ0aGlzWyRuXS5udW1iZXJJbkxpbmU+MHx8dGhpc1tjc10oKVtTc10oKX1beHNdKCl7Y29uc3QgZT10aGlzW29zXSgpO2lmKCFlW3hzXSgpKXJldHVybiExO2lmKHZvaWQgMCE9PXRoaXNbJG5dLl9pc1NwbGl0dGFibGUpcmV0dXJuIHRoaXNbJG5dLl9pc1NwbGl0dGFibGU7aWYoInBvc2l0aW9uIj09PXRoaXMubGF5b3V0fHx0aGlzLmxheW91dC5pbmNsdWRlcygicm93Iikpe3RoaXNbJG5dLl9pc1NwbGl0dGFibGU9ITE7cmV0dXJuITF9aWYoZS5sYXlvdXQ/LmVuZHNXaXRoKCItdGIiKSYmMCE9PWVbJG5dLm51bWJlckluTGluZSlyZXR1cm4hMTt0aGlzWyRuXS5faXNTcGxpdHRhYmxlPSEwO3JldHVybiEwfVtWbl0oKXtyZXR1cm4gZmx1c2hIVE1MKHRoaXMpfVtFbl0oZSx0KXthZGRIVE1MKHRoaXMsZSx0KX1bWW5dKCl7cmV0dXJuIGdldEF2YWlsYWJsZVNwYWNlKHRoaXMpfVt6c10oZSl7c2V0VGFiSW5kZXgodGhpcyk7aWYoImhpZGRlbiI9PT10aGlzLnByZXNlbmNlfHwiaW5hY3RpdmUiPT09dGhpcy5wcmVzZW5jZXx8MD09PXRoaXMuaHx8MD09PXRoaXMudylyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWTtmaXhEaW1lbnNpb25zKHRoaXMpO2NvbnN0IHQ9W10sYT17aWQ6dGhpc1tWc10sY2xhc3M6W119O3NldEFjY2Vzcyh0aGlzLGEuY2xhc3MpO3RoaXNbJG5dfHw9T2JqZWN0LmNyZWF0ZShudWxsKTtPYmplY3QuYXNzaWduKHRoaXNbJG5dLHtjaGlsZHJlbjp0LGF0dHJpYnV0ZXM6YSxhdHRlbXB0OjAsbGluZTpudWxsLG51bWJlckluTGluZTowLGF2YWlsYWJsZVNwYWNlOnt3aWR0aDpNYXRoLm1pbih0aGlzLnd8fDEvMCxlLndpZHRoKSxoZWlnaHQ6TWF0aC5taW4odGhpcy5ofHwxLzAsZS5oZWlnaHQpfSx3aWR0aDowLGhlaWdodDowLHByZXZIZWlnaHQ6MCxjdXJyZW50V2lkdGg6MH0pO2NvbnN0IHI9dGhpc1t4c10oKTtyfHxzZXRGaXJzdFVuc3BsaXR0YWJsZSh0aGlzKTtpZighY2hlY2tEaW1lbnNpb25zKHRoaXMsZSkpcmV0dXJuIEhUTUxSZXN1bHQuRkFJTFVSRTtjb25zdCBpPW5ldyBTZXQoWyJmaWVsZCJdKTtpZih0aGlzLmxheW91dC5pbmNsdWRlcygicm93Iikpe2NvbnN0IGU9dGhpc1tvc10oKS5jb2x1bW5XaWR0aHM7aWYoQXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg+MCl7dGhpc1skbl0uY29sdW1uV2lkdGhzPWU7dGhpc1skbl0uY3VycmVudENvbHVtbj0wfX1jb25zdCBuPXRvU3R5bGUodGhpcywiYW5jaG9yVHlwZSIsImRpbWVuc2lvbnMiLCJwb3NpdGlvbiIsInByZXNlbmNlIiwiYm9yZGVyIiwibWFyZ2luIiwiaEFsaWduIikscz1bInhmYUV4Y2xncm91cCJdLG89bGF5b3V0Q2xhc3ModGhpcyk7byYmcy5wdXNoKG8pO2lzUHJpbnRPbmx5KHRoaXMpJiZzLnB1c2goInhmYVByaW50T25seSIpO2Euc3R5bGU9bjthLmNsYXNzPXM7dGhpcy5uYW1lJiYoYS54ZmFOYW1lPXRoaXMubmFtZSk7dGhpc1tSc10oKTtjb25zdCBjPSJsci10YiI9PT10aGlzLmxheW91dHx8InJsLXRiIj09PXRoaXMubGF5b3V0LGw9Yz8yOjE7Zm9yKDt0aGlzWyRuXS5hdHRlbXB0PGw7dGhpc1skbl0uYXR0ZW1wdCsrKXtjJiYxPT09dGhpc1skbl0uYXR0ZW1wdCYmKHRoaXNbJG5dLm51bWJlckluTGluZT0wKTtjb25zdCBlPXRoaXNbTG5dKHtmaWx0ZXI6aSxpbmNsdWRlOiEwfSk7aWYoZS5zdWNjZXNzKWJyZWFrO2lmKGUuaXNCcmVhaygpKXt0aGlzW0JzXSgpO3JldHVybiBlfWlmKGMmJjA9PT10aGlzWyRuXS5hdHRlbXB0JiYwPT09dGhpc1skbl0ubnVtYmVySW5MaW5lJiYhdGhpc1tsc10oKVskbl0ubm9MYXlvdXRGYWlsdXJlKXt0aGlzWyRuXS5hdHRlbXB0PWw7YnJlYWt9fXRoaXNbQnNdKCk7cnx8dW5zZXRGaXJzdFVuc3BsaXR0YWJsZSh0aGlzKTtpZih0aGlzWyRuXS5hdHRlbXB0PT09bCl7cnx8ZGVsZXRlIHRoaXNbJG5dO3JldHVybiBIVE1MUmVzdWx0LkZBSUxVUkV9bGV0IGg9MCx1PTA7aWYodGhpcy5tYXJnaW4pe2g9dGhpcy5tYXJnaW4ubGVmdEluc2V0K3RoaXMubWFyZ2luLnJpZ2h0SW5zZXQ7dT10aGlzLm1hcmdpbi50b3BJbnNldCt0aGlzLm1hcmdpbi5ib3R0b21JbnNldH1jb25zdCBkPU1hdGgubWF4KHRoaXNbJG5dLndpZHRoK2gsdGhpcy53fHwwKSxmPU1hdGgubWF4KHRoaXNbJG5dLmhlaWdodCt1LHRoaXMuaHx8MCksZz1bdGhpcy54LHRoaXMueSxkLGZdOyIiPT09dGhpcy53JiYobi53aWR0aD1tZWFzdXJlVG9TdHJpbmcoZCkpOyIiPT09dGhpcy5oJiYobi5oZWlnaHQ9bWVhc3VyZVRvU3RyaW5nKGYpKTtjb25zdCBwPXtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6YSxjaGlsZHJlbjp0fTthcHBseUFzc2lzdCh0aGlzLGEpO2RlbGV0ZSB0aGlzWyRuXTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGNyZWF0ZVdyYXBwZXIodGhpcyxwKSxnKX19Y2xhc3MgRXhlY3V0ZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiZXhlY3V0ZSIpO3RoaXMuY29ubmVjdGlvbj1lLmNvbm5lY3Rpb258fCIiO3RoaXMuZXhlY3V0ZVR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUuZXhlY3V0ZVR5cGUsWyJpbXBvcnQiLCJyZW1lcmdlIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5ydW5BdD1nZXRTdHJpbmdPcHRpb24oZS5ydW5BdCxbImNsaWVudCIsImJvdGgiLCJzZXJ2ZXIiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBFeHRyYXMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImV4dHJhcyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9vbGVhbj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRhdGVUaW1lPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRlY2ltYWw9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhEYXRhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4dHJhcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5mbG9hdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbWFnZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbnRlZ2VyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRleHQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGltZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEZpZWxkIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJmaWVsZCIsITApO3RoaXMuYWNjZXNzPWdldFN0cmluZ09wdGlvbihlLmFjY2VzcyxbIm9wZW4iLCJub25JbnRlcmFjdGl2ZSIsInByb3RlY3RlZCIsInJlYWRPbmx5Il0pO3RoaXMuYWNjZXNzS2V5PWUuYWNjZXNzS2V5fHwiIjt0aGlzLmFuY2hvclR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUuYW5jaG9yVHlwZSxbInRvcExlZnQiLCJib3R0b21DZW50ZXIiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJtaWRkbGVDZW50ZXIiLCJtaWRkbGVMZWZ0IiwibWlkZGxlUmlnaHQiLCJ0b3BDZW50ZXIiLCJ0b3BSaWdodCJdKTt0aGlzLmNvbFNwYW49Z2V0SW50ZWdlcih7ZGF0YTplLmNvbFNwYW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ZT49MXx8LTE9PT1lfSk7dGhpcy5oPWUuaD9nZXRNZWFzdXJlbWVudChlLmgpOiIiO3RoaXMuaEFsaWduPWdldFN0cmluZ09wdGlvbihlLmhBbGlnbixbImxlZnQiLCJjZW50ZXIiLCJqdXN0aWZ5IiwianVzdGlmeUFsbCIsInJhZGl4IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxvY2FsZT1lLmxvY2FsZXx8IiI7dGhpcy5tYXhIPWdldE1lYXN1cmVtZW50KGUubWF4SCwiMHB0Iik7dGhpcy5tYXhXPWdldE1lYXN1cmVtZW50KGUubWF4VywiMHB0Iik7dGhpcy5taW5IPWdldE1lYXN1cmVtZW50KGUubWluSCwiMHB0Iik7dGhpcy5taW5XPWdldE1lYXN1cmVtZW50KGUubWluVywiMHB0Iik7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5wcmVzZW5jZT1nZXRTdHJpbmdPcHRpb24oZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMucm90YXRlPWdldEludGVnZXIoe2RhdGE6ZS5yb3RhdGUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+ZSU5MD09MH0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnc9ZS53P2dldE1lYXN1cmVtZW50KGUudyk6IiI7dGhpcy54PWdldE1lYXN1cmVtZW50KGUueCwiMHB0Iik7dGhpcy55PWdldE1lYXN1cmVtZW50KGUueSwiMHB0Iik7dGhpcy5hc3Npc3Q9bnVsbDt0aGlzLmJpbmQ9bnVsbDt0aGlzLmJvcmRlcj1udWxsO3RoaXMuY2FsY3VsYXRlPW51bGw7dGhpcy5jYXB0aW9uPW51bGw7dGhpcy5kZXNjPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmZvbnQ9bnVsbDt0aGlzLmZvcm1hdD1udWxsO3RoaXMuaXRlbXM9bmV3IFhGQU9iamVjdEFycmF5KDIpO3RoaXMua2VlcD1udWxsO3RoaXMubWFyZ2luPW51bGw7dGhpcy5wYXJhPW51bGw7dGhpcy50cmF2ZXJzYWw9bnVsbDt0aGlzLnVpPW51bGw7dGhpcy52YWxpZGF0ZT1udWxsO3RoaXMudmFsdWU9bnVsbDt0aGlzLmJpbmRJdGVtcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5jb25uZWN0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV2ZW50PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnNldFByb3BlcnR5PW5ldyBYRkFPYmplY3RBcnJheX1bbXNdKCl7cmV0dXJuITB9W1hzXShlKXtfc2V0VmFsdWUodGhpcyxlKX1benNdKGUpe3NldFRhYkluZGV4KHRoaXMpO2lmKCF0aGlzLnVpKXt0aGlzLnVpPW5ldyBVaSh7fSk7dGhpcy51aVtoc109dGhpc1toc107dGhpc1tQbl0odGhpcy51aSk7bGV0IGU7c3dpdGNoKHRoaXMuaXRlbXMuY2hpbGRyZW4ubGVuZ3RoKXtjYXNlIDA6ZT1uZXcgVGV4dEVkaXQoe30pO3RoaXMudWkudGV4dEVkaXQ9ZTticmVhaztjYXNlIDE6ZT1uZXcgQ2hlY2tCdXR0b24oe30pO3RoaXMudWkuY2hlY2tCdXR0b249ZTticmVhaztjYXNlIDI6ZT1uZXcgQ2hvaWNlTGlzdCh7fSk7dGhpcy51aS5jaG9pY2VMaXN0PWV9dGhpcy51aVtQbl0oZSl9aWYoIXRoaXMudWl8fCJoaWRkZW4iPT09dGhpcy5wcmVzZW5jZXx8ImluYWN0aXZlIj09PXRoaXMucHJlc2VuY2V8fDA9PT10aGlzLmh8fDA9PT10aGlzLncpcmV0dXJuIEhUTUxSZXN1bHQuRU1QVFk7dGhpcy5jYXB0aW9uJiZkZWxldGUgdGhpcy5jYXB0aW9uWyRuXTt0aGlzW1JzXSgpO2NvbnN0IHQ9dGhpcy5jYXB0aW9uP3RoaXMuY2FwdGlvblt6c10oZSkuaHRtbDpudWxsLGE9dGhpcy53LHI9dGhpcy5oO2xldCBpPTAsbj0wO2lmKHRoaXMubWFyZ2luKXtpPXRoaXMubWFyZ2luLmxlZnRJbnNldCt0aGlzLm1hcmdpbi5yaWdodEluc2V0O249dGhpcy5tYXJnaW4udG9wSW5zZXQrdGhpcy5tYXJnaW4uYm90dG9tSW5zZXR9bGV0IHM9bnVsbDtpZigiIj09PXRoaXMud3x8IiI9PT10aGlzLmgpe2xldCB0PW51bGwsYT1udWxsLHI9MCxvPTA7aWYodGhpcy51aS5jaGVja0J1dHRvbilyPW89dGhpcy51aS5jaGVja0J1dHRvbi5zaXplO2Vsc2V7Y29uc3R7dzp0LGg6YX09bGF5b3V0Tm9kZSh0aGlzLGUpO2lmKG51bGwhPT10KXtyPXQ7bz1hfWVsc2Ugbz1mdW5jdGlvbiBmb250c19nZXRNZXRyaWNzKGUsdD0hMSl7bGV0IGE9bnVsbDtpZihlKXtjb25zdCB0PXN0cmlwUXVvdGVzKGUudHlwZWZhY2UpLHI9ZVtoc10uZm9udEZpbmRlci5maW5kKHQpO2E9c2VsZWN0Rm9udChlLHIpfWlmKCFhKXJldHVybntsaW5lSGVpZ2h0OjEyLGxpbmVHYXA6MixsaW5lTm9HYXA6MTB9O2NvbnN0IHI9ZS5zaXplfHwxMCxpPWEubGluZUhlaWdodD9NYXRoLm1heCh0PzA6MS4yLGEubGluZUhlaWdodCk6MS4yLG49dm9pZCAwPT09YS5saW5lR2FwPy4yOmEubGluZUdhcDtyZXR1cm57bGluZUhlaWdodDppKnIsbGluZUdhcDpuKnIsbGluZU5vR2FwOk1hdGgubWF4KDEsaS1uKSpyfX0odGhpcy5mb250LCEwKS5saW5lTm9HYXB9cz1nZXRCb3JkZXJEaW1zKHRoaXMudWlbYXNdKCkpO3IrPXMudztvKz1zLmg7aWYodGhpcy5jYXB0aW9uKXtjb25zdHt3OmksaDpuLGlzQnJva2VuOnN9PXRoaXMuY2FwdGlvblthc10oZSk7aWYocyYmdGhpc1tvc10oKVtTc10oKSl7dGhpc1tCc10oKTtyZXR1cm4gSFRNTFJlc3VsdC5GQUlMVVJFfXQ9aTthPW47c3dpdGNoKHRoaXMuY2FwdGlvbi5wbGFjZW1lbnQpe2Nhc2UibGVmdCI6Y2FzZSJyaWdodCI6Y2FzZSJpbmxpbmUiOnQrPXI7YnJlYWs7Y2FzZSJ0b3AiOmNhc2UiYm90dG9tIjphKz1vfX1lbHNle3Q9cjthPW99aWYodCYmIiI9PT10aGlzLncpe3QrPWk7dGhpcy53PU1hdGgubWluKHRoaXMubWF4Vzw9MD8xLzA6dGhpcy5tYXhXLHRoaXMubWluVysxPHQ/dDp0aGlzLm1pblcpfWlmKGEmJiIiPT09dGhpcy5oKXthKz1uO3RoaXMuaD1NYXRoLm1pbih0aGlzLm1heEg8PTA/MS8wOnRoaXMubWF4SCx0aGlzLm1pbkgrMTxhP2E6dGhpcy5taW5IKX19dGhpc1tCc10oKTtmaXhEaW1lbnNpb25zKHRoaXMpO3NldEZpcnN0VW5zcGxpdHRhYmxlKHRoaXMpO2lmKCFjaGVja0RpbWVuc2lvbnModGhpcyxlKSl7dGhpcy53PWE7dGhpcy5oPXI7dGhpc1tCc10oKTtyZXR1cm4gSFRNTFJlc3VsdC5GQUlMVVJFfXVuc2V0Rmlyc3RVbnNwbGl0dGFibGUodGhpcyk7Y29uc3Qgbz10b1N0eWxlKHRoaXMsImZvbnQiLCJkaW1lbnNpb25zIiwicG9zaXRpb24iLCJyb3RhdGUiLCJhbmNob3JUeXBlIiwicHJlc2VuY2UiLCJtYXJnaW4iLCJoQWxpZ24iKTtzZXRNaW5NYXhEaW1lbnNpb25zKHRoaXMsbyk7Y29uc3QgYz1bInhmYUZpZWxkIl07dGhpcy5mb250JiZjLnB1c2goInhmYUZvbnQiKTtpc1ByaW50T25seSh0aGlzKSYmYy5wdXNoKCJ4ZmFQcmludE9ubHkiKTtjb25zdCBsPXtzdHlsZTpvLGlkOnRoaXNbVnNdLGNsYXNzOmN9O2lmKG8ubWFyZ2luKXtvLnBhZGRpbmc9by5tYXJnaW47ZGVsZXRlIG8ubWFyZ2lufXNldEFjY2Vzcyh0aGlzLGMpO3RoaXMubmFtZSYmKGwueGZhTmFtZT10aGlzLm5hbWUpO2NvbnN0IGg9W10sdT17bmFtZToiZGl2IixhdHRyaWJ1dGVzOmwsY2hpbGRyZW46aH07YXBwbHlBc3Npc3QodGhpcyxsKTtjb25zdCBkPXRoaXMuYm9yZGVyP3RoaXMuYm9yZGVyW0dzXSgpOm51bGwsZj1jb21wdXRlQmJveCh0aGlzLHUsZSksZz10aGlzLnVpW3pzXSgpLmh0bWw7aWYoIWcpe09iamVjdC5hc3NpZ24obyxkKTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGNyZWF0ZVdyYXBwZXIodGhpcyx1KSxmKX10aGlzW3FzXSYmKGcuY2hpbGRyZW4/LlswXT9nLmNoaWxkcmVuWzBdLmF0dHJpYnV0ZXMudGFiaW5kZXg9dGhpc1txc106Zy5hdHRyaWJ1dGVzLnRhYmluZGV4PXRoaXNbcXNdKTtnLmF0dHJpYnV0ZXMuc3R5bGV8fD1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBwPW51bGw7aWYodGhpcy51aS5idXR0b24pezE9PT1nLmNoaWxkcmVuLmxlbmd0aCYmKFtwXT1nLmNoaWxkcmVuLnNwbGljZSgwLDEpKTtPYmplY3QuYXNzaWduKGcuYXR0cmlidXRlcy5zdHlsZSxkKX1lbHNlIE9iamVjdC5hc3NpZ24obyxkKTtoLnB1c2goZyk7aWYodGhpcy52YWx1ZSlpZih0aGlzLnVpLmltYWdlRWRpdClnLmNoaWxkcmVuLnB1c2godGhpcy52YWx1ZVt6c10oKS5odG1sKTtlbHNlIGlmKCF0aGlzLnVpLmJ1dHRvbil7bGV0IGU9IiI7aWYodGhpcy52YWx1ZS5leERhdGEpZT10aGlzLnZhbHVlLmV4RGF0YVtIc10oKTtlbHNlIGlmKHRoaXMudmFsdWUudGV4dCllPXRoaXMudmFsdWUudGV4dFthc10oKTtlbHNle2NvbnN0IHQ9dGhpcy52YWx1ZVt6c10oKS5odG1sO251bGwhPT10JiYoZT10LmNoaWxkcmVuWzBdLnZhbHVlKX10aGlzLnVpLnRleHRFZGl0JiZ0aGlzLnZhbHVlLnRleHQ/Lm1heENoYXJzJiYoZy5jaGlsZHJlblswXS5hdHRyaWJ1dGVzLm1heExlbmd0aD10aGlzLnZhbHVlLnRleHQubWF4Q2hhcnMpO2lmKGUpe2lmKHRoaXMudWkubnVtZXJpY0VkaXQpe2U9cGFyc2VGbG9hdChlKTtlPWlzTmFOKGUpPyIiOmUudG9TdHJpbmcoKX0idGV4dGFyZWEiPT09Zy5jaGlsZHJlblswXS5uYW1lP2cuY2hpbGRyZW5bMF0uYXR0cmlidXRlcy50ZXh0Q29udGVudD1lOmcuY2hpbGRyZW5bMF0uYXR0cmlidXRlcy52YWx1ZT1lfX1pZighdGhpcy51aS5pbWFnZUVkaXQmJmcuY2hpbGRyZW4/LlswXSYmdGhpcy5oKXtzPXN8fGdldEJvcmRlckRpbXModGhpcy51aVthc10oKSk7bGV0IHQ9MDtpZih0aGlzLmNhcHRpb24mJlsidG9wIiwiYm90dG9tIl0uaW5jbHVkZXModGhpcy5jYXB0aW9uLnBsYWNlbWVudCkpe3Q9dGhpcy5jYXB0aW9uLnJlc2VydmU7dDw9MCYmKHQ9dGhpcy5jYXB0aW9uW2FzXShlKS5oKTtjb25zdCBhPXRoaXMuaC10LW4tcy5oO2cuY2hpbGRyZW5bMF0uYXR0cmlidXRlcy5zdHlsZS5oZWlnaHQ9bWVhc3VyZVRvU3RyaW5nKGEpfWVsc2UgZy5jaGlsZHJlblswXS5hdHRyaWJ1dGVzLnN0eWxlLmhlaWdodD0iMTAwJSJ9cCYmZy5jaGlsZHJlbi5wdXNoKHApO2lmKCF0KXtnLmF0dHJpYnV0ZXMuY2xhc3MmJmcuYXR0cmlidXRlcy5jbGFzcy5wdXNoKCJ4ZmFMZWZ0Iik7dGhpcy53PWE7dGhpcy5oPXI7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhjcmVhdGVXcmFwcGVyKHRoaXMsdSksZil9aWYodGhpcy51aS5idXR0b24pe28ucGFkZGluZyYmZGVsZXRlIG8ucGFkZGluZzsiZGl2Ij09PXQubmFtZSYmKHQubmFtZT0ic3BhbiIpO2cuY2hpbGRyZW4ucHVzaCh0KTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHUsZil9dGhpcy51aS5jaGVja0J1dHRvbiYmKHQuYXR0cmlidXRlcy5jbGFzc1swXT0ieGZhQ2FwdGlvbkZvckNoZWNrQnV0dG9uIik7Zy5hdHRyaWJ1dGVzLmNsYXNzfHw9W107Zy5jaGlsZHJlbi5zcGxpY2UoMCwwLHQpO3N3aXRjaCh0aGlzLmNhcHRpb24ucGxhY2VtZW50KXtjYXNlImxlZnQiOmNhc2UiaW5saW5lIjpnLmF0dHJpYnV0ZXMuY2xhc3MucHVzaCgieGZhTGVmdCIpO2JyZWFrO2Nhc2UicmlnaHQiOmcuYXR0cmlidXRlcy5jbGFzcy5wdXNoKCJ4ZmFSaWdodCIpO2JyZWFrO2Nhc2UidG9wIjpnLmF0dHJpYnV0ZXMuY2xhc3MucHVzaCgieGZhVG9wIik7YnJlYWs7Y2FzZSJib3R0b20iOmcuYXR0cmlidXRlcy5jbGFzcy5wdXNoKCJ4ZmFCb3R0b20iKX10aGlzLnc9YTt0aGlzLmg9cjtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGNyZWF0ZVdyYXBwZXIodGhpcyx1KSxmKX19Y2xhc3MgRmlsbCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiZmlsbCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5wcmVzZW5jZT1nZXRTdHJpbmdPcHRpb24oZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jb2xvcj1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5saW5lYXI9bnVsbDt0aGlzLnBhdHRlcm49bnVsbDt0aGlzLnJhZGlhbD1udWxsO3RoaXMuc29saWQ9bnVsbDt0aGlzLnN0aXBwbGU9bnVsbH1bR3NdKCl7Y29uc3QgZT10aGlzW2NzXSgpLHQ9ZVtjc10oKVtjc10oKSxhPU9iamVjdC5jcmVhdGUobnVsbCk7bGV0IHI9ImNvbG9yIixpPXI7aWYoZSBpbnN0YW5jZW9mIEJvcmRlcil7cj0iYmFja2dyb3VuZC1jb2xvciI7aT0iYmFja2dyb3VuZCI7dCBpbnN0YW5jZW9mIFVpJiYoYS5iYWNrZ3JvdW5kQ29sb3I9IndoaXRlIil9aWYoZSBpbnN0YW5jZW9mIFJlY3RhbmdsZXx8ZSBpbnN0YW5jZW9mIEFyYyl7cj1pPSJmaWxsIjthLmZpbGw9IndoaXRlIn1mb3IoY29uc3QgZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7aWYoImV4dHJhcyI9PT1lfHwiY29sb3IiPT09ZSljb250aW51ZTtjb25zdCB0PXRoaXNbZV07aWYoISh0IGluc3RhbmNlb2YgWEZBT2JqZWN0KSljb250aW51ZTtjb25zdCBuPXRbR3NdKHRoaXMuY29sb3IpO24mJihhW24uc3RhcnRzV2l0aCgiIyIpP3I6aV09bik7cmV0dXJuIGF9aWYodGhpcy5jb2xvcj8udmFsdWUpe2NvbnN0IGU9dGhpcy5jb2xvcltHc10oKTthW2Uuc3RhcnRzV2l0aCgiIyIpP3I6aV09ZX1yZXR1cm4gYX19Y2xhc3MgRmlsdGVyIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJmaWx0ZXIiLCEwKTt0aGlzLmFkZFJldm9jYXRpb25JbmZvPWdldFN0cmluZ09wdGlvbihlLmFkZFJldm9jYXRpb25JbmZvLFsiIiwicmVxdWlyZWQiLCJvcHRpb25hbCIsIm5vbmUiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy52ZXJzaW9uPWdldEludGVnZXIoe2RhdGE6dGhpcy52ZXJzaW9uLGRlZmF1bHRWYWx1ZTo1LHZhbGlkYXRlOmU9PmU+PTEmJmU8PTV9KTt0aGlzLmFwcGVhcmFuY2VGaWx0ZXI9bnVsbDt0aGlzLmNlcnRpZmljYXRlcz1udWxsO3RoaXMuZGlnZXN0TWV0aG9kcz1udWxsO3RoaXMuZW5jb2RpbmdzPW51bGw7dGhpcy5lbmNyeXB0aW9uTWV0aG9kcz1udWxsO3RoaXMuaGFuZGxlcj1udWxsO3RoaXMubG9ja0RvY3VtZW50PW51bGw7dGhpcy5tZHA9bnVsbDt0aGlzLnJlYXNvbnM9bnVsbDt0aGlzLnRpbWVTdGFtcD1udWxsfX1jbGFzcyBGbG9hdCBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImZsb2F0Iik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W0duXSgpe2NvbnN0IGU9cGFyc2VGbG9hdCh0aGlzW0huXS50cmltKCkpO3RoaXNbSG5dPWlzTmFOKGUpP251bGw6ZX1benNdKGUpe3JldHVybiB2YWx1ZVRvSHRtbChudWxsIT09dGhpc1tIbl0/dGhpc1tIbl0udG9TdHJpbmcoKToiIil9fWNsYXNzIHRlbXBsYXRlX0ZvbnQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImZvbnQiLCEwKTt0aGlzLmJhc2VsaW5lU2hpZnQ9Z2V0TWVhc3VyZW1lbnQoZS5iYXNlbGluZVNoaWZ0KTt0aGlzLmZvbnRIb3Jpem9udGFsU2NhbGU9Z2V0RmxvYXQoe2RhdGE6ZS5mb250SG9yaXpvbnRhbFNjYWxlLGRlZmF1bHRWYWx1ZToxMDAsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMuZm9udFZlcnRpY2FsU2NhbGU9Z2V0RmxvYXQoe2RhdGE6ZS5mb250VmVydGljYWxTY2FsZSxkZWZhdWx0VmFsdWU6MTAwLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMua2VybmluZ01vZGU9Z2V0U3RyaW5nT3B0aW9uKGUua2VybmluZ01vZGUsWyJub25lIiwicGFpciJdKTt0aGlzLmxldHRlclNwYWNpbmc9Z2V0TWVhc3VyZW1lbnQoZS5sZXR0ZXJTcGFjaW5nLCIwIik7dGhpcy5saW5lVGhyb3VnaD1nZXRJbnRlZ2VyKHtkYXRhOmUubGluZVRocm91Z2gsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV8fDI9PT1lfSk7dGhpcy5saW5lVGhyb3VnaFBlcmlvZD1nZXRTdHJpbmdPcHRpb24oZS5saW5lVGhyb3VnaFBlcmlvZCxbImFsbCIsIndvcmQiXSk7dGhpcy5vdmVybGluZT1nZXRJbnRlZ2VyKHtkYXRhOmUub3ZlcmxpbmUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV8fDI9PT1lfSk7dGhpcy5vdmVybGluZVBlcmlvZD1nZXRTdHJpbmdPcHRpb24oZS5vdmVybGluZVBlcmlvZCxbImFsbCIsIndvcmQiXSk7dGhpcy5wb3N0dXJlPWdldFN0cmluZ09wdGlvbihlLnBvc3R1cmUsWyJub3JtYWwiLCJpdGFsaWMiXSk7dGhpcy5zaXplPWdldE1lYXN1cmVtZW50KGUuc2l6ZSwiMTBwdCIpO3RoaXMudHlwZWZhY2U9ZS50eXBlZmFjZXx8IkNvdXJpZXIiO3RoaXMudW5kZXJsaW5lPWdldEludGVnZXIoe2RhdGE6ZS51bmRlcmxpbmUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV8fDI9PT1lfSk7dGhpcy51bmRlcmxpbmVQZXJpb2Q9Z2V0U3RyaW5nT3B0aW9uKGUudW5kZXJsaW5lUGVyaW9kLFsiYWxsIiwid29yZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy53ZWlnaHQ9Z2V0U3RyaW5nT3B0aW9uKGUud2VpZ2h0LFsibm9ybWFsIiwiYm9sZCJdKTt0aGlzLmV4dHJhcz1udWxsO3RoaXMuZmlsbD1udWxsfVtqbl0oZSl7c3VwZXJbam5dKGUpO3RoaXNbaHNdLnVzZWRUeXBlZmFjZXMuYWRkKHRoaXMudHlwZWZhY2UpfVtHc10oKXtjb25zdCBlPXRvU3R5bGUodGhpcywiZmlsbCIpLHQ9ZS5jb2xvcjtpZih0KWlmKCIjMDAwMDAwIj09PXQpZGVsZXRlIGUuY29sb3I7ZWxzZSBpZighdC5zdGFydHNXaXRoKCIjIikpe2UuYmFja2dyb3VuZD10O2UuYmFja2dyb3VuZENsaXA9InRleHQiO2UuY29sb3I9InRyYW5zcGFyZW50In10aGlzLmJhc2VsaW5lU2hpZnQmJihlLnZlcnRpY2FsQWxpZ249bWVhc3VyZVRvU3RyaW5nKHRoaXMuYmFzZWxpbmVTaGlmdCkpO2UuZm9udEtlcm5pbmc9Im5vbmUiPT09dGhpcy5rZXJuaW5nTW9kZT8ibm9uZSI6Im5vcm1hbCI7ZS5sZXR0ZXJTcGFjaW5nPW1lYXN1cmVUb1N0cmluZyh0aGlzLmxldHRlclNwYWNpbmcpO2lmKDAhPT10aGlzLmxpbmVUaHJvdWdoKXtlLnRleHREZWNvcmF0aW9uPSJsaW5lLXRocm91Z2giOzI9PT10aGlzLmxpbmVUaHJvdWdoJiYoZS50ZXh0RGVjb3JhdGlvblN0eWxlPSJkb3VibGUiKX1pZigwIT09dGhpcy5vdmVybGluZSl7ZS50ZXh0RGVjb3JhdGlvbj0ib3ZlcmxpbmUiOzI9PT10aGlzLm92ZXJsaW5lJiYoZS50ZXh0RGVjb3JhdGlvblN0eWxlPSJkb3VibGUiKX1lLmZvbnRTdHlsZT10aGlzLnBvc3R1cmU7ZS5mb250U2l6ZT1tZWFzdXJlVG9TdHJpbmcoLjk5KnRoaXMuc2l6ZSk7c2V0Rm9udEZhbWlseSh0aGlzLHRoaXMsdGhpc1toc10uZm9udEZpbmRlcixlKTtpZigwIT09dGhpcy51bmRlcmxpbmUpe2UudGV4dERlY29yYXRpb249InVuZGVybGluZSI7Mj09PXRoaXMudW5kZXJsaW5lJiYoZS50ZXh0RGVjb3JhdGlvblN0eWxlPSJkb3VibGUiKX1lLmZvbnRXZWlnaHQ9dGhpcy53ZWlnaHQ7cmV0dXJuIGV9fWNsYXNzIEZvcm1hdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiZm9ybWF0IiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLnBpY3R1cmU9bnVsbH19Y2xhc3MgSGFuZGxlciBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiaGFuZGxlciIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgSHlwaGVuYXRpb24gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImh5cGhlbmF0aW9uIik7dGhpcy5leGNsdWRlQWxsQ2Fwcz1nZXRJbnRlZ2VyKHtkYXRhOmUuZXhjbHVkZUFsbENhcHMsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLmV4Y2x1ZGVJbml0aWFsQ2FwPWdldEludGVnZXIoe2RhdGE6ZS5leGNsdWRlSW5pdGlhbENhcCxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMuaHlwaGVuYXRlPWdldEludGVnZXIoe2RhdGE6ZS5oeXBoZW5hdGUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucHVzaENoYXJhY3RlckNvdW50PWdldEludGVnZXIoe2RhdGE6ZS5wdXNoQ2hhcmFjdGVyQ291bnQsZGVmYXVsdFZhbHVlOjMsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMucmVtYWluQ2hhcmFjdGVyQ291bnQ9Z2V0SW50ZWdlcih7ZGF0YTplLnJlbWFpbkNoYXJhY3RlckNvdW50LGRlZmF1bHRWYWx1ZTozLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy53b3JkQ2hhcmFjdGVyQ291bnQ9Z2V0SW50ZWdlcih7ZGF0YTplLndvcmRDaGFyYWN0ZXJDb3VudCxkZWZhdWx0VmFsdWU6Nyx2YWxpZGF0ZTplPT5lPj0wfSl9fWNsYXNzIEltYWdlIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJpbWFnZSIpO3RoaXMuYXNwZWN0PWdldFN0cmluZ09wdGlvbihlLmFzcGVjdCxbImZpdCIsImFjdHVhbCIsImhlaWdodCIsIm5vbmUiLCJ3aWR0aCJdKTt0aGlzLmNvbnRlbnRUeXBlPWUuY29udGVudFR5cGV8fCIiO3RoaXMuaHJlZj1lLmhyZWZ8fCIiO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy50cmFuc2ZlckVuY29kaW5nPWdldFN0cmluZ09wdGlvbihlLnRyYW5zZmVyRW5jb2RpbmcsWyJiYXNlNjQiLCJub25lIiwicGFja2FnZSJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W3pzXSgpe2lmKHRoaXMuY29udGVudFR5cGUmJiFSby5oYXModGhpcy5jb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpKSlyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWTtsZXQgZT10aGlzW2hzXS5pbWFnZXM/LmdldCh0aGlzLmhyZWYpO2lmKCFlJiYodGhpcy5ocmVmfHwhdGhpc1tIbl0pKXJldHVybiBIVE1MUmVzdWx0LkVNUFRZO2V8fCJiYXNlNjQiIT09dGhpcy50cmFuc2ZlckVuY29kaW5nfHwoZT1mdW5jdGlvbiBmcm9tQmFzZTY0VXRpbChlKXtyZXR1cm4gVWludDhBcnJheS5mcm9tQmFzZTY0P1VpbnQ4QXJyYXkuZnJvbUJhc2U2NChlKTpzdHJpbmdUb0J5dGVzKGF0b2IoZSkpfSh0aGlzW0huXSkpO2lmKCFlKXJldHVybiBIVE1MUmVzdWx0LkVNUFRZO2lmKCF0aGlzLmNvbnRlbnRUeXBlKXtmb3IoY29uc3RbdCxhXW9mIE5vKWlmKGUubGVuZ3RoPnQubGVuZ3RoJiZ0LmV2ZXJ5KCgodCxhKT0+dD09PWVbYV0pKSl7dGhpcy5jb250ZW50VHlwZT1hO2JyZWFrfWlmKCF0aGlzLmNvbnRlbnRUeXBlKXJldHVybiBIVE1MUmVzdWx0LkVNUFRZfWNvbnN0IHQ9bmV3IEJsb2IoW2VdLHt0eXBlOnRoaXMuY29udGVudFR5cGV9KTtsZXQgYTtzd2l0Y2godGhpcy5hc3BlY3Qpe2Nhc2UiZml0IjpjYXNlImFjdHVhbCI6YnJlYWs7Y2FzZSJoZWlnaHQiOmE9e2hlaWdodDoiMTAwJSIsb2JqZWN0Rml0OiJmaWxsIn07YnJlYWs7Y2FzZSJub25lIjphPXt3aWR0aDoiMTAwJSIsaGVpZ2h0OiIxMDAlIixvYmplY3RGaXQ6ImZpbGwifTticmVhaztjYXNlIndpZHRoIjphPXt3aWR0aDoiMTAwJSIsb2JqZWN0Rml0OiJmaWxsIn19Y29uc3Qgcj10aGlzW2NzXSgpO3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImltZyIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFJbWFnZSJdLHN0eWxlOmEsc3JjOlVSTC5jcmVhdGVPYmplY3RVUkwodCksYWx0OnI/YXJpYUxhYmVsKHJbY3NdKCkpOm51bGx9fSl9fWNsYXNzIEltYWdlRWRpdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywiaW1hZ2VFZGl0IiwhMCk7dGhpcy5kYXRhPWdldFN0cmluZ09wdGlvbihlLmRhdGEsWyJsaW5rIiwiZW1iZWQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMubWFyZ2luPW51bGx9W3pzXShlKXtyZXR1cm4iZW1iZWQiPT09dGhpcy5kYXRhP0hUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixjaGlsZHJlbjpbXSxhdHRyaWJ1dGVzOnt9fSk6SFRNTFJlc3VsdC5FTVBUWX19Y2xhc3MgSW50ZWdlciBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImludGVnZXIiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn1bR25dKCl7Y29uc3QgZT1wYXJzZUludCh0aGlzW0huXS50cmltKCksMTApO3RoaXNbSG5dPWlzTmFOKGUpP251bGw6ZX1benNdKGUpe3JldHVybiB2YWx1ZVRvSHRtbChudWxsIT09dGhpc1tIbl0/dGhpc1tIbl0udG9TdHJpbmcoKToiIil9fWNsYXNzIElzc3VlcnMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImlzc3VlcnMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jZXJ0aWZpY2F0ZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEl0ZW1zIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJpdGVtcyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5wcmVzZW5jZT1nZXRTdHJpbmdPcHRpb24oZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlZj1lLnJlZnx8IiI7dGhpcy5zYXZlPWdldEludGVnZXIoe2RhdGE6ZS5zYXZlLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9vbGVhbj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRhdGVUaW1lPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRlY2ltYWw9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhEYXRhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZsb2F0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmltYWdlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmludGVnZXI9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGV4dD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50aW1lPW5ldyBYRkFPYmplY3RBcnJheX1benNdKCl7Y29uc3QgZT1bXTtmb3IoY29uc3QgdCBvZiB0aGlzW2lzXSgpKWUucHVzaCh0W0hzXSgpKTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGUpfX1jbGFzcyBLZWVwIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJrZWVwIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjtjb25zdCB0PVsibm9uZSIsImNvbnRlbnRBcmVhIiwicGFnZUFyZWEiXTt0aGlzLmludGFjdD1nZXRTdHJpbmdPcHRpb24oZS5pbnRhY3QsdCk7dGhpcy5uZXh0PWdldFN0cmluZ09wdGlvbihlLm5leHQsdCk7dGhpcy5wcmV2aW91cz1nZXRTdHJpbmdPcHRpb24oZS5wcmV2aW91cyx0KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbH19Y2xhc3MgS2V5VXNhZ2UgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImtleVVzYWdlIik7Y29uc3QgdD1bIiIsInllcyIsIm5vIl07dGhpcy5jcmxTaWduPWdldFN0cmluZ09wdGlvbihlLmNybFNpZ24sdCk7dGhpcy5kYXRhRW5jaXBoZXJtZW50PWdldFN0cmluZ09wdGlvbihlLmRhdGFFbmNpcGhlcm1lbnQsdCk7dGhpcy5kZWNpcGhlck9ubHk9Z2V0U3RyaW5nT3B0aW9uKGUuZGVjaXBoZXJPbmx5LHQpO3RoaXMuZGlnaXRhbFNpZ25hdHVyZT1nZXRTdHJpbmdPcHRpb24oZS5kaWdpdGFsU2lnbmF0dXJlLHQpO3RoaXMuZW5jaXBoZXJPbmx5PWdldFN0cmluZ09wdGlvbihlLmVuY2lwaGVyT25seSx0KTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMua2V5QWdyZWVtZW50PWdldFN0cmluZ09wdGlvbihlLmtleUFncmVlbWVudCx0KTt0aGlzLmtleUNlcnRTaWduPWdldFN0cmluZ09wdGlvbihlLmtleUNlcnRTaWduLHQpO3RoaXMua2V5RW5jaXBoZXJtZW50PWdldFN0cmluZ09wdGlvbihlLmtleUVuY2lwaGVybWVudCx0KTt0aGlzLm5vblJlcHVkaWF0aW9uPWdldFN0cmluZ09wdGlvbihlLm5vblJlcHVkaWF0aW9uLHQpO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIExpbmUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sImxpbmUiLCEwKTt0aGlzLmhhbmQ9Z2V0U3RyaW5nT3B0aW9uKGUuaGFuZCxbImV2ZW4iLCJsZWZ0IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnNsb3BlPWdldFN0cmluZ09wdGlvbihlLnNsb3BlLFsiXFwiLCIvIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmVkZ2U9bnVsbH1benNdKCl7Y29uc3QgZT10aGlzW2NzXSgpW2NzXSgpLHQ9dGhpcy5lZGdlfHxuZXcgRWRnZSh7fSksYT10W0dzXSgpLHI9T2JqZWN0LmNyZWF0ZShudWxsKSxpPSJ2aXNpYmxlIj09PXQucHJlc2VuY2U/dC50aGlja25lc3M6MDtyLnN0cm9rZVdpZHRoPW1lYXN1cmVUb1N0cmluZyhpKTtyLnN0cm9rZT1hLmNvbG9yO2xldCBuLHMsbyxjLGw9IjEwMCUiLGg9IjEwMCUiO2lmKGUudzw9aSl7W24scyxvLGNdPVsiNTAlIiwwLCI1MCUiLCIxMDAlIl07bD1yLnN0cm9rZVdpZHRofWVsc2UgaWYoZS5oPD1pKXtbbixzLG8sY109WzAsIjUwJSIsIjEwMCUiLCI1MCUiXTtoPXIuc3Ryb2tlV2lkdGh9ZWxzZSJcXCI9PT10aGlzLnNsb3BlP1tuLHMsbyxjXT1bMCwwLCIxMDAlIiwiMTAwJSJdOltuLHMsbyxjXT1bMCwiMTAwJSIsIjEwMCUiLDBdO2NvbnN0IHU9e25hbWU6InN2ZyIsY2hpbGRyZW46W3tuYW1lOiJsaW5lIixhdHRyaWJ1dGVzOnt4bWxuczpEbyx4MTpuLHkxOnMseDI6byx5MjpjLHN0eWxlOnJ9fV0sYXR0cmlidXRlczp7eG1sbnM6RG8sd2lkdGg6bCxoZWlnaHQ6aCxzdHlsZTp7b3ZlcmZsb3c6InZpc2libGUifX19O2lmKGhhc01hcmdpbihlKSlyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e3N0eWxlOntkaXNwbGF5OiJpbmxpbmUiLHdpZHRoOiIxMDAlIixoZWlnaHQ6IjEwMCUifX0sY2hpbGRyZW46W3VdfSk7dS5hdHRyaWJ1dGVzLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh1KX19Y2xhc3MgTGluZWFyIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJsaW5lYXIiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsidG9SaWdodCIsInRvQm90dG9tIiwidG9MZWZ0IiwidG9Ub3AiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsfVtHc10oZSl7ZT1lP2VbR3NdKCk6IiNGRkZGRkYiO3JldHVybmBsaW5lYXItZ3JhZGllbnQoJHt0aGlzLnR5cGUucmVwbGFjZSgvKFtSQkxUXSkvLCIgJDEiKS50b0xvd2VyQ2FzZSgpfSwgJHtlfSwgJHt0aGlzLmNvbG9yP3RoaXMuY29sb3JbR3NdKCk6IiMwMDAwMDAifSlgfX1jbGFzcyBMb2NrRG9jdW1lbnQgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJsb2NrRG9jdW1lbnQiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W0duXSgpe3RoaXNbSG5dPWdldFN0cmluZ09wdGlvbih0aGlzW0huXSxbImF1dG8iLCIwIiwiMSJdKX19Y2xhc3MgTWFuaWZlc3QgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sIm1hbmlmZXN0IiwhMCk7dGhpcy5hY3Rpb249Z2V0U3RyaW5nT3B0aW9uKGUuYWN0aW9uLFsiaW5jbHVkZSIsImFsbCIsImV4Y2x1ZGUiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLnJlZj1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIE1hcmdpbiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywibWFyZ2luIiwhMCk7dGhpcy5ib3R0b21JbnNldD1nZXRNZWFzdXJlbWVudChlLmJvdHRvbUluc2V0LCIwIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlZnRJbnNldD1nZXRNZWFzdXJlbWVudChlLmxlZnRJbnNldCwiMCIpO3RoaXMucmlnaHRJbnNldD1nZXRNZWFzdXJlbWVudChlLnJpZ2h0SW5zZXQsIjAiKTt0aGlzLnRvcEluc2V0PWdldE1lYXN1cmVtZW50KGUudG9wSW5zZXQsIjAiKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbH1bR3NdKCl7cmV0dXJue21hcmdpbjptZWFzdXJlVG9TdHJpbmcodGhpcy50b3BJbnNldCkrIiAiK21lYXN1cmVUb1N0cmluZyh0aGlzLnJpZ2h0SW5zZXQpKyIgIittZWFzdXJlVG9TdHJpbmcodGhpcy5ib3R0b21JbnNldCkrIiAiK21lYXN1cmVUb1N0cmluZyh0aGlzLmxlZnRJbnNldCl9fX1jbGFzcyBNZHAgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sIm1kcCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5wZXJtaXNzaW9ucz1nZXRJbnRlZ2VyKHtkYXRhOmUucGVybWlzc2lvbnMsZGVmYXVsdFZhbHVlOjIsdmFsaWRhdGU6ZT0+MT09PWV8fDM9PT1lfSk7dGhpcy5zaWduYXR1cmVUeXBlPWdldFN0cmluZ09wdGlvbihlLnNpZ25hdHVyZVR5cGUsWyJmaWxsZXIiLCJhdXRob3IiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBNZWRpdW0gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sIm1lZGl1bSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5pbWFnaW5nQkJveD1mdW5jdGlvbiBnZXRCQm94KGUpe2NvbnN0IHQ9LTE7aWYoIWUpcmV0dXJue3g6dCx5OnQsd2lkdGg6dCxoZWlnaHQ6dH07Y29uc3QgYT1lLnNwbGl0KCIsIiw0KS5tYXAoKGU9PmdldE1lYXN1cmVtZW50KGUudHJpbSgpLCItMSIpKSk7aWYoYS5sZW5ndGg8NHx8YVsyXTwwfHxhWzNdPDApcmV0dXJue3g6dCx5OnQsd2lkdGg6dCxoZWlnaHQ6dH07Y29uc3RbcixpLG4sc109YTtyZXR1cm57eDpyLHk6aSx3aWR0aDpuLGhlaWdodDpzfX0oZS5pbWFnaW5nQkJveCk7dGhpcy5sb25nPWdldE1lYXN1cmVtZW50KGUubG9uZyk7dGhpcy5vcmllbnRhdGlvbj1nZXRTdHJpbmdPcHRpb24oZS5vcmllbnRhdGlvbixbInBvcnRyYWl0IiwibGFuZHNjYXBlIl0pO3RoaXMuc2hvcnQ9Z2V0TWVhc3VyZW1lbnQoZS5zaG9ydCk7dGhpcy5zdG9jaz1lLnN0b2NrfHwiIjt0aGlzLnRyYXlJbj1nZXRTdHJpbmdPcHRpb24oZS50cmF5SW4sWyJhdXRvIiwiZGVsZWdhdGUiLCJwYWdlRnJvbnQiXSk7dGhpcy50cmF5T3V0PWdldFN0cmluZ09wdGlvbihlLnRyYXlPdXQsWyJhdXRvIiwiZGVsZWdhdGUiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBNZXNzYWdlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJtZXNzYWdlIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy50ZXh0PW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgTnVtZXJpY0VkaXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sIm51bWVyaWNFZGl0IiwhMCk7dGhpcy5oU2Nyb2xsUG9saWN5PWdldFN0cmluZ09wdGlvbihlLmhTY3JvbGxQb2xpY3ksWyJhdXRvIiwib2ZmIiwib24iXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmNvbWI9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMubWFyZ2luPW51bGx9W3pzXShlKXtjb25zdCB0PXRvU3R5bGUodGhpcywiYm9yZGVyIiwiZm9udCIsIm1hcmdpbiIpLGE9dGhpc1tjc10oKVtjc10oKSxyPXtuYW1lOiJpbnB1dCIsYXR0cmlidXRlczp7dHlwZToidGV4dCIsZmllbGRJZDphW1ZzXSxkYXRhSWQ6YVtXbl0/LltWc118fGFbVnNdLGNsYXNzOlsieGZhVGV4dGZpZWxkIl0sc3R5bGU6dCwiYXJpYS1sYWJlbCI6YXJpYUxhYmVsKGEpLCJhcmlhLXJlcXVpcmVkIjohMX19O2lmKGlzUmVxdWlyZWQoYSkpe3IuYXR0cmlidXRlc1siYXJpYS1yZXF1aXJlZCJdPSEwO3IuYXR0cmlidXRlcy5yZXF1aXJlZD0hMH1yZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJsYWJlbCIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFMYWJlbCJdfSxjaGlsZHJlbjpbcl19KX19Y2xhc3MgT2NjdXIgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sIm9jY3VyIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmluaXRpYWw9IiIhPT1lLmluaXRpYWw/Z2V0SW50ZWdlcih7ZGF0YTplLmluaXRpYWwsZGVmYXVsdFZhbHVlOiIiLHZhbGlkYXRlOmU9PiEwfSk6IiI7dGhpcy5tYXg9IiIhPT1lLm1heD9nZXRJbnRlZ2VyKHtkYXRhOmUubWF4LGRlZmF1bHRWYWx1ZToxLHZhbGlkYXRlOmU9PiEwfSk6IiI7dGhpcy5taW49IiIhPT1lLm1pbj9nZXRJbnRlZ2VyKHtkYXRhOmUubWluLGRlZmF1bHRWYWx1ZToxLHZhbGlkYXRlOmU9PiEwfSk6IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGx9W2puXSgpe2NvbnN0IGU9dGhpc1tjc10oKSx0PXRoaXMubWluOyIiPT09dGhpcy5taW4mJih0aGlzLm1pbj1lIGluc3RhbmNlb2YgUGFnZUFyZWF8fGUgaW5zdGFuY2VvZiBQYWdlU2V0PzA6MSk7IiI9PT10aGlzLm1heCYmKHRoaXMubWF4PSIiPT09dD9lIGluc3RhbmNlb2YgUGFnZUFyZWF8fGUgaW5zdGFuY2VvZiBQYWdlU2V0Py0xOjE6dGhpcy5taW4pOy0xIT09dGhpcy5tYXgmJnRoaXMubWF4PHRoaXMubWluJiYodGhpcy5tYXg9dGhpcy5taW4pOyIiPT09dGhpcy5pbml0aWFsJiYodGhpcy5pbml0aWFsPWUgaW5zdGFuY2VvZiBUZW1wbGF0ZT8xOnRoaXMubWluKX19Y2xhc3MgT2lkIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJvaWQiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgT2lkcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywib2lkcyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLm9pZD1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIE92ZXJmbG93IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJvdmVyZmxvdyIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5sZWFkZXI9ZS5sZWFkZXJ8fCIiO3RoaXMudGFyZ2V0PWUudGFyZ2V0fHwiIjt0aGlzLnRyYWlsZXI9ZS50cmFpbGVyfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W2FzXSgpe2lmKCF0aGlzWyRuXSl7Y29uc3QgZT10aGlzW2NzXSgpLHQ9dGhpc1tsc10oKSxhPXRbanNdKHRoaXMudGFyZ2V0LGUpLHI9dFtqc10odGhpcy5sZWFkZXIsZSksaT10W2pzXSh0aGlzLnRyYWlsZXIsZSk7dGhpc1skbl09e3RhcmdldDphPy5bMF18fG51bGwsbGVhZGVyOnI/LlswXXx8bnVsbCx0cmFpbGVyOmk/LlswXXx8bnVsbCxhZGRMZWFkZXI6ITEsYWRkVHJhaWxlcjohMX19cmV0dXJuIHRoaXNbJG5dfX1jbGFzcyBQYWdlQXJlYSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywicGFnZUFyZWEiLCEwKTt0aGlzLmJsYW5rT3JOb3RCbGFuaz1nZXRTdHJpbmdPcHRpb24oZS5ibGFua09yTm90QmxhbmssWyJhbnkiLCJibGFuayIsIm5vdEJsYW5rIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5pbml0aWFsTnVtYmVyPWdldEludGVnZXIoe2RhdGE6ZS5pbml0aWFsTnVtYmVyLGRlZmF1bHRWYWx1ZToxLHZhbGlkYXRlOmU9PiEwfSk7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5udW1iZXJlZD1nZXRJbnRlZ2VyKHtkYXRhOmUubnVtYmVyZWQsZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ITB9KTt0aGlzLm9kZE9yRXZlbj1nZXRTdHJpbmdPcHRpb24oZS5vZGRPckV2ZW4sWyJhbnkiLCJldmVuIiwib2RkIl0pO3RoaXMucGFnZVBvc2l0aW9uPWdldFN0cmluZ09wdGlvbihlLnBhZ2VQb3NpdGlvbixbImFueSIsImZpcnN0IiwibGFzdCIsIm9ubHkiLCJyZXN0Il0pO3RoaXMucmVsZXZhbnQ9Z2V0UmVsZXZhbnQoZS5yZWxldmFudCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZGVzYz1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tZWRpdW09bnVsbDt0aGlzLm9jY3VyPW51bGw7dGhpcy5hcmVhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmNvbnRlbnRBcmVhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRyYXc9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhjbEdyb3VwPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZpZWxkPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm09bmV3IFhGQU9iamVjdEFycmF5fVtrc10oKXtpZighdGhpc1skbl0pe3RoaXNbJG5dPXtudW1iZXJPZlVzZTowfTtyZXR1cm4hMH1yZXR1cm4hdGhpcy5vY2N1cnx8LTE9PT10aGlzLm9jY3VyLm1heHx8dGhpc1skbl0ubnVtYmVyT2ZVc2U8dGhpcy5vY2N1ci5tYXh9W19uXSgpe2RlbGV0ZSB0aGlzWyRuXX1bc3NdKCl7dGhpc1skbl18fD17bnVtYmVyT2ZVc2U6MH07Y29uc3QgZT10aGlzW2NzXSgpO2lmKCJvcmRlcmVkT2NjdXJyZW5jZSI9PT1lLnJlbGF0aW9uJiZ0aGlzW2tzXSgpKXt0aGlzWyRuXS5udW1iZXJPZlVzZSs9MTtyZXR1cm4gdGhpc31yZXR1cm4gZVtzc10oKX1bWW5dKCl7cmV0dXJuIHRoaXNbJG5dLnNwYWNlfHx7d2lkdGg6MCxoZWlnaHQ6MH19W3pzXSgpe3RoaXNbJG5dfHw9e251bWJlck9mVXNlOjF9O2NvbnN0IGU9W107dGhpc1skbl0uY2hpbGRyZW49ZTtjb25zdCB0PU9iamVjdC5jcmVhdGUobnVsbCk7aWYodGhpcy5tZWRpdW0mJnRoaXMubWVkaXVtLnNob3J0JiZ0aGlzLm1lZGl1bS5sb25nKXt0LndpZHRoPW1lYXN1cmVUb1N0cmluZyh0aGlzLm1lZGl1bS5zaG9ydCk7dC5oZWlnaHQ9bWVhc3VyZVRvU3RyaW5nKHRoaXMubWVkaXVtLmxvbmcpO3RoaXNbJG5dLnNwYWNlPXt3aWR0aDp0aGlzLm1lZGl1bS5zaG9ydCxoZWlnaHQ6dGhpcy5tZWRpdW0ubG9uZ307aWYoImxhbmRzY2FwZSI9PT10aGlzLm1lZGl1bS5vcmllbnRhdGlvbil7Y29uc3QgZT10LndpZHRoO3Qud2lkdGg9dC5oZWlnaHQ7dC5oZWlnaHQ9ZTt0aGlzWyRuXS5zcGFjZT17d2lkdGg6dGhpcy5tZWRpdW0ubG9uZyxoZWlnaHQ6dGhpcy5tZWRpdW0uc2hvcnR9fX1lbHNlIHdhcm4oIlhGQSAtIE5vIG1lZGl1bSBzcGVjaWZpZWQgaW4gcGFnZUFyZWE6IHBsZWFzZSBmaWxlIGEgYnVnLiIpO3RoaXNbTG5dKHtmaWx0ZXI6bmV3IFNldChbImFyZWEiLCJkcmF3IiwiZmllbGQiLCJzdWJmb3JtIl0pLGluY2x1ZGU6ITB9KTt0aGlzW0xuXSh7ZmlsdGVyOm5ldyBTZXQoWyJjb250ZW50QXJlYSJdKSxpbmNsdWRlOiEwfSk7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixjaGlsZHJlbjplLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhUGFnZSJdLGlkOnRoaXNbVnNdLHN0eWxlOnQseGZhTmFtZTp0aGlzLm5hbWV9fSl9fWNsYXNzIFBhZ2VTZXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInBhZ2VTZXQiLCEwKTt0aGlzLmR1cGxleEltcG9zaXRpb249Z2V0U3RyaW5nT3B0aW9uKGUuZHVwbGV4SW1wb3NpdGlvbixbImxvbmdFZGdlIiwic2hvcnRFZGdlIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5yZWxhdGlvbj1nZXRTdHJpbmdPcHRpb24oZS5yZWxhdGlvbixbIm9yZGVyZWRPY2N1cnJlbmNlIiwiZHVwbGV4UGFnaW5hdGVkIiwic2ltcGxleFBhZ2luYXRlZCJdKTt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsO3RoaXMub2NjdXI9bnVsbDt0aGlzLnBhZ2VBcmVhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnBhZ2VTZXQ9bmV3IFhGQU9iamVjdEFycmF5fVtfbl0oKXtmb3IoY29uc3QgZSBvZiB0aGlzLnBhZ2VBcmVhLmNoaWxkcmVuKWVbX25dKCk7Zm9yKGNvbnN0IGUgb2YgdGhpcy5wYWdlU2V0LmNoaWxkcmVuKWVbX25dKCl9W2tzXSgpe3JldHVybiF0aGlzLm9jY3VyfHwtMT09PXRoaXMub2NjdXIubWF4fHx0aGlzWyRuXS5udW1iZXJPZlVzZTx0aGlzLm9jY3VyLm1heH1bc3NdKCl7dGhpc1skbl18fD17bnVtYmVyT2ZVc2U6MSxwYWdlSW5kZXg6LTEscGFnZVNldEluZGV4Oi0xfTtpZigib3JkZXJlZE9jY3VycmVuY2UiPT09dGhpcy5yZWxhdGlvbil7aWYodGhpc1skbl0ucGFnZUluZGV4KzE8dGhpcy5wYWdlQXJlYS5jaGlsZHJlbi5sZW5ndGgpe3RoaXNbJG5dLnBhZ2VJbmRleCs9MTtyZXR1cm4gdGhpcy5wYWdlQXJlYS5jaGlsZHJlblt0aGlzWyRuXS5wYWdlSW5kZXhdW3NzXSgpfWlmKHRoaXNbJG5dLnBhZ2VTZXRJbmRleCsxPHRoaXMucGFnZVNldC5jaGlsZHJlbi5sZW5ndGgpe3RoaXNbJG5dLnBhZ2VTZXRJbmRleCs9MTtyZXR1cm4gdGhpcy5wYWdlU2V0LmNoaWxkcmVuW3RoaXNbJG5dLnBhZ2VTZXRJbmRleF1bc3NdKCl9aWYodGhpc1trc10oKSl7dGhpc1skbl0ubnVtYmVyT2ZVc2UrPTE7dGhpc1skbl0ucGFnZUluZGV4PS0xO3RoaXNbJG5dLnBhZ2VTZXRJbmRleD0tMTtyZXR1cm4gdGhpc1tzc10oKX1jb25zdCBlPXRoaXNbY3NdKCk7aWYoZSBpbnN0YW5jZW9mIFBhZ2VTZXQpcmV0dXJuIGVbc3NdKCk7dGhpc1tfbl0oKTtyZXR1cm4gdGhpc1tzc10oKX1jb25zdCBlPXRoaXNbbHNdKClbJG5dLnBhZ2VOdW1iZXIsdD1lJTI9PTA/ImV2ZW4iOiJvZGQiLGE9MD09PWU/ImZpcnN0IjoicmVzdCI7bGV0IHI9dGhpcy5wYWdlQXJlYS5jaGlsZHJlbi5maW5kKChlPT5lLm9kZE9yRXZlbj09PXQmJmUucGFnZVBvc2l0aW9uPT09YSkpO2lmKHIpcmV0dXJuIHI7cj10aGlzLnBhZ2VBcmVhLmNoaWxkcmVuLmZpbmQoKGU9PiJhbnkiPT09ZS5vZGRPckV2ZW4mJmUucGFnZVBvc2l0aW9uPT09YSkpO2lmKHIpcmV0dXJuIHI7cj10aGlzLnBhZ2VBcmVhLmNoaWxkcmVuLmZpbmQoKGU9PiJhbnkiPT09ZS5vZGRPckV2ZW4mJiJhbnkiPT09ZS5wYWdlUG9zaXRpb24pKTtyZXR1cm4gcnx8dGhpcy5wYWdlQXJlYS5jaGlsZHJlblswXX19Y2xhc3MgUGFyYSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywicGFyYSIsITApO3RoaXMuaEFsaWduPWdldFN0cmluZ09wdGlvbihlLmhBbGlnbixbImxlZnQiLCJjZW50ZXIiLCJqdXN0aWZ5IiwianVzdGlmeUFsbCIsInJhZGl4IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxpbmVIZWlnaHQ9ZS5saW5lSGVpZ2h0P2dldE1lYXN1cmVtZW50KGUubGluZUhlaWdodCwiMHB0Iik6IiI7dGhpcy5tYXJnaW5MZWZ0PWUubWFyZ2luTGVmdD9nZXRNZWFzdXJlbWVudChlLm1hcmdpbkxlZnQsIjBwdCIpOiIiO3RoaXMubWFyZ2luUmlnaHQ9ZS5tYXJnaW5SaWdodD9nZXRNZWFzdXJlbWVudChlLm1hcmdpblJpZ2h0LCIwcHQiKToiIjt0aGlzLm9ycGhhbnM9Z2V0SW50ZWdlcih7ZGF0YTplLm9ycGhhbnMsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMucHJlc2VydmU9ZS5wcmVzZXJ2ZXx8IiI7dGhpcy5yYWRpeE9mZnNldD1lLnJhZGl4T2Zmc2V0P2dldE1lYXN1cmVtZW50KGUucmFkaXhPZmZzZXQsIjBwdCIpOiIiO3RoaXMuc3BhY2VBYm92ZT1lLnNwYWNlQWJvdmU/Z2V0TWVhc3VyZW1lbnQoZS5zcGFjZUFib3ZlLCIwcHQiKToiIjt0aGlzLnNwYWNlQmVsb3c9ZS5zcGFjZUJlbG93P2dldE1lYXN1cmVtZW50KGUuc3BhY2VCZWxvdywiMHB0Iik6IiI7dGhpcy50YWJEZWZhdWx0PWUudGFiRGVmYXVsdD9nZXRNZWFzdXJlbWVudCh0aGlzLnRhYkRlZmF1bHQpOiIiO3RoaXMudGFiU3RvcHM9KGUudGFiU3RvcHN8fCIiKS50cmltKCkuc3BsaXQoL1xzKy8pLm1hcCgoKGUsdCk9PnQlMj09MT9nZXRNZWFzdXJlbWVudChlKTplKSk7dGhpcy50ZXh0SW5kZW50PWUudGV4dEluZGVudD9nZXRNZWFzdXJlbWVudChlLnRleHRJbmRlbnQsIjBwdCIpOiIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnZBbGlnbj1nZXRTdHJpbmdPcHRpb24oZS52QWxpZ24sWyJ0b3AiLCJib3R0b20iLCJtaWRkbGUiXSk7dGhpcy53aWRvd3M9Z2V0SW50ZWdlcih7ZGF0YTplLndpZG93cyxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy5oeXBoZW5hdGlvbj1udWxsfVtHc10oKXtjb25zdCBlPXRvU3R5bGUodGhpcywiaEFsaWduIik7IiIhPT10aGlzLm1hcmdpbkxlZnQmJihlLnBhZGRpbmdMZWZ0PW1lYXN1cmVUb1N0cmluZyh0aGlzLm1hcmdpbkxlZnQpKTsiIiE9PXRoaXMubWFyZ2luUmlnaHQmJihlLnBhZGRpbmdSaWdodD1tZWFzdXJlVG9TdHJpbmcodGhpcy5tYXJnaW5SaWdodCkpOyIiIT09dGhpcy5zcGFjZUFib3ZlJiYoZS5wYWRkaW5nVG9wPW1lYXN1cmVUb1N0cmluZyh0aGlzLnNwYWNlQWJvdmUpKTsiIiE9PXRoaXMuc3BhY2VCZWxvdyYmKGUucGFkZGluZ0JvdHRvbT1tZWFzdXJlVG9TdHJpbmcodGhpcy5zcGFjZUJlbG93KSk7aWYoIiIhPT10aGlzLnRleHRJbmRlbnQpe2UudGV4dEluZGVudD1tZWFzdXJlVG9TdHJpbmcodGhpcy50ZXh0SW5kZW50KTtmaXhUZXh0SW5kZW50KGUpfXRoaXMubGluZUhlaWdodD4wJiYoZS5saW5lSGVpZ2h0PW1lYXN1cmVUb1N0cmluZyh0aGlzLmxpbmVIZWlnaHQpKTsiIiE9PXRoaXMudGFiRGVmYXVsdCYmKGUudGFiU2l6ZT1tZWFzdXJlVG9TdHJpbmcodGhpcy50YWJEZWZhdWx0KSk7dGhpcy50YWJTdG9wcy5sZW5ndGg7dGhpcy5oeXBoZW5hdGF0aW9uJiZPYmplY3QuYXNzaWduKGUsdGhpcy5oeXBoZW5hdGF0aW9uW0dzXSgpKTtyZXR1cm4gZX19Y2xhc3MgUGFzc3dvcmRFZGl0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJwYXNzd29yZEVkaXQiLCEwKTt0aGlzLmhTY3JvbGxQb2xpY3k9Z2V0U3RyaW5nT3B0aW9uKGUuaFNjcm9sbFBvbGljeSxbImF1dG8iLCJvZmYiLCJvbiJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucGFzc3dvcmRDaGFyPWUucGFzc3dvcmRDaGFyfHwiKiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsfX1jbGFzcyB0ZW1wbGF0ZV9QYXR0ZXJuIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJwYXR0ZXJuIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbImNyb3NzSGF0Y2giLCJjcm9zc0RpYWdvbmFsIiwiZGlhZ29uYWxMZWZ0IiwiZGlhZ29uYWxSaWdodCIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jb2xvcj1udWxsO3RoaXMuZXh0cmFzPW51bGx9W0dzXShlKXtlPWU/ZVtHc10oKToiI0ZGRkZGRiI7Y29uc3QgdD10aGlzLmNvbG9yP3RoaXMuY29sb3JbR3NdKCk6IiMwMDAwMDAiLGE9InJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQiLHI9YCR7ZX0sJHtlfSA1cHgsJHt0fSA1cHgsJHt0fSAxMHB4YDtzd2l0Y2godGhpcy50eXBlKXtjYXNlImNyb3NzSGF0Y2giOnJldHVybmAke2F9KHRvIHRvcCwke3J9KSAke2F9KHRvIHJpZ2h0LCR7cn0pYDtjYXNlImNyb3NzRGlhZ29uYWwiOnJldHVybmAke2F9KDQ1ZGVnLCR7cn0pICR7YX0oLTQ1ZGVnLCR7cn0pYDtjYXNlImRpYWdvbmFsTGVmdCI6cmV0dXJuYCR7YX0oNDVkZWcsJHtyfSlgO2Nhc2UiZGlhZ29uYWxSaWdodCI6cmV0dXJuYCR7YX0oLTQ1ZGVnLCR7cn0pYDtjYXNlImhvcml6b250YWwiOnJldHVybmAke2F9KHRvIHRvcCwke3J9KWA7Y2FzZSJ2ZXJ0aWNhbCI6cmV0dXJuYCR7YX0odG8gcmlnaHQsJHtyfSlgfXJldHVybiIifX1jbGFzcyBQaWN0dXJlIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJwaWN0dXJlIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFByb3RvIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJwcm90byIsITApO3RoaXMuYXBwZWFyYW5jZUZpbHRlcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5hcmM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYXJlYT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5hc3Npc3Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYmFyY29kZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5iaW5kSXRlbXM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYm9va2VuZD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5ib29sZWFuPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmJvcmRlcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5icmVhaz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5icmVha0FmdGVyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmJyZWFrQmVmb3JlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmJ1dHRvbj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5jYWxjdWxhdGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY2FwdGlvbj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5jZXJ0aWZpY2F0ZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5jZXJ0aWZpY2F0ZXM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY2hlY2tCdXR0b249bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY2hvaWNlTGlzdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5jb2xvcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5jb21iPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmNvbm5lY3Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY29udGVudEFyZWE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY29ybmVyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRhdGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZVRpbWU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZVRpbWVFZGl0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRlY2ltYWw9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGVmYXVsdFVpPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRlc2M9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGlnZXN0TWV0aG9kPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRpZ2VzdE1ldGhvZHM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZHJhdz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5lZGdlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmVuY29kaW5nPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmVuY29kaW5ncz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5lbmNyeXB0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmVuY3J5cHREYXRhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmVuY3J5cHRpb249bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZW5jcnlwdGlvbk1ldGhvZD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5lbmNyeXB0aW9uTWV0aG9kcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5ldmVudD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5leERhdGE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhPYmplY3Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhjbEdyb3VwPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4ZWN1dGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXh0cmFzPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZpZWxkPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZpbGw9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZmlsdGVyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZsb2F0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZvbnQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZm9ybWF0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmhhbmRsZXI9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuaHlwaGVuYXRpb249bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuaW1hZ2U9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuaW1hZ2VFZGl0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmludGVnZXI9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuaXNzdWVycz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pdGVtcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5rZWVwPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmtleVVzYWdlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmxpbmU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMubGluZWFyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmxvY2tEb2N1bWVudD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5tYW5pZmVzdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5tYXJnaW49bmV3IFhGQU9iamVjdEFycmF5O3RoaXMubWRwPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLm1lZGl1bT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5tZXNzYWdlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLm51bWVyaWNFZGl0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLm9jY3VyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLm9pZD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5vaWRzPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLm92ZXJmbG93PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnBhZ2VBcmVhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnBhZ2VTZXQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucGFyYT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5wYXNzd29yZEVkaXQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucGF0dGVybj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5waWN0dXJlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnJhZGlhbD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5yZWFzb249bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucmVhc29ucz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5yZWN0YW5nbGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucmVmPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnNjcmlwdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zZXRQcm9wZXJ0eT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zaWduRGF0YT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zaWduYXR1cmU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc2lnbmluZz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zb2xpZD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zcGVhaz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zdGlwcGxlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm09bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3ViZm9ybVNldD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJqZWN0RE49bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3ViamVjdEROcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJtaXQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGV4dD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50ZXh0RWRpdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50aW1lPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRpbWVTdGFtcD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50b29sVGlwPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRyYXZlcnNhbD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50cmF2ZXJzZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy51aT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy52YWxpZGF0ZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy52YWx1ZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy52YXJpYWJsZXM9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBSYWRpYWwgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInJhZGlhbCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJ0b0VkZ2UiLCJ0b0NlbnRlciJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jb2xvcj1udWxsO3RoaXMuZXh0cmFzPW51bGx9W0dzXShlKXtlPWU/ZVtHc10oKToiI0ZGRkZGRiI7Y29uc3QgdD10aGlzLmNvbG9yP3RoaXMuY29sb3JbR3NdKCk6IiMwMDAwMDAiO3JldHVybmByYWRpYWwtZ3JhZGllbnQoY2lyY2xlIGF0IGNlbnRlciwgJHsidG9FZGdlIj09PXRoaXMudHlwZT9gJHtlfSwke3R9YDpgJHt0fSwke2V9YH0pYH19Y2xhc3MgUmVhc29uIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJyZWFzb24iKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgUmVhc29ucyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywicmVhc29ucyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnJlYXNvbj1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywicmVjdGFuZ2xlIiwhMCk7dGhpcy5oYW5kPWdldFN0cmluZ09wdGlvbihlLmhhbmQsWyJldmVuIiwibGVmdCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29ybmVyPW5ldyBYRkFPYmplY3RBcnJheSg0KTt0aGlzLmVkZ2U9bmV3IFhGQU9iamVjdEFycmF5KDQpO3RoaXMuZmlsbD1udWxsfVt6c10oKXtjb25zdCBlPXRoaXMuZWRnZS5jaGlsZHJlbi5sZW5ndGg/dGhpcy5lZGdlLmNoaWxkcmVuWzBdOm5ldyBFZGdlKHt9KSx0PWVbR3NdKCksYT1PYmplY3QuY3JlYXRlKG51bGwpOyJ2aXNpYmxlIj09PXRoaXMuZmlsbD8ucHJlc2VuY2U/T2JqZWN0LmFzc2lnbihhLHRoaXMuZmlsbFtHc10oKSk6YS5maWxsPSJ0cmFuc3BhcmVudCI7YS5zdHJva2VXaWR0aD1tZWFzdXJlVG9TdHJpbmcoInZpc2libGUiPT09ZS5wcmVzZW5jZT9lLnRoaWNrbmVzczowKTthLnN0cm9rZT10LmNvbG9yO2NvbnN0IHI9KHRoaXMuY29ybmVyLmNoaWxkcmVuLmxlbmd0aD90aGlzLmNvcm5lci5jaGlsZHJlblswXTpuZXcgQ29ybmVyKHt9KSlbR3NdKCksaT17bmFtZToic3ZnIixjaGlsZHJlbjpbe25hbWU6InJlY3QiLGF0dHJpYnV0ZXM6e3htbG5zOkRvLHdpZHRoOiIxMDAlIixoZWlnaHQ6IjEwMCUiLHg6MCx5OjAscng6ci5yYWRpdXMscnk6ci5yYWRpdXMsc3R5bGU6YX19XSxhdHRyaWJ1dGVzOnt4bWxuczpEbyxzdHlsZTp7b3ZlcmZsb3c6InZpc2libGUifSx3aWR0aDoiMTAwJSIsaGVpZ2h0OiIxMDAlIn19O2lmKGhhc01hcmdpbih0aGlzW2NzXSgpW2NzXSgpKSlyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e3N0eWxlOntkaXNwbGF5OiJpbmxpbmUiLHdpZHRoOiIxMDAlIixoZWlnaHQ6IjEwMCUifX0sY2hpbGRyZW46W2ldfSk7aS5hdHRyaWJ1dGVzLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhpKX19Y2xhc3MgUmVmRWxlbWVudCBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywicmVmIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFNjcmlwdCBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywic2NyaXB0Iik7dGhpcy5iaW5kaW5nPWUuYmluZGluZ3x8IiI7dGhpcy5jb250ZW50VHlwZT1lLmNvbnRlbnRUeXBlfHwiIjt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucnVuQXQ9Z2V0U3RyaW5nT3B0aW9uKGUucnVuQXQsWyJjbGllbnQiLCJib3RoIiwic2VydmVyIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgU2V0UHJvcGVydHkgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInNldFByb3BlcnR5Iik7dGhpcy5jb25uZWN0aW9uPWUuY29ubmVjdGlvbnx8IiI7dGhpcy5yZWY9ZS5yZWZ8fCIiO3RoaXMudGFyZ2V0PWUudGFyZ2V0fHwiIn19Y2xhc3MgU2lnbkRhdGEgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInNpZ25EYXRhIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm9wZXJhdGlvbj1nZXRTdHJpbmdPcHRpb24oZS5vcGVyYXRpb24sWyJzaWduIiwiY2xlYXIiLCJ2ZXJpZnkiXSk7dGhpcy5yZWY9ZS5yZWZ8fCIiO3RoaXMudGFyZ2V0PWUudGFyZ2V0fHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5maWx0ZXI9bnVsbDt0aGlzLm1hbmlmZXN0PW51bGx9fWNsYXNzIFNpZ25hdHVyZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywic2lnbmF0dXJlIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIlBERjEuMyIsIlBERjEuNiJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMuZmlsdGVyPW51bGw7dGhpcy5tYW5pZmVzdD1udWxsO3RoaXMubWFyZ2luPW51bGx9fWNsYXNzIFNpZ25pbmcgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInNpZ25pbmciLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jZXJ0aWZpY2F0ZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIFNvbGlkIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJzb2xpZCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGx9W0dzXShlKXtyZXR1cm4gZT9lW0dzXSgpOiIjRkZGRkZGIn19Y2xhc3MgU3BlYWsgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInNwZWFrIik7dGhpcy5kaXNhYmxlPWdldEludGVnZXIoe2RhdGE6ZS5kaXNhYmxlLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnByaW9yaXR5PWdldFN0cmluZ09wdGlvbihlLnByaW9yaXR5LFsiY3VzdG9tIiwiY2FwdGlvbiIsIm5hbWUiLCJ0b29sVGlwIl0pO3RoaXMucmlkPWUucmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFN0aXBwbGUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInN0aXBwbGUiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucmF0ZT1nZXRJbnRlZ2VyKHtkYXRhOmUucmF0ZSxkZWZhdWx0VmFsdWU6NTAsdmFsaWRhdGU6ZT0+ZT49MCYmZTw9MTAwfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsfVtHc10oZSl7Y29uc3QgdD10aGlzLnJhdGUvMTAwO3JldHVybiBVdGlsLm1ha2VIZXhDb2xvcihNYXRoLnJvdW5kKGUudmFsdWUuciooMS10KSt0aGlzLnZhbHVlLnIqdCksTWF0aC5yb3VuZChlLnZhbHVlLmcqKDEtdCkrdGhpcy52YWx1ZS5nKnQpLE1hdGgucm91bmQoZS52YWx1ZS5iKigxLXQpK3RoaXMudmFsdWUuYip0KSl9fWNsYXNzIFN1YmZvcm0gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInN1YmZvcm0iLCEwKTt0aGlzLmFjY2Vzcz1nZXRTdHJpbmdPcHRpb24oZS5hY2Nlc3MsWyJvcGVuIiwibm9uSW50ZXJhY3RpdmUiLCJwcm90ZWN0ZWQiLCJyZWFkT25seSJdKTt0aGlzLmFsbG93TWFjcm89Z2V0SW50ZWdlcih7ZGF0YTplLmFsbG93TWFjcm8sZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLmFuY2hvclR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUuYW5jaG9yVHlwZSxbInRvcExlZnQiLCJib3R0b21DZW50ZXIiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJtaWRkbGVDZW50ZXIiLCJtaWRkbGVMZWZ0IiwibWlkZGxlUmlnaHQiLCJ0b3BDZW50ZXIiLCJ0b3BSaWdodCJdKTt0aGlzLmNvbFNwYW49Z2V0SW50ZWdlcih7ZGF0YTplLmNvbFNwYW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ZT49MXx8LTE9PT1lfSk7dGhpcy5jb2x1bW5XaWR0aHM9KGUuY29sdW1uV2lkdGhzfHwiIikudHJpbSgpLnNwbGl0KC9ccysvKS5tYXAoKGU9PiItMSI9PT1lPy0xOmdldE1lYXN1cmVtZW50KGUpKSk7dGhpcy5oPWUuaD9nZXRNZWFzdXJlbWVudChlLmgpOiIiO3RoaXMuaEFsaWduPWdldFN0cmluZ09wdGlvbihlLmhBbGlnbixbImxlZnQiLCJjZW50ZXIiLCJqdXN0aWZ5IiwianVzdGlmeUFsbCIsInJhZGl4IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxheW91dD1nZXRTdHJpbmdPcHRpb24oZS5sYXlvdXQsWyJwb3NpdGlvbiIsImxyLXRiIiwicmwtcm93IiwicmwtdGIiLCJyb3ciLCJ0YWJsZSIsInRiIl0pO3RoaXMubG9jYWxlPWUubG9jYWxlfHwiIjt0aGlzLm1heEg9Z2V0TWVhc3VyZW1lbnQoZS5tYXhILCIwcHQiKTt0aGlzLm1heFc9Z2V0TWVhc3VyZW1lbnQoZS5tYXhXLCIwcHQiKTt0aGlzLm1lcmdlTW9kZT1nZXRTdHJpbmdPcHRpb24oZS5tZXJnZU1vZGUsWyJjb25zdW1lRGF0YSIsIm1hdGNoVGVtcGxhdGUiXSk7dGhpcy5taW5IPWdldE1lYXN1cmVtZW50KGUubWluSCwiMHB0Iik7dGhpcy5taW5XPWdldE1lYXN1cmVtZW50KGUubWluVywiMHB0Iik7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5wcmVzZW5jZT1nZXRTdHJpbmdPcHRpb24oZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMucmVzdG9yZVN0YXRlPWdldFN0cmluZ09wdGlvbihlLnJlc3RvcmVTdGF0ZSxbIm1hbnVhbCIsImF1dG8iXSk7dGhpcy5zY29wZT1nZXRTdHJpbmdPcHRpb24oZS5zY29wZSxbIm5hbWUiLCJub25lIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnc9ZS53P2dldE1lYXN1cmVtZW50KGUudyk6IiI7dGhpcy54PWdldE1lYXN1cmVtZW50KGUueCwiMHB0Iik7dGhpcy55PWdldE1lYXN1cmVtZW50KGUueSwiMHB0Iik7dGhpcy5hc3Npc3Q9bnVsbDt0aGlzLmJpbmQ9bnVsbDt0aGlzLmJvb2tlbmQ9bnVsbDt0aGlzLmJvcmRlcj1udWxsO3RoaXMuYnJlYWs9bnVsbDt0aGlzLmNhbGN1bGF0ZT1udWxsO3RoaXMuZGVzYz1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5rZWVwPW51bGw7dGhpcy5tYXJnaW49bnVsbDt0aGlzLm9jY3VyPW51bGw7dGhpcy5vdmVyZmxvdz1udWxsO3RoaXMucGFnZVNldD1udWxsO3RoaXMucGFyYT1udWxsO3RoaXMudHJhdmVyc2FsPW51bGw7dGhpcy52YWxpZGF0ZT1udWxsO3RoaXMudmFyaWFibGVzPW51bGw7dGhpcy5hcmVhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmJyZWFrQWZ0ZXI9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYnJlYWtCZWZvcmU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY29ubmVjdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kcmF3PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV2ZW50PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4T2JqZWN0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4Y2xHcm91cD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5maWVsZD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5wcm90bz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zZXRQcm9wZXJ0eT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJmb3JtPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm1TZXQ9bmV3IFhGQU9iamVjdEFycmF5fVtvc10oKXtjb25zdCBlPXRoaXNbY3NdKCk7cmV0dXJuIGUgaW5zdGFuY2VvZiBTdWJmb3JtU2V0P2Vbb3NdKCk6ZX1bbXNdKCl7cmV0dXJuITB9W1NzXSgpe3JldHVybiB0aGlzLmxheW91dC5lbmRzV2l0aCgiLXRiIikmJjA9PT10aGlzWyRuXS5hdHRlbXB0JiZ0aGlzWyRuXS5udW1iZXJJbkxpbmU+MHx8dGhpc1tjc10oKVtTc10oKX0qW25zXSgpe3lpZWxkKmdldENvbnRhaW5lZENoaWxkcmVuKHRoaXMpfVtWbl0oKXtyZXR1cm4gZmx1c2hIVE1MKHRoaXMpfVtFbl0oZSx0KXthZGRIVE1MKHRoaXMsZSx0KX1bWW5dKCl7cmV0dXJuIGdldEF2YWlsYWJsZVNwYWNlKHRoaXMpfVt4c10oKXtjb25zdCBlPXRoaXNbb3NdKCk7aWYoIWVbeHNdKCkpcmV0dXJuITE7aWYodm9pZCAwIT09dGhpc1skbl0uX2lzU3BsaXR0YWJsZSlyZXR1cm4gdGhpc1skbl0uX2lzU3BsaXR0YWJsZTtpZigicG9zaXRpb24iPT09dGhpcy5sYXlvdXR8fHRoaXMubGF5b3V0LmluY2x1ZGVzKCJyb3ciKSl7dGhpc1skbl0uX2lzU3BsaXR0YWJsZT0hMTtyZXR1cm4hMX1pZih0aGlzLmtlZXAmJiJub25lIiE9PXRoaXMua2VlcC5pbnRhY3Qpe3RoaXNbJG5dLl9pc1NwbGl0dGFibGU9ITE7cmV0dXJuITF9aWYoZS5sYXlvdXQ/LmVuZHNXaXRoKCItdGIiKSYmMCE9PWVbJG5dLm51bWJlckluTGluZSlyZXR1cm4hMTt0aGlzWyRuXS5faXNTcGxpdHRhYmxlPSEwO3JldHVybiEwfVt6c10oZSl7c2V0VGFiSW5kZXgodGhpcyk7aWYodGhpcy5icmVhayl7aWYoImF1dG8iIT09dGhpcy5icmVhay5hZnRlcnx8IiIhPT10aGlzLmJyZWFrLmFmdGVyVGFyZ2V0KXtjb25zdCBlPW5ldyBCcmVha0FmdGVyKHt0YXJnZXRUeXBlOnRoaXMuYnJlYWsuYWZ0ZXIsdGFyZ2V0OnRoaXMuYnJlYWsuYWZ0ZXJUYXJnZXQsc3RhcnROZXc6dGhpcy5icmVhay5zdGFydE5ldy50b1N0cmluZygpfSk7ZVtoc109dGhpc1toc107dGhpc1tQbl0oZSk7dGhpcy5icmVha0FmdGVyLnB1c2goZSl9aWYoImF1dG8iIT09dGhpcy5icmVhay5iZWZvcmV8fCIiIT09dGhpcy5icmVhay5iZWZvcmVUYXJnZXQpe2NvbnN0IGU9bmV3IEJyZWFrQmVmb3JlKHt0YXJnZXRUeXBlOnRoaXMuYnJlYWsuYmVmb3JlLHRhcmdldDp0aGlzLmJyZWFrLmJlZm9yZVRhcmdldCxzdGFydE5ldzp0aGlzLmJyZWFrLnN0YXJ0TmV3LnRvU3RyaW5nKCl9KTtlW2hzXT10aGlzW2hzXTt0aGlzW1BuXShlKTt0aGlzLmJyZWFrQmVmb3JlLnB1c2goZSl9aWYoIiIhPT10aGlzLmJyZWFrLm92ZXJmbG93VGFyZ2V0KXtjb25zdCBlPW5ldyBPdmVyZmxvdyh7dGFyZ2V0OnRoaXMuYnJlYWsub3ZlcmZsb3dUYXJnZXQsbGVhZGVyOnRoaXMuYnJlYWsub3ZlcmZsb3dMZWFkZXIsdHJhaWxlcjp0aGlzLmJyZWFrLm92ZXJmbG93VHJhaWxlcn0pO2VbaHNdPXRoaXNbaHNdO3RoaXNbUG5dKGUpO3RoaXMub3ZlcmZsb3cucHVzaChlKX10aGlzW05zXSh0aGlzLmJyZWFrKTt0aGlzLmJyZWFrPW51bGx9aWYoImhpZGRlbiI9PT10aGlzLnByZXNlbmNlfHwiaW5hY3RpdmUiPT09dGhpcy5wcmVzZW5jZSlyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWTsodGhpcy5icmVha0JlZm9yZS5jaGlsZHJlbi5sZW5ndGg+MXx8dGhpcy5icmVha0FmdGVyLmNoaWxkcmVuLmxlbmd0aD4xKSYmd2FybigiWEZBIC0gU2V2ZXJhbCBicmVha0JlZm9yZSBvciBicmVha0FmdGVyIGluIHN1YmZvcm1zOiBwbGVhc2UgZmlsZSBhIGJ1Zy4iKTtpZih0aGlzLmJyZWFrQmVmb3JlLmNoaWxkcmVuLmxlbmd0aD49MSl7Y29uc3QgZT10aGlzLmJyZWFrQmVmb3JlLmNoaWxkcmVuWzBdO2lmKGhhbmRsZUJyZWFrKGUpKXJldHVybiBIVE1MUmVzdWx0LmJyZWFrTm9kZShlKX1pZih0aGlzWyRuXT8uYWZ0ZXJCcmVha0FmdGVyKXJldHVybiBIVE1MUmVzdWx0LkVNUFRZO2ZpeERpbWVuc2lvbnModGhpcyk7Y29uc3QgdD1bXSxhPXtpZDp0aGlzW1ZzXSxjbGFzczpbXX07c2V0QWNjZXNzKHRoaXMsYS5jbGFzcyk7dGhpc1skbl18fD1PYmplY3QuY3JlYXRlKG51bGwpO09iamVjdC5hc3NpZ24odGhpc1skbl0se2NoaWxkcmVuOnQsbGluZTpudWxsLGF0dHJpYnV0ZXM6YSxhdHRlbXB0OjAsbnVtYmVySW5MaW5lOjAsYXZhaWxhYmxlU3BhY2U6e3dpZHRoOk1hdGgubWluKHRoaXMud3x8MS8wLGUud2lkdGgpLGhlaWdodDpNYXRoLm1pbih0aGlzLmh8fDEvMCxlLmhlaWdodCl9LHdpZHRoOjAsaGVpZ2h0OjAscHJldkhlaWdodDowLGN1cnJlbnRXaWR0aDowfSk7Y29uc3Qgcj10aGlzW2xzXSgpLGk9clskbl0ubm9MYXlvdXRGYWlsdXJlLG49dGhpc1t4c10oKTtufHxzZXRGaXJzdFVuc3BsaXR0YWJsZSh0aGlzKTtpZighY2hlY2tEaW1lbnNpb25zKHRoaXMsZSkpcmV0dXJuIEhUTUxSZXN1bHQuRkFJTFVSRTtjb25zdCBzPW5ldyBTZXQoWyJhcmVhIiwiZHJhdyIsImV4Y2xHcm91cCIsImZpZWxkIiwic3ViZm9ybSIsInN1YmZvcm1TZXQiXSk7aWYodGhpcy5sYXlvdXQuaW5jbHVkZXMoInJvdyIpKXtjb25zdCBlPXRoaXNbb3NdKCkuY29sdW1uV2lkdGhzO2lmKEFycmF5LmlzQXJyYXkoZSkmJmUubGVuZ3RoPjApe3RoaXNbJG5dLmNvbHVtbldpZHRocz1lO3RoaXNbJG5dLmN1cnJlbnRDb2x1bW49MH19Y29uc3Qgbz10b1N0eWxlKHRoaXMsImFuY2hvclR5cGUiLCJkaW1lbnNpb25zIiwicG9zaXRpb24iLCJwcmVzZW5jZSIsImJvcmRlciIsIm1hcmdpbiIsImhBbGlnbiIpLGM9WyJ4ZmFTdWJmb3JtIl0sbD1sYXlvdXRDbGFzcyh0aGlzKTtsJiZjLnB1c2gobCk7YS5zdHlsZT1vO2EuY2xhc3M9Yzt0aGlzLm5hbWUmJihhLnhmYU5hbWU9dGhpcy5uYW1lKTtpZih0aGlzLm92ZXJmbG93KXtjb25zdCB0PXRoaXMub3ZlcmZsb3dbYXNdKCk7aWYodC5hZGRMZWFkZXIpe3QuYWRkTGVhZGVyPSExO2hhbmRsZU92ZXJmbG93KHRoaXMsdC5sZWFkZXIsZSl9fXRoaXNbUnNdKCk7Y29uc3QgaD0ibHItdGIiPT09dGhpcy5sYXlvdXR8fCJybC10YiI9PT10aGlzLmxheW91dCx1PWg/MjoxO2Zvcig7dGhpc1skbl0uYXR0ZW1wdDx1O3RoaXNbJG5dLmF0dGVtcHQrKyl7aCYmMT09PXRoaXNbJG5dLmF0dGVtcHQmJih0aGlzWyRuXS5udW1iZXJJbkxpbmU9MCk7Y29uc3QgZT10aGlzW0xuXSh7ZmlsdGVyOnMsaW5jbHVkZTohMH0pO2lmKGUuc3VjY2VzcylicmVhaztpZihlLmlzQnJlYWsoKSl7dGhpc1tCc10oKTtyZXR1cm4gZX1pZihoJiYwPT09dGhpc1skbl0uYXR0ZW1wdCYmMD09PXRoaXNbJG5dLm51bWJlckluTGluZSYmIXJbJG5dLm5vTGF5b3V0RmFpbHVyZSl7dGhpc1skbl0uYXR0ZW1wdD11O2JyZWFrfX10aGlzW0JzXSgpO258fHVuc2V0Rmlyc3RVbnNwbGl0dGFibGUodGhpcyk7clskbl0ubm9MYXlvdXRGYWlsdXJlPWk7aWYodGhpc1skbl0uYXR0ZW1wdD09PXUpe3RoaXMub3ZlcmZsb3cmJih0aGlzW2xzXSgpWyRuXS5vdmVyZmxvd05vZGU9dGhpcy5vdmVyZmxvdyk7bnx8ZGVsZXRlIHRoaXNbJG5dO3JldHVybiBIVE1MUmVzdWx0LkZBSUxVUkV9aWYodGhpcy5vdmVyZmxvdyl7Y29uc3QgdD10aGlzLm92ZXJmbG93W2FzXSgpO2lmKHQuYWRkVHJhaWxlcil7dC5hZGRUcmFpbGVyPSExO2hhbmRsZU92ZXJmbG93KHRoaXMsdC50cmFpbGVyLGUpfX1sZXQgZD0wLGY9MDtpZih0aGlzLm1hcmdpbil7ZD10aGlzLm1hcmdpbi5sZWZ0SW5zZXQrdGhpcy5tYXJnaW4ucmlnaHRJbnNldDtmPXRoaXMubWFyZ2luLnRvcEluc2V0K3RoaXMubWFyZ2luLmJvdHRvbUluc2V0fWNvbnN0IGc9TWF0aC5tYXgodGhpc1skbl0ud2lkdGgrZCx0aGlzLnd8fDApLHA9TWF0aC5tYXgodGhpc1skbl0uaGVpZ2h0K2YsdGhpcy5ofHwwKSxtPVt0aGlzLngsdGhpcy55LGcscF07IiI9PT10aGlzLncmJihvLndpZHRoPW1lYXN1cmVUb1N0cmluZyhnKSk7IiI9PT10aGlzLmgmJihvLmhlaWdodD1tZWFzdXJlVG9TdHJpbmcocCkpO2lmKCgiMHB4Ij09PW8ud2lkdGh8fCIwcHgiPT09by5oZWlnaHQpJiYwPT09dC5sZW5ndGgpcmV0dXJuIEhUTUxSZXN1bHQuRU1QVFk7Y29uc3QgYj17bmFtZToiZGl2IixhdHRyaWJ1dGVzOmEsY2hpbGRyZW46dH07YXBwbHlBc3Npc3QodGhpcyxhKTtjb25zdCB5PUhUTUxSZXN1bHQuc3VjY2VzcyhjcmVhdGVXcmFwcGVyKHRoaXMsYiksbSk7aWYodGhpcy5icmVha0FmdGVyLmNoaWxkcmVuLmxlbmd0aD49MSl7Y29uc3QgZT10aGlzLmJyZWFrQWZ0ZXIuY2hpbGRyZW5bMF07aWYoaGFuZGxlQnJlYWsoZSkpe3RoaXNbJG5dLmFmdGVyQnJlYWtBZnRlcj15O3JldHVybiBIVE1MUmVzdWx0LmJyZWFrTm9kZShlKX19ZGVsZXRlIHRoaXNbJG5dO3JldHVybiB5fX1jbGFzcyBTdWJmb3JtU2V0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJzdWJmb3JtU2V0IiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnJlbGF0aW9uPWdldFN0cmluZ09wdGlvbihlLnJlbGF0aW9uLFsib3JkZXJlZCIsImNob2ljZSIsInVub3JkZXJlZCJdKTt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvb2tlbmQ9bnVsbDt0aGlzLmJyZWFrPW51bGw7dGhpcy5kZXNjPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm9jY3VyPW51bGw7dGhpcy5vdmVyZmxvdz1udWxsO3RoaXMuYnJlYWtBZnRlcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5icmVha0JlZm9yZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJmb3JtPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm1TZXQ9bmV3IFhGQU9iamVjdEFycmF5fSpbbnNdKCl7eWllbGQqZ2V0Q29udGFpbmVkQ2hpbGRyZW4odGhpcyl9W29zXSgpe2xldCBlPXRoaXNbY3NdKCk7Zm9yKDshKGUgaW5zdGFuY2VvZiBTdWJmb3JtKTspZT1lW2NzXSgpO3JldHVybiBlfVttc10oKXtyZXR1cm4hMH19Y2xhc3MgU3ViamVjdEROIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywic3ViamVjdEROIik7dGhpcy5kZWxpbWl0ZXI9ZS5kZWxpbWl0ZXJ8fCIsIjt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn1bR25dKCl7dGhpc1tIbl09bmV3IE1hcCh0aGlzW0huXS5zcGxpdCh0aGlzLmRlbGltaXRlcikubWFwKChlPT57KGU9ZS5zcGxpdCgiPSIsMikpWzBdPWVbMF0udHJpbSgpO3JldHVybiBlfSkpKX19Y2xhc3MgU3ViamVjdEROcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywic3ViamVjdEROcyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnN1YmplY3RETj1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIFN1Ym1pdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywic3VibWl0IiwhMCk7dGhpcy5lbWJlZFBERj1nZXRJbnRlZ2VyKHtkYXRhOmUuZW1iZWRQREYsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLmZvcm1hdD1nZXRTdHJpbmdPcHRpb24oZS5mb3JtYXQsWyJ4ZHAiLCJmb3JtZGF0YSIsInBkZiIsInVybGVuY29kZWQiLCJ4ZmQiLCJ4bWwiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnRhcmdldD1lLnRhcmdldHx8IiI7dGhpcy50ZXh0RW5jb2Rpbmc9Z2V0S2V5d29yZCh7ZGF0YTplLnRleHRFbmNvZGluZz9lLnRleHRFbmNvZGluZy50b0xvd2VyQ2FzZSgpOiIiLGRlZmF1bHRWYWx1ZToiIix2YWxpZGF0ZTplPT5bInV0Zi04IiwiYmlnLWZpdmUiLCJmb250c3BlY2lmaWMiLCJnYmsiLCJnYi0xODAzMCIsImdiLTIzMTIiLCJrc2MtNTYwMSIsIm5vbmUiLCJzaGlmdC1qaXMiLCJ1Y3MtMiIsInV0Zi0xNiJdLmluY2x1ZGVzKGUpfHxlLm1hdGNoKC9pc28tODg1OS1cZHsyfS8pfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMueGRwQ29udGVudD1lLnhkcENvbnRlbnR8fCIiO3RoaXMuZW5jcnlwdD1udWxsO3RoaXMuZW5jcnlwdERhdGE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc2lnbkRhdGE9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBUZW1wbGF0ZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywidGVtcGxhdGUiLCEwKTt0aGlzLmJhc2VQcm9maWxlPWdldFN0cmluZ09wdGlvbihlLmJhc2VQcm9maWxlLFsiZnVsbCIsImludGVyYWN0aXZlRm9ybXMiXSk7dGhpcy5leHRyYXM9bnVsbDt0aGlzLnN1YmZvcm09bmV3IFhGQU9iamVjdEFycmF5fVtHbl0oKXswPT09dGhpcy5zdWJmb3JtLmNoaWxkcmVuLmxlbmd0aCYmd2FybigiWEZBIC0gTm8gc3ViZm9ybXMgaW4gdGVtcGxhdGUgbm9kZS4iKTt0aGlzLnN1YmZvcm0uY2hpbGRyZW4ubGVuZ3RoPj0yJiZ3YXJuKCJYRkEgLSBTZXZlcmFsIHN1YmZvcm1zIGluIHRlbXBsYXRlIG5vZGU6IHBsZWFzZSBmaWxlIGEgYnVnLiIpO3RoaXNbcXNdPTVlM31beHNdKCl7cmV0dXJuITB9W2pzXShlLHQpe3JldHVybiBlLnN0YXJ0c1dpdGgoIiMiKT9bdGhpc1tkc10uZ2V0KGUuc2xpY2UoMSkpXTpzZWFyY2hOb2RlKHRoaXMsdCxlLCEwLCEwKX0qW1dzXSgpe2lmKCF0aGlzLnN1YmZvcm0uY2hpbGRyZW4ubGVuZ3RoKXJldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsY2hpbGRyZW46W119KTt0aGlzWyRuXT17b3ZlcmZsb3dOb2RlOm51bGwsZmlyc3RVbnNwbGl0dGFibGU6bnVsbCxjdXJyZW50Q29udGVudEFyZWE6bnVsbCxjdXJyZW50UGFnZUFyZWE6bnVsbCxub0xheW91dEZhaWx1cmU6ITEscGFnZU51bWJlcjoxLHBhZ2VQb3NpdGlvbjoiZmlyc3QiLG9kZE9yRXZlbjoib2RkIixibGFua09yTm90Qmxhbms6Im5vbkJsYW5rIixwYXJhU3RhY2s6W119O2NvbnN0IGU9dGhpcy5zdWJmb3JtLmNoaWxkcmVuWzBdO2UucGFnZVNldFtfbl0oKTtjb25zdCB0PWUucGFnZVNldC5wYWdlQXJlYS5jaGlsZHJlbixhPXtuYW1lOiJkaXYiLGNoaWxkcmVuOltdfTtsZXQgcj1udWxsLGk9bnVsbCxuPW51bGw7aWYoZS5icmVha0JlZm9yZS5jaGlsZHJlbi5sZW5ndGg+PTEpe2k9ZS5icmVha0JlZm9yZS5jaGlsZHJlblswXTtuPWkudGFyZ2V0fWVsc2UgaWYoZS5zdWJmb3JtLmNoaWxkcmVuLmxlbmd0aD49MSYmZS5zdWJmb3JtLmNoaWxkcmVuWzBdLmJyZWFrQmVmb3JlLmNoaWxkcmVuLmxlbmd0aD49MSl7aT1lLnN1YmZvcm0uY2hpbGRyZW5bMF0uYnJlYWtCZWZvcmUuY2hpbGRyZW5bMF07bj1pLnRhcmdldH1lbHNlIGlmKGUuYnJlYWs/LmJlZm9yZVRhcmdldCl7aT1lLmJyZWFrO249aS5iZWZvcmVUYXJnZXR9ZWxzZSBpZihlLnN1YmZvcm0uY2hpbGRyZW4ubGVuZ3RoPj0xJiZlLnN1YmZvcm0uY2hpbGRyZW5bMF0uYnJlYWs/LmJlZm9yZVRhcmdldCl7aT1lLnN1YmZvcm0uY2hpbGRyZW5bMF0uYnJlYWs7bj1pLmJlZm9yZVRhcmdldH1pZihpKXtjb25zdCBlPXRoaXNbanNdKG4saVtjc10oKSk7aWYoZSBpbnN0YW5jZW9mIFBhZ2VBcmVhKXtyPWU7aVskbl09e319fXJ8fD10WzBdO3JbJG5dPXtudW1iZXJPZlVzZToxfTtjb25zdCBzPXJbY3NdKCk7c1skbl09e251bWJlck9mVXNlOjEscGFnZUluZGV4OnMucGFnZUFyZWEuY2hpbGRyZW4uaW5kZXhPZihyKSxwYWdlU2V0SW5kZXg6MH07bGV0IG8sYz1udWxsLGw9bnVsbCxoPSEwLHU9MCxkPTA7Zm9yKDs7KXtpZihoKXU9MDtlbHNle2EuY2hpbGRyZW4ucG9wKCk7aWYoMz09Kyt1KXt3YXJuKCJYRkEgLSBTb21ldGhpbmcgZ29lcyB3cm9uZzogcGxlYXNlIGZpbGUgYSBidWcuIik7cmV0dXJuIGF9fW89bnVsbDt0aGlzWyRuXS5jdXJyZW50UGFnZUFyZWE9cjtjb25zdCB0PXJbenNdKCkuaHRtbDthLmNoaWxkcmVuLnB1c2godCk7aWYoYyl7dGhpc1skbl0ubm9MYXlvdXRGYWlsdXJlPSEwO3QuY2hpbGRyZW4ucHVzaChjW3pzXShyWyRuXS5zcGFjZSkuaHRtbCk7Yz1udWxsfWlmKGwpe3RoaXNbJG5dLm5vTGF5b3V0RmFpbHVyZT0hMDt0LmNoaWxkcmVuLnB1c2gobFt6c10oclskbl0uc3BhY2UpLmh0bWwpO2w9bnVsbH1jb25zdCBpPXIuY29udGVudEFyZWEuY2hpbGRyZW4sbj10LmNoaWxkcmVuLmZpbHRlcigoZT0+ZS5hdHRyaWJ1dGVzLmNsYXNzLmluY2x1ZGVzKCJ4ZmFDb250ZW50YXJlYSIpKSk7aD0hMTt0aGlzWyRuXS5maXJzdFVuc3BsaXR0YWJsZT1udWxsO3RoaXNbJG5dLm5vTGF5b3V0RmFpbHVyZT0hMTtjb25zdCBmbHVzaD10PT57Y29uc3QgYT1lW1ZuXSgpO2lmKGEpe2h8fD1hLmNoaWxkcmVuPy5sZW5ndGg+MDtuW3RdLmNoaWxkcmVuLnB1c2goYSl9fTtmb3IobGV0IHQ9ZCxyPWkubGVuZ3RoO3Q8cjt0Kyspe2NvbnN0IHI9dGhpc1skbl0uY3VycmVudENvbnRlbnRBcmVhPWlbdF0scz17d2lkdGg6ci53LGhlaWdodDpyLmh9O2Q9MDtpZihjKXtuW3RdLmNoaWxkcmVuLnB1c2goY1t6c10ocykuaHRtbCk7Yz1udWxsfWlmKGwpe25bdF0uY2hpbGRyZW4ucHVzaChsW3pzXShzKS5odG1sKTtsPW51bGx9Y29uc3QgdT1lW3pzXShzKTtpZih1LnN1Y2Nlc3Mpe2lmKHUuaHRtbCl7aHx8PXUuaHRtbC5jaGlsZHJlbj8ubGVuZ3RoPjA7blt0XS5jaGlsZHJlbi5wdXNoKHUuaHRtbCl9ZWxzZSFoJiZhLmNoaWxkcmVuLmxlbmd0aD4xJiZhLmNoaWxkcmVuLnBvcCgpO3JldHVybiBhfWlmKHUuaXNCcmVhaygpKXtjb25zdCBlPXUuYnJlYWtOb2RlO2ZsdXNoKHQpO2lmKCJhdXRvIj09PWUudGFyZ2V0VHlwZSljb250aW51ZTtpZihlLmxlYWRlcil7Yz10aGlzW2pzXShlLmxlYWRlcixlW2NzXSgpKTtjPWM/Y1swXTpudWxsfWlmKGUudHJhaWxlcil7bD10aGlzW2pzXShlLnRyYWlsZXIsZVtjc10oKSk7bD1sP2xbMF06bnVsbH1pZigicGFnZUFyZWEiPT09ZS50YXJnZXRUeXBlKXtvPWVbJG5dLnRhcmdldDt0PTEvMH1lbHNlIGlmKGVbJG5dLnRhcmdldCl7bz1lWyRuXS50YXJnZXQ7ZD1lWyRuXS5pbmRleCsxO3Q9MS8wfWVsc2UgdD1lWyRuXS5pbmRleH1lbHNlIGlmKHRoaXNbJG5dLm92ZXJmbG93Tm9kZSl7Y29uc3QgZT10aGlzWyRuXS5vdmVyZmxvd05vZGU7dGhpc1skbl0ub3ZlcmZsb3dOb2RlPW51bGw7Y29uc3QgYT1lW2FzXSgpLHI9YS50YXJnZXQ7YS5hZGRMZWFkZXI9bnVsbCE9PWEubGVhZGVyO2EuYWRkVHJhaWxlcj1udWxsIT09YS50cmFpbGVyO2ZsdXNoKHQpO2NvbnN0IG49dDt0PTEvMDtpZihyIGluc3RhbmNlb2YgUGFnZUFyZWEpbz1yO2Vsc2UgaWYociBpbnN0YW5jZW9mIENvbnRlbnRBcmVhKXtjb25zdCBlPWkuaW5kZXhPZihyKTtpZigtMSE9PWUpZT5uP3Q9ZS0xOmQ9ZTtlbHNle289cltjc10oKTtkPW8uY29udGVudEFyZWEuY2hpbGRyZW4uaW5kZXhPZihyKX19fWVsc2UgZmx1c2godCl9dGhpc1skbl0ucGFnZU51bWJlcis9MTtvJiYob1trc10oKT9vWyRuXS5udW1iZXJPZlVzZSs9MTpvPW51bGwpO3I9b3x8cltzc10oKTt5aWVsZCBudWxsfX19Y2xhc3MgVGV4dCBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInRleHQiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubWF4Q2hhcnM9Z2V0SW50ZWdlcih7ZGF0YTplLm1heENoYXJzLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnJpZD1lLnJpZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtObl0oKXtyZXR1cm4hMH1bVHNdKGUpe2lmKGVbdnNdPT09SnMueGh0bWwuaWQpe3RoaXNbSG5dPWU7cmV0dXJuITB9d2FybihgWEZBIC0gSW52YWxpZCBjb250ZW50IGluIFRleHQ6ICR7ZVtGc119LmApO3JldHVybiExfVtNc10oZSl7dGhpc1tIbl1pbnN0YW5jZW9mIFhGQU9iamVjdHx8c3VwZXJbTXNdKGUpfVtHbl0oKXsic3RyaW5nIj09dHlwZW9mIHRoaXNbSG5dJiYodGhpc1tIbl09dGhpc1tIbl0ucmVwbGFjZUFsbCgiXHJcbiIsIlxuIikpfVthc10oKXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHRoaXNbSG5dP3RoaXNbSG5dLnNwbGl0KC9bXHUyMDI5XHUyMDI4XG5dLykuZmlsdGVyKChlPT4hIWUpKS5qb2luKCJcbiIpOnRoaXNbSG5dW0hzXSgpfVt6c10oZSl7aWYoInN0cmluZyI9PXR5cGVvZiB0aGlzW0huXSl7Y29uc3QgZT12YWx1ZVRvSHRtbCh0aGlzW0huXSkuaHRtbDtpZih0aGlzW0huXS5pbmNsdWRlcygiXHUyMDI5Iikpe2UubmFtZT0iZGl2IjtlLmNoaWxkcmVuPVtdO3RoaXNbSG5dLnNwbGl0KCJcdTIwMjkiKS5tYXAoKGU9PmUuc3BsaXQoL1tcdTIwMjhcbl0vKS5mbGF0TWFwKChlPT5be25hbWU6InNwYW4iLHZhbHVlOmV9LHtuYW1lOiJiciJ9XSkpKSkuZm9yRWFjaCgodD0+e2UuY2hpbGRyZW4ucHVzaCh7bmFtZToicCIsY2hpbGRyZW46dH0pfSkpfWVsc2UgaWYoL1tcdTIwMjhcbl0vLnRlc3QodGhpc1tIbl0pKXtlLm5hbWU9ImRpdiI7ZS5jaGlsZHJlbj1bXTt0aGlzW0huXS5zcGxpdCgvW1x1MjAyOFxuXS8pLmZvckVhY2goKHQ9PntlLmNoaWxkcmVuLnB1c2goe25hbWU6InNwYW4iLHZhbHVlOnR9LHtuYW1lOiJiciJ9KX0pKX1yZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGUpfXJldHVybiB0aGlzW0huXVt6c10oZSl9fWNsYXNzIFRleHRFZGl0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJ0ZXh0RWRpdCIsITApO3RoaXMuYWxsb3dSaWNoVGV4dD1nZXRJbnRlZ2VyKHtkYXRhOmUuYWxsb3dSaWNoVGV4dCxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMuaFNjcm9sbFBvbGljeT1nZXRTdHJpbmdPcHRpb24oZS5oU2Nyb2xsUG9saWN5LFsiYXV0byIsIm9mZiIsIm9uIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5tdWx0aUxpbmU9Z2V0SW50ZWdlcih7ZGF0YTplLm11bHRpTGluZSxkZWZhdWx0VmFsdWU6IiIsdmFsaWRhdGU6ZT0+MD09PWV8fDE9PT1lfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMudlNjcm9sbFBvbGljeT1nZXRTdHJpbmdPcHRpb24oZS52U2Nyb2xsUG9saWN5LFsiYXV0byIsIm9mZiIsIm9uIl0pO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5jb21iPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsfVt6c10oZSl7Y29uc3QgdD10b1N0eWxlKHRoaXMsImJvcmRlciIsImZvbnQiLCJtYXJnaW4iKTtsZXQgYTtjb25zdCByPXRoaXNbY3NdKClbY3NdKCk7IiI9PT10aGlzLm11bHRpTGluZSYmKHRoaXMubXVsdGlMaW5lPXIgaW5zdGFuY2VvZiBEcmF3PzE6MCk7YT0xPT09dGhpcy5tdWx0aUxpbmU/e25hbWU6InRleHRhcmVhIixhdHRyaWJ1dGVzOntkYXRhSWQ6cltXbl0/LltWc118fHJbVnNdLGZpZWxkSWQ6cltWc10sY2xhc3M6WyJ4ZmFUZXh0ZmllbGQiXSxzdHlsZTp0LCJhcmlhLWxhYmVsIjphcmlhTGFiZWwociksImFyaWEtcmVxdWlyZWQiOiExfX06e25hbWU6ImlucHV0IixhdHRyaWJ1dGVzOnt0eXBlOiJ0ZXh0IixkYXRhSWQ6cltXbl0/LltWc118fHJbVnNdLGZpZWxkSWQ6cltWc10sY2xhc3M6WyJ4ZmFUZXh0ZmllbGQiXSxzdHlsZTp0LCJhcmlhLWxhYmVsIjphcmlhTGFiZWwociksImFyaWEtcmVxdWlyZWQiOiExfX07aWYoaXNSZXF1aXJlZChyKSl7YS5hdHRyaWJ1dGVzWyJhcmlhLXJlcXVpcmVkIl09ITA7YS5hdHRyaWJ1dGVzLnJlcXVpcmVkPSEwfXJldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImxhYmVsIixhdHRyaWJ1dGVzOntjbGFzczpbInhmYUxhYmVsIl19LGNoaWxkcmVuOlthXX0pfX1jbGFzcyBUaW1lIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJ0aW1lIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W0duXSgpe2NvbnN0IGU9dGhpc1tIbl0udHJpbSgpO3RoaXNbSG5dPWU/bmV3IERhdGUoZSk6bnVsbH1benNdKGUpe3JldHVybiB2YWx1ZVRvSHRtbCh0aGlzW0huXT90aGlzW0huXS50b1N0cmluZygpOiIiKX19Y2xhc3MgVGltZVN0YW1wIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJ0aW1lU3RhbXAiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMuc2VydmVyPWUuc2VydmVyfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBUb29sVGlwIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJ0b29sVGlwIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnJpZD1lLnJpZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBUcmF2ZXJzYWwgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInRyYXZlcnNhbCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy50cmF2ZXJzZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIFRyYXZlcnNlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJ0cmF2ZXJzZSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vcGVyYXRpb249Z2V0U3RyaW5nT3B0aW9uKGUub3BlcmF0aW9uLFsibmV4dCIsImJhY2siLCJkb3duIiwiZmlyc3QiLCJsZWZ0IiwicmlnaHQiLCJ1cCJdKTt0aGlzLnJlZj1lLnJlZnx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5zY3JpcHQ9bnVsbH1nZXQgbmFtZSgpe3JldHVybiB0aGlzLm9wZXJhdGlvbn1bQXNdKCl7cmV0dXJuITF9fWNsYXNzIFVpIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJ1aSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5waWN0dXJlPW51bGw7dGhpcy5iYXJjb2RlPW51bGw7dGhpcy5idXR0b249bnVsbDt0aGlzLmNoZWNrQnV0dG9uPW51bGw7dGhpcy5jaG9pY2VMaXN0PW51bGw7dGhpcy5kYXRlVGltZUVkaXQ9bnVsbDt0aGlzLmRlZmF1bHRVaT1udWxsO3RoaXMuaW1hZ2VFZGl0PW51bGw7dGhpcy5udW1lcmljRWRpdD1udWxsO3RoaXMucGFzc3dvcmRFZGl0PW51bGw7dGhpcy5zaWduYXR1cmU9bnVsbDt0aGlzLnRleHRFZGl0PW51bGx9W2FzXSgpe2lmKHZvaWQgMD09PXRoaXNbJG5dKXtmb3IoY29uc3QgZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7aWYoImV4dHJhcyI9PT1lfHwicGljdHVyZSI9PT1lKWNvbnRpbnVlO2NvbnN0IHQ9dGhpc1tlXTtpZih0IGluc3RhbmNlb2YgWEZBT2JqZWN0KXt0aGlzWyRuXT10O3JldHVybiB0fX10aGlzWyRuXT1udWxsfXJldHVybiB0aGlzWyRuXX1benNdKGUpe2NvbnN0IHQ9dGhpc1thc10oKTtyZXR1cm4gdD90W3pzXShlKTpIVE1MUmVzdWx0LkVNUFRZfX1jbGFzcyBWYWxpZGF0ZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihNbywidmFsaWRhdGUiLCEwKTt0aGlzLmZvcm1hdFRlc3Q9Z2V0U3RyaW5nT3B0aW9uKGUuZm9ybWF0VGVzdCxbIndhcm5pbmciLCJkaXNhYmxlZCIsImVycm9yIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5udWxsVGVzdD1nZXRTdHJpbmdPcHRpb24oZS5udWxsVGVzdCxbImRpc2FibGVkIiwiZXJyb3IiLCJ3YXJuaW5nIl0pO3RoaXMuc2NyaXB0VGVzdD1nZXRTdHJpbmdPcHRpb24oZS5zY3JpcHRUZXN0LFsiZXJyb3IiLCJkaXNhYmxlZCIsIndhcm5pbmciXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tZXNzYWdlPW51bGw7dGhpcy5waWN0dXJlPW51bGw7dGhpcy5zY3JpcHQ9bnVsbH19Y2xhc3MgVmFsdWUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTW8sInZhbHVlIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm92ZXJyaWRlPWdldEludGVnZXIoe2RhdGE6ZS5vdmVycmlkZSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMucmVsZXZhbnQ9Z2V0UmVsZXZhbnQoZS5yZWxldmFudCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYXJjPW51bGw7dGhpcy5ib29sZWFuPW51bGw7dGhpcy5kYXRlPW51bGw7dGhpcy5kYXRlVGltZT1udWxsO3RoaXMuZGVjaW1hbD1udWxsO3RoaXMuZXhEYXRhPW51bGw7dGhpcy5mbG9hdD1udWxsO3RoaXMuaW1hZ2U9bnVsbDt0aGlzLmludGVnZXI9bnVsbDt0aGlzLmxpbmU9bnVsbDt0aGlzLnJlY3RhbmdsZT1udWxsO3RoaXMudGV4dD1udWxsO3RoaXMudGltZT1udWxsfVtYc10oZSl7Y29uc3QgdD10aGlzW2NzXSgpO2lmKHQgaW5zdGFuY2VvZiBGaWVsZCYmdC51aT8uaW1hZ2VFZGl0KXtpZighdGhpcy5pbWFnZSl7dGhpcy5pbWFnZT1uZXcgSW1hZ2Uoe30pO3RoaXNbUG5dKHRoaXMuaW1hZ2UpfXRoaXMuaW1hZ2VbSG5dPWVbSG5dO3JldHVybn1jb25zdCBhPWVbRnNdO2lmKG51bGw9PT10aGlzW2FdKXtmb3IoY29uc3QgZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7Y29uc3QgdD10aGlzW2VdO2lmKHQgaW5zdGFuY2VvZiBYRkFPYmplY3Qpe3RoaXNbZV09bnVsbDt0aGlzW05zXSh0KX19dGhpc1tlW0ZzXV09ZTt0aGlzW1BuXShlKX1lbHNlIHRoaXNbYV1bSG5dPWVbSG5dfVtIc10oKXtpZih0aGlzLmV4RGF0YSlyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHRoaXMuZXhEYXRhW0huXT90aGlzLmV4RGF0YVtIbl0udHJpbSgpOnRoaXMuZXhEYXRhW0huXVtIc10oKS50cmltKCk7Zm9yKGNvbnN0IGUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpe2lmKCJpbWFnZSI9PT1lKWNvbnRpbnVlO2NvbnN0IHQ9dGhpc1tlXTtpZih0IGluc3RhbmNlb2YgWEZBT2JqZWN0KXJldHVybih0W0huXXx8IiIpLnRvU3RyaW5nKCkudHJpbSgpfXJldHVybiBudWxsfVt6c10oZSl7Zm9yKGNvbnN0IHQgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpe2NvbnN0IGE9dGhpc1t0XTtpZihhIGluc3RhbmNlb2YgWEZBT2JqZWN0KXJldHVybiBhW3pzXShlKX1yZXR1cm4gSFRNTFJlc3VsdC5FTVBUWX19Y2xhc3MgVmFyaWFibGVzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE1vLCJ2YXJpYWJsZXMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvb2xlYW49bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlVGltZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kZWNpbWFsPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4RGF0YT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5mbG9hdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbWFnZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbnRlZ2VyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLm1hbmlmZXN0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnNjcmlwdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50ZXh0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRpbWU9bmV3IFhGQU9iamVjdEFycmF5fVtBc10oKXtyZXR1cm4hMH19Y2xhc3MgVGVtcGxhdGVOYW1lc3BhY2V7c3RhdGljW0tzXShlLHQpe2lmKFRlbXBsYXRlTmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXtjb25zdCBhPVRlbXBsYXRlTmFtZXNwYWNlW2VdKHQpO2FbVXNdKHQpO3JldHVybiBhfX1zdGF0aWMgYXBwZWFyYW5jZUZpbHRlcihlKXtyZXR1cm4gbmV3IEFwcGVhcmFuY2VGaWx0ZXIoZSl9c3RhdGljIGFyYyhlKXtyZXR1cm4gbmV3IEFyYyhlKX1zdGF0aWMgYXJlYShlKXtyZXR1cm4gbmV3IEFyZWEoZSl9c3RhdGljIGFzc2lzdChlKXtyZXR1cm4gbmV3IEFzc2lzdChlKX1zdGF0aWMgYmFyY29kZShlKXtyZXR1cm4gbmV3IEJhcmNvZGUoZSl9c3RhdGljIGJpbmQoZSl7cmV0dXJuIG5ldyBCaW5kKGUpfXN0YXRpYyBiaW5kSXRlbXMoZSl7cmV0dXJuIG5ldyBCaW5kSXRlbXMoZSl9c3RhdGljIGJvb2tlbmQoZSl7cmV0dXJuIG5ldyBCb29rZW5kKGUpfXN0YXRpYyBib29sZWFuKGUpe3JldHVybiBuZXcgQm9vbGVhbkVsZW1lbnQoZSl9c3RhdGljIGJvcmRlcihlKXtyZXR1cm4gbmV3IEJvcmRlcihlKX1zdGF0aWMgYnJlYWsoZSl7cmV0dXJuIG5ldyBCcmVhayhlKX1zdGF0aWMgYnJlYWtBZnRlcihlKXtyZXR1cm4gbmV3IEJyZWFrQWZ0ZXIoZSl9c3RhdGljIGJyZWFrQmVmb3JlKGUpe3JldHVybiBuZXcgQnJlYWtCZWZvcmUoZSl9c3RhdGljIGJ1dHRvbihlKXtyZXR1cm4gbmV3IEJ1dHRvbihlKX1zdGF0aWMgY2FsY3VsYXRlKGUpe3JldHVybiBuZXcgQ2FsY3VsYXRlKGUpfXN0YXRpYyBjYXB0aW9uKGUpe3JldHVybiBuZXcgQ2FwdGlvbihlKX1zdGF0aWMgY2VydGlmaWNhdGUoZSl7cmV0dXJuIG5ldyBDZXJ0aWZpY2F0ZShlKX1zdGF0aWMgY2VydGlmaWNhdGVzKGUpe3JldHVybiBuZXcgQ2VydGlmaWNhdGVzKGUpfXN0YXRpYyBjaGVja0J1dHRvbihlKXtyZXR1cm4gbmV3IENoZWNrQnV0dG9uKGUpfXN0YXRpYyBjaG9pY2VMaXN0KGUpe3JldHVybiBuZXcgQ2hvaWNlTGlzdChlKX1zdGF0aWMgY29sb3IoZSl7cmV0dXJuIG5ldyBDb2xvcihlKX1zdGF0aWMgY29tYihlKXtyZXR1cm4gbmV3IENvbWIoZSl9c3RhdGljIGNvbm5lY3QoZSl7cmV0dXJuIG5ldyBDb25uZWN0KGUpfXN0YXRpYyBjb250ZW50QXJlYShlKXtyZXR1cm4gbmV3IENvbnRlbnRBcmVhKGUpfXN0YXRpYyBjb3JuZXIoZSl7cmV0dXJuIG5ldyBDb3JuZXIoZSl9c3RhdGljIGRhdGUoZSl7cmV0dXJuIG5ldyBEYXRlRWxlbWVudChlKX1zdGF0aWMgZGF0ZVRpbWUoZSl7cmV0dXJuIG5ldyBEYXRlVGltZShlKX1zdGF0aWMgZGF0ZVRpbWVFZGl0KGUpe3JldHVybiBuZXcgRGF0ZVRpbWVFZGl0KGUpfXN0YXRpYyBkZWNpbWFsKGUpe3JldHVybiBuZXcgRGVjaW1hbChlKX1zdGF0aWMgZGVmYXVsdFVpKGUpe3JldHVybiBuZXcgRGVmYXVsdFVpKGUpfXN0YXRpYyBkZXNjKGUpe3JldHVybiBuZXcgRGVzYyhlKX1zdGF0aWMgZGlnZXN0TWV0aG9kKGUpe3JldHVybiBuZXcgRGlnZXN0TWV0aG9kKGUpfXN0YXRpYyBkaWdlc3RNZXRob2RzKGUpe3JldHVybiBuZXcgRGlnZXN0TWV0aG9kcyhlKX1zdGF0aWMgZHJhdyhlKXtyZXR1cm4gbmV3IERyYXcoZSl9c3RhdGljIGVkZ2UoZSl7cmV0dXJuIG5ldyBFZGdlKGUpfXN0YXRpYyBlbmNvZGluZyhlKXtyZXR1cm4gbmV3IEVuY29kaW5nKGUpfXN0YXRpYyBlbmNvZGluZ3MoZSl7cmV0dXJuIG5ldyBFbmNvZGluZ3MoZSl9c3RhdGljIGVuY3J5cHQoZSl7cmV0dXJuIG5ldyBFbmNyeXB0KGUpfXN0YXRpYyBlbmNyeXB0RGF0YShlKXtyZXR1cm4gbmV3IEVuY3J5cHREYXRhKGUpfXN0YXRpYyBlbmNyeXB0aW9uKGUpe3JldHVybiBuZXcgRW5jcnlwdGlvbihlKX1zdGF0aWMgZW5jcnlwdGlvbk1ldGhvZChlKXtyZXR1cm4gbmV3IEVuY3J5cHRpb25NZXRob2QoZSl9c3RhdGljIGVuY3J5cHRpb25NZXRob2RzKGUpe3JldHVybiBuZXcgRW5jcnlwdGlvbk1ldGhvZHMoZSl9c3RhdGljIGV2ZW50KGUpe3JldHVybiBuZXcgRXZlbnQoZSl9c3RhdGljIGV4RGF0YShlKXtyZXR1cm4gbmV3IEV4RGF0YShlKX1zdGF0aWMgZXhPYmplY3QoZSl7cmV0dXJuIG5ldyBFeE9iamVjdChlKX1zdGF0aWMgZXhjbEdyb3VwKGUpe3JldHVybiBuZXcgRXhjbEdyb3VwKGUpfXN0YXRpYyBleGVjdXRlKGUpe3JldHVybiBuZXcgRXhlY3V0ZShlKX1zdGF0aWMgZXh0cmFzKGUpe3JldHVybiBuZXcgRXh0cmFzKGUpfXN0YXRpYyBmaWVsZChlKXtyZXR1cm4gbmV3IEZpZWxkKGUpfXN0YXRpYyBmaWxsKGUpe3JldHVybiBuZXcgRmlsbChlKX1zdGF0aWMgZmlsdGVyKGUpe3JldHVybiBuZXcgRmlsdGVyKGUpfXN0YXRpYyBmbG9hdChlKXtyZXR1cm4gbmV3IEZsb2F0KGUpfXN0YXRpYyBmb250KGUpe3JldHVybiBuZXcgdGVtcGxhdGVfRm9udChlKX1zdGF0aWMgZm9ybWF0KGUpe3JldHVybiBuZXcgRm9ybWF0KGUpfXN0YXRpYyBoYW5kbGVyKGUpe3JldHVybiBuZXcgSGFuZGxlcihlKX1zdGF0aWMgaHlwaGVuYXRpb24oZSl7cmV0dXJuIG5ldyBIeXBoZW5hdGlvbihlKX1zdGF0aWMgaW1hZ2UoZSl7cmV0dXJuIG5ldyBJbWFnZShlKX1zdGF0aWMgaW1hZ2VFZGl0KGUpe3JldHVybiBuZXcgSW1hZ2VFZGl0KGUpfXN0YXRpYyBpbnRlZ2VyKGUpe3JldHVybiBuZXcgSW50ZWdlcihlKX1zdGF0aWMgaXNzdWVycyhlKXtyZXR1cm4gbmV3IElzc3VlcnMoZSl9c3RhdGljIGl0ZW1zKGUpe3JldHVybiBuZXcgSXRlbXMoZSl9c3RhdGljIGtlZXAoZSl7cmV0dXJuIG5ldyBLZWVwKGUpfXN0YXRpYyBrZXlVc2FnZShlKXtyZXR1cm4gbmV3IEtleVVzYWdlKGUpfXN0YXRpYyBsaW5lKGUpe3JldHVybiBuZXcgTGluZShlKX1zdGF0aWMgbGluZWFyKGUpe3JldHVybiBuZXcgTGluZWFyKGUpfXN0YXRpYyBsb2NrRG9jdW1lbnQoZSl7cmV0dXJuIG5ldyBMb2NrRG9jdW1lbnQoZSl9c3RhdGljIG1hbmlmZXN0KGUpe3JldHVybiBuZXcgTWFuaWZlc3QoZSl9c3RhdGljIG1hcmdpbihlKXtyZXR1cm4gbmV3IE1hcmdpbihlKX1zdGF0aWMgbWRwKGUpe3JldHVybiBuZXcgTWRwKGUpfXN0YXRpYyBtZWRpdW0oZSl7cmV0dXJuIG5ldyBNZWRpdW0oZSl9c3RhdGljIG1lc3NhZ2UoZSl7cmV0dXJuIG5ldyBNZXNzYWdlKGUpfXN0YXRpYyBudW1lcmljRWRpdChlKXtyZXR1cm4gbmV3IE51bWVyaWNFZGl0KGUpfXN0YXRpYyBvY2N1cihlKXtyZXR1cm4gbmV3IE9jY3VyKGUpfXN0YXRpYyBvaWQoZSl7cmV0dXJuIG5ldyBPaWQoZSl9c3RhdGljIG9pZHMoZSl7cmV0dXJuIG5ldyBPaWRzKGUpfXN0YXRpYyBvdmVyZmxvdyhlKXtyZXR1cm4gbmV3IE92ZXJmbG93KGUpfXN0YXRpYyBwYWdlQXJlYShlKXtyZXR1cm4gbmV3IFBhZ2VBcmVhKGUpfXN0YXRpYyBwYWdlU2V0KGUpe3JldHVybiBuZXcgUGFnZVNldChlKX1zdGF0aWMgcGFyYShlKXtyZXR1cm4gbmV3IFBhcmEoZSl9c3RhdGljIHBhc3N3b3JkRWRpdChlKXtyZXR1cm4gbmV3IFBhc3N3b3JkRWRpdChlKX1zdGF0aWMgcGF0dGVybihlKXtyZXR1cm4gbmV3IHRlbXBsYXRlX1BhdHRlcm4oZSl9c3RhdGljIHBpY3R1cmUoZSl7cmV0dXJuIG5ldyBQaWN0dXJlKGUpfXN0YXRpYyBwcm90byhlKXtyZXR1cm4gbmV3IFByb3RvKGUpfXN0YXRpYyByYWRpYWwoZSl7cmV0dXJuIG5ldyBSYWRpYWwoZSl9c3RhdGljIHJlYXNvbihlKXtyZXR1cm4gbmV3IFJlYXNvbihlKX1zdGF0aWMgcmVhc29ucyhlKXtyZXR1cm4gbmV3IFJlYXNvbnMoZSl9c3RhdGljIHJlY3RhbmdsZShlKXtyZXR1cm4gbmV3IFJlY3RhbmdsZShlKX1zdGF0aWMgcmVmKGUpe3JldHVybiBuZXcgUmVmRWxlbWVudChlKX1zdGF0aWMgc2NyaXB0KGUpe3JldHVybiBuZXcgU2NyaXB0KGUpfXN0YXRpYyBzZXRQcm9wZXJ0eShlKXtyZXR1cm4gbmV3IFNldFByb3BlcnR5KGUpfXN0YXRpYyBzaWduRGF0YShlKXtyZXR1cm4gbmV3IFNpZ25EYXRhKGUpfXN0YXRpYyBzaWduYXR1cmUoZSl7cmV0dXJuIG5ldyBTaWduYXR1cmUoZSl9c3RhdGljIHNpZ25pbmcoZSl7cmV0dXJuIG5ldyBTaWduaW5nKGUpfXN0YXRpYyBzb2xpZChlKXtyZXR1cm4gbmV3IFNvbGlkKGUpfXN0YXRpYyBzcGVhayhlKXtyZXR1cm4gbmV3IFNwZWFrKGUpfXN0YXRpYyBzdGlwcGxlKGUpe3JldHVybiBuZXcgU3RpcHBsZShlKX1zdGF0aWMgc3ViZm9ybShlKXtyZXR1cm4gbmV3IFN1YmZvcm0oZSl9c3RhdGljIHN1YmZvcm1TZXQoZSl7cmV0dXJuIG5ldyBTdWJmb3JtU2V0KGUpfXN0YXRpYyBzdWJqZWN0RE4oZSl7cmV0dXJuIG5ldyBTdWJqZWN0RE4oZSl9c3RhdGljIHN1YmplY3RETnMoZSl7cmV0dXJuIG5ldyBTdWJqZWN0RE5zKGUpfXN0YXRpYyBzdWJtaXQoZSl7cmV0dXJuIG5ldyBTdWJtaXQoZSl9c3RhdGljIHRlbXBsYXRlKGUpe3JldHVybiBuZXcgVGVtcGxhdGUoZSl9c3RhdGljIHRleHQoZSl7cmV0dXJuIG5ldyBUZXh0KGUpfXN0YXRpYyB0ZXh0RWRpdChlKXtyZXR1cm4gbmV3IFRleHRFZGl0KGUpfXN0YXRpYyB0aW1lKGUpe3JldHVybiBuZXcgVGltZShlKX1zdGF0aWMgdGltZVN0YW1wKGUpe3JldHVybiBuZXcgVGltZVN0YW1wKGUpfXN0YXRpYyB0b29sVGlwKGUpe3JldHVybiBuZXcgVG9vbFRpcChlKX1zdGF0aWMgdHJhdmVyc2FsKGUpe3JldHVybiBuZXcgVHJhdmVyc2FsKGUpfXN0YXRpYyB0cmF2ZXJzZShlKXtyZXR1cm4gbmV3IFRyYXZlcnNlKGUpfXN0YXRpYyB1aShlKXtyZXR1cm4gbmV3IFVpKGUpfXN0YXRpYyB2YWxpZGF0ZShlKXtyZXR1cm4gbmV3IFZhbGlkYXRlKGUpfXN0YXRpYyB2YWx1ZShlKXtyZXR1cm4gbmV3IFZhbHVlKGUpfXN0YXRpYyB2YXJpYWJsZXMoZSl7cmV0dXJuIG5ldyBWYXJpYWJsZXMoZSl9fWNvbnN0IEVvPUpzLmRhdGFzZXRzLmlkO2Z1bmN0aW9uIGNyZWF0ZVRleHQoZSl7Y29uc3QgdD1uZXcgVGV4dCh7fSk7dFtIbl09ZTtyZXR1cm4gdH1jbGFzcyBCaW5kZXJ7Y29uc3RydWN0b3IoZSl7dGhpcy5yb290PWU7dGhpcy5kYXRhc2V0cz1lLmRhdGFzZXRzO3RoaXMuZGF0YT1lLmRhdGFzZXRzPy5kYXRhfHxuZXcgWG1sT2JqZWN0KEpzLmRhdGFzZXRzLmlkLCJkYXRhIik7dGhpcy5lbXB0eU1lcmdlPTA9PT10aGlzLmRhdGFbaXNdKCkubGVuZ3RoO3RoaXMucm9vdC5mb3JtPXRoaXMuZm9ybT1lLnRlbXBsYXRlW1huXSgpfV9pc0NvbnN1bWVEYXRhKCl7cmV0dXJuIXRoaXMuZW1wdHlNZXJnZSYmdGhpcy5fbWVyZ2VNb2RlfV9pc01hdGNoVGVtcGxhdGUoKXtyZXR1cm4hdGhpcy5faXNDb25zdW1lRGF0YSgpfWJpbmQoKXt0aGlzLl9iaW5kRWxlbWVudCh0aGlzLmZvcm0sdGhpcy5kYXRhKTtyZXR1cm4gdGhpcy5mb3JtfWdldERhdGEoKXtyZXR1cm4gdGhpcy5kYXRhfV9iaW5kVmFsdWUoZSx0LGEpe2VbV25dPXQ7aWYoZVt1c10oKSlpZih0W2JzXSgpKXtjb25zdCBhPXRbdHNdKCk7ZVtYc10oY3JlYXRlVGV4dChhKSl9ZWxzZSBpZihlIGluc3RhbmNlb2YgRmllbGQmJiJtdWx0aVNlbGVjdCI9PT1lLnVpPy5jaG9pY2VMaXN0Py5vcGVuKXtjb25zdCBhPXRbaXNdKCkubWFwKChlPT5lW0huXS50cmltKCkpKS5qb2luKCJcbiIpO2VbWHNdKGNyZWF0ZVRleHQoYSkpfWVsc2UgdGhpcy5faXNDb25zdW1lRGF0YSgpJiZ3YXJuKCJYRkEgLSBOb2RlcyBoYXZlbid0IHRoZSBzYW1lIHR5cGUuIik7ZWxzZSF0W2JzXSgpfHx0aGlzLl9pc01hdGNoVGVtcGxhdGUoKT90aGlzLl9iaW5kRWxlbWVudChlLHQpOndhcm4oIlhGQSAtIE5vZGVzIGhhdmVuJ3QgdGhlIHNhbWUgdHlwZS4iKX1fZmluZERhdGFCeU5hbWVUb0NvbnN1bWUoZSx0LGEscil7aWYoIWUpcmV0dXJuIG51bGw7bGV0IGksbjtmb3IobGV0IHI9MDtyPDM7cisrKXtpPWFbcnNdKGUsITEsITApO2Zvcig7Oyl7bj1pLm5leHQoKS52YWx1ZTtpZighbilicmVhaztpZih0PT09bltic10oKSlyZXR1cm4gbn1pZihhW3ZzXT09PUpzLmRhdGFzZXRzLmlkJiYiZGF0YSI9PT1hW0ZzXSlicmVhazthPWFbY3NdKCl9aWYoIXIpcmV0dXJuIG51bGw7aT10aGlzLmRhdGFbcnNdKGUsITAsITEpO249aS5uZXh0KCkudmFsdWU7aWYobilyZXR1cm4gbjtpPXRoaXMuZGF0YVtLbl0oZSwhMCk7bj1pLm5leHQoKS52YWx1ZTtyZXR1cm4gbj8uW2JzXSgpP246bnVsbH1fc2V0UHJvcGVydGllcyhlLHQpe2lmKGUuaGFzT3duUHJvcGVydHkoInNldFByb3BlcnR5IikpZm9yKGNvbnN0e3JlZjphLHRhcmdldDpyLGNvbm5lY3Rpb246aX1vZiBlLnNldFByb3BlcnR5LmNoaWxkcmVuKXtpZihpKWNvbnRpbnVlO2lmKCFhKWNvbnRpbnVlO2NvbnN0IG49c2VhcmNoTm9kZSh0aGlzLnJvb3QsdCxhLCExLCExKTtpZighbil7d2FybihgWEZBIC0gSW52YWxpZCByZWZlcmVuY2U6ICR7YX0uYCk7Y29udGludWV9Y29uc3Rbc109bjtpZighc1t5c10odGhpcy5kYXRhKSl7d2FybigiWEZBIC0gSW52YWxpZCBub2RlOiBtdXN0IGJlIGEgZGF0YSBub2RlLiIpO2NvbnRpbnVlfWNvbnN0IG89c2VhcmNoTm9kZSh0aGlzLnJvb3QsZSxyLCExLCExKTtpZighbyl7d2FybihgWEZBIC0gSW52YWxpZCB0YXJnZXQ6ICR7cn0uYCk7Y29udGludWV9Y29uc3RbY109bztpZighY1t5c10oZSkpe3dhcm4oIlhGQSAtIEludmFsaWQgdGFyZ2V0OiBtdXN0IGJlIGEgcHJvcGVydHkgb3Igc3VicHJvcGVydHkuIik7Y29udGludWV9Y29uc3QgbD1jW2NzXSgpO2lmKGMgaW5zdGFuY2VvZiBTZXRQcm9wZXJ0eXx8bCBpbnN0YW5jZW9mIFNldFByb3BlcnR5KXt3YXJuKCJYRkEgLSBJbnZhbGlkIHRhcmdldDogY2Fubm90IGJlIGEgc2V0UHJvcGVydHkgb3Igb25lIG9mIGl0cyBwcm9wZXJ0aWVzLiIpO2NvbnRpbnVlfWlmKGMgaW5zdGFuY2VvZiBCaW5kSXRlbXN8fGwgaW5zdGFuY2VvZiBCaW5kSXRlbXMpe3dhcm4oIlhGQSAtIEludmFsaWQgdGFyZ2V0OiBjYW5ub3QgYmUgYSBiaW5kSXRlbXMgb3Igb25lIG9mIGl0cyBwcm9wZXJ0aWVzLiIpO2NvbnRpbnVlfWNvbnN0IGg9c1tIc10oKSx1PWNbRnNdO2lmKGMgaW5zdGFuY2VvZiBYRkFBdHRyaWJ1dGUpe2NvbnN0IGU9T2JqZWN0LmNyZWF0ZShudWxsKTtlW3VdPWg7Y29uc3QgdD1SZWZsZWN0LmNvbnN0cnVjdChPYmplY3QuZ2V0UHJvdG90eXBlT2YobCkuY29uc3RydWN0b3IsW2VdKTtsW3VdPXRbdV19ZWxzZSBpZihjLmhhc093blByb3BlcnR5KEhuKSl7Y1tXbl09cztjW0huXT1oO2NbR25dKCl9ZWxzZSB3YXJuKCJYRkEgLSBJbnZhbGlkIG5vZGUgdG8gdXNlIGluIHNldFByb3BlcnR5Iil9fV9iaW5kSXRlbXMoZSx0KXtpZighZS5oYXNPd25Qcm9wZXJ0eSgiaXRlbXMiKXx8IWUuaGFzT3duUHJvcGVydHkoImJpbmRJdGVtcyIpfHxlLmJpbmRJdGVtcy5pc0VtcHR5KCkpcmV0dXJuO2Zvcihjb25zdCB0IG9mIGUuaXRlbXMuY2hpbGRyZW4pZVtOc10odCk7ZS5pdGVtcy5jbGVhcigpO2NvbnN0IGE9bmV3IEl0ZW1zKHt9KSxyPW5ldyBJdGVtcyh7fSk7ZVtQbl0oYSk7ZS5pdGVtcy5wdXNoKGEpO2VbUG5dKHIpO2UuaXRlbXMucHVzaChyKTtmb3IoY29uc3R7cmVmOmksbGFiZWxSZWY6bix2YWx1ZVJlZjpzLGNvbm5lY3Rpb246b31vZiBlLmJpbmRJdGVtcy5jaGlsZHJlbil7aWYobyljb250aW51ZTtpZighaSljb250aW51ZTtjb25zdCBlPXNlYXJjaE5vZGUodGhpcy5yb290LHQsaSwhMSwhMSk7aWYoZSlmb3IoY29uc3QgdCBvZiBlKXtpZighdFt5c10odGhpcy5kYXRhc2V0cykpe3dhcm4oYFhGQSAtIEludmFsaWQgcmVmICgke2l9KTogbXVzdCBiZSBhIGRhdGFzZXRzIGNoaWxkLmApO2NvbnRpbnVlfWNvbnN0IGU9c2VhcmNoTm9kZSh0aGlzLnJvb3QsdCxuLCEwLCExKTtpZighZSl7d2FybihgWEZBIC0gSW52YWxpZCBsYWJlbDogJHtufS5gKTtjb250aW51ZX1jb25zdFtvXT1lO2lmKCFvW3lzXSh0aGlzLmRhdGFzZXRzKSl7d2FybigiWEZBIC0gSW52YWxpZCBsYWJlbDogbXVzdCBiZSBhIGRhdGFzZXRzIGNoaWxkLiIpO2NvbnRpbnVlfWNvbnN0IGM9c2VhcmNoTm9kZSh0aGlzLnJvb3QsdCxzLCEwLCExKTtpZighYyl7d2FybihgWEZBIC0gSW52YWxpZCB2YWx1ZTogJHtzfS5gKTtjb250aW51ZX1jb25zdFtsXT1jO2lmKCFsW3lzXSh0aGlzLmRhdGFzZXRzKSl7d2FybigiWEZBIC0gSW52YWxpZCB2YWx1ZTogbXVzdCBiZSBhIGRhdGFzZXRzIGNoaWxkLiIpO2NvbnRpbnVlfWNvbnN0IGg9Y3JlYXRlVGV4dChvW0hzXSgpKSx1PWNyZWF0ZVRleHQobFtIc10oKSk7YVtQbl0oaCk7YS50ZXh0LnB1c2goaCk7cltQbl0odSk7ci50ZXh0LnB1c2godSl9ZWxzZSB3YXJuKGBYRkEgLSBJbnZhbGlkIHJlZmVyZW5jZTogJHtpfS5gKX19X2JpbmRPY2N1cnJlbmNlcyhlLHQsYSl7bGV0IHI7aWYodC5sZW5ndGg+MSl7cj1lW1huXSgpO3JbTnNdKHIub2NjdXIpO3Iub2NjdXI9bnVsbH10aGlzLl9iaW5kVmFsdWUoZSx0WzBdLGEpO3RoaXMuX3NldFByb3BlcnRpZXMoZSx0WzBdKTt0aGlzLl9iaW5kSXRlbXMoZSx0WzBdKTtpZigxPT09dC5sZW5ndGgpcmV0dXJuO2NvbnN0IGk9ZVtjc10oKSxuPWVbRnNdLHM9aVtmc10oZSk7Zm9yKGxldCBlPTEsbz10Lmxlbmd0aDtlPG87ZSsrKXtjb25zdCBvPXRbZV0sYz1yW1huXSgpO2lbbl0ucHVzaChjKTtpW2dzXShzK2UsYyk7dGhpcy5fYmluZFZhbHVlKGMsbyxhKTt0aGlzLl9zZXRQcm9wZXJ0aWVzKGMsbyk7dGhpcy5fYmluZEl0ZW1zKGMsbyl9fV9jcmVhdGVPY2N1cnJlbmNlcyhlKXtpZighdGhpcy5lbXB0eU1lcmdlKXJldHVybjtjb25zdHtvY2N1cjp0fT1lO2lmKCF0fHx0LmluaXRpYWw8PTEpcmV0dXJuO2NvbnN0IGE9ZVtjc10oKSxyPWVbRnNdO2lmKCEoYVtyXWluc3RhbmNlb2YgWEZBT2JqZWN0QXJyYXkpKXJldHVybjtsZXQgaTtpPWUubmFtZT9hW3JdLmNoaWxkcmVuLmZpbHRlcigodD0+dC5uYW1lPT09ZS5uYW1lKSkubGVuZ3RoOmFbcl0uY2hpbGRyZW4ubGVuZ3RoO2NvbnN0IG49YVtmc10oZSkrMSxzPXQuaW5pdGlhbC1pO2lmKHMpe2NvbnN0IHQ9ZVtYbl0oKTt0W05zXSh0Lm9jY3VyKTt0Lm9jY3VyPW51bGw7YVtyXS5wdXNoKHQpO2FbZ3NdKG4sdCk7Zm9yKGxldCBlPTE7ZTxzO2UrKyl7Y29uc3QgaT10W1huXSgpO2Fbcl0ucHVzaChpKTthW2dzXShuK2UsaSl9fX1fZ2V0T2NjdXJJbmZvKGUpe2NvbnN0e25hbWU6dCxvY2N1cjphfT1lO2lmKCFhfHwhdClyZXR1cm5bMSwxXTtjb25zdCByPS0xPT09YS5tYXg/MS8wOmEubWF4O3JldHVyblthLm1pbixyXX1fc2V0QW5kQmluZChlLHQpe3RoaXMuX3NldFByb3BlcnRpZXMoZSx0KTt0aGlzLl9iaW5kSXRlbXMoZSx0KTt0aGlzLl9iaW5kRWxlbWVudChlLHQpfV9iaW5kRWxlbWVudChlLHQpe2NvbnN0IGE9W107dGhpcy5fY3JlYXRlT2NjdXJyZW5jZXMoZSk7Zm9yKGNvbnN0IHIgb2YgZVtpc10oKSl7aWYocltXbl0pY29udGludWU7aWYodm9pZCAwPT09dGhpcy5fbWVyZ2VNb2RlJiYic3ViZm9ybSI9PT1yW0ZzXSl7dGhpcy5fbWVyZ2VNb2RlPSJjb25zdW1lRGF0YSI9PT1yLm1lcmdlTW9kZTtjb25zdCBlPXRbaXNdKCk7aWYoZS5sZW5ndGg+MCl0aGlzLl9iaW5kT2NjdXJyZW5jZXMocixbZVswXV0sbnVsbCk7ZWxzZSBpZih0aGlzLmVtcHR5TWVyZ2Upe2NvbnN0IGU9dFt2c109PT1Fbz8tMTp0W3ZzXSxhPXJbV25dPW5ldyBYbWxPYmplY3QoZSxyLm5hbWV8fCJyb290Iik7dFtQbl0oYSk7dGhpcy5fYmluZEVsZW1lbnQocixhKX1jb250aW51ZX1pZighclttc10oKSljb250aW51ZTtsZXQgZT0hMSxpPW51bGwsbj1udWxsLHM9bnVsbDtpZihyLmJpbmQpe3N3aXRjaChyLmJpbmQubWF0Y2gpe2Nhc2Uibm9uZSI6dGhpcy5fc2V0QW5kQmluZChyLHQpO2NvbnRpbnVlO2Nhc2UiZ2xvYmFsIjplPSEwO2JyZWFrO2Nhc2UiZGF0YVJlZiI6aWYoIXIuYmluZC5yZWYpe3dhcm4oYFhGQSAtIHJlZiBpcyBlbXB0eSBpbiBub2RlICR7cltGc119LmApO3RoaXMuX3NldEFuZEJpbmQocix0KTtjb250aW51ZX1uPXIuYmluZC5yZWZ9ci5iaW5kLnBpY3R1cmUmJihpPXIuYmluZC5waWN0dXJlW0huXSl9Y29uc3RbbyxjXT10aGlzLl9nZXRPY2N1ckluZm8ocik7aWYobil7cz1zZWFyY2hOb2RlKHRoaXMucm9vdCx0LG4sITAsITEpO2lmKG51bGw9PT1zKXtzPWNyZWF0ZURhdGFOb2RlKHRoaXMuZGF0YSx0LG4pO2lmKCFzKWNvbnRpbnVlO3RoaXMuX2lzQ29uc3VtZURhdGEoKSYmKHNbcW5dPSEwKTt0aGlzLl9zZXRBbmRCaW5kKHIscyk7Y29udGludWV9dGhpcy5faXNDb25zdW1lRGF0YSgpJiYocz1zLmZpbHRlcigoZT0+IWVbcW5dKSkpO3MubGVuZ3RoPmM/cz1zLnNsaWNlKDAsYyk6MD09PXMubGVuZ3RoJiYocz1udWxsKTtzJiZ0aGlzLl9pc0NvbnN1bWVEYXRhKCkmJnMuZm9yRWFjaCgoZT0+e2VbcW5dPSEwfSkpfWVsc2V7aWYoIXIubmFtZSl7dGhpcy5fc2V0QW5kQmluZChyLHQpO2NvbnRpbnVlfWlmKHRoaXMuX2lzQ29uc3VtZURhdGEoKSl7Y29uc3QgYT1bXTtmb3IoO2EubGVuZ3RoPGM7KXtjb25zdCBpPXRoaXMuX2ZpbmREYXRhQnlOYW1lVG9Db25zdW1lKHIubmFtZSxyW3VzXSgpLHQsZSk7aWYoIWkpYnJlYWs7aVtxbl09ITA7YS5wdXNoKGkpfXM9YS5sZW5ndGg+MD9hOm51bGx9ZWxzZXtzPXRbcnNdKHIubmFtZSwhMSx0aGlzLmVtcHR5TWVyZ2UpLm5leHQoKS52YWx1ZTtpZighcyl7aWYoMD09PW8pe2EucHVzaChyKTtjb250aW51ZX1jb25zdCBlPXRbdnNdPT09RW8/LTE6dFt2c107cz1yW1duXT1uZXcgWG1sT2JqZWN0KGUsci5uYW1lKTt0aGlzLmVtcHR5TWVyZ2UmJihzW3FuXT0hMCk7dFtQbl0ocyk7dGhpcy5fc2V0QW5kQmluZChyLHMpO2NvbnRpbnVlfXRoaXMuZW1wdHlNZXJnZSYmKHNbcW5dPSEwKTtzPVtzXX19cz90aGlzLl9iaW5kT2NjdXJyZW5jZXMocixzLGkpOm8+MD90aGlzLl9zZXRBbmRCaW5kKHIsdCk6YS5wdXNoKHIpfWEuZm9yRWFjaCgoZT0+ZVtjc10oKVtOc10oZSkpKX19Y2xhc3MgRGF0YUhhbmRsZXJ7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmRhdGE9dDt0aGlzLmRhdGFzZXQ9ZS5kYXRhc2V0c3x8bnVsbH1zZXJpYWxpemUoZSl7Y29uc3QgdD1bWy0xLHRoaXMuZGF0YVtpc10oKV1dO2Zvcig7dC5sZW5ndGg+MDspe2NvbnN0IGE9dC5hdCgtMSksW3IsaV09YTtpZihyKzE9PT1pLmxlbmd0aCl7dC5wb3AoKTtjb250aW51ZX1jb25zdCBuPWlbKythWzBdXSxzPWUuZ2V0KG5bVnNdKTtpZihzKW5bWHNdKHMpO2Vsc2V7Y29uc3QgdD1uW0puXSgpO2Zvcihjb25zdCBhIG9mIHQudmFsdWVzKCkpe2NvbnN0IHQ9ZS5nZXQoYVtWc10pO2lmKHQpe2FbWHNdKHQpO2JyZWFrfX19Y29uc3Qgbz1uW2lzXSgpO28ubGVuZ3RoPjAmJnQucHVzaChbLTEsb10pfWNvbnN0IGE9Wyc8eGZhOmRhdGFzZXRzIHhtbG5zOnhmYT0iaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtZGF0YS8xLjAvIj4nXTtpZih0aGlzLmRhdGFzZXQpZm9yKGNvbnN0IGUgb2YgdGhpcy5kYXRhc2V0W2lzXSgpKSJkYXRhIiE9PWVbRnNdJiZlWyRzXShhKTt0aGlzLmRhdGFbJHNdKGEpO2EucHVzaCgiPC94ZmE6ZGF0YXNldHM+Iik7cmV0dXJuIGEuam9pbigiIil9fWNvbnN0IFBvPUpzLmNvbmZpZy5pZDtjbGFzcyBBY3JvYmF0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJhY3JvYmF0IiwhMCk7dGhpcy5hY3JvYmF0Nz1udWxsO3RoaXMuYXV0b1NhdmU9bnVsbDt0aGlzLmNvbW1vbj1udWxsO3RoaXMudmFsaWRhdGU9bnVsbDt0aGlzLnZhbGlkYXRlQXBwcm92YWxTaWduYXR1cmVzPW51bGw7dGhpcy5zdWJtaXRVcmw9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBBY3JvYmF0NyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiYWNyb2JhdDciLCEwKTt0aGlzLmR5bmFtaWNSZW5kZXI9bnVsbH19Y2xhc3MgQURCRV9KU0NvbnNvbGUgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sIkFEQkVfSlNDb25zb2xlIixbImRlbGVnYXRlIiwiRW5hYmxlIiwiRGlzYWJsZSJdKX19Y2xhc3MgQURCRV9KU0RlYnVnZ2VyIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJBREJFX0pTRGVidWdnZXIiLFsiZGVsZWdhdGUiLCJFbmFibGUiLCJEaXNhYmxlIl0pfX1jbGFzcyBBZGRTaWxlbnRQcmludCBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJhZGRTaWxlbnRQcmludCIpfX1jbGFzcyBBZGRWaWV3ZXJQcmVmZXJlbmNlcyBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJhZGRWaWV3ZXJQcmVmZXJlbmNlcyIpfX1jbGFzcyBBZGp1c3REYXRhIGV4dGVuZHMgT3B0aW9uMTB7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImFkanVzdERhdGEiKX19Y2xhc3MgQWRvYmVFeHRlbnNpb25MZXZlbCBleHRlbmRzIEludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImFkb2JlRXh0ZW5zaW9uTGV2ZWwiLDAsKGU9PmU+PTEmJmU8PTgpKX19Y2xhc3MgQWdlbnQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImFnZW50IiwhMCk7dGhpcy5uYW1lPWUubmFtZT9lLm5hbWUudHJpbSgpOiIiO3RoaXMuY29tbW9uPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgQWx3YXlzRW1iZWQgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJhbHdheXNFbWJlZCIpfX1jbGFzcyBBbWQgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImFtZCIpfX1jbGFzcyBjb25maWdfQXJlYSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiYXJlYSIpO3RoaXMubGV2ZWw9Z2V0SW50ZWdlcih7ZGF0YTplLmxldmVsLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PmU+PTEmJmU8PTN9KTt0aGlzLm5hbWU9Z2V0U3RyaW5nT3B0aW9uKGUubmFtZSxbIiIsImJhcmNvZGUiLCJjb3JlaW5pdCIsImRldmljZURyaXZlciIsImZvbnQiLCJnZW5lcmFsIiwibGF5b3V0IiwibWVyZ2UiLCJzY3JpcHQiLCJzaWduYXR1cmUiLCJzb3VyY2VTZXQiLCJ0ZW1wbGF0ZUNhY2hlIl0pfX1jbGFzcyBBdHRyaWJ1dGVzIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJhdHRyaWJ1dGVzIixbInByZXNlcnZlIiwiZGVsZWdhdGUiLCJpZ25vcmUiXSl9fWNsYXNzIEF1dG9TYXZlIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJhdXRvU2F2ZSIsWyJkaXNhYmxlZCIsImVuYWJsZWQiXSl9fWNsYXNzIEJhc2UgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImJhc2UiKX19Y2xhc3MgQmF0Y2hPdXRwdXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImJhdGNoT3V0cHV0Iik7dGhpcy5mb3JtYXQ9Z2V0U3RyaW5nT3B0aW9uKGUuZm9ybWF0LFsibm9uZSIsImNvbmNhdCIsInppcCIsInppcENvbXByZXNzIl0pfX1jbGFzcyBCZWhhdmlvck92ZXJyaWRlIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiYmVoYXZpb3JPdmVycmlkZSIpfVtHbl0oKXt0aGlzW0huXT1uZXcgTWFwKHRoaXNbSG5dLnRyaW0oKS5zcGxpdCgvXHMrLykuZmlsdGVyKChlPT5lLmluY2x1ZGVzKCI6IikpKS5tYXAoKGU9PmUuc3BsaXQoIjoiLDIpKSkpfX1jbGFzcyBDYWNoZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiY2FjaGUiLCEwKTt0aGlzLnRlbXBsYXRlQ2FjaGU9bnVsbH19Y2xhc3MgQ2hhbmdlIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImNoYW5nZSIpfX1jbGFzcyBDb21tb24gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImNvbW1vbiIsITApO3RoaXMuZGF0YT1udWxsO3RoaXMubG9jYWxlPW51bGw7dGhpcy5sb2NhbGVTZXQ9bnVsbDt0aGlzLm1lc3NhZ2luZz1udWxsO3RoaXMuc3VwcHJlc3NCYW5uZXI9bnVsbDt0aGlzLnRlbXBsYXRlPW51bGw7dGhpcy52YWxpZGF0aW9uTWVzc2FnaW5nPW51bGw7dGhpcy52ZXJzaW9uQ29udHJvbD1udWxsO3RoaXMubG9nPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgQ29tcHJlc3MgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImNvbXByZXNzIik7dGhpcy5zY29wZT1nZXRTdHJpbmdPcHRpb24oZS5zY29wZSxbImltYWdlT25seSIsImRvY3VtZW50Il0pfX1jbGFzcyBDb21wcmVzc0xvZ2ljYWxTdHJ1Y3R1cmUgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiY29tcHJlc3NMb2dpY2FsU3RydWN0dXJlIil9fWNsYXNzIENvbXByZXNzT2JqZWN0U3RyZWFtIGV4dGVuZHMgT3B0aW9uMTB7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImNvbXByZXNzT2JqZWN0U3RyZWFtIil9fWNsYXNzIENvbXByZXNzaW9uIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJjb21wcmVzc2lvbiIsITApO3RoaXMuY29tcHJlc3NMb2dpY2FsU3RydWN0dXJlPW51bGw7dGhpcy5jb21wcmVzc09iamVjdFN0cmVhbT1udWxsO3RoaXMubGV2ZWw9bnVsbDt0aGlzLnR5cGU9bnVsbH19Y2xhc3MgQ29uZmlnIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJjb25maWciLCEwKTt0aGlzLmFjcm9iYXQ9bnVsbDt0aGlzLnByZXNlbnQ9bnVsbDt0aGlzLnRyYWNlPW51bGw7dGhpcy5hZ2VudD1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIENvbmZvcm1hbmNlIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJjb25mb3JtYW5jZSIsWyJBIiwiQiJdKX19Y2xhc3MgQ29udGVudENvcHkgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiY29udGVudENvcHkiKX19Y2xhc3MgQ29waWVzIGV4dGVuZHMgSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiY29waWVzIiwxLChlPT5lPj0xKSl9fWNsYXNzIENyZWF0b3IgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImNyZWF0b3IiKX19Y2xhc3MgQ3VycmVudFBhZ2UgZXh0ZW5kcyBJbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJjdXJyZW50UGFnZSIsMCwoZT0+ZT49MCkpfX1jbGFzcyBEYXRhIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJkYXRhIiwhMCk7dGhpcy5hZGp1c3REYXRhPW51bGw7dGhpcy5hdHRyaWJ1dGVzPW51bGw7dGhpcy5pbmNyZW1lbnRhbExvYWQ9bnVsbDt0aGlzLm91dHB1dFhTTD1udWxsO3RoaXMucmFuZ2U9bnVsbDt0aGlzLnJlY29yZD1udWxsO3RoaXMuc3RhcnROb2RlPW51bGw7dGhpcy51cmk9bnVsbDt0aGlzLndpbmRvdz1udWxsO3RoaXMueHNsPW51bGw7dGhpcy5leGNsdWRlTlM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudHJhbnNmb3JtPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgRGVidWcgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImRlYnVnIiwhMCk7dGhpcy51cmk9bnVsbH19Y2xhc3MgRGVmYXVsdFR5cGVmYWNlIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiZGVmYXVsdFR5cGVmYWNlIik7dGhpcy53cml0aW5nU2NyaXB0PWdldFN0cmluZ09wdGlvbihlLndyaXRpbmdTY3JpcHQsWyIqIiwiQXJhYmljIiwiQ3lyaWxsaWMiLCJFYXN0RXVyb3BlYW5Sb21hbiIsIkdyZWVrIiwiSGVicmV3IiwiSmFwYW5lc2UiLCJLb3JlYW4iLCJSb21hbiIsIlNpbXBsaWZpZWRDaGluZXNlIiwiVGhhaSIsIlRyYWRpdGlvbmFsQ2hpbmVzZSIsIlZpZXRuYW1lc2UiXSl9fWNsYXNzIERlc3RpbmF0aW9uIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJkZXN0aW5hdGlvbiIsWyJwZGYiLCJwY2wiLCJwcyIsIndlYkNsaWVudCIsInpwbCJdKX19Y2xhc3MgRG9jdW1lbnRBc3NlbWJseSBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJkb2N1bWVudEFzc2VtYmx5Iil9fWNsYXNzIERyaXZlciBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiZHJpdmVyIiwhMCk7dGhpcy5uYW1lPWUubmFtZT9lLm5hbWUudHJpbSgpOiIiO3RoaXMuZm9udEluZm89bnVsbDt0aGlzLnhkYz1udWxsfX1jbGFzcyBEdXBsZXhPcHRpb24gZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImR1cGxleE9wdGlvbiIsWyJzaW1wbGV4IiwiZHVwbGV4RmxpcExvbmdFZGdlIiwiZHVwbGV4RmxpcFNob3J0RWRnZSJdKX19Y2xhc3MgRHluYW1pY1JlbmRlciBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiZHluYW1pY1JlbmRlciIsWyJmb3JiaWRkZW4iLCJyZXF1aXJlZCJdKX19Y2xhc3MgRW1iZWQgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiZW1iZWQiKX19Y2xhc3MgY29uZmlnX0VuY3J5cHQgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiZW5jcnlwdCIpfX1jbGFzcyBjb25maWdfRW5jcnlwdGlvbiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiZW5jcnlwdGlvbiIsITApO3RoaXMuZW5jcnlwdD1udWxsO3RoaXMuZW5jcnlwdGlvbkxldmVsPW51bGw7dGhpcy5wZXJtaXNzaW9ucz1udWxsfX1jbGFzcyBFbmNyeXB0aW9uTGV2ZWwgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImVuY3J5cHRpb25MZXZlbCIsWyI0MGJpdCIsIjEyOGJpdCJdKX19Y2xhc3MgRW5mb3JjZSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiZW5mb3JjZSIpfX1jbGFzcyBFcXVhdGUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImVxdWF0ZSIpO3RoaXMuZm9yY2U9Z2V0SW50ZWdlcih7ZGF0YTplLmZvcmNlLGRlZmF1bHRWYWx1ZToxLHZhbGlkYXRlOmU9PjA9PT1lfSk7dGhpcy5mcm9tPWUuZnJvbXx8IiI7dGhpcy50bz1lLnRvfHwiIn19Y2xhc3MgRXF1YXRlUmFuZ2UgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImVxdWF0ZVJhbmdlIik7dGhpcy5mcm9tPWUuZnJvbXx8IiI7dGhpcy50bz1lLnRvfHwiIjt0aGlzLl91bmljb2RlUmFuZ2U9ZS51bmljb2RlUmFuZ2V8fCIifWdldCB1bmljb2RlUmFuZ2UoKXtjb25zdCBlPVtdLHQ9L1VcKyhbMC05YS1mQS1GXSspLyxhPXRoaXMuX3VuaWNvZGVSYW5nZTtmb3IobGV0IHIgb2YgYS5zcGxpdCgiLCIpLm1hcCgoZT0+ZS50cmltKCkpKS5maWx0ZXIoKGU9PiEhZSkpKXtyPXIuc3BsaXQoIi0iLDIpLm1hcCgoZT0+e2NvbnN0IGE9ZS5tYXRjaCh0KTtyZXR1cm4gYT9wYXJzZUludChhWzFdLDE2KTowfSkpOzE9PT1yLmxlbmd0aCYmci5wdXNoKHJbMF0pO2UucHVzaChyKX1yZXR1cm4gc2hhZG93KHRoaXMsInVuaWNvZGVSYW5nZSIsZSl9fWNsYXNzIEV4Y2x1ZGUgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJleGNsdWRlIil9W0duXSgpe3RoaXNbSG5dPXRoaXNbSG5dLnRyaW0oKS5zcGxpdCgvXHMrLykuZmlsdGVyKChlPT5lJiZbImNhbGN1bGF0ZSIsImNsb3NlIiwiZW50ZXIiLCJleGl0IiwiaW5pdGlhbGl6ZSIsInJlYWR5IiwidmFsaWRhdGUiXS5pbmNsdWRlcyhlKSkpfX1jbGFzcyBFeGNsdWRlTlMgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImV4Y2x1ZGVOUyIpfX1jbGFzcyBGbGlwTGFiZWwgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImZsaXBMYWJlbCIsWyJ1c2VQcmludGVyU2V0dGluZyIsIm9uIiwib2ZmIl0pfX1jbGFzcyBjb25maWdfRm9udEluZm8gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImZvbnRJbmZvIiwhMCk7dGhpcy5lbWJlZD1udWxsO3RoaXMubWFwPW51bGw7dGhpcy5zdWJzZXRCZWxvdz1udWxsO3RoaXMuYWx3YXlzRW1iZWQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGVmYXVsdFR5cGVmYWNlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLm5ldmVyRW1iZWQ9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBGb3JtRmllbGRGaWxsaW5nIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImZvcm1GaWVsZEZpbGxpbmciKX19Y2xhc3MgR3JvdXBQYXJlbnQgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImdyb3VwUGFyZW50Iil9fWNsYXNzIElmRW1wdHkgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImlmRW1wdHkiLFsiZGF0YVZhbHVlIiwiZGF0YUdyb3VwIiwiaWdub3JlIiwicmVtb3ZlIl0pfX1jbGFzcyBJbmNsdWRlWERQQ29udGVudCBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiaW5jbHVkZVhEUENvbnRlbnQiKX19Y2xhc3MgSW5jcmVtZW50YWxMb2FkIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJpbmNyZW1lbnRhbExvYWQiLFsibm9uZSIsImZvcndhcmRPbmx5Il0pfX1jbGFzcyBJbmNyZW1lbnRhbE1lcmdlIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImluY3JlbWVudGFsTWVyZ2UiKX19Y2xhc3MgSW50ZXJhY3RpdmUgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiaW50ZXJhY3RpdmUiKX19Y2xhc3MgSm9nIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJqb2ciLFsidXNlUHJpbnRlclNldHRpbmciLCJub25lIiwicGFnZVNldCJdKX19Y2xhc3MgTGFiZWxQcmludGVyIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJsYWJlbFByaW50ZXIiLCEwKTt0aGlzLm5hbWU9Z2V0U3RyaW5nT3B0aW9uKGUubmFtZSxbInpwbCIsImRwbCIsImlwbCIsInRjcGwiXSk7dGhpcy5iYXRjaE91dHB1dD1udWxsO3RoaXMuZmxpcExhYmVsPW51bGw7dGhpcy5mb250SW5mbz1udWxsO3RoaXMueGRjPW51bGx9fWNsYXNzIExheW91dCBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywibGF5b3V0IixbInBhZ2luYXRlIiwicGFuZWwiXSl9fWNsYXNzIExldmVsIGV4dGVuZHMgSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywibGV2ZWwiLDAsKGU9PmU+MCkpfX1jbGFzcyBMaW5lYXJpemVkIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sImxpbmVhcml6ZWQiKX19Y2xhc3MgTG9jYWxlIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJsb2NhbGUiKX19Y2xhc3MgTG9jYWxlU2V0IGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJsb2NhbGVTZXQiKX19Y2xhc3MgTG9nIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJsb2ciLCEwKTt0aGlzLm1vZGU9bnVsbDt0aGlzLnRocmVzaG9sZD1udWxsO3RoaXMudG89bnVsbDt0aGlzLnVyaT1udWxsfX1jbGFzcyBNYXBFbGVtZW50IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJtYXAiLCEwKTt0aGlzLmVxdWF0ZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5lcXVhdGVSYW5nZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIE1lZGl1bUluZm8gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sIm1lZGl1bUluZm8iLCEwKTt0aGlzLm1hcD1udWxsfX1jbGFzcyBjb25maWdfTWVzc2FnZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywibWVzc2FnZSIsITApO3RoaXMubXNnSWQ9bnVsbDt0aGlzLnNldmVyaXR5PW51bGx9fWNsYXNzIE1lc3NhZ2luZyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywibWVzc2FnaW5nIiwhMCk7dGhpcy5tZXNzYWdlPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgTW9kZSBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywibW9kZSIsWyJhcHBlbmQiLCJvdmVyd3JpdGUiXSl9fWNsYXNzIE1vZGlmeUFubm90cyBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJtb2RpZnlBbm5vdHMiKX19Y2xhc3MgTXNnSWQgZXh0ZW5kcyBJbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJtc2dJZCIsMSwoZT0+ZT49MSkpfX1jbGFzcyBOYW1lQXR0ciBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywibmFtZUF0dHIiKX19Y2xhc3MgTmV2ZXJFbWJlZCBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sIm5ldmVyRW1iZWQiKX19Y2xhc3MgTnVtYmVyT2ZDb3BpZXMgZXh0ZW5kcyBJbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJudW1iZXJPZkNvcGllcyIsbnVsbCwoZT0+ZT49MiYmZTw9NSkpfX1jbGFzcyBPcGVuQWN0aW9uIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJvcGVuQWN0aW9uIiwhMCk7dGhpcy5kZXN0aW5hdGlvbj1udWxsfX1jbGFzcyBPdXRwdXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sIm91dHB1dCIsITApO3RoaXMudG89bnVsbDt0aGlzLnR5cGU9bnVsbDt0aGlzLnVyaT1udWxsfX1jbGFzcyBPdXRwdXRCaW4gZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sIm91dHB1dEJpbiIpfX1jbGFzcyBPdXRwdXRYU0wgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sIm91dHB1dFhTTCIsITApO3RoaXMudXJpPW51bGx9fWNsYXNzIE92ZXJwcmludCBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywib3ZlcnByaW50IixbIm5vbmUiLCJib3RoIiwiZHJhdyIsImZpZWxkIl0pfX1jbGFzcyBQYWNrZXRzIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJwYWNrZXRzIil9W0duXSgpeyIqIiE9PXRoaXNbSG5dJiYodGhpc1tIbl09dGhpc1tIbl0udHJpbSgpLnNwbGl0KC9ccysvKS5maWx0ZXIoKGU9PlsiY29uZmlnIiwiZGF0YXNldHMiLCJ0ZW1wbGF0ZSIsInhmZGYiLCJ4c2x0Il0uaW5jbHVkZXMoZSkpKSl9fWNsYXNzIFBhZ2VPZmZzZXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInBhZ2VPZmZzZXQiKTt0aGlzLng9Z2V0SW50ZWdlcih7ZGF0YTplLngsZGVmYXVsdFZhbHVlOiJ1c2VYRENTZXR0aW5nIix2YWxpZGF0ZTplPT4hMH0pO3RoaXMueT1nZXRJbnRlZ2VyKHtkYXRhOmUueSxkZWZhdWx0VmFsdWU6InVzZVhEQ1NldHRpbmciLHZhbGlkYXRlOmU9PiEwfSl9fWNsYXNzIFBhZ2VSYW5nZSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicGFnZVJhbmdlIil9W0duXSgpe2NvbnN0IGU9dGhpc1tIbl0udHJpbSgpLnNwbGl0KC9ccysvKS5tYXAoKGU9PnBhcnNlSW50KGUsMTApKSksdD1bXTtmb3IobGV0IGE9MCxyPWUubGVuZ3RoO2E8cjthKz0yKXQucHVzaChlLnNsaWNlKGEsYSsyKSk7dGhpc1tIbl09dH19Y2xhc3MgUGFnaW5hdGlvbiBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicGFnaW5hdGlvbiIsWyJzaW1wbGV4IiwiZHVwbGV4U2hvcnRFZGdlIiwiZHVwbGV4TG9uZ0VkZ2UiXSl9fWNsYXNzIFBhZ2luYXRpb25PdmVycmlkZSBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicGFnaW5hdGlvbk92ZXJyaWRlIixbIm5vbmUiLCJmb3JjZUR1cGxleCIsImZvcmNlRHVwbGV4TG9uZ0VkZ2UiLCJmb3JjZUR1cGxleFNob3J0RWRnZSIsImZvcmNlU2ltcGxleCJdKX19Y2xhc3MgUGFydCBleHRlbmRzIEludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInBhcnQiLDEsKGU9PiExKSl9fWNsYXNzIFBjbCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicGNsIiwhMCk7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5iYXRjaE91dHB1dD1udWxsO3RoaXMuZm9udEluZm89bnVsbDt0aGlzLmpvZz1udWxsO3RoaXMubWVkaXVtSW5mbz1udWxsO3RoaXMub3V0cHV0QmluPW51bGw7dGhpcy5wYWdlT2Zmc2V0PW51bGw7dGhpcy5zdGFwbGU9bnVsbDt0aGlzLnhkYz1udWxsfX1jbGFzcyBQZGYgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInBkZiIsITApO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMuYWRvYmVFeHRlbnNpb25MZXZlbD1udWxsO3RoaXMuYmF0Y2hPdXRwdXQ9bnVsbDt0aGlzLmNvbXByZXNzaW9uPW51bGw7dGhpcy5jcmVhdG9yPW51bGw7dGhpcy5lbmNyeXB0aW9uPW51bGw7dGhpcy5mb250SW5mbz1udWxsO3RoaXMuaW50ZXJhY3RpdmU9bnVsbDt0aGlzLmxpbmVhcml6ZWQ9bnVsbDt0aGlzLm9wZW5BY3Rpb249bnVsbDt0aGlzLnBkZmE9bnVsbDt0aGlzLnByb2R1Y2VyPW51bGw7dGhpcy5yZW5kZXJQb2xpY3k9bnVsbDt0aGlzLnNjcmlwdE1vZGVsPW51bGw7dGhpcy5zaWxlbnRQcmludD1udWxsO3RoaXMuc3VibWl0Rm9ybWF0PW51bGw7dGhpcy50YWdnZWQ9bnVsbDt0aGlzLnZlcnNpb249bnVsbDt0aGlzLnZpZXdlclByZWZlcmVuY2VzPW51bGw7dGhpcy54ZGM9bnVsbH19Y2xhc3MgUGRmYSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicGRmYSIsITApO3RoaXMuYW1kPW51bGw7dGhpcy5jb25mb3JtYW5jZT1udWxsO3RoaXMuaW5jbHVkZVhEUENvbnRlbnQ9bnVsbDt0aGlzLnBhcnQ9bnVsbH19Y2xhc3MgUGVybWlzc2lvbnMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInBlcm1pc3Npb25zIiwhMCk7dGhpcy5hY2Nlc3NpYmxlQ29udGVudD1udWxsO3RoaXMuY2hhbmdlPW51bGw7dGhpcy5jb250ZW50Q29weT1udWxsO3RoaXMuZG9jdW1lbnRBc3NlbWJseT1udWxsO3RoaXMuZm9ybUZpZWxkRmlsbGluZz1udWxsO3RoaXMubW9kaWZ5QW5ub3RzPW51bGw7dGhpcy5wbGFpbnRleHRNZXRhZGF0YT1udWxsO3RoaXMucHJpbnQ9bnVsbDt0aGlzLnByaW50SGlnaFF1YWxpdHk9bnVsbH19Y2xhc3MgUGlja1RyYXlCeVBERlNpemUgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicGlja1RyYXlCeVBERlNpemUiKX19Y2xhc3MgY29uZmlnX1BpY3R1cmUgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInBpY3R1cmUiKX19Y2xhc3MgUGxhaW50ZXh0TWV0YWRhdGEgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicGxhaW50ZXh0TWV0YWRhdGEiKX19Y2xhc3MgUHJlc2VuY2UgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInByZXNlbmNlIixbInByZXNlcnZlIiwiZGlzc29sdmUiLCJkaXNzb2x2ZVN0cnVjdHVyZSIsImlnbm9yZSIsInJlbW92ZSJdKX19Y2xhc3MgUHJlc2VudCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicHJlc2VudCIsITApO3RoaXMuYmVoYXZpb3JPdmVycmlkZT1udWxsO3RoaXMuY2FjaGU9bnVsbDt0aGlzLmNvbW1vbj1udWxsO3RoaXMuY29waWVzPW51bGw7dGhpcy5kZXN0aW5hdGlvbj1udWxsO3RoaXMuaW5jcmVtZW50YWxNZXJnZT1udWxsO3RoaXMubGF5b3V0PW51bGw7dGhpcy5vdXRwdXQ9bnVsbDt0aGlzLm92ZXJwcmludD1udWxsO3RoaXMucGFnaW5hdGlvbj1udWxsO3RoaXMucGFnaW5hdGlvbk92ZXJyaWRlPW51bGw7dGhpcy5zY3JpcHQ9bnVsbDt0aGlzLnZhbGlkYXRlPW51bGw7dGhpcy54ZHA9bnVsbDt0aGlzLmRyaXZlcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5sYWJlbFByaW50ZXI9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucGNsPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnBkZj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5wcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJtaXRVcmw9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMud2ViQ2xpZW50PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnpwbD1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIFByaW50IGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInByaW50Iil9fWNsYXNzIFByaW50SGlnaFF1YWxpdHkgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicHJpbnRIaWdoUXVhbGl0eSIpfX1jbGFzcyBQcmludFNjYWxpbmcgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInByaW50U2NhbGluZyIsWyJhcHBkZWZhdWx0Iiwibm9TY2FsaW5nIl0pfX1jbGFzcyBQcmludGVyTmFtZSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicHJpbnRlck5hbWUiKX19Y2xhc3MgUHJvZHVjZXIgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInByb2R1Y2VyIil9fWNsYXNzIFBzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJwcyIsITApO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMuYmF0Y2hPdXRwdXQ9bnVsbDt0aGlzLmZvbnRJbmZvPW51bGw7dGhpcy5qb2c9bnVsbDt0aGlzLm1lZGl1bUluZm89bnVsbDt0aGlzLm91dHB1dEJpbj1udWxsO3RoaXMuc3RhcGxlPW51bGw7dGhpcy54ZGM9bnVsbH19Y2xhc3MgUmFuZ2UgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJyYW5nZSIpfVtHbl0oKXt0aGlzW0huXT10aGlzW0huXS5zcGxpdCgiLCIsMikubWFwKChlPT5lLnNwbGl0KCItIikubWFwKChlPT5wYXJzZUludChlLnRyaW0oKSwxMCkpKSkpLmZpbHRlcigoZT0+ZS5ldmVyeSgoZT0+IWlzTmFOKGUpKSkpKS5tYXAoKGU9PnsxPT09ZS5sZW5ndGgmJmUucHVzaChlWzBdKTtyZXR1cm4gZX0pKX19Y2xhc3MgUmVjb3JkIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywicmVjb3JkIil9W0duXSgpe3RoaXNbSG5dPXRoaXNbSG5dLnRyaW0oKTtjb25zdCBlPXBhcnNlSW50KHRoaXNbSG5dLDEwKTshaXNOYU4oZSkmJmU+PTAmJih0aGlzW0huXT1lKX19Y2xhc3MgUmVsZXZhbnQgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJyZWxldmFudCIpfVtHbl0oKXt0aGlzW0huXT10aGlzW0huXS50cmltKCkuc3BsaXQoL1xzKy8pfX1jbGFzcyBSZW5hbWUgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJyZW5hbWUiKX1bR25dKCl7dGhpc1tIbl09dGhpc1tIbl0udHJpbSgpOyh0aGlzW0huXS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoInhtbCIpfHxuZXcgUmVnRXhwKCJbXFxwe0x9X11bXFxwe0x9XFxkLl9cXHB7TX0tXSoiLCJ1IikudGVzdCh0aGlzW0huXSkpJiZ3YXJuKCJYRkEgLSBSZW5hbWU6IGludmFsaWQgWEZBIG5hbWUiKX19Y2xhc3MgUmVuZGVyUG9saWN5IGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJyZW5kZXJQb2xpY3kiLFsic2VydmVyIiwiY2xpZW50Il0pfX1jbGFzcyBSdW5TY3JpcHRzIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJydW5TY3JpcHRzIixbImJvdGgiLCJjbGllbnQiLCJub25lIiwic2VydmVyIl0pfX1jbGFzcyBjb25maWdfU2NyaXB0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJzY3JpcHQiLCEwKTt0aGlzLmN1cnJlbnRQYWdlPW51bGw7dGhpcy5leGNsdWRlPW51bGw7dGhpcy5ydW5TY3JpcHRzPW51bGx9fWNsYXNzIFNjcmlwdE1vZGVsIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJzY3JpcHRNb2RlbCIsWyJYRkEiLCJub25lIl0pfX1jbGFzcyBTZXZlcml0eSBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywic2V2ZXJpdHkiLFsiaWdub3JlIiwiZXJyb3IiLCJpbmZvcm1hdGlvbiIsInRyYWNlIiwid2FybmluZyJdKX19Y2xhc3MgU2lsZW50UHJpbnQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInNpbGVudFByaW50IiwhMCk7dGhpcy5hZGRTaWxlbnRQcmludD1udWxsO3RoaXMucHJpbnRlck5hbWU9bnVsbH19Y2xhc3MgU3RhcGxlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJzdGFwbGUiKTt0aGlzLm1vZGU9Z2V0U3RyaW5nT3B0aW9uKGUubW9kZSxbInVzZVByaW50ZXJTZXR0aW5nIiwib24iLCJvZmYiXSl9fWNsYXNzIFN0YXJ0Tm9kZSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywic3RhcnROb2RlIil9fWNsYXNzIFN0YXJ0UGFnZSBleHRlbmRzIEludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInN0YXJ0UGFnZSIsMCwoZT0+ITApKX19Y2xhc3MgU3VibWl0Rm9ybWF0IGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJzdWJtaXRGb3JtYXQiLFsiaHRtbCIsImRlbGVnYXRlIiwiZmRmIiwieG1sIiwicGRmIl0pfX1jbGFzcyBTdWJtaXRVcmwgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInN1Ym1pdFVybCIpfX1jbGFzcyBTdWJzZXRCZWxvdyBleHRlbmRzIEludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInN1YnNldEJlbG93IiwxMDAsKGU9PmU+PTAmJmU8PTEwMCkpfX1jbGFzcyBTdXBwcmVzc0Jhbm5lciBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJzdXBwcmVzc0Jhbm5lciIpfX1jbGFzcyBUYWdnZWQgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywidGFnZ2VkIil9fWNsYXNzIGNvbmZpZ19UZW1wbGF0ZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywidGVtcGxhdGUiLCEwKTt0aGlzLmJhc2U9bnVsbDt0aGlzLnJlbGV2YW50PW51bGw7dGhpcy5zdGFydFBhZ2U9bnVsbDt0aGlzLnVyaT1udWxsO3RoaXMueHNsPW51bGx9fWNsYXNzIFRocmVzaG9sZCBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywidGhyZXNob2xkIixbInRyYWNlIiwiZXJyb3IiLCJpbmZvcm1hdGlvbiIsIndhcm5pbmciXSl9fWNsYXNzIFRvIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJ0byIsWyJudWxsIiwibWVtb3J5Iiwic3RkZXJyIiwic3Rkb3V0Iiwic3lzdGVtIiwidXJpIl0pfX1jbGFzcyBUZW1wbGF0ZUNhY2hlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJ0ZW1wbGF0ZUNhY2hlIik7dGhpcy5tYXhFbnRyaWVzPWdldEludGVnZXIoe2RhdGE6ZS5tYXhFbnRyaWVzLGRlZmF1bHRWYWx1ZTo1LHZhbGlkYXRlOmU9PmU+PTB9KX19Y2xhc3MgVHJhY2UgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInRyYWNlIiwhMCk7dGhpcy5hcmVhPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgVHJhbnNmb3JtIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJ0cmFuc2Zvcm0iLCEwKTt0aGlzLmdyb3VwUGFyZW50PW51bGw7dGhpcy5pZkVtcHR5PW51bGw7dGhpcy5uYW1lQXR0cj1udWxsO3RoaXMucGljdHVyZT1udWxsO3RoaXMucHJlc2VuY2U9bnVsbDt0aGlzLnJlbmFtZT1udWxsO3RoaXMud2hpdGVzcGFjZT1udWxsfX1jbGFzcyBUeXBlIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJ0eXBlIixbIm5vbmUiLCJhc2NpaTg1IiwiYXNjaWlIZXgiLCJjY2l0dGZheCIsImZsYXRlIiwibHp3IiwicnVuTGVuZ3RoIiwibmF0aXZlIiwieGRwIiwibWVyZ2VkWERQIl0pfX1jbGFzcyBVcmkgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInVyaSIpfX1jbGFzcyBjb25maWdfVmFsaWRhdGUgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInZhbGlkYXRlIixbInByZVN1Ym1pdCIsInByZVByaW50IiwicHJlRXhlY3V0ZSIsInByZVNhdmUiXSl9fWNsYXNzIFZhbGlkYXRlQXBwcm92YWxTaWduYXR1cmVzIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywidmFsaWRhdGVBcHByb3ZhbFNpZ25hdHVyZXMiKX1bR25dKCl7dGhpc1tIbl09dGhpc1tIbl0udHJpbSgpLnNwbGl0KC9ccysvKS5maWx0ZXIoKGU9PlsiZG9jUmVhZHkiLCJwb3N0U2lnbiJdLmluY2x1ZGVzKGUpKSl9fWNsYXNzIFZhbGlkYXRpb25NZXNzYWdpbmcgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInZhbGlkYXRpb25NZXNzYWdpbmciLFsiYWxsTWVzc2FnZXNJbmRpdmlkdWFsbHkiLCJhbGxNZXNzYWdlc1RvZ2V0aGVyIiwiZmlyc3RNZXNzYWdlT25seSIsIm5vTWVzc2FnZXMiXSl9fWNsYXNzIFZlcnNpb24gZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sInZlcnNpb24iLFsiMS43IiwiMS42IiwiMS41IiwiMS40IiwiMS4zIiwiMS4yIl0pfX1jbGFzcyBWZXJzaW9uQ29udHJvbCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywiVmVyc2lvbkNvbnRyb2wiKTt0aGlzLm91dHB1dEJlbG93PWdldFN0cmluZ09wdGlvbihlLm91dHB1dEJlbG93LFsid2FybiIsImVycm9yIiwidXBkYXRlIl0pO3RoaXMuc291cmNlQWJvdmU9Z2V0U3RyaW5nT3B0aW9uKGUuc291cmNlQWJvdmUsWyJ3YXJuIiwiZXJyb3IiXSk7dGhpcy5zb3VyY2VCZWxvdz1nZXRTdHJpbmdPcHRpb24oZS5zb3VyY2VCZWxvdyxbInVwZGF0ZSIsIm1haW50YWluIl0pfX1jbGFzcyBWaWV3ZXJQcmVmZXJlbmNlcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywidmlld2VyUHJlZmVyZW5jZXMiLCEwKTt0aGlzLkFEQkVfSlNDb25zb2xlPW51bGw7dGhpcy5BREJFX0pTRGVidWdnZXI9bnVsbDt0aGlzLmFkZFZpZXdlclByZWZlcmVuY2VzPW51bGw7dGhpcy5kdXBsZXhPcHRpb249bnVsbDt0aGlzLmVuZm9yY2U9bnVsbDt0aGlzLm51bWJlck9mQ29waWVzPW51bGw7dGhpcy5wYWdlUmFuZ2U9bnVsbDt0aGlzLnBpY2tUcmF5QnlQREZTaXplPW51bGw7dGhpcy5wcmludFNjYWxpbmc9bnVsbH19Y2xhc3MgV2ViQ2xpZW50IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJ3ZWJDbGllbnQiLCEwKTt0aGlzLm5hbWU9ZS5uYW1lP2UubmFtZS50cmltKCk6IiI7dGhpcy5mb250SW5mbz1udWxsO3RoaXMueGRjPW51bGx9fWNsYXNzIFdoaXRlc3BhY2UgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG8sIndoaXRlc3BhY2UiLFsicHJlc2VydmUiLCJsdHJpbSIsIm5vcm1hbGl6ZSIsInJ0cmltIiwidHJpbSJdKX19Y2xhc3MgV2luZG93IGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywid2luZG93Iil9W0duXSgpe2NvbnN0IGU9dGhpc1tIbl0uc3BsaXQoIiwiLDIpLm1hcCgoZT0+cGFyc2VJbnQoZS50cmltKCksMTApKSk7aWYoZS5zb21lKChlPT5pc05hTihlKSkpKXRoaXNbSG5dPVswLDBdO2Vsc2V7MT09PWUubGVuZ3RoJiZlLnB1c2goZVswXSk7dGhpc1tIbl09ZX19fWNsYXNzIFhkYyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihQbywieGRjIiwhMCk7dGhpcy51cmk9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMueHNsPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgWGRwIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJ4ZHAiLCEwKTt0aGlzLnBhY2tldHM9bnVsbH19Y2xhc3MgWHNsIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJ4c2wiLCEwKTt0aGlzLmRlYnVnPW51bGw7dGhpcy51cmk9bnVsbH19Y2xhc3MgWnBsIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFBvLCJ6cGwiLCEwKTt0aGlzLm5hbWU9ZS5uYW1lP2UubmFtZS50cmltKCk6IiI7dGhpcy5iYXRjaE91dHB1dD1udWxsO3RoaXMuZmxpcExhYmVsPW51bGw7dGhpcy5mb250SW5mbz1udWxsO3RoaXMueGRjPW51bGx9fWNsYXNzIENvbmZpZ05hbWVzcGFjZXtzdGF0aWNbS3NdKGUsdCl7aWYoQ29uZmlnTmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXJldHVybiBDb25maWdOYW1lc3BhY2VbZV0odCl9c3RhdGljIGFjcm9iYXQoZSl7cmV0dXJuIG5ldyBBY3JvYmF0KGUpfXN0YXRpYyBhY3JvYmF0NyhlKXtyZXR1cm4gbmV3IEFjcm9iYXQ3KGUpfXN0YXRpYyBBREJFX0pTQ29uc29sZShlKXtyZXR1cm4gbmV3IEFEQkVfSlNDb25zb2xlKGUpfXN0YXRpYyBBREJFX0pTRGVidWdnZXIoZSl7cmV0dXJuIG5ldyBBREJFX0pTRGVidWdnZXIoZSl9c3RhdGljIGFkZFNpbGVudFByaW50KGUpe3JldHVybiBuZXcgQWRkU2lsZW50UHJpbnQoZSl9c3RhdGljIGFkZFZpZXdlclByZWZlcmVuY2VzKGUpe3JldHVybiBuZXcgQWRkVmlld2VyUHJlZmVyZW5jZXMoZSl9c3RhdGljIGFkanVzdERhdGEoZSl7cmV0dXJuIG5ldyBBZGp1c3REYXRhKGUpfXN0YXRpYyBhZG9iZUV4dGVuc2lvbkxldmVsKGUpe3JldHVybiBuZXcgQWRvYmVFeHRlbnNpb25MZXZlbChlKX1zdGF0aWMgYWdlbnQoZSl7cmV0dXJuIG5ldyBBZ2VudChlKX1zdGF0aWMgYWx3YXlzRW1iZWQoZSl7cmV0dXJuIG5ldyBBbHdheXNFbWJlZChlKX1zdGF0aWMgYW1kKGUpe3JldHVybiBuZXcgQW1kKGUpfXN0YXRpYyBhcmVhKGUpe3JldHVybiBuZXcgY29uZmlnX0FyZWEoZSl9c3RhdGljIGF0dHJpYnV0ZXMoZSl7cmV0dXJuIG5ldyBBdHRyaWJ1dGVzKGUpfXN0YXRpYyBhdXRvU2F2ZShlKXtyZXR1cm4gbmV3IEF1dG9TYXZlKGUpfXN0YXRpYyBiYXNlKGUpe3JldHVybiBuZXcgQmFzZShlKX1zdGF0aWMgYmF0Y2hPdXRwdXQoZSl7cmV0dXJuIG5ldyBCYXRjaE91dHB1dChlKX1zdGF0aWMgYmVoYXZpb3JPdmVycmlkZShlKXtyZXR1cm4gbmV3IEJlaGF2aW9yT3ZlcnJpZGUoZSl9c3RhdGljIGNhY2hlKGUpe3JldHVybiBuZXcgQ2FjaGUoZSl9c3RhdGljIGNoYW5nZShlKXtyZXR1cm4gbmV3IENoYW5nZShlKX1zdGF0aWMgY29tbW9uKGUpe3JldHVybiBuZXcgQ29tbW9uKGUpfXN0YXRpYyBjb21wcmVzcyhlKXtyZXR1cm4gbmV3IENvbXByZXNzKGUpfXN0YXRpYyBjb21wcmVzc0xvZ2ljYWxTdHJ1Y3R1cmUoZSl7cmV0dXJuIG5ldyBDb21wcmVzc0xvZ2ljYWxTdHJ1Y3R1cmUoZSl9c3RhdGljIGNvbXByZXNzT2JqZWN0U3RyZWFtKGUpe3JldHVybiBuZXcgQ29tcHJlc3NPYmplY3RTdHJlYW0oZSl9c3RhdGljIGNvbXByZXNzaW9uKGUpe3JldHVybiBuZXcgQ29tcHJlc3Npb24oZSl9c3RhdGljIGNvbmZpZyhlKXtyZXR1cm4gbmV3IENvbmZpZyhlKX1zdGF0aWMgY29uZm9ybWFuY2UoZSl7cmV0dXJuIG5ldyBDb25mb3JtYW5jZShlKX1zdGF0aWMgY29udGVudENvcHkoZSl7cmV0dXJuIG5ldyBDb250ZW50Q29weShlKX1zdGF0aWMgY29waWVzKGUpe3JldHVybiBuZXcgQ29waWVzKGUpfXN0YXRpYyBjcmVhdG9yKGUpe3JldHVybiBuZXcgQ3JlYXRvcihlKX1zdGF0aWMgY3VycmVudFBhZ2UoZSl7cmV0dXJuIG5ldyBDdXJyZW50UGFnZShlKX1zdGF0aWMgZGF0YShlKXtyZXR1cm4gbmV3IERhdGEoZSl9c3RhdGljIGRlYnVnKGUpe3JldHVybiBuZXcgRGVidWcoZSl9c3RhdGljIGRlZmF1bHRUeXBlZmFjZShlKXtyZXR1cm4gbmV3IERlZmF1bHRUeXBlZmFjZShlKX1zdGF0aWMgZGVzdGluYXRpb24oZSl7cmV0dXJuIG5ldyBEZXN0aW5hdGlvbihlKX1zdGF0aWMgZG9jdW1lbnRBc3NlbWJseShlKXtyZXR1cm4gbmV3IERvY3VtZW50QXNzZW1ibHkoZSl9c3RhdGljIGRyaXZlcihlKXtyZXR1cm4gbmV3IERyaXZlcihlKX1zdGF0aWMgZHVwbGV4T3B0aW9uKGUpe3JldHVybiBuZXcgRHVwbGV4T3B0aW9uKGUpfXN0YXRpYyBkeW5hbWljUmVuZGVyKGUpe3JldHVybiBuZXcgRHluYW1pY1JlbmRlcihlKX1zdGF0aWMgZW1iZWQoZSl7cmV0dXJuIG5ldyBFbWJlZChlKX1zdGF0aWMgZW5jcnlwdChlKXtyZXR1cm4gbmV3IGNvbmZpZ19FbmNyeXB0KGUpfXN0YXRpYyBlbmNyeXB0aW9uKGUpe3JldHVybiBuZXcgY29uZmlnX0VuY3J5cHRpb24oZSl9c3RhdGljIGVuY3J5cHRpb25MZXZlbChlKXtyZXR1cm4gbmV3IEVuY3J5cHRpb25MZXZlbChlKX1zdGF0aWMgZW5mb3JjZShlKXtyZXR1cm4gbmV3IEVuZm9yY2UoZSl9c3RhdGljIGVxdWF0ZShlKXtyZXR1cm4gbmV3IEVxdWF0ZShlKX1zdGF0aWMgZXF1YXRlUmFuZ2UoZSl7cmV0dXJuIG5ldyBFcXVhdGVSYW5nZShlKX1zdGF0aWMgZXhjbHVkZShlKXtyZXR1cm4gbmV3IEV4Y2x1ZGUoZSl9c3RhdGljIGV4Y2x1ZGVOUyhlKXtyZXR1cm4gbmV3IEV4Y2x1ZGVOUyhlKX1zdGF0aWMgZmxpcExhYmVsKGUpe3JldHVybiBuZXcgRmxpcExhYmVsKGUpfXN0YXRpYyBmb250SW5mbyhlKXtyZXR1cm4gbmV3IGNvbmZpZ19Gb250SW5mbyhlKX1zdGF0aWMgZm9ybUZpZWxkRmlsbGluZyhlKXtyZXR1cm4gbmV3IEZvcm1GaWVsZEZpbGxpbmcoZSl9c3RhdGljIGdyb3VwUGFyZW50KGUpe3JldHVybiBuZXcgR3JvdXBQYXJlbnQoZSl9c3RhdGljIGlmRW1wdHkoZSl7cmV0dXJuIG5ldyBJZkVtcHR5KGUpfXN0YXRpYyBpbmNsdWRlWERQQ29udGVudChlKXtyZXR1cm4gbmV3IEluY2x1ZGVYRFBDb250ZW50KGUpfXN0YXRpYyBpbmNyZW1lbnRhbExvYWQoZSl7cmV0dXJuIG5ldyBJbmNyZW1lbnRhbExvYWQoZSl9c3RhdGljIGluY3JlbWVudGFsTWVyZ2UoZSl7cmV0dXJuIG5ldyBJbmNyZW1lbnRhbE1lcmdlKGUpfXN0YXRpYyBpbnRlcmFjdGl2ZShlKXtyZXR1cm4gbmV3IEludGVyYWN0aXZlKGUpfXN0YXRpYyBqb2coZSl7cmV0dXJuIG5ldyBKb2coZSl9c3RhdGljIGxhYmVsUHJpbnRlcihlKXtyZXR1cm4gbmV3IExhYmVsUHJpbnRlcihlKX1zdGF0aWMgbGF5b3V0KGUpe3JldHVybiBuZXcgTGF5b3V0KGUpfXN0YXRpYyBsZXZlbChlKXtyZXR1cm4gbmV3IExldmVsKGUpfXN0YXRpYyBsaW5lYXJpemVkKGUpe3JldHVybiBuZXcgTGluZWFyaXplZChlKX1zdGF0aWMgbG9jYWxlKGUpe3JldHVybiBuZXcgTG9jYWxlKGUpfXN0YXRpYyBsb2NhbGVTZXQoZSl7cmV0dXJuIG5ldyBMb2NhbGVTZXQoZSl9c3RhdGljIGxvZyhlKXtyZXR1cm4gbmV3IExvZyhlKX1zdGF0aWMgbWFwKGUpe3JldHVybiBuZXcgTWFwRWxlbWVudChlKX1zdGF0aWMgbWVkaXVtSW5mbyhlKXtyZXR1cm4gbmV3IE1lZGl1bUluZm8oZSl9c3RhdGljIG1lc3NhZ2UoZSl7cmV0dXJuIG5ldyBjb25maWdfTWVzc2FnZShlKX1zdGF0aWMgbWVzc2FnaW5nKGUpe3JldHVybiBuZXcgTWVzc2FnaW5nKGUpfXN0YXRpYyBtb2RlKGUpe3JldHVybiBuZXcgTW9kZShlKX1zdGF0aWMgbW9kaWZ5QW5ub3RzKGUpe3JldHVybiBuZXcgTW9kaWZ5QW5ub3RzKGUpfXN0YXRpYyBtc2dJZChlKXtyZXR1cm4gbmV3IE1zZ0lkKGUpfXN0YXRpYyBuYW1lQXR0cihlKXtyZXR1cm4gbmV3IE5hbWVBdHRyKGUpfXN0YXRpYyBuZXZlckVtYmVkKGUpe3JldHVybiBuZXcgTmV2ZXJFbWJlZChlKX1zdGF0aWMgbnVtYmVyT2ZDb3BpZXMoZSl7cmV0dXJuIG5ldyBOdW1iZXJPZkNvcGllcyhlKX1zdGF0aWMgb3BlbkFjdGlvbihlKXtyZXR1cm4gbmV3IE9wZW5BY3Rpb24oZSl9c3RhdGljIG91dHB1dChlKXtyZXR1cm4gbmV3IE91dHB1dChlKX1zdGF0aWMgb3V0cHV0QmluKGUpe3JldHVybiBuZXcgT3V0cHV0QmluKGUpfXN0YXRpYyBvdXRwdXRYU0woZSl7cmV0dXJuIG5ldyBPdXRwdXRYU0woZSl9c3RhdGljIG92ZXJwcmludChlKXtyZXR1cm4gbmV3IE92ZXJwcmludChlKX1zdGF0aWMgcGFja2V0cyhlKXtyZXR1cm4gbmV3IFBhY2tldHMoZSl9c3RhdGljIHBhZ2VPZmZzZXQoZSl7cmV0dXJuIG5ldyBQYWdlT2Zmc2V0KGUpfXN0YXRpYyBwYWdlUmFuZ2UoZSl7cmV0dXJuIG5ldyBQYWdlUmFuZ2UoZSl9c3RhdGljIHBhZ2luYXRpb24oZSl7cmV0dXJuIG5ldyBQYWdpbmF0aW9uKGUpfXN0YXRpYyBwYWdpbmF0aW9uT3ZlcnJpZGUoZSl7cmV0dXJuIG5ldyBQYWdpbmF0aW9uT3ZlcnJpZGUoZSl9c3RhdGljIHBhcnQoZSl7cmV0dXJuIG5ldyBQYXJ0KGUpfXN0YXRpYyBwY2woZSl7cmV0dXJuIG5ldyBQY2woZSl9c3RhdGljIHBkZihlKXtyZXR1cm4gbmV3IFBkZihlKX1zdGF0aWMgcGRmYShlKXtyZXR1cm4gbmV3IFBkZmEoZSl9c3RhdGljIHBlcm1pc3Npb25zKGUpe3JldHVybiBuZXcgUGVybWlzc2lvbnMoZSl9c3RhdGljIHBpY2tUcmF5QnlQREZTaXplKGUpe3JldHVybiBuZXcgUGlja1RyYXlCeVBERlNpemUoZSl9c3RhdGljIHBpY3R1cmUoZSl7cmV0dXJuIG5ldyBjb25maWdfUGljdHVyZShlKX1zdGF0aWMgcGxhaW50ZXh0TWV0YWRhdGEoZSl7cmV0dXJuIG5ldyBQbGFpbnRleHRNZXRhZGF0YShlKX1zdGF0aWMgcHJlc2VuY2UoZSl7cmV0dXJuIG5ldyBQcmVzZW5jZShlKX1zdGF0aWMgcHJlc2VudChlKXtyZXR1cm4gbmV3IFByZXNlbnQoZSl9c3RhdGljIHByaW50KGUpe3JldHVybiBuZXcgUHJpbnQoZSl9c3RhdGljIHByaW50SGlnaFF1YWxpdHkoZSl7cmV0dXJuIG5ldyBQcmludEhpZ2hRdWFsaXR5KGUpfXN0YXRpYyBwcmludFNjYWxpbmcoZSl7cmV0dXJuIG5ldyBQcmludFNjYWxpbmcoZSl9c3RhdGljIHByaW50ZXJOYW1lKGUpe3JldHVybiBuZXcgUHJpbnRlck5hbWUoZSl9c3RhdGljIHByb2R1Y2VyKGUpe3JldHVybiBuZXcgUHJvZHVjZXIoZSl9c3RhdGljIHBzKGUpe3JldHVybiBuZXcgUHMoZSl9c3RhdGljIHJhbmdlKGUpe3JldHVybiBuZXcgUmFuZ2UoZSl9c3RhdGljIHJlY29yZChlKXtyZXR1cm4gbmV3IFJlY29yZChlKX1zdGF0aWMgcmVsZXZhbnQoZSl7cmV0dXJuIG5ldyBSZWxldmFudChlKX1zdGF0aWMgcmVuYW1lKGUpe3JldHVybiBuZXcgUmVuYW1lKGUpfXN0YXRpYyByZW5kZXJQb2xpY3koZSl7cmV0dXJuIG5ldyBSZW5kZXJQb2xpY3koZSl9c3RhdGljIHJ1blNjcmlwdHMoZSl7cmV0dXJuIG5ldyBSdW5TY3JpcHRzKGUpfXN0YXRpYyBzY3JpcHQoZSl7cmV0dXJuIG5ldyBjb25maWdfU2NyaXB0KGUpfXN0YXRpYyBzY3JpcHRNb2RlbChlKXtyZXR1cm4gbmV3IFNjcmlwdE1vZGVsKGUpfXN0YXRpYyBzZXZlcml0eShlKXtyZXR1cm4gbmV3IFNldmVyaXR5KGUpfXN0YXRpYyBzaWxlbnRQcmludChlKXtyZXR1cm4gbmV3IFNpbGVudFByaW50KGUpfXN0YXRpYyBzdGFwbGUoZSl7cmV0dXJuIG5ldyBTdGFwbGUoZSl9c3RhdGljIHN0YXJ0Tm9kZShlKXtyZXR1cm4gbmV3IFN0YXJ0Tm9kZShlKX1zdGF0aWMgc3RhcnRQYWdlKGUpe3JldHVybiBuZXcgU3RhcnRQYWdlKGUpfXN0YXRpYyBzdWJtaXRGb3JtYXQoZSl7cmV0dXJuIG5ldyBTdWJtaXRGb3JtYXQoZSl9c3RhdGljIHN1Ym1pdFVybChlKXtyZXR1cm4gbmV3IFN1Ym1pdFVybChlKX1zdGF0aWMgc3Vic2V0QmVsb3coZSl7cmV0dXJuIG5ldyBTdWJzZXRCZWxvdyhlKX1zdGF0aWMgc3VwcHJlc3NCYW5uZXIoZSl7cmV0dXJuIG5ldyBTdXBwcmVzc0Jhbm5lcihlKX1zdGF0aWMgdGFnZ2VkKGUpe3JldHVybiBuZXcgVGFnZ2VkKGUpfXN0YXRpYyB0ZW1wbGF0ZShlKXtyZXR1cm4gbmV3IGNvbmZpZ19UZW1wbGF0ZShlKX1zdGF0aWMgdGVtcGxhdGVDYWNoZShlKXtyZXR1cm4gbmV3IFRlbXBsYXRlQ2FjaGUoZSl9c3RhdGljIHRocmVzaG9sZChlKXtyZXR1cm4gbmV3IFRocmVzaG9sZChlKX1zdGF0aWMgdG8oZSl7cmV0dXJuIG5ldyBUbyhlKX1zdGF0aWMgdHJhY2UoZSl7cmV0dXJuIG5ldyBUcmFjZShlKX1zdGF0aWMgdHJhbnNmb3JtKGUpe3JldHVybiBuZXcgVHJhbnNmb3JtKGUpfXN0YXRpYyB0eXBlKGUpe3JldHVybiBuZXcgVHlwZShlKX1zdGF0aWMgdXJpKGUpe3JldHVybiBuZXcgVXJpKGUpfXN0YXRpYyB2YWxpZGF0ZShlKXtyZXR1cm4gbmV3IGNvbmZpZ19WYWxpZGF0ZShlKX1zdGF0aWMgdmFsaWRhdGVBcHByb3ZhbFNpZ25hdHVyZXMoZSl7cmV0dXJuIG5ldyBWYWxpZGF0ZUFwcHJvdmFsU2lnbmF0dXJlcyhlKX1zdGF0aWMgdmFsaWRhdGlvbk1lc3NhZ2luZyhlKXtyZXR1cm4gbmV3IFZhbGlkYXRpb25NZXNzYWdpbmcoZSl9c3RhdGljIHZlcnNpb24oZSl7cmV0dXJuIG5ldyBWZXJzaW9uKGUpfXN0YXRpYyB2ZXJzaW9uQ29udHJvbChlKXtyZXR1cm4gbmV3IFZlcnNpb25Db250cm9sKGUpfXN0YXRpYyB2aWV3ZXJQcmVmZXJlbmNlcyhlKXtyZXR1cm4gbmV3IFZpZXdlclByZWZlcmVuY2VzKGUpfXN0YXRpYyB3ZWJDbGllbnQoZSl7cmV0dXJuIG5ldyBXZWJDbGllbnQoZSl9c3RhdGljIHdoaXRlc3BhY2UoZSl7cmV0dXJuIG5ldyBXaGl0ZXNwYWNlKGUpfXN0YXRpYyB3aW5kb3coZSl7cmV0dXJuIG5ldyBXaW5kb3coZSl9c3RhdGljIHhkYyhlKXtyZXR1cm4gbmV3IFhkYyhlKX1zdGF0aWMgeGRwKGUpe3JldHVybiBuZXcgWGRwKGUpfXN0YXRpYyB4c2woZSl7cmV0dXJuIG5ldyBYc2woZSl9c3RhdGljIHpwbChlKXtyZXR1cm4gbmV3IFpwbChlKX19Y29uc3QgTG89SnMuY29ubmVjdGlvblNldC5pZDtjbGFzcyBDb25uZWN0aW9uU2V0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKExvLCJjb25uZWN0aW9uU2V0IiwhMCk7dGhpcy53c2RsQ29ubmVjdGlvbj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy54bWxDb25uZWN0aW9uPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnhzZENvbm5lY3Rpb249bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBFZmZlY3RpdmVJbnB1dFBvbGljeSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihMbywiZWZmZWN0aXZlSW5wdXRQb2xpY3kiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgRWZmZWN0aXZlT3V0cHV0UG9saWN5IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKExvLCJlZmZlY3RpdmVPdXRwdXRQb2xpY3kiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgT3BlcmF0aW9uIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKExvLCJvcGVyYXRpb24iKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMuaW5wdXQ9ZS5pbnB1dHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5vdXRwdXQ9ZS5vdXRwdXR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgUm9vdEVsZW1lbnQgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTG8sInJvb3RFbGVtZW50Iik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFNvYXBBY3Rpb24gZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTG8sInNvYXBBY3Rpb24iKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgU29hcEFkZHJlc3MgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTG8sInNvYXBBZGRyZXNzIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIGNvbm5lY3Rpb25fc2V0X1VyaSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihMbywidXJpIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFdzZGxBZGRyZXNzIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKExvLCJ3c2RsQWRkcmVzcyIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBXc2RsQ29ubmVjdGlvbiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihMbywid3NkbENvbm5lY3Rpb24iLCEwKTt0aGlzLmRhdGFEZXNjcmlwdGlvbj1lLmRhdGFEZXNjcmlwdGlvbnx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5lZmZlY3RpdmVJbnB1dFBvbGljeT1udWxsO3RoaXMuZWZmZWN0aXZlT3V0cHV0UG9saWN5PW51bGw7dGhpcy5vcGVyYXRpb249bnVsbDt0aGlzLnNvYXBBY3Rpb249bnVsbDt0aGlzLnNvYXBBZGRyZXNzPW51bGw7dGhpcy53c2RsQWRkcmVzcz1udWxsfX1jbGFzcyBYbWxDb25uZWN0aW9uIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKExvLCJ4bWxDb25uZWN0aW9uIiwhMCk7dGhpcy5kYXRhRGVzY3JpcHRpb249ZS5kYXRhRGVzY3JpcHRpb258fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXJpPW51bGx9fWNsYXNzIFhzZENvbm5lY3Rpb24gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoTG8sInhzZENvbm5lY3Rpb24iLCEwKTt0aGlzLmRhdGFEZXNjcmlwdGlvbj1lLmRhdGFEZXNjcmlwdGlvbnx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5yb290RWxlbWVudD1udWxsO3RoaXMudXJpPW51bGx9fWNsYXNzIENvbm5lY3Rpb25TZXROYW1lc3BhY2V7c3RhdGljW0tzXShlLHQpe2lmKENvbm5lY3Rpb25TZXROYW1lc3BhY2UuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIENvbm5lY3Rpb25TZXROYW1lc3BhY2VbZV0odCl9c3RhdGljIGNvbm5lY3Rpb25TZXQoZSl7cmV0dXJuIG5ldyBDb25uZWN0aW9uU2V0KGUpfXN0YXRpYyBlZmZlY3RpdmVJbnB1dFBvbGljeShlKXtyZXR1cm4gbmV3IEVmZmVjdGl2ZUlucHV0UG9saWN5KGUpfXN0YXRpYyBlZmZlY3RpdmVPdXRwdXRQb2xpY3koZSl7cmV0dXJuIG5ldyBFZmZlY3RpdmVPdXRwdXRQb2xpY3koZSl9c3RhdGljIG9wZXJhdGlvbihlKXtyZXR1cm4gbmV3IE9wZXJhdGlvbihlKX1zdGF0aWMgcm9vdEVsZW1lbnQoZSl7cmV0dXJuIG5ldyBSb290RWxlbWVudChlKX1zdGF0aWMgc29hcEFjdGlvbihlKXtyZXR1cm4gbmV3IFNvYXBBY3Rpb24oZSl9c3RhdGljIHNvYXBBZGRyZXNzKGUpe3JldHVybiBuZXcgU29hcEFkZHJlc3MoZSl9c3RhdGljIHVyaShlKXtyZXR1cm4gbmV3IGNvbm5lY3Rpb25fc2V0X1VyaShlKX1zdGF0aWMgd3NkbEFkZHJlc3MoZSl7cmV0dXJuIG5ldyBXc2RsQWRkcmVzcyhlKX1zdGF0aWMgd3NkbENvbm5lY3Rpb24oZSl7cmV0dXJuIG5ldyBXc2RsQ29ubmVjdGlvbihlKX1zdGF0aWMgeG1sQ29ubmVjdGlvbihlKXtyZXR1cm4gbmV3IFhtbENvbm5lY3Rpb24oZSl9c3RhdGljIHhzZENvbm5lY3Rpb24oZSl7cmV0dXJuIG5ldyBYc2RDb25uZWN0aW9uKGUpfX1jb25zdCBqbz1Kcy5kYXRhc2V0cy5pZDtjbGFzcyBkYXRhc2V0c19EYXRhIGV4dGVuZHMgWG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGpvLCJkYXRhIixlKX1bd3NdKCl7cmV0dXJuITB9fWNsYXNzIERhdGFzZXRzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGpvLCJkYXRhc2V0cyIsITApO3RoaXMuZGF0YT1udWxsO3RoaXMuU2lnbmF0dXJlPW51bGx9W1RzXShlKXtjb25zdCB0PWVbRnNdOygiZGF0YSI9PT10JiZlW3ZzXT09PWpvfHwiU2lnbmF0dXJlIj09PXQmJmVbdnNdPT09SnMuc2lnbmF0dXJlLmlkKSYmKHRoaXNbdF09ZSk7dGhpc1tQbl0oZSl9fWNsYXNzIERhdGFzZXRzTmFtZXNwYWNle3N0YXRpY1tLc10oZSx0KXtpZihEYXRhc2V0c05hbWVzcGFjZS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gRGF0YXNldHNOYW1lc3BhY2VbZV0odCl9c3RhdGljIGRhdGFzZXRzKGUpe3JldHVybiBuZXcgRGF0YXNldHMoZSl9c3RhdGljIGRhdGEoZSl7cmV0dXJuIG5ldyBkYXRhc2V0c19EYXRhKGUpfX1jb25zdCBfbz1Kcy5sb2NhbGVTZXQuaWQ7Y2xhc3MgQ2FsZW5kYXJTeW1ib2xzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJjYWxlbmRhclN5bWJvbHMiLCEwKTt0aGlzLm5hbWU9ImdyZWdvcmlhbiI7dGhpcy5kYXlOYW1lcz1uZXcgWEZBT2JqZWN0QXJyYXkoMik7dGhpcy5lcmFOYW1lcz1udWxsO3RoaXMubWVyaWRpZW1OYW1lcz1udWxsO3RoaXMubW9udGhOYW1lcz1uZXcgWEZBT2JqZWN0QXJyYXkoMil9fWNsYXNzIEN1cnJlbmN5U3ltYm9sIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJjdXJyZW5jeVN5bWJvbCIpO3RoaXMubmFtZT1nZXRTdHJpbmdPcHRpb24oZS5uYW1lLFsic3ltYm9sIiwiaXNvbmFtZSIsImRlY2ltYWwiXSl9fWNsYXNzIEN1cnJlbmN5U3ltYm9scyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihfbywiY3VycmVuY3lTeW1ib2xzIiwhMCk7dGhpcy5jdXJyZW5jeVN5bWJvbD1uZXcgWEZBT2JqZWN0QXJyYXkoMyl9fWNsYXNzIERhdGVQYXR0ZXJuIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJkYXRlUGF0dGVybiIpO3RoaXMubmFtZT1nZXRTdHJpbmdPcHRpb24oZS5uYW1lLFsiZnVsbCIsImxvbmciLCJtZWQiLCJzaG9ydCJdKX19Y2xhc3MgRGF0ZVBhdHRlcm5zIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJkYXRlUGF0dGVybnMiLCEwKTt0aGlzLmRhdGVQYXR0ZXJuPW5ldyBYRkFPYmplY3RBcnJheSg0KX19Y2xhc3MgRGF0ZVRpbWVTeW1ib2xzIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihfbywiZGF0ZVRpbWVTeW1ib2xzIil9fWNsYXNzIERheSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihfbywiZGF5Iil9fWNsYXNzIERheU5hbWVzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJkYXlOYW1lcyIsITApO3RoaXMuYWJicj1nZXRJbnRlZ2VyKHtkYXRhOmUuYWJicixkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMuZGF5PW5ldyBYRkFPYmplY3RBcnJheSg3KX19Y2xhc3MgRXJhIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJlcmEiKX19Y2xhc3MgRXJhTmFtZXMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoX28sImVyYU5hbWVzIiwhMCk7dGhpcy5lcmE9bmV3IFhGQU9iamVjdEFycmF5KDIpfX1jbGFzcyBsb2NhbGVfc2V0X0xvY2FsZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihfbywibG9jYWxlIiwhMCk7dGhpcy5kZXNjPWUuZGVzY3x8IiI7dGhpcy5uYW1lPSJpc29uYW1lIjt0aGlzLmNhbGVuZGFyU3ltYm9scz1udWxsO3RoaXMuY3VycmVuY3lTeW1ib2xzPW51bGw7dGhpcy5kYXRlUGF0dGVybnM9bnVsbDt0aGlzLmRhdGVUaW1lU3ltYm9scz1udWxsO3RoaXMubnVtYmVyUGF0dGVybnM9bnVsbDt0aGlzLm51bWJlclN5bWJvbHM9bnVsbDt0aGlzLnRpbWVQYXR0ZXJucz1udWxsO3RoaXMudHlwZUZhY2VzPW51bGx9fWNsYXNzIGxvY2FsZV9zZXRfTG9jYWxlU2V0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJsb2NhbGVTZXQiLCEwKTt0aGlzLmxvY2FsZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIE1lcmlkaWVtIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJtZXJpZGllbSIpfX1jbGFzcyBNZXJpZGllbU5hbWVzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJtZXJpZGllbU5hbWVzIiwhMCk7dGhpcy5tZXJpZGllbT1uZXcgWEZBT2JqZWN0QXJyYXkoMil9fWNsYXNzIE1vbnRoIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJtb250aCIpfX1jbGFzcyBNb250aE5hbWVzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJtb250aE5hbWVzIiwhMCk7dGhpcy5hYmJyPWdldEludGVnZXIoe2RhdGE6ZS5hYmJyLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5tb250aD1uZXcgWEZBT2JqZWN0QXJyYXkoMTIpfX1jbGFzcyBOdW1iZXJQYXR0ZXJuIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKF9vLCJudW1iZXJQYXR0ZXJuIik7dGhpcy5uYW1lPWdldFN0cmluZ09wdGlvbihlLm5hbWUsWyJmdWxsIiwibG9uZyIsIm1lZCIsInNob3J0Il0pfX1jbGFzcyBOdW1iZXJQYXR0ZXJucyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihfbywibnVtYmVyUGF0dGVybnMiLCEwKTt0aGlzLm51bWJlclBhdHRlcm49bmV3IFhGQU9iamVjdEFycmF5KDQpfX1jbGFzcyBOdW1iZXJTeW1ib2wgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoX28sIm51bWJlclN5bWJvbCIpO3RoaXMubmFtZT1nZXRTdHJpbmdPcHRpb24oZS5uYW1lLFsiZGVjaW1hbCIsImdyb3VwaW5nIiwicGVyY2VudCIsIm1pbnVzIiwiemVybyJdKX19Y2xhc3MgTnVtYmVyU3ltYm9scyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihfbywibnVtYmVyU3ltYm9scyIsITApO3RoaXMubnVtYmVyU3ltYm9sPW5ldyBYRkFPYmplY3RBcnJheSg1KX19Y2xhc3MgVGltZVBhdHRlcm4gZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoX28sInRpbWVQYXR0ZXJuIik7dGhpcy5uYW1lPWdldFN0cmluZ09wdGlvbihlLm5hbWUsWyJmdWxsIiwibG9uZyIsIm1lZCIsInNob3J0Il0pfX1jbGFzcyBUaW1lUGF0dGVybnMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoX28sInRpbWVQYXR0ZXJucyIsITApO3RoaXMudGltZVBhdHRlcm49bmV3IFhGQU9iamVjdEFycmF5KDQpfX1jbGFzcyBUeXBlRmFjZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihfbywidHlwZUZhY2UiLCEwKTt0aGlzLm5hbWU9IiJ8ZS5uYW1lfX1jbGFzcyBUeXBlRmFjZXMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoX28sInR5cGVGYWNlcyIsITApO3RoaXMudHlwZUZhY2U9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBMb2NhbGVTZXROYW1lc3BhY2V7c3RhdGljW0tzXShlLHQpe2lmKExvY2FsZVNldE5hbWVzcGFjZS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gTG9jYWxlU2V0TmFtZXNwYWNlW2VdKHQpfXN0YXRpYyBjYWxlbmRhclN5bWJvbHMoZSl7cmV0dXJuIG5ldyBDYWxlbmRhclN5bWJvbHMoZSl9c3RhdGljIGN1cnJlbmN5U3ltYm9sKGUpe3JldHVybiBuZXcgQ3VycmVuY3lTeW1ib2woZSl9c3RhdGljIGN1cnJlbmN5U3ltYm9scyhlKXtyZXR1cm4gbmV3IEN1cnJlbmN5U3ltYm9scyhlKX1zdGF0aWMgZGF0ZVBhdHRlcm4oZSl7cmV0dXJuIG5ldyBEYXRlUGF0dGVybihlKX1zdGF0aWMgZGF0ZVBhdHRlcm5zKGUpe3JldHVybiBuZXcgRGF0ZVBhdHRlcm5zKGUpfXN0YXRpYyBkYXRlVGltZVN5bWJvbHMoZSl7cmV0dXJuIG5ldyBEYXRlVGltZVN5bWJvbHMoZSl9c3RhdGljIGRheShlKXtyZXR1cm4gbmV3IERheShlKX1zdGF0aWMgZGF5TmFtZXMoZSl7cmV0dXJuIG5ldyBEYXlOYW1lcyhlKX1zdGF0aWMgZXJhKGUpe3JldHVybiBuZXcgRXJhKGUpfXN0YXRpYyBlcmFOYW1lcyhlKXtyZXR1cm4gbmV3IEVyYU5hbWVzKGUpfXN0YXRpYyBsb2NhbGUoZSl7cmV0dXJuIG5ldyBsb2NhbGVfc2V0X0xvY2FsZShlKX1zdGF0aWMgbG9jYWxlU2V0KGUpe3JldHVybiBuZXcgbG9jYWxlX3NldF9Mb2NhbGVTZXQoZSl9c3RhdGljIG1lcmlkaWVtKGUpe3JldHVybiBuZXcgTWVyaWRpZW0oZSl9c3RhdGljIG1lcmlkaWVtTmFtZXMoZSl7cmV0dXJuIG5ldyBNZXJpZGllbU5hbWVzKGUpfXN0YXRpYyBtb250aChlKXtyZXR1cm4gbmV3IE1vbnRoKGUpfXN0YXRpYyBtb250aE5hbWVzKGUpe3JldHVybiBuZXcgTW9udGhOYW1lcyhlKX1zdGF0aWMgbnVtYmVyUGF0dGVybihlKXtyZXR1cm4gbmV3IE51bWJlclBhdHRlcm4oZSl9c3RhdGljIG51bWJlclBhdHRlcm5zKGUpe3JldHVybiBuZXcgTnVtYmVyUGF0dGVybnMoZSl9c3RhdGljIG51bWJlclN5bWJvbChlKXtyZXR1cm4gbmV3IE51bWJlclN5bWJvbChlKX1zdGF0aWMgbnVtYmVyU3ltYm9scyhlKXtyZXR1cm4gbmV3IE51bWJlclN5bWJvbHMoZSl9c3RhdGljIHRpbWVQYXR0ZXJuKGUpe3JldHVybiBuZXcgVGltZVBhdHRlcm4oZSl9c3RhdGljIHRpbWVQYXR0ZXJucyhlKXtyZXR1cm4gbmV3IFRpbWVQYXR0ZXJucyhlKX1zdGF0aWMgdHlwZUZhY2UoZSl7cmV0dXJuIG5ldyBUeXBlRmFjZShlKX1zdGF0aWMgdHlwZUZhY2VzKGUpe3JldHVybiBuZXcgVHlwZUZhY2VzKGUpfX1jb25zdCBVbz1Kcy5zaWduYXR1cmUuaWQ7Y2xhc3Mgc2lnbmF0dXJlX1NpZ25hdHVyZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihVbywic2lnbmF0dXJlIiwhMCl9fWNsYXNzIFNpZ25hdHVyZU5hbWVzcGFjZXtzdGF0aWNbS3NdKGUsdCl7aWYoU2lnbmF0dXJlTmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXJldHVybiBTaWduYXR1cmVOYW1lc3BhY2VbZV0odCl9c3RhdGljIHNpZ25hdHVyZShlKXtyZXR1cm4gbmV3IHNpZ25hdHVyZV9TaWduYXR1cmUoZSl9fWNvbnN0IFhvPUpzLnN0eWxlc2hlZXQuaWQ7Y2xhc3MgU3R5bGVzaGVldCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihYbywic3R5bGVzaGVldCIsITApfX1jbGFzcyBTdHlsZXNoZWV0TmFtZXNwYWNle3N0YXRpY1tLc10oZSx0KXtpZihTdHlsZXNoZWV0TmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXJldHVybiBTdHlsZXNoZWV0TmFtZXNwYWNlW2VdKHQpfXN0YXRpYyBzdHlsZXNoZWV0KGUpe3JldHVybiBuZXcgU3R5bGVzaGVldChlKX19Y29uc3QgcW89SnMueGRwLmlkO2NsYXNzIHhkcF9YZHAgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW8sInhkcCIsITApO3RoaXMudXVpZD1lLnV1aWR8fCIiO3RoaXMudGltZVN0YW1wPWUudGltZVN0YW1wfHwiIjt0aGlzLmNvbmZpZz1udWxsO3RoaXMuY29ubmVjdGlvblNldD1udWxsO3RoaXMuZGF0YXNldHM9bnVsbDt0aGlzLmxvY2FsZVNldD1udWxsO3RoaXMuc3R5bGVzaGVldD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50ZW1wbGF0ZT1udWxsfVtPc10oZSl7Y29uc3QgdD1Kc1tlW0ZzXV07cmV0dXJuIHQmJmVbdnNdPT09dC5pZH19Y2xhc3MgWGRwTmFtZXNwYWNle3N0YXRpY1tLc10oZSx0KXtpZihYZHBOYW1lc3BhY2UuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIFhkcE5hbWVzcGFjZVtlXSh0KX1zdGF0aWMgeGRwKGUpe3JldHVybiBuZXcgeGRwX1hkcChlKX19Y29uc3QgSG89SnMueGh0bWwuaWQsV289U3ltYm9sKCksem89bmV3IFNldChbImNvbG9yIiwiZm9udCIsImZvbnQtZmFtaWx5IiwiZm9udC1zaXplIiwiZm9udC1zdHJldGNoIiwiZm9udC1zdHlsZSIsImZvbnQtd2VpZ2h0IiwibWFyZ2luIiwibWFyZ2luLWJvdHRvbSIsIm1hcmdpbi1sZWZ0IiwibWFyZ2luLXJpZ2h0IiwibWFyZ2luLXRvcCIsImxldHRlci1zcGFjaW5nIiwibGluZS1oZWlnaHQiLCJvcnBoYW5zIiwicGFnZS1icmVhay1hZnRlciIsInBhZ2UtYnJlYWstYmVmb3JlIiwicGFnZS1icmVhay1pbnNpZGUiLCJ0YWItaW50ZXJ2YWwiLCJ0YWItc3RvcCIsInRleHQtYWxpZ24iLCJ0ZXh0LWRlY29yYXRpb24iLCJ0ZXh0LWluZGVudCIsInZlcnRpY2FsLWFsaWduIiwid2lkb3dzIiwia2VybmluZy1tb2RlIiwieGZhLWZvbnQtaG9yaXpvbnRhbC1zY2FsZSIsInhmYS1mb250LXZlcnRpY2FsLXNjYWxlIiwieGZhLXNwYWNlcnVuIiwieGZhLXRhYi1zdG9wcyJdKSwkbz1uZXcgTWFwKFtbInBhZ2UtYnJlYWstYWZ0ZXIiLCJicmVha0FmdGVyIl0sWyJwYWdlLWJyZWFrLWJlZm9yZSIsImJyZWFrQmVmb3JlIl0sWyJwYWdlLWJyZWFrLWluc2lkZSIsImJyZWFrSW5zaWRlIl0sWyJrZXJuaW5nLW1vZGUiLGU9PiJub25lIj09PWU/Im5vbmUiOiJub3JtYWwiXSxbInhmYS1mb250LWhvcml6b250YWwtc2NhbGUiLGU9PmBzY2FsZVgoJHtNYXRoLm1heCgwLHBhcnNlSW50KGUpLzEwMCkudG9GaXhlZCgyKX0pYF0sWyJ4ZmEtZm9udC12ZXJ0aWNhbC1zY2FsZSIsZT0+YHNjYWxlWSgke01hdGgubWF4KDAscGFyc2VJbnQoZSkvMTAwKS50b0ZpeGVkKDIpfSlgXSxbInhmYS1zcGFjZXJ1biIsIiJdLFsieGZhLXRhYi1zdG9wcyIsIiJdLFsiZm9udC1zaXplIiwoZSx0KT0+bWVhc3VyZVRvU3RyaW5nKC45OSooZT10LmZvbnRTaXplPU1hdGguYWJzKGdldE1lYXN1cmVtZW50KGUpKSkpXSxbImxldHRlci1zcGFjaW5nIixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbImxpbmUtaGVpZ2h0IixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbIm1hcmdpbiIsZT0+bWVhc3VyZVRvU3RyaW5nKGdldE1lYXN1cmVtZW50KGUpKV0sWyJtYXJnaW4tYm90dG9tIixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbIm1hcmdpbi1sZWZ0IixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbIm1hcmdpbi1yaWdodCIsZT0+bWVhc3VyZVRvU3RyaW5nKGdldE1lYXN1cmVtZW50KGUpKV0sWyJtYXJnaW4tdG9wIixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbInRleHQtaW5kZW50IixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbImZvbnQtZmFtaWx5IixlPT5lXSxbInZlcnRpY2FsLWFsaWduIixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXV0pLEdvPS9ccysvZyxWbz0vW1xyXG5dKy9nLEtvPS9cclxuPy9nO2Z1bmN0aW9uIG1hcFN0eWxlKGUsdCxhKXtjb25zdCByPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoIWUpcmV0dXJuIHI7Y29uc3QgaT1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdFt0LGFdb2YgZS5zcGxpdCgiOyIpLm1hcCgoZT0+ZS5zcGxpdCgiOiIsMikpKSl7Y29uc3QgZT0kby5nZXQodCk7aWYoIiI9PT1lKWNvbnRpbnVlO2xldCBuPWE7ZSYmKG49InN0cmluZyI9PXR5cGVvZiBlP2U6ZShhLGkpKTt0LmVuZHNXaXRoKCJzY2FsZSIpP3IudHJhbnNmb3JtPXIudHJhbnNmb3JtP2Ake3JbdF19ICR7bn1gOm46clt0LnJlcGxhY2VBbGwoLy0oW2EtekEtWl0pL2csKChlLHQpPT50LnRvVXBwZXJDYXNlKCkpKV09bn1yLmZvbnRGYW1pbHkmJnNldEZvbnRGYW1pbHkoe3R5cGVmYWNlOnIuZm9udEZhbWlseSx3ZWlnaHQ6ci5mb250V2VpZ2h0fHwibm9ybWFsIixwb3N0dXJlOnIuZm9udFN0eWxlfHwibm9ybWFsIixzaXplOmkuZm9udFNpemV8fDB9LHQsdFtoc10uZm9udEZpbmRlcixyKTtpZihhJiZyLnZlcnRpY2FsQWxpZ24mJiIwcHgiIT09ci52ZXJ0aWNhbEFsaWduJiZyLmZvbnRTaXplKXtjb25zdCBlPS41ODMsdD0uMzMzLGE9Z2V0TWVhc3VyZW1lbnQoci5mb250U2l6ZSk7ci5mb250U2l6ZT1tZWFzdXJlVG9TdHJpbmcoYSplKTtyLnZlcnRpY2FsQWxpZ249bWVhc3VyZVRvU3RyaW5nKE1hdGguc2lnbihnZXRNZWFzdXJlbWVudChyLnZlcnRpY2FsQWxpZ24pKSphKnQpfWEmJnIuZm9udFNpemUmJihyLmZvbnRTaXplPWBjYWxjKCR7ci5mb250U2l6ZX0gKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWApO2ZpeFRleHRJbmRlbnQocik7cmV0dXJuIHJ9Y29uc3QgSm89bmV3IFNldChbImJvZHkiLCJodG1sIl0pO2NsYXNzIFhodG1sT2JqZWN0IGV4dGVuZHMgWG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoSG8sdCk7dGhpc1tXb109ITE7dGhpcy5zdHlsZT1lLnN0eWxlfHwiIn1bam5dKGUpe3N1cGVyW2puXShlKTt0aGlzLnN0eWxlPWZ1bmN0aW9uIGNoZWNrU3R5bGUoZSl7cmV0dXJuIGUuc3R5bGU/ZS5zdHlsZS5zcGxpdCgiOyIpLmZpbHRlcigoZT0+ISFlLnRyaW0oKSkpLm1hcCgoZT0+ZS5zcGxpdCgiOiIsMikubWFwKChlPT5lLnRyaW0oKSkpKSkuZmlsdGVyKCgoW3QsYV0pPT57ImZvbnQtZmFtaWx5Ij09PXQmJmVbaHNdLnVzZWRUeXBlZmFjZXMuYWRkKGEpO3JldHVybiB6by5oYXModCl9KSkubWFwKChlPT5lLmpvaW4oIjoiKSkpLmpvaW4oIjsiKToiIn0odGhpcyl9W05uXSgpe3JldHVybiFKby5oYXModGhpc1tGc10pfVtNc10oZSx0PSExKXtpZih0KXRoaXNbV29dPSEwO2Vsc2V7ZT1lLnJlcGxhY2VBbGwoVm8sIiIpO3RoaXMuc3R5bGUuaW5jbHVkZXMoInhmYS1zcGFjZXJ1bjp5ZXMiKXx8KGU9ZS5yZXBsYWNlQWxsKEdvLCIgIikpfWUmJih0aGlzW0huXSs9ZSl9W0RzXShlLHQ9ITApe2NvbnN0IGE9T2JqZWN0LmNyZWF0ZShudWxsKSxyPXt0b3A6TmFOLGJvdHRvbTpOYU4sbGVmdDpOYU4scmlnaHQ6TmFOfTtsZXQgaT1udWxsO2Zvcihjb25zdFtlLHRdb2YgdGhpcy5zdHlsZS5zcGxpdCgiOyIpLm1hcCgoZT0+ZS5zcGxpdCgiOiIsMikpKSlzd2l0Y2goZSl7Y2FzZSJmb250LWZhbWlseSI6YS50eXBlZmFjZT1zdHJpcFF1b3Rlcyh0KTticmVhaztjYXNlImZvbnQtc2l6ZSI6YS5zaXplPWdldE1lYXN1cmVtZW50KHQpO2JyZWFrO2Nhc2UiZm9udC13ZWlnaHQiOmEud2VpZ2h0PXQ7YnJlYWs7Y2FzZSJmb250LXN0eWxlIjphLnBvc3R1cmU9dDticmVhaztjYXNlImxldHRlci1zcGFjaW5nIjphLmxldHRlclNwYWNpbmc9Z2V0TWVhc3VyZW1lbnQodCk7YnJlYWs7Y2FzZSJtYXJnaW4iOmNvbnN0IGU9dC5zcGxpdCgvIFx0LykubWFwKChlPT5nZXRNZWFzdXJlbWVudChlKSkpO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAxOnIudG9wPXIuYm90dG9tPXIubGVmdD1yLnJpZ2h0PWVbMF07YnJlYWs7Y2FzZSAyOnIudG9wPXIuYm90dG9tPWVbMF07ci5sZWZ0PXIucmlnaHQ9ZVsxXTticmVhaztjYXNlIDM6ci50b3A9ZVswXTtyLmJvdHRvbT1lWzJdO3IubGVmdD1yLnJpZ2h0PWVbMV07YnJlYWs7Y2FzZSA0OnIudG9wPWVbMF07ci5sZWZ0PWVbMV07ci5ib3R0b209ZVsyXTtyLnJpZ2h0PWVbM119YnJlYWs7Y2FzZSJtYXJnaW4tdG9wIjpyLnRvcD1nZXRNZWFzdXJlbWVudCh0KTticmVhaztjYXNlIm1hcmdpbi1ib3R0b20iOnIuYm90dG9tPWdldE1lYXN1cmVtZW50KHQpO2JyZWFrO2Nhc2UibWFyZ2luLWxlZnQiOnIubGVmdD1nZXRNZWFzdXJlbWVudCh0KTticmVhaztjYXNlIm1hcmdpbi1yaWdodCI6ci5yaWdodD1nZXRNZWFzdXJlbWVudCh0KTticmVhaztjYXNlImxpbmUtaGVpZ2h0IjppPWdldE1lYXN1cmVtZW50KHQpfWUucHVzaERhdGEoYSxyLGkpO2lmKHRoaXNbSG5dKWUuYWRkU3RyaW5nKHRoaXNbSG5dKTtlbHNlIGZvcihjb25zdCB0IG9mIHRoaXNbaXNdKCkpIiN0ZXh0IiE9PXRbRnNdP3RbRHNdKGUpOmUuYWRkU3RyaW5nKHRbSG5dKTt0JiZlLnBvcEZvbnQoKX1benNdKGUpe2NvbnN0IHQ9W107dGhpc1skbl09e2NoaWxkcmVuOnR9O3RoaXNbTG5dKHt9KTtpZigwPT09dC5sZW5ndGgmJiF0aGlzW0huXSlyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWTtsZXQgYTthPXRoaXNbV29dP3RoaXNbSG5dP3RoaXNbSG5dLnJlcGxhY2VBbGwoS28sIlxuIik6dm9pZCAwOnRoaXNbSG5dfHx2b2lkIDA7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZTp0aGlzW0ZzXSxhdHRyaWJ1dGVzOntocmVmOnRoaXMuaHJlZixzdHlsZTptYXBTdHlsZSh0aGlzLnN0eWxlLHRoaXMsdGhpc1tXb10pfSxjaGlsZHJlbjp0LHZhbHVlOmF9KX19Y2xhc3MgQSBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImEiKTt0aGlzLmhyZWY9Zml4VVJMKGUuaHJlZil8fCIifX1jbGFzcyBCIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiYiIpfVtEc10oZSl7ZS5wdXNoRm9udCh7d2VpZ2h0OiJib2xkIn0pO3N1cGVyW0RzXShlKTtlLnBvcEZvbnQoKX19Y2xhc3MgQm9keSBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImJvZHkiKX1benNdKGUpe2NvbnN0IHQ9c3VwZXJbenNdKGUpLHtodG1sOmF9PXQ7aWYoIWEpcmV0dXJuIEhUTUxSZXN1bHQuRU1QVFk7YS5uYW1lPSJkaXYiO2EuYXR0cmlidXRlcy5jbGFzcz1bInhmYVJpY2giXTtyZXR1cm4gdH19Y2xhc3MgQnIgZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJiciIpfVtIc10oKXtyZXR1cm4iXG4ifVtEc10oZSl7ZS5hZGRTdHJpbmcoIlxuIil9W3pzXShlKXtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJiciJ9KX19Y2xhc3MgSHRtbCBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImh0bWwiKX1benNdKGUpe2NvbnN0IHQ9W107dGhpc1skbl09e2NoaWxkcmVuOnR9O3RoaXNbTG5dKHt9KTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixhdHRyaWJ1dGVzOntjbGFzczpbInhmYVJpY2giXSxzdHlsZTp7fX0sdmFsdWU6dGhpc1tIbl18fCIifSk7aWYoMT09PXQubGVuZ3RoKXtjb25zdCBlPXRbMF07aWYoZS5hdHRyaWJ1dGVzPy5jbGFzcy5pbmNsdWRlcygieGZhUmljaCIpKXJldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3MoZSl9cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixhdHRyaWJ1dGVzOntjbGFzczpbInhmYVJpY2giXSxzdHlsZTp7fX0sY2hpbGRyZW46dH0pfX1jbGFzcyBJIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiaSIpfVtEc10oZSl7ZS5wdXNoRm9udCh7cG9zdHVyZToiaXRhbGljIn0pO3N1cGVyW0RzXShlKTtlLnBvcEZvbnQoKX19Y2xhc3MgTGkgZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJsaSIpfX1jbGFzcyBPbCBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIm9sIil9fWNsYXNzIFAgZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJwIil9W0RzXShlKXtzdXBlcltEc10oZSwhMSk7ZS5hZGRTdHJpbmcoIlxuIik7ZS5hZGRQYXJhKCk7ZS5wb3BGb250KCl9W0hzXSgpe3JldHVybiB0aGlzW2NzXSgpW2lzXSgpLmF0KC0xKT09PXRoaXM/c3VwZXJbSHNdKCk6c3VwZXJbSHNdKCkrIlxuIn19Y2xhc3MgU3BhbiBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsInNwYW4iKX19Y2xhc3MgU3ViIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwic3ViIil9fWNsYXNzIFN1cCBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsInN1cCIpfX1jbGFzcyBVbCBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsInVsIil9fWNsYXNzIFhodG1sTmFtZXNwYWNle3N0YXRpY1tLc10oZSx0KXtpZihYaHRtbE5hbWVzcGFjZS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gWGh0bWxOYW1lc3BhY2VbZV0odCl9c3RhdGljIGEoZSl7cmV0dXJuIG5ldyBBKGUpfXN0YXRpYyBiKGUpe3JldHVybiBuZXcgQihlKX1zdGF0aWMgYm9keShlKXtyZXR1cm4gbmV3IEJvZHkoZSl9c3RhdGljIGJyKGUpe3JldHVybiBuZXcgQnIoZSl9c3RhdGljIGh0bWwoZSl7cmV0dXJuIG5ldyBIdG1sKGUpfXN0YXRpYyBpKGUpe3JldHVybiBuZXcgSShlKX1zdGF0aWMgbGkoZSl7cmV0dXJuIG5ldyBMaShlKX1zdGF0aWMgb2woZSl7cmV0dXJuIG5ldyBPbChlKX1zdGF0aWMgcChlKXtyZXR1cm4gbmV3IFAoZSl9c3RhdGljIHNwYW4oZSl7cmV0dXJuIG5ldyBTcGFuKGUpfXN0YXRpYyBzdWIoZSl7cmV0dXJuIG5ldyBTdWIoZSl9c3RhdGljIHN1cChlKXtyZXR1cm4gbmV3IFN1cChlKX1zdGF0aWMgdWwoZSl7cmV0dXJuIG5ldyBVbChlKX19Y29uc3QgWW89e2NvbmZpZzpDb25maWdOYW1lc3BhY2UsY29ubmVjdGlvbjpDb25uZWN0aW9uU2V0TmFtZXNwYWNlLGRhdGFzZXRzOkRhdGFzZXRzTmFtZXNwYWNlLGxvY2FsZVNldDpMb2NhbGVTZXROYW1lc3BhY2Usc2lnbmF0dXJlOlNpZ25hdHVyZU5hbWVzcGFjZSxzdHlsZXNoZWV0OlN0eWxlc2hlZXROYW1lc3BhY2UsdGVtcGxhdGU6VGVtcGxhdGVOYW1lc3BhY2UseGRwOlhkcE5hbWVzcGFjZSx4aHRtbDpYaHRtbE5hbWVzcGFjZX07Y2xhc3MgVW5rbm93bk5hbWVzcGFjZXtjb25zdHJ1Y3RvcihlKXt0aGlzLm5hbWVzcGFjZUlkPWV9W0tzXShlLHQpe3JldHVybiBuZXcgWG1sT2JqZWN0KHRoaXMubmFtZXNwYWNlSWQsZSx0KX19Y2xhc3MgUm9vdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcigtMSwicm9vdCIsT2JqZWN0LmNyZWF0ZShudWxsKSk7dGhpcy5lbGVtZW50PW51bGw7dGhpc1tkc109ZX1bVHNdKGUpe3RoaXMuZWxlbWVudD1lO3JldHVybiEwfVtHbl0oKXtzdXBlcltHbl0oKTtpZih0aGlzLmVsZW1lbnQudGVtcGxhdGUgaW5zdGFuY2VvZiBUZW1wbGF0ZSl7dGhpc1tkc10uc2V0KEVzLHRoaXMuZWxlbWVudCk7dGhpcy5lbGVtZW50LnRlbXBsYXRlW0xzXSh0aGlzW2RzXSk7dGhpcy5lbGVtZW50LnRlbXBsYXRlW2RzXT10aGlzW2RzXX19fWNsYXNzIEVtcHR5IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKCl7c3VwZXIoLTEsIiIsT2JqZWN0LmNyZWF0ZShudWxsKSl9W1RzXShlKXtyZXR1cm4hMX19Y2xhc3MgQnVpbGRlcntjb25zdHJ1Y3RvcihlPW51bGwpe3RoaXMuX25hbWVzcGFjZVN0YWNrPVtdO3RoaXMuX25zQWdub3N0aWNMZXZlbD0wO3RoaXMuX25hbWVzcGFjZVByZWZpeGVzPW5ldyBNYXA7dGhpcy5fbmFtZXNwYWNlcz1uZXcgTWFwO3RoaXMuX25leHROc0lkPU1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMoSnMpLm1hcCgoKHtpZDplfSk9PmUpKSk7dGhpcy5fY3VycmVudE5hbWVzcGFjZT1lfHxuZXcgVW5rbm93bk5hbWVzcGFjZSgrK3RoaXMuX25leHROc0lkKX1idWlsZFJvb3QoZSl7cmV0dXJuIG5ldyBSb290KGUpfWJ1aWxkKHtuc1ByZWZpeDplLG5hbWU6dCxhdHRyaWJ1dGVzOmEsbmFtZXNwYWNlOnIscHJlZml4ZXM6aX0pe2NvbnN0IG49bnVsbCE9PXI7aWYobil7dGhpcy5fbmFtZXNwYWNlU3RhY2sucHVzaCh0aGlzLl9jdXJyZW50TmFtZXNwYWNlKTt0aGlzLl9jdXJyZW50TmFtZXNwYWNlPXRoaXMuX3NlYXJjaE5hbWVzcGFjZShyKX1pJiZ0aGlzLl9hZGROYW1lc3BhY2VQcmVmaXgoaSk7aWYoYS5oYXNPd25Qcm9wZXJ0eShJcykpe2NvbnN0IGU9WW8uZGF0YXNldHMsdD1hW0lzXTtsZXQgcj1udWxsO2Zvcihjb25zdFthLGldb2YgT2JqZWN0LmVudHJpZXModCkpe2lmKHRoaXMuX2dldE5hbWVzcGFjZVRvVXNlKGEpPT09ZSl7cj17eGZhOml9O2JyZWFrfX1yP2FbSXNdPXI6ZGVsZXRlIGFbSXNdfWNvbnN0IHM9dGhpcy5fZ2V0TmFtZXNwYWNlVG9Vc2UoZSksbz1zPy5bS3NdKHQsYSl8fG5ldyBFbXB0eTtvW3dzXSgpJiZ0aGlzLl9uc0Fnbm9zdGljTGV2ZWwrKzsobnx8aXx8b1t3c10oKSkmJihvW1VuXT17aGFzTmFtZXNwYWNlOm4scHJlZml4ZXM6aSxuc0Fnbm9zdGljOm9bd3NdKCl9KTtyZXR1cm4gb31pc05zQWdub3N0aWMoKXtyZXR1cm4gdGhpcy5fbnNBZ25vc3RpY0xldmVsPjB9X3NlYXJjaE5hbWVzcGFjZShlKXtsZXQgdD10aGlzLl9uYW1lc3BhY2VzLmdldChlKTtpZih0KXJldHVybiB0O2Zvcihjb25zdFthLHtjaGVjazpyfV1vZiBPYmplY3QuZW50cmllcyhKcykpaWYocihlKSl7dD1Zb1thXTtpZih0KXt0aGlzLl9uYW1lc3BhY2VzLnNldChlLHQpO3JldHVybiB0fWJyZWFrfXQ9bmV3IFVua25vd25OYW1lc3BhY2UoKyt0aGlzLl9uZXh0TnNJZCk7dGhpcy5fbmFtZXNwYWNlcy5zZXQoZSx0KTtyZXR1cm4gdH1fYWRkTmFtZXNwYWNlUHJlZml4KGUpe2Zvcihjb25zdHtwcmVmaXg6dCx2YWx1ZTphfW9mIGUpe2NvbnN0IGU9dGhpcy5fc2VhcmNoTmFtZXNwYWNlKGEpO2xldCByPXRoaXMuX25hbWVzcGFjZVByZWZpeGVzLmdldCh0KTtpZighcil7cj1bXTt0aGlzLl9uYW1lc3BhY2VQcmVmaXhlcy5zZXQodCxyKX1yLnB1c2goZSl9fV9nZXROYW1lc3BhY2VUb1VzZShlKXtpZighZSlyZXR1cm4gdGhpcy5fY3VycmVudE5hbWVzcGFjZTtjb25zdCB0PXRoaXMuX25hbWVzcGFjZVByZWZpeGVzLmdldChlKTtpZih0Py5sZW5ndGg+MClyZXR1cm4gdC5hdCgtMSk7d2FybihgVW5rbm93biBuYW1lc3BhY2UgcHJlZml4OiAke2V9LmApO3JldHVybiBudWxsfWNsZWFuKGUpe2NvbnN0e2hhc05hbWVzcGFjZTp0LHByZWZpeGVzOmEsbnNBZ25vc3RpYzpyfT1lO3QmJih0aGlzLl9jdXJyZW50TmFtZXNwYWNlPXRoaXMuX25hbWVzcGFjZVN0YWNrLnBvcCgpKTthJiZhLmZvckVhY2goKCh7cHJlZml4OmV9KT0+e3RoaXMuX25hbWVzcGFjZVByZWZpeGVzLmdldChlKS5wb3AoKX0pKTtyJiZ0aGlzLl9uc0Fnbm9zdGljTGV2ZWwtLX19Y2xhc3MgWEZBUGFyc2VyIGV4dGVuZHMgWE1MUGFyc2VyQmFzZXtjb25zdHJ1Y3RvcihlPW51bGwsdD0hMSl7c3VwZXIoKTt0aGlzLl9idWlsZGVyPW5ldyBCdWlsZGVyKGUpO3RoaXMuX3N0YWNrPVtdO3RoaXMuX2dsb2JhbERhdGE9e3VzZWRUeXBlZmFjZXM6bmV3IFNldH07dGhpcy5faWRzPW5ldyBNYXA7dGhpcy5fY3VycmVudD10aGlzLl9idWlsZGVyLmJ1aWxkUm9vdCh0aGlzLl9pZHMpO3RoaXMuX2Vycm9yQ29kZT1Tbjt0aGlzLl93aGl0ZVJlZ2V4PS9eXHMrJC87dGhpcy5fbmJzcHM9L1x4YTArL2c7dGhpcy5fcmljaFRleHQ9dH1wYXJzZShlKXt0aGlzLnBhcnNlWG1sKGUpO2lmKHRoaXMuX2Vycm9yQ29kZT09PVNuKXt0aGlzLl9jdXJyZW50W0duXSgpO3JldHVybiB0aGlzLl9jdXJyZW50LmVsZW1lbnR9fW9uVGV4dChlKXtlPWUucmVwbGFjZSh0aGlzLl9uYnNwcywoZT0+ZS5zbGljZSgxKSsiICIpKTt0aGlzLl9yaWNoVGV4dHx8dGhpcy5fY3VycmVudFtObl0oKT90aGlzLl9jdXJyZW50W01zXShlLHRoaXMuX3JpY2hUZXh0KTp0aGlzLl93aGl0ZVJlZ2V4LnRlc3QoZSl8fHRoaXMuX2N1cnJlbnRbTXNdKGUudHJpbSgpKX1vbkNkYXRhKGUpe3RoaXMuX2N1cnJlbnRbTXNdKGUpfV9ta0F0dHJpYnV0ZXMoZSx0KXtsZXQgYT1udWxsLHI9bnVsbDtjb25zdCBpPU9iamVjdC5jcmVhdGUoe30pO2Zvcihjb25zdHtuYW1lOm4sdmFsdWU6c31vZiBlKWlmKCJ4bWxucyI9PT1uKWE/d2FybihgWEZBIC0gbXVsdGlwbGUgbmFtZXNwYWNlIGRlZmluaXRpb24gaW4gPCR7dH0+YCk6YT1zO2Vsc2UgaWYobi5zdGFydHNXaXRoKCJ4bWxuczoiKSl7Y29uc3QgZT1uLnN1YnN0cmluZyg2KTtyPz89W107ci5wdXNoKHtwcmVmaXg6ZSx2YWx1ZTpzfSl9ZWxzZXtjb25zdCBlPW4uaW5kZXhPZigiOiIpO2lmKC0xPT09ZSlpW25dPXM7ZWxzZXtjb25zdCB0PWlbSXNdPz89T2JqZWN0LmNyZWF0ZShudWxsKSxbYSxyXT1bbi5zbGljZSgwLGUpLG4uc2xpY2UoZSsxKV07KHRbYV18fD1PYmplY3QuY3JlYXRlKG51bGwpKVtyXT1zfX1yZXR1cm5bYSxyLGldfV9nZXROYW1lQW5kUHJlZml4KGUsdCl7Y29uc3QgYT1lLmluZGV4T2YoIjoiKTtyZXR1cm4tMT09PWE/W2UsbnVsbF06W2Uuc3Vic3RyaW5nKGErMSksdD8iIjplLnN1YnN0cmluZygwLGEpXX1vbkJlZ2luRWxlbWVudChlLHQsYSl7Y29uc3RbcixpLG5dPXRoaXMuX21rQXR0cmlidXRlcyh0LGUpLFtzLG9dPXRoaXMuX2dldE5hbWVBbmRQcmVmaXgoZSx0aGlzLl9idWlsZGVyLmlzTnNBZ25vc3RpYygpKSxjPXRoaXMuX2J1aWxkZXIuYnVpbGQoe25zUHJlZml4Om8sbmFtZTpzLGF0dHJpYnV0ZXM6bixuYW1lc3BhY2U6cixwcmVmaXhlczppfSk7Y1toc109dGhpcy5fZ2xvYmFsRGF0YTtpZihhKXtjW0duXSgpO3RoaXMuX2N1cnJlbnRbVHNdKGMpJiZjW19zXSh0aGlzLl9pZHMpO2Nbam5dKHRoaXMuX2J1aWxkZXIpfWVsc2V7dGhpcy5fc3RhY2sucHVzaCh0aGlzLl9jdXJyZW50KTt0aGlzLl9jdXJyZW50PWN9fW9uRW5kRWxlbWVudChlKXtjb25zdCB0PXRoaXMuX2N1cnJlbnQ7aWYodFtwc10oKSYmInN0cmluZyI9PXR5cGVvZiB0W0huXSl7Y29uc3QgZT1uZXcgWEZBUGFyc2VyO2UuX2dsb2JhbERhdGE9dGhpcy5fZ2xvYmFsRGF0YTtjb25zdCBhPWUucGFyc2UodFtIbl0pO3RbSG5dPW51bGw7dFtUc10oYSl9dFtHbl0oKTt0aGlzLl9jdXJyZW50PXRoaXMuX3N0YWNrLnBvcCgpO3RoaXMuX2N1cnJlbnRbVHNdKHQpJiZ0W19zXSh0aGlzLl9pZHMpO3Rbam5dKHRoaXMuX2J1aWxkZXIpfW9uRXJyb3IoZSl7dGhpcy5fZXJyb3JDb2RlPWV9fWNsYXNzIFhGQUZhY3Rvcnl7Y29uc3RydWN0b3IoZSl7dHJ5e3RoaXMucm9vdD0obmV3IFhGQVBhcnNlcikucGFyc2UoWEZBRmFjdG9yeS5fY3JlYXRlRG9jdW1lbnQoZSkpO2NvbnN0IHQ9bmV3IEJpbmRlcih0aGlzLnJvb3QpO3RoaXMuZm9ybT10LmJpbmQoKTt0aGlzLmRhdGFIYW5kbGVyPW5ldyBEYXRhSGFuZGxlcih0aGlzLnJvb3QsdC5nZXREYXRhKCkpO3RoaXMuZm9ybVtoc10udGVtcGxhdGU9dGhpcy5mb3JtfWNhdGNoKGUpe3dhcm4oYFhGQSAtIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBwYXJzaW5nIGFuZCBiaW5kaW5nOiAke2V9YCl9fWlzVmFsaWQoKXtyZXR1cm4hKCF0aGlzLnJvb3R8fCF0aGlzLmZvcm0pfV9jcmVhdGVQYWdlc0hlbHBlcigpe2NvbnN0IGU9dGhpcy5mb3JtW1dzXSgpO3JldHVybiBuZXcgUHJvbWlzZSgoKHQsYSk9Pntjb25zdCBuZXh0SXRlcmF0aW9uPSgpPT57dHJ5e2NvbnN0IGE9ZS5uZXh0KCk7YS5kb25lP3QoYS52YWx1ZSk6c2V0VGltZW91dChuZXh0SXRlcmF0aW9uLDApfWNhdGNoKGUpe2EoZSl9fTtzZXRUaW1lb3V0KG5leHRJdGVyYXRpb24sMCl9KSl9YXN5bmMgX2NyZWF0ZVBhZ2VzKCl7dHJ5e3RoaXMucGFnZXM9YXdhaXQgdGhpcy5fY3JlYXRlUGFnZXNIZWxwZXIoKTt0aGlzLmRpbXM9dGhpcy5wYWdlcy5jaGlsZHJlbi5tYXAoKGU9Pntjb25zdHt3aWR0aDp0LGhlaWdodDphfT1lLmF0dHJpYnV0ZXMuc3R5bGU7cmV0dXJuWzAsMCxwYXJzZUludCh0KSxwYXJzZUludChhKV19KSl9Y2F0Y2goZSl7d2FybihgWEZBIC0gYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGxheW91dDogJHtlfWApfX1nZXRCb3VuZGluZ0JveChlKXtyZXR1cm4gdGhpcy5kaW1zW2VdfWFzeW5jIGdldE51bVBhZ2VzKCl7dGhpcy5wYWdlc3x8YXdhaXQgdGhpcy5fY3JlYXRlUGFnZXMoKTtyZXR1cm4gdGhpcy5kaW1zLmxlbmd0aH1zZXRJbWFnZXMoZSl7dGhpcy5mb3JtW2hzXS5pbWFnZXM9ZX1zZXRGb250cyhlKXt0aGlzLmZvcm1baHNdLmZvbnRGaW5kZXI9bmV3IEZvbnRGaW5kZXIoZSk7Y29uc3QgdD1bXTtmb3IobGV0IGUgb2YgdGhpcy5mb3JtW2hzXS51c2VkVHlwZWZhY2VzKXtlPXN0cmlwUXVvdGVzKGUpO3RoaXMuZm9ybVtoc10uZm9udEZpbmRlci5maW5kKGUpfHx0LnB1c2goZSl9cmV0dXJuIHQubGVuZ3RoPjA/dDpudWxsfWFwcGVuZEZvbnRzKGUsdCl7dGhpcy5mb3JtW2hzXS5mb250RmluZGVyLmFkZChlLHQpfWFzeW5jIGdldFBhZ2VzKCl7dGhpcy5wYWdlc3x8YXdhaXQgdGhpcy5fY3JlYXRlUGFnZXMoKTtjb25zdCBlPXRoaXMucGFnZXM7dGhpcy5wYWdlcz1udWxsO3JldHVybiBlfXNlcmlhbGl6ZURhdGEoZSl7cmV0dXJuIHRoaXMuZGF0YUhhbmRsZXIuc2VyaWFsaXplKGUpfXN0YXRpYyBfY3JlYXRlRG9jdW1lbnQoZSl7cmV0dXJuIGVbIi94ZHA6eGRwIl0/T2JqZWN0LnZhbHVlcyhlKS5qb2luKCIiKTplWyJ4ZHA6eGRwIl19c3RhdGljIGdldFJpY2hUZXh0QXNIdG1sKGUpe2lmKCFlfHwic3RyaW5nIiE9dHlwZW9mIGUpcmV0dXJuIG51bGw7dHJ5e2xldCB0PW5ldyBYRkFQYXJzZXIoWGh0bWxOYW1lc3BhY2UsITApLnBhcnNlKGUpO2lmKCFbImJvZHkiLCJ4aHRtbCJdLmluY2x1ZGVzKHRbRnNdKSl7Y29uc3QgZT1YaHRtbE5hbWVzcGFjZS5ib2R5KHt9KTtlW1BuXSh0KTt0PWV9Y29uc3QgYT10W3pzXSgpO2lmKCFhLnN1Y2Nlc3MpcmV0dXJuIG51bGw7Y29uc3R7aHRtbDpyfT1hLHthdHRyaWJ1dGVzOml9PXI7aWYoaSl7aS5jbGFzcyYmKGkuY2xhc3M9aS5jbGFzcy5maWx0ZXIoKGU9PiFlLnN0YXJ0c1dpdGgoInhmYSIpKSkpO2kuZGlyPSJhdXRvIn1yZXR1cm57aHRtbDpyLHN0cjp0W0hzXSgpfX1jYXRjaChlKXt3YXJuKGBYRkEgLSBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgcGFyc2luZyBvZiByaWNoIHRleHQ6ICR7ZX1gKX1yZXR1cm4gbnVsbH19Y2xhc3MgQW5ub3RhdGlvbkZhY3Rvcnl7c3RhdGljIGNyZWF0ZUdsb2JhbHMoZSl7cmV0dXJuIFByb21pc2UuYWxsKFtlLmVuc3VyZUNhdGFsb2coImFjcm9Gb3JtIiksZS5lbnN1cmVEb2MoInhmYURhdGFzZXRzIiksZS5lbnN1cmVDYXRhbG9nKCJzdHJ1Y3RUcmVlUm9vdCIpLGUuZW5zdXJlQ2F0YWxvZygiYmFzZVVybCIpLGUuZW5zdXJlQ2F0YWxvZygiYXR0YWNobWVudHMiKSxlLmVuc3VyZUNhdGFsb2coImdsb2JhbENvbG9yU3BhY2VDYWNoZSIpXSkudGhlbigoKFt0LGEscixpLG4sc10pPT4oe3BkZk1hbmFnZXI6ZSxhY3JvRm9ybTp0IGluc3RhbmNlb2YgRGljdD90OkRpY3QuZW1wdHkseGZhRGF0YXNldHM6YSxzdHJ1Y3RUcmVlUm9vdDpyLGJhc2VVcmw6aSxhdHRhY2htZW50czpuLGdsb2JhbENvbG9yU3BhY2VDYWNoZTpzfSkpLChlPT57d2FybihgY3JlYXRlR2xvYmFsczogIiR7ZX0iLmApO3JldHVybiBudWxsfSkpfXN0YXRpYyBhc3luYyBjcmVhdGUoZSx0LGEscixpLG4scyxvKXtjb25zdCBjPWk/YXdhaXQgdGhpcy5fZ2V0UGFnZUluZGV4KGUsdCxhLnBkZk1hbmFnZXIpOm51bGw7cmV0dXJuIGEucGRmTWFuYWdlci5lbnN1cmUodGhpcywiX2NyZWF0ZSIsW2UsdCxhLHIsaSxuLHMsYyxvXSl9c3RhdGljIF9jcmVhdGUoZSx0LGEscixpPSExLG49bnVsbCxzPW51bGwsbz1udWxsLGM9bnVsbCl7Y29uc3QgbD1lLmZldGNoSWZSZWYodCk7aWYoIShsIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuO2xldCBoPWwuZ2V0KCJTdWJ0eXBlIik7aD1oIGluc3RhbmNlb2YgTmFtZT9oLm5hbWU6bnVsbDtpZihzJiYhcy5oYXMoRltoLnRvVXBwZXJDYXNlKCldKSlyZXR1cm4gbnVsbDtjb25zdHthY3JvRm9ybTp1LHBkZk1hbmFnZXI6ZH09YSxmPXQgaW5zdGFuY2VvZiBSZWY/dC50b1N0cmluZygpOmBhbm5vdF8ke3IuY3JlYXRlT2JqSWQoKX1gLGc9e3hyZWY6ZSxyZWY6dCxkaWN0Omwsc3VidHlwZTpoLGlkOmYsYW5ub3RhdGlvbkdsb2JhbHM6YSxjb2xsZWN0RmllbGRzOmksb3JwaGFuRmllbGRzOm4sbmVlZEFwcGVhcmFuY2VzOiFpJiYhMD09PXUuZ2V0KCJOZWVkQXBwZWFyYW5jZXMiKSxwYWdlSW5kZXg6byxldmFsdWF0b3JPcHRpb25zOmQuZXZhbHVhdG9yT3B0aW9ucyxwYWdlUmVmOmN9O3N3aXRjaChoKXtjYXNlIkxpbmsiOnJldHVybiBuZXcgTGlua0Fubm90YXRpb24oZyk7Y2FzZSJUZXh0IjpyZXR1cm4gbmV3IFRleHRBbm5vdGF0aW9uKGcpO2Nhc2UiV2lkZ2V0IjpsZXQgZT1nZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0Omwsa2V5OiJGVCJ9KTtlPWUgaW5zdGFuY2VvZiBOYW1lP2UubmFtZTpudWxsO3N3aXRjaChlKXtjYXNlIlR4IjpyZXR1cm4gbmV3IFRleHRXaWRnZXRBbm5vdGF0aW9uKGcpO2Nhc2UiQnRuIjpyZXR1cm4gbmV3IEJ1dHRvbldpZGdldEFubm90YXRpb24oZyk7Y2FzZSJDaCI6cmV0dXJuIG5ldyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uKGcpO2Nhc2UiU2lnIjpyZXR1cm4gbmV3IFNpZ25hdHVyZVdpZGdldEFubm90YXRpb24oZyl9d2FybihgVW5pbXBsZW1lbnRlZCB3aWRnZXQgZmllbGQgdHlwZSAiJHtlfSIsIGZhbGxpbmcgYmFjayB0byBiYXNlIGZpZWxkIHR5cGUuYCk7cmV0dXJuIG5ldyBXaWRnZXRBbm5vdGF0aW9uKGcpO2Nhc2UiUG9wdXAiOnJldHVybiBuZXcgUG9wdXBBbm5vdGF0aW9uKGcpO2Nhc2UiRnJlZVRleHQiOnJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uKGcpO2Nhc2UiTGluZSI6cmV0dXJuIG5ldyBMaW5lQW5ub3RhdGlvbihnKTtjYXNlIlNxdWFyZSI6cmV0dXJuIG5ldyBTcXVhcmVBbm5vdGF0aW9uKGcpO2Nhc2UiQ2lyY2xlIjpyZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb24oZyk7Y2FzZSJQb2x5TGluZSI6cmV0dXJuIG5ldyBQb2x5bGluZUFubm90YXRpb24oZyk7Y2FzZSJQb2x5Z29uIjpyZXR1cm4gbmV3IFBvbHlnb25Bbm5vdGF0aW9uKGcpO2Nhc2UiQ2FyZXQiOnJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uKGcpO2Nhc2UiSW5rIjpyZXR1cm4gbmV3IElua0Fubm90YXRpb24oZyk7Y2FzZSJIaWdobGlnaHQiOnJldHVybiBuZXcgSGlnaGxpZ2h0QW5ub3RhdGlvbihnKTtjYXNlIlVuZGVybGluZSI6cmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uKGcpO2Nhc2UiU3F1aWdnbHkiOnJldHVybiBuZXcgU3F1aWdnbHlBbm5vdGF0aW9uKGcpO2Nhc2UiU3RyaWtlT3V0IjpyZXR1cm4gbmV3IFN0cmlrZU91dEFubm90YXRpb24oZyk7Y2FzZSJTdGFtcCI6cmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb24oZyk7Y2FzZSJGaWxlQXR0YWNobWVudCI6cmV0dXJuIG5ldyBGaWxlQXR0YWNobWVudEFubm90YXRpb24oZyk7ZGVmYXVsdDppfHx3YXJuKGg/YFVuaW1wbGVtZW50ZWQgYW5ub3RhdGlvbiB0eXBlICIke2h9IiwgZmFsbGluZyBiYWNrIHRvIGJhc2UgYW5ub3RhdGlvbi5gOiJBbm5vdGF0aW9uIGlzIG1pc3NpbmcgdGhlIHJlcXVpcmVkIC9TdWJ0eXBlLiIpO3JldHVybiBuZXcgQW5ub3RhdGlvbihnKX19c3RhdGljIGFzeW5jIF9nZXRQYWdlSW5kZXgoZSx0LGEpe3RyeXtjb25zdCByPWF3YWl0IGUuZmV0Y2hJZlJlZkFzeW5jKHQpO2lmKCEociBpbnN0YW5jZW9mIERpY3QpKXJldHVybi0xO2NvbnN0IGk9ci5nZXRSYXcoIlAiKTtpZihpIGluc3RhbmNlb2YgUmVmKXRyeXtyZXR1cm4gYXdhaXQgYS5lbnN1cmVDYXRhbG9nKCJnZXRQYWdlSW5kZXgiLFtpXSl9Y2F0Y2goZSl7aW5mbyhgX2dldFBhZ2VJbmRleCAtLSBub3QgYSB2YWxpZCBwYWdlIHJlZmVyZW5jZTogIiR7ZX0iLmApfWlmKHIuaGFzKCJLaWRzIikpcmV0dXJuLTE7Y29uc3Qgbj1hd2FpdCBhLmVuc3VyZURvYygibnVtUGFnZXMiKTtmb3IobGV0IGU9MDtlPG47ZSsrKXtjb25zdCByPWF3YWl0IGEuZ2V0UGFnZShlKSxpPWF3YWl0IGEuZW5zdXJlKHIsImFubm90YXRpb25zIik7Zm9yKGNvbnN0IGEgb2YgaSlpZihhIGluc3RhbmNlb2YgUmVmJiZpc1JlZnNFcXVhbChhLHQpKXJldHVybiBlfX1jYXRjaChlKXt3YXJuKGBfZ2V0UGFnZUluZGV4OiAiJHtlfSIuYCl9cmV0dXJuLTF9c3RhdGljIGdlbmVyYXRlSW1hZ2VzKGUsdCxhKXtpZighYSl7d2FybigiZ2VuZXJhdGVJbWFnZXM6IE9mZnNjcmVlbkNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkLCBjYW5ub3Qgc2F2ZSBvciBwcmludCBzb21lIGFubm90YXRpb25zIHdpdGggaW1hZ2VzLiIpO3JldHVybiBudWxsfWxldCByO2Zvcihjb25zdHtiaXRtYXBJZDphLGJpdG1hcDppfW9mIGUpaWYoaSl7cnx8PW5ldyBNYXA7ci5zZXQoYSxTdGFtcEFubm90YXRpb24uY3JlYXRlSW1hZ2UoaSx0KSl9cmV0dXJuIHJ9c3RhdGljIGFzeW5jIHNhdmVOZXdBbm5vdGF0aW9ucyhlLHQsYSxyLGkpe2NvbnN0IG49ZS54cmVmO2xldCBzO2NvbnN0IG89W10se2lzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkOmN9PWUub3B0aW9ucztmb3IoY29uc3QgbCBvZiBhKWlmKCFsLmRlbGV0ZWQpc3dpdGNoKGwuYW5ub3RhdGlvblR5cGUpe2Nhc2UgZzppZighcyl7Y29uc3QgZT1uZXcgRGljdChuKTtlLnNldElmTmFtZSgiQmFzZUZvbnQiLCJIZWx2ZXRpY2EiKTtlLnNldElmTmFtZSgiVHlwZSIsIkZvbnQiKTtlLnNldElmTmFtZSgiU3VidHlwZSIsIlR5cGUxIik7ZS5zZXRJZk5hbWUoIkVuY29kaW5nIiwiV2luQW5zaUVuY29kaW5nIik7cz1uLmdldE5ld1RlbXBvcmFyeVJlZigpO2kucHV0KHMse2RhdGE6ZX0pfW8ucHVzaChGcmVlVGV4dEFubm90YXRpb24uY3JlYXRlTmV3QW5ub3RhdGlvbihuLGwsaSx7ZXZhbHVhdG9yOmUsdGFzazp0LGJhc2VGb250UmVmOnN9KSk7YnJlYWs7Y2FzZSBwOmwucXVhZFBvaW50cz9vLnB1c2goSGlnaGxpZ2h0QW5ub3RhdGlvbi5jcmVhdGVOZXdBbm5vdGF0aW9uKG4sbCxpKSk6by5wdXNoKElua0Fubm90YXRpb24uY3JlYXRlTmV3QW5ub3RhdGlvbihuLGwsaSkpO2JyZWFrO2Nhc2UgYjpvLnB1c2goSW5rQW5ub3RhdGlvbi5jcmVhdGVOZXdBbm5vdGF0aW9uKG4sbCxpKSk7YnJlYWs7Y2FzZSBtOmNvbnN0IGE9Yz9hd2FpdChyPy5nZXQobC5iaXRtYXBJZCkpOm51bGw7aWYoYT8uaW1hZ2VTdHJlYW0pe2NvbnN0e2ltYWdlU3RyZWFtOmUsc21hc2tTdHJlYW06dH09YTtpZih0KXtjb25zdCBhPW4uZ2V0TmV3VGVtcG9yYXJ5UmVmKCk7aS5wdXQoYSx7ZGF0YTp0fSk7ZS5kaWN0LnNldCgiU01hc2siLGEpfWNvbnN0IHI9YS5pbWFnZVJlZj1uLmdldE5ld1RlbXBvcmFyeVJlZigpO2kucHV0KHIse2RhdGE6ZX0pO2EuaW1hZ2VTdHJlYW09YS5zbWFza1N0cmVhbT1udWxsfW8ucHVzaChTdGFtcEFubm90YXRpb24uY3JlYXRlTmV3QW5ub3RhdGlvbihuLGwsaSx7aW1hZ2U6YX0pKTticmVhaztjYXNlIHk6by5wdXNoKFN0YW1wQW5ub3RhdGlvbi5jcmVhdGVOZXdBbm5vdGF0aW9uKG4sbCxpLHt9KSl9cmV0dXJue2Fubm90YXRpb25zOihhd2FpdCBQcm9taXNlLmFsbChvKSkuZmxhdCgpfX1zdGF0aWMgYXN5bmMgcHJpbnROZXdBbm5vdGF0aW9ucyhlLHQsYSxyLGkpe2lmKCFyKXJldHVybiBudWxsO2NvbnN0e29wdGlvbnM6bix4cmVmOnN9PXQsbz1bXTtmb3IoY29uc3QgYyBvZiByKWlmKCFjLmRlbGV0ZWQpc3dpdGNoKGMuYW5ub3RhdGlvblR5cGUpe2Nhc2UgZzpvLnB1c2goRnJlZVRleHRBbm5vdGF0aW9uLmNyZWF0ZU5ld1ByaW50QW5ub3RhdGlvbihlLHMsYyx7ZXZhbHVhdG9yOnQsdGFzazphLGV2YWx1YXRvck9wdGlvbnM6bn0pKTticmVhaztjYXNlIHA6Yy5xdWFkUG9pbnRzP28ucHVzaChIaWdobGlnaHRBbm5vdGF0aW9uLmNyZWF0ZU5ld1ByaW50QW5ub3RhdGlvbihlLHMsYyx7ZXZhbHVhdG9yT3B0aW9uczpufSkpOm8ucHVzaChJbmtBbm5vdGF0aW9uLmNyZWF0ZU5ld1ByaW50QW5ub3RhdGlvbihlLHMsYyx7ZXZhbHVhdG9yT3B0aW9uczpufSkpO2JyZWFrO2Nhc2UgYjpvLnB1c2goSW5rQW5ub3RhdGlvbi5jcmVhdGVOZXdQcmludEFubm90YXRpb24oZSxzLGMse2V2YWx1YXRvck9wdGlvbnM6bn0pKTticmVhaztjYXNlIG06Y29uc3Qgcj1uLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkP2F3YWl0KGk/LmdldChjLmJpdG1hcElkKSk6bnVsbDtpZihyPy5pbWFnZVN0cmVhbSl7Y29uc3R7aW1hZ2VTdHJlYW06ZSxzbWFza1N0cmVhbTp0fT1yO3QmJmUuZGljdC5zZXQoIlNNYXNrIix0KTtyLmltYWdlUmVmPW5ldyBKcGVnU3RyZWFtKGUsZS5sZW5ndGgpO3IuaW1hZ2VTdHJlYW09ci5zbWFza1N0cmVhbT1udWxsfW8ucHVzaChTdGFtcEFubm90YXRpb24uY3JlYXRlTmV3UHJpbnRBbm5vdGF0aW9uKGUscyxjLHtpbWFnZTpyLGV2YWx1YXRvck9wdGlvbnM6bn0pKTticmVhaztjYXNlIHk6by5wdXNoKFN0YW1wQW5ub3RhdGlvbi5jcmVhdGVOZXdQcmludEFubm90YXRpb24oZSxzLGMse2V2YWx1YXRvck9wdGlvbnM6bn0pKX1yZXR1cm4gUHJvbWlzZS5hbGwobyl9fWZ1bmN0aW9uIGdldFJnYkNvbG9yKGUsdD1uZXcgVWludDhDbGFtcGVkQXJyYXkoMykpe2lmKCFBcnJheS5pc0FycmF5KGUpKXJldHVybiB0O2NvbnN0IGE9dHx8bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMpO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBudWxsO2Nhc2UgMTpDb2xvclNwYWNlVXRpbHMuZ3JheS5nZXRSZ2JJdGVtKGUsMCxhLDApO3JldHVybiBhO2Nhc2UgMzpDb2xvclNwYWNlVXRpbHMucmdiLmdldFJnYkl0ZW0oZSwwLGEsMCk7cmV0dXJuIGE7Y2FzZSA0OkNvbG9yU3BhY2VVdGlscy5jbXlrLmdldFJnYkl0ZW0oZSwwLGEsMCk7cmV0dXJuIGE7ZGVmYXVsdDpyZXR1cm4gdH19ZnVuY3Rpb24gZ2V0UGRmQ29sb3JBcnJheShlLHQ9bnVsbCl7cmV0dXJuIGUmJkFycmF5LmZyb20oZSwoZT0+ZS8yNTUpKXx8dH1mdW5jdGlvbiBnZXRRdWFkUG9pbnRzKGUsdCl7Y29uc3QgYT1lLmdldEFycmF5KCJRdWFkUG9pbnRzIik7aWYoIWlzTnVtYmVyQXJyYXkoYSxudWxsKXx8MD09PWEubGVuZ3RofHxhLmxlbmd0aCU4PjApcmV0dXJuIG51bGw7Y29uc3Qgcj1uZXcgRmxvYXQzMkFycmF5KGEubGVuZ3RoKTtmb3IobGV0IGU9MCxpPWEubGVuZ3RoO2U8aTtlKz04KXtjb25zdFtpLG4scyxvLGMsbCxoLHVdPWEuc2xpY2UoZSxlKzgpLGQ9TWF0aC5taW4oaSxzLGMsaCksZj1NYXRoLm1heChpLHMsYyxoKSxnPU1hdGgubWluKG4sbyxsLHUpLHA9TWF0aC5tYXgobixvLGwsdSk7aWYobnVsbCE9PXQmJihkPHRbMF18fGY+dFsyXXx8Zzx0WzFdfHxwPnRbM10pKXJldHVybiBudWxsO3Iuc2V0KFtkLHAsZixwLGQsZyxmLGddLGUpfXJldHVybiByfWZ1bmN0aW9uIGdldFRyYW5zZm9ybU1hdHJpeChlLHQsYSl7Y29uc3Qgcj1uZXcgRmxvYXQzMkFycmF5KFsxLzAsMS8wLC0xLzAsLTEvMF0pO1V0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3godCxhLHIpO2NvbnN0W2ksbixzLG9dPXI7aWYoaT09PXN8fG49PT1vKXJldHVyblsxLDAsMCwxLGVbMF0sZVsxXV07Y29uc3QgYz0oZVsyXS1lWzBdKS8ocy1pKSxsPShlWzNdLWVbMV0pLyhvLW4pO3JldHVybltjLDAsMCxsLGVbMF0taSpjLGVbMV0tbipsXX1jbGFzcyBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe2NvbnN0e2RpY3Q6dCx4cmVmOmEsYW5ub3RhdGlvbkdsb2JhbHM6cixyZWY6aSxvcnBoYW5GaWVsZHM6bn09ZSxzPW4/LmdldChpKTtzJiZ0LnNldCgiUGFyZW50IixzKTt0aGlzLnNldFRpdGxlKHQuZ2V0KCJUIikpO3RoaXMuc2V0Q29udGVudHModC5nZXQoIkNvbnRlbnRzIikpO3RoaXMuc2V0TW9kaWZpY2F0aW9uRGF0ZSh0LmdldCgiTSIpKTt0aGlzLnNldEZsYWdzKHQuZ2V0KCJGIikpO3RoaXMuc2V0UmVjdGFuZ2xlKHQuZ2V0QXJyYXkoIlJlY3QiKSk7dGhpcy5zZXRDb2xvcih0LmdldEFycmF5KCJDIikpO3RoaXMuc2V0Qm9yZGVyU3R5bGUodCk7dGhpcy5zZXRBcHBlYXJhbmNlKHQpO3RoaXMuc2V0T3B0aW9uYWxDb250ZW50KHQpO2NvbnN0IG89dC5nZXQoIk1LIik7dGhpcy5zZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQ29sb3JzKG8pO3RoaXMuc2V0Um90YXRpb24obyx0KTt0aGlzLnJlZj1lLnJlZiBpbnN0YW5jZW9mIFJlZj9lLnJlZjpudWxsO3RoaXMuX3N0cmVhbXM9W107dGhpcy5hcHBlYXJhbmNlJiZ0aGlzLl9zdHJlYW1zLnB1c2godGhpcy5hcHBlYXJhbmNlKTtjb25zdCBjPSEhKHRoaXMuZmxhZ3MmTCksbD0hISh0aGlzLmZsYWdzJmopO3RoaXMuZGF0YT17YW5ub3RhdGlvbkZsYWdzOnRoaXMuZmxhZ3MsYm9yZGVyU3R5bGU6dGhpcy5ib3JkZXJTdHlsZSxjb2xvcjp0aGlzLmNvbG9yLGJhY2tncm91bmRDb2xvcjp0aGlzLmJhY2tncm91bmRDb2xvcixib3JkZXJDb2xvcjp0aGlzLmJvcmRlckNvbG9yLHJvdGF0aW9uOnRoaXMucm90YXRpb24sY29udGVudHNPYmo6dGhpcy5fY29udGVudHMsaGFzQXBwZWFyYW5jZTohIXRoaXMuYXBwZWFyYW5jZSxpZDplLmlkLG1vZGlmaWNhdGlvbkRhdGU6dGhpcy5tb2RpZmljYXRpb25EYXRlLHJlY3Q6dGhpcy5yZWN0YW5nbGUsc3VidHlwZTplLnN1YnR5cGUsaGFzT3duQ2FudmFzOiExLG5vUm90YXRlOiEhKHRoaXMuZmxhZ3MmTiksbm9IVE1MOmMmJmwsaXNFZGl0YWJsZTohMSxzdHJ1Y3RQYXJlbnQ6LTF9O2lmKHIuc3RydWN0VHJlZVJvb3Qpe2xldCBhPXQuZ2V0KCJTdHJ1Y3RQYXJlbnQiKTt0aGlzLmRhdGEuc3RydWN0UGFyZW50PWE9TnVtYmVyLmlzSW50ZWdlcihhKSYmYT49MD9hOi0xO3Iuc3RydWN0VHJlZVJvb3QuYWRkQW5ub3RhdGlvbklkVG9QYWdlKGUucGFnZVJlZixhKX1pZihlLmNvbGxlY3RGaWVsZHMpe2NvbnN0IHI9dC5nZXQoIktpZHMiKTtpZihBcnJheS5pc0FycmF5KHIpKXtjb25zdCBlPVtdO2Zvcihjb25zdCB0IG9mIHIpdCBpbnN0YW5jZW9mIFJlZiYmZS5wdXNoKHQudG9TdHJpbmcoKSk7MCE9PWUubGVuZ3RoJiYodGhpcy5kYXRhLmtpZElkcz1lKX10aGlzLmRhdGEuYWN0aW9ucz1jb2xsZWN0QWN0aW9ucyhhLHQsdGUpO3RoaXMuZGF0YS5maWVsZE5hbWU9dGhpcy5fY29uc3RydWN0RmllbGROYW1lKHQpO3RoaXMuZGF0YS5wYWdlSW5kZXg9ZS5wYWdlSW5kZXh9Y29uc3QgaD10LmdldCgiSVQiKTtoIGluc3RhbmNlb2YgTmFtZSYmKHRoaXMuZGF0YS5pdD1oLm5hbWUpO3RoaXMuX2lzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkPWUuZXZhbHVhdG9yT3B0aW9ucy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDt0aGlzLl9mYWxsYmFja0ZvbnREaWN0PW51bGw7dGhpcy5fbmVlZEFwcGVhcmFuY2VzPSExfV9oYXNGbGFnKGUsdCl7cmV0dXJuISEoZSZ0KX1fYnVpbGRGbGFncyhlLHQpe2xldHtmbGFnczphfT10aGlzO2lmKHZvaWQgMD09PWUpe2lmKHZvaWQgMD09PXQpcmV0dXJuO3JldHVybiB0P2EmflI6YSZ+RHxSfWlmKGUpe2F8PVI7cmV0dXJuIHQ/YSZ+RXxEOmEmfkR8RX1hJj1+KER8RSk7cmV0dXJuIHQ/YSZ+UjphfFJ9X2lzVmlld2FibGUoZSl7cmV0dXJuIXRoaXMuX2hhc0ZsYWcoZSxNKSYmIXRoaXMuX2hhc0ZsYWcoZSxFKX1faXNQcmludGFibGUoZSl7cmV0dXJuIHRoaXMuX2hhc0ZsYWcoZSxSKSYmIXRoaXMuX2hhc0ZsYWcoZSxEKSYmIXRoaXMuX2hhc0ZsYWcoZSxNKX1tdXN0QmVWaWV3ZWQoZSx0KXtjb25zdCBhPWU/LmdldCh0aGlzLmRhdGEuaWQpPy5ub1ZpZXc7cmV0dXJuIHZvaWQgMCE9PWE/IWE6dGhpcy52aWV3YWJsZSYmIXRoaXMuX2hhc0ZsYWcodGhpcy5mbGFncyxEKX1tdXN0QmVQcmludGVkKGUpe2NvbnN0IHQ9ZT8uZ2V0KHRoaXMuZGF0YS5pZCk/Lm5vUHJpbnQ7cmV0dXJuIHZvaWQgMCE9PXQ/IXQ6dGhpcy5wcmludGFibGV9bXVzdEJlVmlld2VkV2hlbkVkaXRpbmcoZSx0PW51bGwpe3JldHVybiBlPyF0aGlzLmRhdGEuaXNFZGl0YWJsZTohdD8uaGFzKHRoaXMuZGF0YS5pZCl9Z2V0IHZpZXdhYmxlKCl7cmV0dXJuIG51bGwhPT10aGlzLmRhdGEucXVhZFBvaW50cyYmKDA9PT10aGlzLmZsYWdzfHx0aGlzLl9pc1ZpZXdhYmxlKHRoaXMuZmxhZ3MpKX1nZXQgcHJpbnRhYmxlKCl7cmV0dXJuIG51bGwhPT10aGlzLmRhdGEucXVhZFBvaW50cyYmKDAhPT10aGlzLmZsYWdzJiZ0aGlzLl9pc1ByaW50YWJsZSh0aGlzLmZsYWdzKSl9X3BhcnNlU3RyaW5nSGVscGVyKGUpe2NvbnN0IHQ9InN0cmluZyI9PXR5cGVvZiBlP3N0cmluZ1RvUERGU3RyaW5nKGUpOiIiO3JldHVybntzdHI6dCxkaXI6dCYmInJ0bCI9PT1iaWRpKHQpLmRpcj8icnRsIjoibHRyIn19c2V0RGVmYXVsdEFwcGVhcmFuY2UoZSl7Y29uc3R7ZGljdDp0LGFubm90YXRpb25HbG9iYWxzOmF9PWUscj1nZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0OnQsa2V5OiJEQSJ9KXx8YS5hY3JvRm9ybS5nZXQoIkRBIik7dGhpcy5fZGVmYXVsdEFwcGVhcmFuY2U9InN0cmluZyI9PXR5cGVvZiByP3I6IiI7dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YT1wYXJzZURlZmF1bHRBcHBlYXJhbmNlKHRoaXMuX2RlZmF1bHRBcHBlYXJhbmNlKX1zZXRUaXRsZShlKXt0aGlzLl90aXRsZT10aGlzLl9wYXJzZVN0cmluZ0hlbHBlcihlKX1zZXRDb250ZW50cyhlKXt0aGlzLl9jb250ZW50cz10aGlzLl9wYXJzZVN0cmluZ0hlbHBlcihlKX1zZXRNb2RpZmljYXRpb25EYXRlKGUpe3RoaXMubW9kaWZpY2F0aW9uRGF0ZT0ic3RyaW5nIj09dHlwZW9mIGU/ZTpudWxsfXNldEZsYWdzKGUpe3RoaXMuZmxhZ3M9TnVtYmVyLmlzSW50ZWdlcihlKSYmZT4wP2U6MDt0aGlzLmZsYWdzJk0mJiJBbm5vdGF0aW9uIiE9PXRoaXMuY29uc3RydWN0b3IubmFtZSYmKHRoaXMuZmxhZ3NePU0pfWhhc0ZsYWcoZSl7cmV0dXJuIHRoaXMuX2hhc0ZsYWcodGhpcy5mbGFncyxlKX1zZXRSZWN0YW5nbGUoZSl7dGhpcy5yZWN0YW5nbGU9bG9va3VwTm9ybWFsUmVjdChlLFswLDAsMCwwXSl9c2V0Q29sb3IoZSl7dGhpcy5jb2xvcj1nZXRSZ2JDb2xvcihlKX1zZXRMaW5lRW5kaW5ncyhlKXt0aGlzLmxpbmVFbmRpbmdzPVsiTm9uZSIsIk5vbmUiXTtpZihBcnJheS5pc0FycmF5KGUpJiYyPT09ZS5sZW5ndGgpZm9yKGxldCB0PTA7dDwyO3QrKyl7Y29uc3QgYT1lW3RdO2lmKGEgaW5zdGFuY2VvZiBOYW1lKXN3aXRjaChhLm5hbWUpe2Nhc2UiTm9uZSI6Y29udGludWU7Y2FzZSJTcXVhcmUiOmNhc2UiQ2lyY2xlIjpjYXNlIkRpYW1vbmQiOmNhc2UiT3BlbkFycm93IjpjYXNlIkNsb3NlZEFycm93IjpjYXNlIkJ1dHQiOmNhc2UiUk9wZW5BcnJvdyI6Y2FzZSJSQ2xvc2VkQXJyb3ciOmNhc2UiU2xhc2giOnRoaXMubGluZUVuZGluZ3NbdF09YS5uYW1lO2NvbnRpbnVlfXdhcm4oYElnbm9yaW5nIGludmFsaWQgbGluZUVuZGluZzogJHthfWApfX1zZXRSb3RhdGlvbihlLHQpe3RoaXMucm90YXRpb249MDtsZXQgYT1lIGluc3RhbmNlb2YgRGljdD9lLmdldCgiUiIpfHwwOnQuZ2V0KCJSb3RhdGUiKXx8MDtpZihOdW1iZXIuaXNJbnRlZ2VyKGEpJiYwIT09YSl7YSU9MzYwO2E8MCYmKGErPTM2MCk7YSU5MD09MCYmKHRoaXMucm90YXRpb249YSl9fXNldEJvcmRlckFuZEJhY2tncm91bmRDb2xvcnMoZSl7aWYoZSBpbnN0YW5jZW9mIERpY3Qpe3RoaXMuYm9yZGVyQ29sb3I9Z2V0UmdiQ29sb3IoZS5nZXRBcnJheSgiQkMiKSxudWxsKTt0aGlzLmJhY2tncm91bmRDb2xvcj1nZXRSZ2JDb2xvcihlLmdldEFycmF5KCJCRyIpLG51bGwpfWVsc2UgdGhpcy5ib3JkZXJDb2xvcj10aGlzLmJhY2tncm91bmRDb2xvcj1udWxsfXNldEJvcmRlclN0eWxlKGUpe3RoaXMuYm9yZGVyU3R5bGU9bmV3IEFubm90YXRpb25Cb3JkZXJTdHlsZTtpZihlIGluc3RhbmNlb2YgRGljdClpZihlLmhhcygiQlMiKSl7Y29uc3QgdD1lLmdldCgiQlMiKTtpZih0IGluc3RhbmNlb2YgRGljdCl7Y29uc3QgZT10LmdldCgiVHlwZSIpO2lmKCFlfHxpc05hbWUoZSwiQm9yZGVyIikpe3RoaXMuYm9yZGVyU3R5bGUuc2V0V2lkdGgodC5nZXQoIlciKSx0aGlzLnJlY3RhbmdsZSk7dGhpcy5ib3JkZXJTdHlsZS5zZXRTdHlsZSh0LmdldCgiUyIpKTt0aGlzLmJvcmRlclN0eWxlLnNldERhc2hBcnJheSh0LmdldEFycmF5KCJEIikpfX19ZWxzZSBpZihlLmhhcygiQm9yZGVyIikpe2NvbnN0IHQ9ZS5nZXRBcnJheSgiQm9yZGVyIik7aWYoQXJyYXkuaXNBcnJheSh0KSYmdC5sZW5ndGg+PTMpe3RoaXMuYm9yZGVyU3R5bGUuc2V0SG9yaXpvbnRhbENvcm5lclJhZGl1cyh0WzBdKTt0aGlzLmJvcmRlclN0eWxlLnNldFZlcnRpY2FsQ29ybmVyUmFkaXVzKHRbMV0pO3RoaXMuYm9yZGVyU3R5bGUuc2V0V2lkdGgodFsyXSx0aGlzLnJlY3RhbmdsZSk7ND09PXQubGVuZ3RoJiZ0aGlzLmJvcmRlclN0eWxlLnNldERhc2hBcnJheSh0WzNdLCEwKX19ZWxzZSB0aGlzLmJvcmRlclN0eWxlLnNldFdpZHRoKDApfXNldEFwcGVhcmFuY2UoZSl7dGhpcy5hcHBlYXJhbmNlPW51bGw7Y29uc3QgdD1lLmdldCgiQVAiKTtpZighKHQgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm47Y29uc3QgYT10LmdldCgiTiIpO2lmKGEgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKXt0aGlzLmFwcGVhcmFuY2U9YTtyZXR1cm59aWYoIShhIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuO2NvbnN0IHI9ZS5nZXQoIkFTIik7aWYoIShyIGluc3RhbmNlb2YgTmFtZSYmYS5oYXMoci5uYW1lKSkpcmV0dXJuO2NvbnN0IGk9YS5nZXQoci5uYW1lKTtpIGluc3RhbmNlb2YgQmFzZVN0cmVhbSYmKHRoaXMuYXBwZWFyYW5jZT1pKX1zZXRPcHRpb25hbENvbnRlbnQoZSl7dGhpcy5vYz1udWxsO2NvbnN0IHQ9ZS5nZXQoIk9DIik7dCBpbnN0YW5jZW9mIE5hbWU/d2Fybigic2V0T3B0aW9uYWxDb250ZW50OiBTdXBwb3J0IGZvciAvTmFtZS1lbnRyeSBpcyBub3QgaW1wbGVtZW50ZWQuIik6dCBpbnN0YW5jZW9mIERpY3QmJih0aGlzLm9jPXQpfWFzeW5jIGxvYWRSZXNvdXJjZXMoZSx0KXtjb25zdCBhPWF3YWl0IHQuZGljdC5nZXRBc3luYygiUmVzb3VyY2VzIik7YSYmYXdhaXQgT2JqZWN0TG9hZGVyLmxvYWQoYSxlLGEueHJlZik7cmV0dXJuIGF9YXN5bmMgZ2V0T3BlcmF0b3JMaXN0KGUsdCxhLHIpe2NvbnN0e2hhc093bkNhbnZhczppLGlkOm4scmVjdDpvfT10aGlzLmRhdGE7bGV0IGM9dGhpcy5hcHBlYXJhbmNlO2NvbnN0IGw9ISEoaSYmYSZzKTtpZihsJiYoMD09PXRoaXMud2lkdGh8fDA9PT10aGlzLmhlaWdodCkpe3RoaXMuZGF0YS5oYXNPd25DYW52YXM9ITE7cmV0dXJue29wTGlzdDpuZXcgT3BlcmF0b3JMaXN0LHNlcGFyYXRlRm9ybTohMSxzZXBhcmF0ZUNhbnZhczohMX19aWYoIWMpe2lmKCFsKXJldHVybntvcExpc3Q6bmV3IE9wZXJhdG9yTGlzdCxzZXBhcmF0ZUZvcm06ITEsc2VwYXJhdGVDYW52YXM6ITF9O2M9bmV3IFN0cmluZ1N0cmVhbSgiIik7Yy5kaWN0PW5ldyBEaWN0fWNvbnN0IGg9Yy5kaWN0LHU9YXdhaXQgdGhpcy5sb2FkUmVzb3VyY2VzKGhhLGMpLGQ9bG9va3VwUmVjdChoLmdldEFycmF5KCJCQm94IiksWzAsMCwxLDFdKSxmPWxvb2t1cE1hdHJpeChoLmdldEFycmF5KCJNYXRyaXgiKSxsYSksZz1nZXRUcmFuc2Zvcm1NYXRyaXgobyxkLGYpLHA9bmV3IE9wZXJhdG9yTGlzdDtsZXQgbTt0aGlzLm9jJiYobT1hd2FpdCBlLnBhcnNlTWFya2VkQ29udGVudFByb3BzKHRoaXMub2MsbnVsbCkpO3ZvaWQgMCE9PW0mJnAuYWRkT3AoU3QsWyJPQyIsbV0pO3AuYWRkT3AoT3QsW24sbyxnLGYsbF0pO2F3YWl0IGUuZ2V0T3BlcmF0b3JMaXN0KHtzdHJlYW06Yyx0YXNrOnQscmVzb3VyY2VzOnUsb3BlcmF0b3JMaXN0OnAsZmFsbGJhY2tGb250RGljdDp0aGlzLl9mYWxsYmFja0ZvbnREaWN0fSk7cC5hZGRPcChNdCxbXSk7dm9pZCAwIT09bSYmcC5hZGRPcChBdCxbXSk7dGhpcy5yZXNldCgpO3JldHVybntvcExpc3Q6cCxzZXBhcmF0ZUZvcm06ITEsc2VwYXJhdGVDYW52YXM6bH19YXN5bmMgc2F2ZShlLHQsYSxyKXtyZXR1cm4gbnVsbH1nZXQgb3ZlcmxheXNUZXh0Q29udGVudCgpe3JldHVybiExfWdldCBoYXNUZXh0Q29udGVudCgpe3JldHVybiExfWFzeW5jIGV4dHJhY3RUZXh0Q29udGVudChlLHQsYSl7aWYoIXRoaXMuYXBwZWFyYW5jZSlyZXR1cm47Y29uc3Qgcj1hd2FpdCB0aGlzLmxvYWRSZXNvdXJjZXModWEsdGhpcy5hcHBlYXJhbmNlKSxpPVtdLG49W107bGV0IHM9bnVsbDtjb25zdCBvPXtkZXNpcmVkU2l6ZTpNYXRoLkluZmluaXR5LHJlYWR5OiEwLGVucXVldWUoZSx0KXtmb3IoY29uc3QgdCBvZiBlLml0ZW1zKWlmKHZvaWQgMCE9PXQuc3RyKXtzfHw9dC50cmFuc2Zvcm0uc2xpY2UoLTIpO24ucHVzaCh0LnN0cik7aWYodC5oYXNFT0wpe2kucHVzaChuLmpvaW4oIiIpLnRyaW1FbmQoKSk7bi5sZW5ndGg9MH19fX07YXdhaXQgZS5nZXRUZXh0Q29udGVudCh7c3RyZWFtOnRoaXMuYXBwZWFyYW5jZSx0YXNrOnQscmVzb3VyY2VzOnIsaW5jbHVkZU1hcmtlZENvbnRlbnQ6ITAsa2VlcFdoaXRlU3BhY2U6ITAsc2luazpvLHZpZXdCb3g6YX0pO3RoaXMucmVzZXQoKTtuLmxlbmd0aCYmaS5wdXNoKG4uam9pbigiIikudHJpbUVuZCgpKTtpZihpLmxlbmd0aD4xfHxpWzBdKXtjb25zdCBlPXRoaXMuYXBwZWFyYW5jZS5kaWN0LHQ9bG9va3VwUmVjdChlLmdldEFycmF5KCJCQm94IiksbnVsbCksYT1sb29rdXBNYXRyaXgoZS5nZXRBcnJheSgiTWF0cml4IiksbnVsbCk7dGhpcy5kYXRhLnRleHRQb3NpdGlvbj10aGlzLl90cmFuc2Zvcm1Qb2ludChzLHQsYSk7dGhpcy5kYXRhLnRleHRDb250ZW50PWl9fV90cmFuc2Zvcm1Qb2ludChlLHQsYSl7Y29uc3R7cmVjdDpyfT10aGlzLmRhdGE7dHx8PVswLDAsMSwxXTthfHw9WzEsMCwwLDEsMCwwXTtjb25zdCBpPWdldFRyYW5zZm9ybU1hdHJpeChyLHQsYSk7aVs0XS09clswXTtpWzVdLT1yWzFdO2NvbnN0IG49ZS5zbGljZSgpO1V0aWwuYXBwbHlUcmFuc2Zvcm0obixpKTtVdGlsLmFwcGx5VHJhbnNmb3JtKG4sYSk7cmV0dXJuIG59Z2V0RmllbGRPYmplY3QoKXtyZXR1cm4gdGhpcy5kYXRhLmtpZElkcz97aWQ6dGhpcy5kYXRhLmlkLGFjdGlvbnM6dGhpcy5kYXRhLmFjdGlvbnMsbmFtZTp0aGlzLmRhdGEuZmllbGROYW1lLHN0cm9rZUNvbG9yOnRoaXMuZGF0YS5ib3JkZXJDb2xvcixmaWxsQ29sb3I6dGhpcy5kYXRhLmJhY2tncm91bmRDb2xvcix0eXBlOiIiLGtpZElkczp0aGlzLmRhdGEua2lkSWRzLHBhZ2U6dGhpcy5kYXRhLnBhZ2VJbmRleCxyb3RhdGlvbjp0aGlzLnJvdGF0aW9ufTpudWxsfXJlc2V0KCl7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fc3RyZWFtcyllLnJlc2V0KCl9X2NvbnN0cnVjdEZpZWxkTmFtZShlKXtpZighZS5oYXMoIlQiKSYmIWUuaGFzKCJQYXJlbnQiKSl7d2FybigiVW5rbm93biBmaWVsZCBuYW1lLCBmYWxsaW5nIGJhY2sgdG8gZW1wdHkgZmllbGQgbmFtZS4iKTtyZXR1cm4iIn1pZighZS5oYXMoIlBhcmVudCIpKXJldHVybiBzdHJpbmdUb1BERlN0cmluZyhlLmdldCgiVCIpKTtjb25zdCB0PVtdO2UuaGFzKCJUIikmJnQudW5zaGlmdChzdHJpbmdUb1BERlN0cmluZyhlLmdldCgiVCIpKSk7bGV0IGE9ZTtjb25zdCByPW5ldyBSZWZTZXQ7ZS5vYmpJZCYmci5wdXQoZS5vYmpJZCk7Zm9yKDthLmhhcygiUGFyZW50Iik7KXthPWEuZ2V0KCJQYXJlbnQiKTtpZighKGEgaW5zdGFuY2VvZiBEaWN0KXx8YS5vYmpJZCYmci5oYXMoYS5vYmpJZCkpYnJlYWs7YS5vYmpJZCYmci5wdXQoYS5vYmpJZCk7YS5oYXMoIlQiKSYmdC51bnNoaWZ0KHN0cmluZ1RvUERGU3RyaW5nKGEuZ2V0KCJUIikpKX1yZXR1cm4gdC5qb2luKCIuIil9Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMuZGF0YS5yZWN0WzJdLXRoaXMuZGF0YS5yZWN0WzBdfWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy5kYXRhLnJlY3RbM10tdGhpcy5kYXRhLnJlY3RbMV19fWNsYXNzIEFubm90YXRpb25Cb3JkZXJTdHlsZXtjb25zdHJ1Y3Rvcigpe3RoaXMud2lkdGg9MTt0aGlzLnJhd1dpZHRoPTE7dGhpcy5zdHlsZT1KO3RoaXMuZGFzaEFycmF5PVszXTt0aGlzLmhvcml6b250YWxDb3JuZXJSYWRpdXM9MDt0aGlzLnZlcnRpY2FsQ29ybmVyUmFkaXVzPTB9c2V0V2lkdGgoZSx0PVswLDAsMCwwXSl7aWYoZSBpbnN0YW5jZW9mIE5hbWUpdGhpcy53aWR0aD0wO2Vsc2UgaWYoIm51bWJlciI9PXR5cGVvZiBlKXtpZihlPjApe3RoaXMucmF3V2lkdGg9ZTtjb25zdCBhPSh0WzJdLXRbMF0pLzIscj0odFszXS10WzFdKS8yO2lmKGE+MCYmcj4wJiYoZT5hfHxlPnIpKXt3YXJuKGBBbm5vdGF0aW9uQm9yZGVyU3R5bGUuc2V0V2lkdGggLSBpZ25vcmluZyB3aWR0aDogJHtlfWApO2U9MX19dGhpcy53aWR0aD1lfX1zZXRTdHlsZShlKXtpZihlIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goZS5uYW1lKXtjYXNlIlMiOnRoaXMuc3R5bGU9SjticmVhaztjYXNlIkQiOnRoaXMuc3R5bGU9WTticmVhaztjYXNlIkIiOnRoaXMuc3R5bGU9WjticmVhaztjYXNlIkkiOnRoaXMuc3R5bGU9UTticmVhaztjYXNlIlUiOnRoaXMuc3R5bGU9ZWV9fXNldERhc2hBcnJheShlLHQ9ITEpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCBhPSEwLHI9ITA7Zm9yKGNvbnN0IHQgb2YgZSl7aWYoISgrdD49MCkpe2E9ITE7YnJlYWt9dD4wJiYocj0hMSl9aWYoMD09PWUubGVuZ3RofHxhJiYhcil7dGhpcy5kYXNoQXJyYXk9ZTt0JiZ0aGlzLnNldFN0eWxlKE5hbWUuZ2V0KCJEIikpfWVsc2UgdGhpcy53aWR0aD0wfWVsc2UgZSYmKHRoaXMud2lkdGg9MCl9c2V0SG9yaXpvbnRhbENvcm5lclJhZGl1cyhlKXtOdW1iZXIuaXNJbnRlZ2VyKGUpJiYodGhpcy5ob3Jpem9udGFsQ29ybmVyUmFkaXVzPWUpfXNldFZlcnRpY2FsQ29ybmVyUmFkaXVzKGUpe051bWJlci5pc0ludGVnZXIoZSkmJih0aGlzLnZlcnRpY2FsQ29ybmVyUmFkaXVzPWUpfX1jbGFzcyBNYXJrdXBBbm5vdGF0aW9uIGV4dGVuZHMgQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnR9PWU7aWYodC5oYXMoIklSVCIpKXtjb25zdCBlPXQuZ2V0UmF3KCJJUlQiKTt0aGlzLmRhdGEuaW5SZXBseVRvPWUgaW5zdGFuY2VvZiBSZWY/ZS50b1N0cmluZygpOm51bGw7Y29uc3QgYT10LmdldCgiUlQiKTt0aGlzLmRhdGEucmVwbHlUeXBlPWEgaW5zdGFuY2VvZiBOYW1lP2EubmFtZTpPfWxldCBhPW51bGw7aWYodGhpcy5kYXRhLnJlcGx5VHlwZT09PVQpe2NvbnN0IGU9dC5nZXQoIklSVCIpO3RoaXMuc2V0VGl0bGUoZS5nZXQoIlQiKSk7dGhpcy5kYXRhLnRpdGxlT2JqPXRoaXMuX3RpdGxlO3RoaXMuc2V0Q29udGVudHMoZS5nZXQoIkNvbnRlbnRzIikpO3RoaXMuZGF0YS5jb250ZW50c09iaj10aGlzLl9jb250ZW50cztpZihlLmhhcygiQ3JlYXRpb25EYXRlIikpe3RoaXMuc2V0Q3JlYXRpb25EYXRlKGUuZ2V0KCJDcmVhdGlvbkRhdGUiKSk7dGhpcy5kYXRhLmNyZWF0aW9uRGF0ZT10aGlzLmNyZWF0aW9uRGF0ZX1lbHNlIHRoaXMuZGF0YS5jcmVhdGlvbkRhdGU9bnVsbDtpZihlLmhhcygiTSIpKXt0aGlzLnNldE1vZGlmaWNhdGlvbkRhdGUoZS5nZXQoIk0iKSk7dGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGU9dGhpcy5tb2RpZmljYXRpb25EYXRlfWVsc2UgdGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGU9bnVsbDthPWUuZ2V0UmF3KCJQb3B1cCIpO2lmKGUuaGFzKCJDIikpe3RoaXMuc2V0Q29sb3IoZS5nZXRBcnJheSgiQyIpKTt0aGlzLmRhdGEuY29sb3I9dGhpcy5jb2xvcn1lbHNlIHRoaXMuZGF0YS5jb2xvcj1udWxsfWVsc2V7dGhpcy5kYXRhLnRpdGxlT2JqPXRoaXMuX3RpdGxlO3RoaXMuc2V0Q3JlYXRpb25EYXRlKHQuZ2V0KCJDcmVhdGlvbkRhdGUiKSk7dGhpcy5kYXRhLmNyZWF0aW9uRGF0ZT10aGlzLmNyZWF0aW9uRGF0ZTthPXQuZ2V0UmF3KCJQb3B1cCIpO3QuaGFzKCJDIil8fCh0aGlzLmRhdGEuY29sb3I9bnVsbCl9dGhpcy5kYXRhLnBvcHVwUmVmPWEgaW5zdGFuY2VvZiBSZWY/YS50b1N0cmluZygpOm51bGw7dC5oYXMoIlJDIikmJih0aGlzLmRhdGEucmljaFRleHQ9WEZBRmFjdG9yeS5nZXRSaWNoVGV4dEFzSHRtbCh0LmdldCgiUkMiKSkpfXNldENyZWF0aW9uRGF0ZShlKXt0aGlzLmNyZWF0aW9uRGF0ZT0ic3RyaW5nIj09dHlwZW9mIGU/ZTpudWxsfV9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjplLGV4dHJhOnQsc3Ryb2tlQ29sb3I6YSxmaWxsQ29sb3I6cixibGVuZE1vZGU6aSxzdHJva2VBbHBoYTpuLGZpbGxBbHBoYTpzLHBvaW50c0NhbGxiYWNrOm99KXtjb25zdCBjPXRoaXMuZGF0YS5yZWN0PVsxLzAsMS8wLC0xLzAsLTEvMF0sbD1bInEiXTt0JiZsLnB1c2godCk7YSYmbC5wdXNoKGAke2FbMF19ICR7YVsxXX0gJHthWzJdfSBSR2ApO3ImJmwucHVzaChgJHtyWzBdfSAke3JbMV19ICR7clsyXX0gcmdgKTtjb25zdCBoPXRoaXMuZGF0YS5xdWFkUG9pbnRzfHxGbG9hdDMyQXJyYXkuZnJvbShbdGhpcy5yZWN0YW5nbGVbMF0sdGhpcy5yZWN0YW5nbGVbM10sdGhpcy5yZWN0YW5nbGVbMl0sdGhpcy5yZWN0YW5nbGVbM10sdGhpcy5yZWN0YW5nbGVbMF0sdGhpcy5yZWN0YW5nbGVbMV0sdGhpcy5yZWN0YW5nbGVbMl0sdGhpcy5yZWN0YW5nbGVbMV1dKTtmb3IobGV0IGU9MCx0PWgubGVuZ3RoO2U8dDtlKz04KXtjb25zdCB0PW8obCxoLnN1YmFycmF5KGUsZSs4KSk7VXRpbC5yZWN0Qm91bmRpbmdCb3goLi4udCxjKX1sLnB1c2goIlEiKTtjb25zdCB1PW5ldyBEaWN0KGUpLGQ9bmV3IERpY3QoZSk7ZC5zZXRJZk5hbWUoIlN1YnR5cGUiLCJGb3JtIik7Y29uc3QgZj1uZXcgU3RyaW5nU3RyZWFtKGwuam9pbigiICIpKTtmLmRpY3Q9ZDt1LnNldCgiRm0wIixmKTtjb25zdCBnPW5ldyBEaWN0KGUpO2kmJmcuc2V0SWZOYW1lKCJCTSIsaSk7Zy5zZXRJZk51bWJlcigiQ0EiLG4pO2cuc2V0SWZOdW1iZXIoImNhIixzKTtjb25zdCBwPW5ldyBEaWN0KGUpO3Auc2V0KCJHUzAiLGcpO2NvbnN0IG09bmV3IERpY3QoZSk7bS5zZXQoIkV4dEdTdGF0ZSIscCk7bS5zZXQoIlhPYmplY3QiLHUpO2NvbnN0IGI9bmV3IERpY3QoZSk7Yi5zZXQoIlJlc291cmNlcyIsbSk7Yi5zZXQoIkJCb3giLGMpO3RoaXMuYXBwZWFyYW5jZT1uZXcgU3RyaW5nU3RyZWFtKCIvR1MwIGdzIC9GbTAgRG8iKTt0aGlzLmFwcGVhcmFuY2UuZGljdD1iO3RoaXMuX3N0cmVhbXMucHVzaCh0aGlzLmFwcGVhcmFuY2UsZil9c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0Fubm90YXRpb24oZSx0LGEscil7Y29uc3QgaT10LnJlZnx8PWUuZ2V0TmV3VGVtcG9yYXJ5UmVmKCksbj1hd2FpdCB0aGlzLmNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW0odCxlLHIpO2xldCBzO2lmKG4pe2NvbnN0IHI9ZS5nZXROZXdUZW1wb3JhcnlSZWYoKTtzPXRoaXMuY3JlYXRlTmV3RGljdCh0LGUse2FwUmVmOnJ9KTthLnB1dChyLHtkYXRhOm59KX1lbHNlIHM9dGhpcy5jcmVhdGVOZXdEaWN0KHQsZSx7fSk7TnVtYmVyLmlzSW50ZWdlcih0LnBhcmVudFRyZWVJZCkmJnMuc2V0KCJTdHJ1Y3RQYXJlbnQiLHQucGFyZW50VHJlZUlkKTthLnB1dChpLHtkYXRhOnN9KTtjb25zdCBvPXtyZWY6aX07aWYodC5wb3B1cCl7Y29uc3Qgcj10LnBvcHVwO2lmKHIuZGVsZXRlZCl7cy5kZWxldGUoIlBvcHVwIik7cy5kZWxldGUoIkNvbnRlbnRzIik7cy5kZWxldGUoIlJDIik7cmV0dXJuIG99Y29uc3Qgbj1yLnJlZnx8PWUuZ2V0TmV3VGVtcG9yYXJ5UmVmKCk7ci5wYXJlbnQ9aTtjb25zdCBjPVBvcHVwQW5ub3RhdGlvbi5jcmVhdGVOZXdEaWN0KHIsZSk7YS5wdXQobix7ZGF0YTpjfSk7cy5zZXRJZkRlZmluZWQoIkNvbnRlbnRzIixzdHJpbmdUb0FzY2lpT3JVVEYxNkJFKHIuY29udGVudHMpKTtzLnNldCgiUG9wdXAiLG4pO3JldHVybltvLHtyZWY6bn1dfXJldHVybiBvfXN0YXRpYyBhc3luYyBjcmVhdGVOZXdQcmludEFubm90YXRpb24oZSx0LGEscil7Y29uc3QgaT1hd2FpdCB0aGlzLmNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW0oYSx0LHIpLG49dGhpcy5jcmVhdGVOZXdEaWN0KGEsdCxpP3thcDppfTp7fSkscz1uZXcgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3Ioe2RpY3Q6bix4cmVmOnQsYW5ub3RhdGlvbkdsb2JhbHM6ZSxldmFsdWF0b3JPcHRpb25zOnIuZXZhbHVhdG9yT3B0aW9uc30pO2EucmVmJiYocy5yZWY9cy5yZWZUb1JlcGxhY2U9YS5yZWYpO3JldHVybiBzfX1jbGFzcyBXaWRnZXRBbm5vdGF0aW9uIGV4dGVuZHMgQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnQseHJlZjphLGFubm90YXRpb25HbG9iYWxzOnJ9PWUsaT10aGlzLmRhdGE7dGhpcy5fbmVlZEFwcGVhcmFuY2VzPWUubmVlZEFwcGVhcmFuY2VzO2kuYW5ub3RhdGlvblR5cGU9Ri5XSURHRVQ7dm9pZCAwPT09aS5maWVsZE5hbWUmJihpLmZpZWxkTmFtZT10aGlzLl9jb25zdHJ1Y3RGaWVsZE5hbWUodCkpO3ZvaWQgMD09PWkuYWN0aW9ucyYmKGkuYWN0aW9ucz1jb2xsZWN0QWN0aW9ucyhhLHQsdGUpKTtsZXQgbj1nZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0OnQsa2V5OiJWIixnZXRBcnJheTohMH0pO2kuZmllbGRWYWx1ZT10aGlzLl9kZWNvZGVGb3JtVmFsdWUobik7Y29uc3Qgcz1nZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0OnQsa2V5OiJEViIsZ2V0QXJyYXk6ITB9KTtpLmRlZmF1bHRGaWVsZFZhbHVlPXRoaXMuX2RlY29kZUZvcm1WYWx1ZShzKTtpZih2b2lkIDA9PT1uJiZyLnhmYURhdGFzZXRzKXtjb25zdCBlPXRoaXMuX3RpdGxlLnN0cjtpZihlKXt0aGlzLl9oYXNWYWx1ZUZyb21YRkE9ITA7aS5maWVsZFZhbHVlPW49ci54ZmFEYXRhc2V0cy5nZXRWYWx1ZShlKX19dm9pZCAwPT09biYmbnVsbCE9PWkuZGVmYXVsdEZpZWxkVmFsdWUmJihpLmZpZWxkVmFsdWU9aS5kZWZhdWx0RmllbGRWYWx1ZSk7aS5hbHRlcm5hdGl2ZVRleHQ9c3RyaW5nVG9QREZTdHJpbmcodC5nZXQoIlRVIil8fCIiKTt0aGlzLnNldERlZmF1bHRBcHBlYXJhbmNlKGUpO2kuaGFzQXBwZWFyYW5jZXx8PXRoaXMuX25lZWRBcHBlYXJhbmNlcyYmdm9pZCAwIT09aS5maWVsZFZhbHVlJiZudWxsIT09aS5maWVsZFZhbHVlO2NvbnN0IG89Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDp0LGtleToiRlQifSk7aS5maWVsZFR5cGU9byBpbnN0YW5jZW9mIE5hbWU/by5uYW1lOm51bGw7Y29uc3QgYz1nZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0OnQsa2V5OiJEUiJ9KSxsPXIuYWNyb0Zvcm0uZ2V0KCJEUiIpLGg9dGhpcy5hcHBlYXJhbmNlPy5kaWN0LmdldCgiUmVzb3VyY2VzIik7dGhpcy5fZmllbGRSZXNvdXJjZXM9e2xvY2FsUmVzb3VyY2VzOmMsYWNyb0Zvcm1SZXNvdXJjZXM6bCxhcHBlYXJhbmNlUmVzb3VyY2VzOmgsbWVyZ2VkUmVzb3VyY2VzOkRpY3QubWVyZ2Uoe3hyZWY6YSxkaWN0QXJyYXk6W2MsaCxsXSxtZXJnZVN1YkRpY3RzOiEwfSl9O2kuZmllbGRGbGFncz1nZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0OnQsa2V5OiJGZiJ9KTsoIU51bWJlci5pc0ludGVnZXIoaS5maWVsZEZsYWdzKXx8aS5maWVsZEZsYWdzPDApJiYoaS5maWVsZEZsYWdzPTApO2kucGFzc3dvcmQ9dGhpcy5oYXNGaWVsZEZsYWcocSk7aS5yZWFkT25seT10aGlzLmhhc0ZpZWxkRmxhZyhfKTtpLnJlcXVpcmVkPXRoaXMuaGFzRmllbGRGbGFnKFUpO2kuaGlkZGVuPXRoaXMuX2hhc0ZsYWcoaS5hbm5vdGF0aW9uRmxhZ3MsRCl8fHRoaXMuX2hhc0ZsYWcoaS5hbm5vdGF0aW9uRmxhZ3MsRSl9X2RlY29kZUZvcm1WYWx1ZShlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT9lLmZpbHRlcigoZT0+InN0cmluZyI9PXR5cGVvZiBlKSkubWFwKChlPT5zdHJpbmdUb1BERlN0cmluZyhlKSkpOmUgaW5zdGFuY2VvZiBOYW1lP3N0cmluZ1RvUERGU3RyaW5nKGUubmFtZSk6InN0cmluZyI9PXR5cGVvZiBlP3N0cmluZ1RvUERGU3RyaW5nKGUpOm51bGx9aGFzRmllbGRGbGFnKGUpe3JldHVybiEhKHRoaXMuZGF0YS5maWVsZEZsYWdzJmUpfV9pc1ZpZXdhYmxlKGUpe3JldHVybiEwfW11c3RCZVZpZXdlZChlLHQpe3JldHVybiB0P3RoaXMudmlld2FibGU6c3VwZXIubXVzdEJlVmlld2VkKGUsdCkmJiF0aGlzLl9oYXNGbGFnKHRoaXMuZmxhZ3MsRSl9Z2V0Um90YXRpb25NYXRyaXgoZSl7bGV0IHQ9ZT8uZ2V0KHRoaXMuZGF0YS5pZCk/LnJvdGF0aW9uO3ZvaWQgMD09PXQmJih0PXRoaXMucm90YXRpb24pO3JldHVybiAwPT09dD9sYTpnZXRSb3RhdGlvbk1hdHJpeCh0LHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpfWdldEJvcmRlckFuZEJhY2tncm91bmRBcHBlYXJhbmNlcyhlKXtsZXQgdD1lPy5nZXQodGhpcy5kYXRhLmlkKT8ucm90YXRpb247dm9pZCAwPT09dCYmKHQ9dGhpcy5yb3RhdGlvbik7aWYoIXRoaXMuYmFja2dyb3VuZENvbG9yJiYhdGhpcy5ib3JkZXJDb2xvcilyZXR1cm4iIjtjb25zdCBhPTA9PT10fHwxODA9PT10P2AwIDAgJHt0aGlzLndpZHRofSAke3RoaXMuaGVpZ2h0fSByZWA6YDAgMCAke3RoaXMuaGVpZ2h0fSAke3RoaXMud2lkdGh9IHJlYDtsZXQgcj0iIjt0aGlzLmJhY2tncm91bmRDb2xvciYmKHI9YCR7Z2V0UGRmQ29sb3IodGhpcy5iYWNrZ3JvdW5kQ29sb3IsITApfSAke2F9IGYgYCk7aWYodGhpcy5ib3JkZXJDb2xvcil7cis9YCR7dGhpcy5ib3JkZXJTdHlsZS53aWR0aHx8MX0gdyAke2dldFBkZkNvbG9yKHRoaXMuYm9yZGVyQ29sb3IsITEpfSAke2F9IFMgYH1yZXR1cm4gcn1hc3luYyBnZXRPcGVyYXRvckxpc3QoZSx0LGEscil7aWYoYSZsJiYhKHRoaXMgaW5zdGFuY2VvZiBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uKSYmIXRoaXMuZGF0YS5ub0hUTUwmJiF0aGlzLmRhdGEuaGFzT3duQ2FudmFzKXJldHVybntvcExpc3Q6bmV3IE9wZXJhdG9yTGlzdCxzZXBhcmF0ZUZvcm06ITAsc2VwYXJhdGVDYW52YXM6ITF9O2lmKCF0aGlzLl9oYXNUZXh0KXJldHVybiBzdXBlci5nZXRPcGVyYXRvckxpc3QoZSx0LGEscik7Y29uc3QgaT1hd2FpdCB0aGlzLl9nZXRBcHBlYXJhbmNlKGUsdCxhLHIpO2lmKHRoaXMuYXBwZWFyYW5jZSYmbnVsbD09PWkpcmV0dXJuIHN1cGVyLmdldE9wZXJhdG9yTGlzdChlLHQsYSxyKTtjb25zdCBuPW5ldyBPcGVyYXRvckxpc3Q7aWYoIXRoaXMuX2RlZmF1bHRBcHBlYXJhbmNlfHxudWxsPT09aSlyZXR1cm57b3BMaXN0Om4sc2VwYXJhdGVGb3JtOiExLHNlcGFyYXRlQ2FudmFzOiExfTtjb25zdCBvPSEhKHRoaXMuZGF0YS5oYXNPd25DYW52YXMmJmEmcyksYz1bMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHRdLGg9Z2V0VHJhbnNmb3JtTWF0cml4KHRoaXMuZGF0YS5yZWN0LGMsWzEsMCwwLDEsMCwwXSk7bGV0IHU7dGhpcy5vYyYmKHU9YXdhaXQgZS5wYXJzZU1hcmtlZENvbnRlbnRQcm9wcyh0aGlzLm9jLG51bGwpKTt2b2lkIDAhPT11JiZuLmFkZE9wKFN0LFsiT0MiLHVdKTtuLmFkZE9wKE90LFt0aGlzLmRhdGEuaWQsdGhpcy5kYXRhLnJlY3QsaCx0aGlzLmdldFJvdGF0aW9uTWF0cml4KHIpLG9dKTtjb25zdCBkPW5ldyBTdHJpbmdTdHJlYW0oaSk7YXdhaXQgZS5nZXRPcGVyYXRvckxpc3Qoe3N0cmVhbTpkLHRhc2s6dCxyZXNvdXJjZXM6dGhpcy5fZmllbGRSZXNvdXJjZXMubWVyZ2VkUmVzb3VyY2VzLG9wZXJhdG9yTGlzdDpufSk7bi5hZGRPcChNdCxbXSk7dm9pZCAwIT09dSYmbi5hZGRPcChBdCxbXSk7cmV0dXJue29wTGlzdDpuLHNlcGFyYXRlRm9ybTohMSxzZXBhcmF0ZUNhbnZhczpvfX1fZ2V0TUtEaWN0KGUpe2NvbnN0IHQ9bmV3IERpY3QobnVsbCk7ZSYmdC5zZXQoIlIiLGUpO3Quc2V0SWZBcnJheSgiQkMiLGdldFBkZkNvbG9yQXJyYXkodGhpcy5ib3JkZXJDb2xvcikpO3Quc2V0SWZBcnJheSgiQkciLGdldFBkZkNvbG9yQXJyYXkodGhpcy5iYWNrZ3JvdW5kQ29sb3IpKTtyZXR1cm4gdC5zaXplPjA/dDpudWxsfWFtZW5kU2F2ZWREaWN0KGUsdCl7fXNldFZhbHVlKGUsdCxhLHIpe2NvbnN0e2RpY3Q6aSxyZWY6bn09ZnVuY3Rpb24gZ2V0UGFyZW50VG9VcGRhdGUoZSx0LGEpe2NvbnN0IHI9bmV3IFJlZlNldCxpPWUsbj17ZGljdDpudWxsLHJlZjpudWxsfTtmb3IoO2UgaW5zdGFuY2VvZiBEaWN0JiYhci5oYXModCk7KXtyLnB1dCh0KTtpZihlLmhhcygiVCIpKWJyZWFrO2lmKCEoKHQ9ZS5nZXRSYXcoIlBhcmVudCIpKWluc3RhbmNlb2YgUmVmKSlyZXR1cm4gbjtlPWEuZmV0Y2godCl9aWYoZSBpbnN0YW5jZW9mIERpY3QmJmUhPT1pKXtuLmRpY3Q9ZTtuLnJlZj10fXJldHVybiBufShlLHRoaXMucmVmLGEpO2lmKGkpe2lmKCFyLmhhcyhuKSl7Y29uc3QgZT1pLmNsb25lKCk7ZS5zZXQoIlYiLHQpO3IucHV0KG4se2RhdGE6ZX0pO3JldHVybiBlfX1lbHNlIGUuc2V0KCJWIix0KTtyZXR1cm4gbnVsbH1hc3luYyBzYXZlKGUsdCxhLHIpe2NvbnN0IGk9YT8uZ2V0KHRoaXMuZGF0YS5pZCksbj10aGlzLl9idWlsZEZsYWdzKGk/Lm5vVmlldyxpPy5ub1ByaW50KTtsZXQgcz1pPy52YWx1ZSxvPWk/LnJvdGF0aW9uO2lmKHM9PT10aGlzLmRhdGEuZmllbGRWYWx1ZXx8dm9pZCAwPT09cyl7aWYoIXRoaXMuX2hhc1ZhbHVlRnJvbVhGQSYmdm9pZCAwPT09byYmdm9pZCAwPT09bilyZXR1cm47c3x8PXRoaXMuZGF0YS5maWVsZFZhbHVlfWlmKHZvaWQgMD09PW8mJiF0aGlzLl9oYXNWYWx1ZUZyb21YRkEmJkFycmF5LmlzQXJyYXkocykmJkFycmF5LmlzQXJyYXkodGhpcy5kYXRhLmZpZWxkVmFsdWUpJiZpc0FycmF5RXF1YWwocyx0aGlzLmRhdGEuZmllbGRWYWx1ZSkmJnZvaWQgMD09PW4pcmV0dXJuO3ZvaWQgMD09PW8mJihvPXRoaXMucm90YXRpb24pO2xldCBsPW51bGw7aWYoIXRoaXMuX25lZWRBcHBlYXJhbmNlcyl7bD1hd2FpdCB0aGlzLl9nZXRBcHBlYXJhbmNlKGUsdCxjLGEpO2lmKG51bGw9PT1sJiZ2b2lkIDA9PT1uKXJldHVybn1sZXQgaD0hMTtpZihsPy5uZWVkQXBwZWFyYW5jZXMpe2g9ITA7bD1udWxsfWNvbnN0e3hyZWY6dX09ZSxkPXUuZmV0Y2hJZlJlZih0aGlzLnJlZik7aWYoIShkIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuO2NvbnN0IGY9bmV3IERpY3QodSk7Zm9yKGNvbnN0IGUgb2YgZC5nZXRLZXlzKCkpIkFQIiE9PWUmJmYuc2V0KGUsZC5nZXRSYXcoZSkpO2lmKHZvaWQgMCE9PW4pe2Yuc2V0KCJGIixuKTtpZihudWxsPT09bCYmIWgpe2NvbnN0IGU9ZC5nZXRSYXcoIkFQIik7ZSYmZi5zZXQoIkFQIixlKX19Y29uc3QgZz17cGF0aDp0aGlzLmRhdGEuZmllbGROYW1lLHZhbHVlOnN9LHA9dGhpcy5zZXRWYWx1ZShmLEFycmF5LmlzQXJyYXkocyk/cy5tYXAoc3RyaW5nVG9Bc2NpaU9yVVRGMTZCRSk6c3RyaW5nVG9Bc2NpaU9yVVRGMTZCRShzKSx1LHIpO3RoaXMuYW1lbmRTYXZlZERpY3QoYSxwfHxmKTtjb25zdCBtPXRoaXMuX2dldE1LRGljdChvKTttJiZmLnNldCgiTUsiLG0pO3IucHV0KHRoaXMucmVmLHtkYXRhOmYseGZhOmcsbmVlZEFwcGVhcmFuY2VzOmh9KTtpZihudWxsIT09bCl7Y29uc3QgZT11LmdldE5ld1RlbXBvcmFyeVJlZigpLHQ9bmV3IERpY3QodSk7Zi5zZXQoIkFQIix0KTt0LnNldCgiTiIsZSk7Y29uc3QgaT10aGlzLl9nZXRTYXZlRmllbGRSZXNvdXJjZXModSksbj1uZXcgU3RyaW5nU3RyZWFtKGwpLHM9bi5kaWN0PW5ldyBEaWN0KHUpO3Muc2V0SWZOYW1lKCJTdWJ0eXBlIiwiRm9ybSIpO3Muc2V0KCJSZXNvdXJjZXMiLGkpO2NvbnN0IGM9byUxODA9PTA/WzAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XTpbMCwwLHRoaXMuaGVpZ2h0LHRoaXMud2lkdGhdO3Muc2V0KCJCQm94IixjKTtjb25zdCBoPXRoaXMuZ2V0Um90YXRpb25NYXRyaXgoYSk7aCE9PWxhJiZzLnNldCgiTWF0cml4IixoKTtyLnB1dChlLHtkYXRhOm4seGZhOm51bGwsbmVlZEFwcGVhcmFuY2VzOiExfSl9Zi5zZXQoIk0iLGBEOiR7Z2V0TW9kaWZpY2F0aW9uRGF0ZSgpfWApfWFzeW5jIF9nZXRBcHBlYXJhbmNlKGUsdCxhLHIpe2lmKHRoaXMuZGF0YS5wYXNzd29yZClyZXR1cm4gbnVsbDtjb25zdCBuPXI/LmdldCh0aGlzLmRhdGEuaWQpO2xldCBzLG87aWYobil7cz1uLmZvcm1hdHRlZFZhbHVlfHxuLnZhbHVlO289bi5yb3RhdGlvbn1pZih2b2lkIDA9PT1vJiZ2b2lkIDA9PT1zJiYhdGhpcy5fbmVlZEFwcGVhcmFuY2VzJiYoIXRoaXMuX2hhc1ZhbHVlRnJvbVhGQXx8dGhpcy5hcHBlYXJhbmNlKSlyZXR1cm4gbnVsbDtjb25zdCBsPXRoaXMuZ2V0Qm9yZGVyQW5kQmFja2dyb3VuZEFwcGVhcmFuY2VzKHIpO2lmKHZvaWQgMD09PXMpe3M9dGhpcy5kYXRhLmZpZWxkVmFsdWU7aWYoIXMpcmV0dXJuYC9UeCBCTUMgcSAke2x9USBFTUNgfUFycmF5LmlzQXJyYXkocykmJjE9PT1zLmxlbmd0aCYmKHM9c1swXSk7YXNzZXJ0KCJzdHJpbmciPT10eXBlb2YgcywiRXhwZWN0ZWQgYHZhbHVlYCB0byBiZSBhIHN0cmluZy4iKTtzPXMudHJpbUVuZCgpO2lmKHRoaXMuZGF0YS5jb21ibyl7Y29uc3QgZT10aGlzLmRhdGEub3B0aW9ucy5maW5kKCgoe2V4cG9ydFZhbHVlOmV9KT0+cz09PWUpKTtzPWU/LmRpc3BsYXlWYWx1ZXx8c31pZigiIj09PXMpcmV0dXJuYC9UeCBCTUMgcSAke2x9USBFTUNgO3ZvaWQgMD09PW8mJihvPXRoaXMucm90YXRpb24pO2xldCBoLHU9LTE7aWYodGhpcy5kYXRhLm11bHRpTGluZSl7aD1zLnNwbGl0KC9cclxuP3xcbi8pLm1hcCgoZT0+ZS5ub3JtYWxpemUoIk5GQyIpKSk7dT1oLmxlbmd0aH1lbHNlIGg9W3MucmVwbGFjZSgvXHJcbj98XG4vLCIiKS5ub3JtYWxpemUoIk5GQyIpXTtsZXR7d2lkdGg6ZCxoZWlnaHQ6Zn09dGhpczs5MCE9PW8mJjI3MCE9PW98fChbZCxmXT1bZixkXSk7dGhpcy5fZGVmYXVsdEFwcGVhcmFuY2V8fCh0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhPXBhcnNlRGVmYXVsdEFwcGVhcmFuY2UodGhpcy5fZGVmYXVsdEFwcGVhcmFuY2U9Ii9IZWx2ZXRpY2EgMCBUZiAwIGciKSk7bGV0IGcscCxtLGI9YXdhaXQgV2lkZ2V0QW5ub3RhdGlvbi5fZ2V0Rm9udERhdGEoZSx0LHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEsdGhpcy5fZmllbGRSZXNvdXJjZXMubWVyZ2VkUmVzb3VyY2VzKTtjb25zdCB5PVtdO2xldCB3PSExO2Zvcihjb25zdCBlIG9mIGgpe2NvbnN0IHQ9Yi5lbmNvZGVTdHJpbmcoZSk7dC5sZW5ndGg+MSYmKHc9ITApO3kucHVzaCh0LmpvaW4oIiIpKX1pZih3JiZhJmMpcmV0dXJue25lZWRBcHBlYXJhbmNlczohMH07aWYodyYmdGhpcy5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpe2NvbnN0IGE9dGhpcy5kYXRhLmNvbWI/Im1vbm9zcGFjZSI6InNhbnMtc2VyaWYiLHI9bmV3IEZha2VVbmljb2RlRm9udChlLnhyZWYsYSksaT1yLmNyZWF0ZUZvbnRSZXNvdXJjZXMoaC5qb2luKCIiKSksbj1pLmdldFJhdygiRm9udCIpO2lmKHRoaXMuX2ZpZWxkUmVzb3VyY2VzLm1lcmdlZFJlc291cmNlcy5oYXMoIkZvbnQiKSl7Y29uc3QgZT10aGlzLl9maWVsZFJlc291cmNlcy5tZXJnZWRSZXNvdXJjZXMuZ2V0KCJGb250Iik7Zm9yKGNvbnN0IHQgb2Ygbi5nZXRLZXlzKCkpZS5zZXQodCxuLmdldFJhdyh0KSl9ZWxzZSB0aGlzLl9maWVsZFJlc291cmNlcy5tZXJnZWRSZXNvdXJjZXMuc2V0KCJGb250IixuKTtjb25zdCBvPXIuZm9udE5hbWUubmFtZTtiPWF3YWl0IFdpZGdldEFubm90YXRpb24uX2dldEZvbnREYXRhKGUsdCx7Zm9udE5hbWU6byxmb250U2l6ZTowfSxpKTtmb3IobGV0IGU9MCx0PXkubGVuZ3RoO2U8dDtlKyspeVtlXT1zdHJpbmdUb1VURjE2U3RyaW5nKGhbZV0pO2NvbnN0IGM9T2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEpO3RoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEuZm9udFNpemU9MDt0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnROYW1lPW87W2cscCxtXT10aGlzLl9jb21wdXRlRm9udFNpemUoZi0yLGQtNCxzLGIsdSk7dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YT1jfWVsc2V7dGhpcy5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWR8fHdhcm4oIl9nZXRBcHBlYXJhbmNlOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZCwgYW5ub3RhdGlvbiBtYXkgbm90IHJlbmRlciBjb3JyZWN0bHkuIik7W2cscCxtXT10aGlzLl9jb21wdXRlRm9udFNpemUoZi0yLGQtNCxzLGIsdSl9bGV0IHg9Yi5kZXNjZW50O3g9aXNOYU4oeCk/aSptOk1hdGgubWF4KGkqbSxNYXRoLmFicyh4KSpwKTtjb25zdCBTPU1hdGgubWluKE1hdGguZmxvb3IoKGYtcCkvMiksMSksaz10aGlzLmRhdGEudGV4dEFsaWdubWVudDtpZih0aGlzLmRhdGEubXVsdGlMaW5lKXJldHVybiB0aGlzLl9nZXRNdWx0aWxpbmVBcHBlYXJhbmNlKGcseSxiLHAsZCxmLGssMixTLHgsbSxyKTtpZih0aGlzLmRhdGEuY29tYilyZXR1cm4gdGhpcy5fZ2V0Q29tYkFwcGVhcmFuY2UoZyxiLHlbMF0scCxkLGYsMixTLHgsbSxyKTtjb25zdCBDPVMreDtpZigwPT09a3x8az4yKXJldHVybmAvVHggQk1DIHEgJHtsfUJUIGArZytgIDEgMCAwIDEgJHtudW1iZXJUb1N0cmluZygyKX0gJHtudW1iZXJUb1N0cmluZyhDKX0gVG0gKCR7ZXNjYXBlU3RyaW5nKHlbMF0pfSkgVGogRVQgUSBFTUNgO3JldHVybmAvVHggQk1DIHEgJHtsfUJUIGArZytgIDEgMCAwIDEgMCAwIFRtICR7dGhpcy5fcmVuZGVyVGV4dCh5WzBdLGIscCxkLGsse3NoaWZ0OjB9LDIsQyl9IEVUIFEgRU1DYH1zdGF0aWMgYXN5bmMgX2dldEZvbnREYXRhKGUsdCxhLHIpe2NvbnN0IGk9bmV3IE9wZXJhdG9yTGlzdCxuPXtmb250Om51bGwsY2xvbmUoKXtyZXR1cm4gdGhpc319LHtmb250TmFtZTpzLGZvbnRTaXplOm99PWE7YXdhaXQgZS5oYW5kbGVTZXRGb250KHIsW3MmJk5hbWUuZ2V0KHMpLG9dLG51bGwsaSx0LG4sbnVsbCk7cmV0dXJuIG4uZm9udH1fZ2V0VGV4dFdpZHRoKGUsdCl7cmV0dXJuIE1hdGguc3VtUHJlY2lzZSh0LmNoYXJzVG9HbHlwaHMoZSkubWFwKChlPT5lLndpZHRoKSkpLzFlM31fY29tcHV0ZUZvbnRTaXplKGUsdCxyLGksbil7bGV0e2ZvbnRTaXplOnN9PXRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEsbz0oc3x8MTIpKmEsYz1NYXRoLnJvdW5kKGUvbyk7aWYoIXMpe2NvbnN0IHJvdW5kV2l0aFR3b0RpZ2l0cz1lPT5NYXRoLmZsb29yKDEwMCplKS8xMDA7aWYoLTE9PT1uKXtjb25zdCBuPXRoaXMuX2dldFRleHRXaWR0aChyLGkpO3M9cm91bmRXaXRoVHdvRGlnaXRzKE1hdGgubWluKGUvYSx0L24pKTtjPTF9ZWxzZXtjb25zdCBsPXIuc3BsaXQoL1xyXG4/fFxuLyksaD1bXTtmb3IoY29uc3QgZSBvZiBsKXtjb25zdCB0PWkuZW5jb2RlU3RyaW5nKGUpLmpvaW4oIiIpLGE9aS5jaGFyc1RvR2x5cGhzKHQpLHI9aS5nZXRDaGFyUG9zaXRpb25zKHQpO2gucHVzaCh7bGluZTp0LGdseXBoczphLHBvc2l0aW9uczpyfSl9Y29uc3QgaXNUb29CaWc9YT0+e2xldCByPTA7Zm9yKGNvbnN0IG4gb2YgaCl7cis9dGhpcy5fc3BsaXRMaW5lKG51bGwsaSxhLHQsbikubGVuZ3RoKmE7aWYocj5lKXJldHVybiEwfXJldHVybiExfTtjPU1hdGgubWF4KGMsbik7Zm9yKDs7KXtvPWUvYztzPXJvdW5kV2l0aFR3b0RpZ2l0cyhvL2EpO2lmKCFpc1Rvb0JpZyhzKSlicmVhaztjKyt9fWNvbnN0e2ZvbnROYW1lOmwsZm9udENvbG9yOmh9PXRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7dGhpcy5fZGVmYXVsdEFwcGVhcmFuY2U9ZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEFwcGVhcmFuY2Uoe2ZvbnRTaXplOmUsZm9udE5hbWU6dCxmb250Q29sb3I6YX0pe3JldHVybmAvJHtlc2NhcGVQREZOYW1lKHQpfSAke2V9IFRmICR7Z2V0UGRmQ29sb3IoYSwhMCl9YH0oe2ZvbnRTaXplOnMsZm9udE5hbWU6bCxmb250Q29sb3I6aH0pfXJldHVyblt0aGlzLl9kZWZhdWx0QXBwZWFyYW5jZSxzLGUvY119X3JlbmRlclRleHQoZSx0LGEscixpLG4scyxvKXtsZXQgYztpZigxPT09aSl7Yz0oci10aGlzLl9nZXRUZXh0V2lkdGgoZSx0KSphKS8yfWVsc2UgaWYoMj09PWkpe2M9ci10aGlzLl9nZXRUZXh0V2lkdGgoZSx0KSphLXN9ZWxzZSBjPXM7Y29uc3QgbD1udW1iZXJUb1N0cmluZyhjLW4uc2hpZnQpO24uc2hpZnQ9YztyZXR1cm5gJHtsfSAke289bnVtYmVyVG9TdHJpbmcobyl9IFRkICgke2VzY2FwZVN0cmluZyhlKX0pIFRqYH1fZ2V0U2F2ZUZpZWxkUmVzb3VyY2VzKGUpe2NvbnN0e2xvY2FsUmVzb3VyY2VzOnQsYXBwZWFyYW5jZVJlc291cmNlczphLGFjcm9Gb3JtUmVzb3VyY2VzOnJ9PXRoaXMuX2ZpZWxkUmVzb3VyY2VzLGk9dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YT8uZm9udE5hbWU7aWYoIWkpcmV0dXJuIHR8fERpY3QuZW1wdHk7Zm9yKGNvbnN0IGUgb2ZbdCxhXSlpZihlIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgdD1lLmdldCgiRm9udCIpO2lmKHQgaW5zdGFuY2VvZiBEaWN0JiZ0LmhhcyhpKSlyZXR1cm4gZX1pZihyIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgYT1yLmdldCgiRm9udCIpO2lmKGEgaW5zdGFuY2VvZiBEaWN0JiZhLmhhcyhpKSl7Y29uc3Qgcj1uZXcgRGljdChlKTtyLnNldChpLGEuZ2V0UmF3KGkpKTtjb25zdCBuPW5ldyBEaWN0KGUpO24uc2V0KCJGb250IixyKTtyZXR1cm4gRGljdC5tZXJnZSh7eHJlZjplLGRpY3RBcnJheTpbbix0XSxtZXJnZVN1YkRpY3RzOiEwfSl9fXJldHVybiB0fHxEaWN0LmVtcHR5fWdldEZpZWxkT2JqZWN0KCl7cmV0dXJuIG51bGx9fWNsYXNzIFRleHRXaWRnZXRBbm5vdGF0aW9uIGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnR9PWU7aWYodC5oYXMoIlBNRCIpKXt0aGlzLmZsYWdzfD1EO3RoaXMuZGF0YS5oaWRkZW49ITA7d2FybigiQmFyY29kZXMgYXJlIG5vdCBzdXBwb3J0ZWQiKX10aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuZGF0YS5yZWFkT25seSYmIXRoaXMuZGF0YS5ub0hUTUw7dGhpcy5faGFzVGV4dD0hMDsic3RyaW5nIiE9dHlwZW9mIHRoaXMuZGF0YS5maWVsZFZhbHVlJiYodGhpcy5kYXRhLmZpZWxkVmFsdWU9IiIpO2xldCBhPWdldEluaGVyaXRhYmxlUHJvcGVydHkoe2RpY3Q6dCxrZXk6IlEifSk7KCFOdW1iZXIuaXNJbnRlZ2VyKGEpfHxhPDB8fGE+MikmJihhPW51bGwpO3RoaXMuZGF0YS50ZXh0QWxpZ25tZW50PWE7bGV0IHI9Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDp0LGtleToiTWF4TGVuIn0pOyghTnVtYmVyLmlzSW50ZWdlcihyKXx8cjwwKSYmKHI9MCk7dGhpcy5kYXRhLm1heExlbj1yO3RoaXMuZGF0YS5tdWx0aUxpbmU9dGhpcy5oYXNGaWVsZEZsYWcoWCk7dGhpcy5kYXRhLmNvbWI9dGhpcy5oYXNGaWVsZEZsYWcoSykmJiF0aGlzLmRhdGEubXVsdGlMaW5lJiYhdGhpcy5kYXRhLnBhc3N3b3JkJiYhdGhpcy5oYXNGaWVsZEZsYWcoJCkmJjAhPT10aGlzLmRhdGEubWF4TGVuO3RoaXMuZGF0YS5kb05vdFNjcm9sbD10aGlzLmhhc0ZpZWxkRmxhZyhWKTtjb25zdHtkYXRhOnthY3Rpb25zOml9fT10aGlzO2lmKCFpKXJldHVybjtjb25zdCBuPS9eQUYoRGF0ZXxUaW1lKV8oPzpLZXlzdHJva2V8Rm9ybWF0KSg/OkV4KT9cKFsnIl0/KFteJyJdKylbJyJdP1wpOyQvO2xldCBzPSExOygxPT09aS5Gb3JtYXQ/Lmxlbmd0aCYmMT09PWkuS2V5c3Ryb2tlPy5sZW5ndGgmJm4udGVzdChpLkZvcm1hdFswXSkmJm4udGVzdChpLktleXN0cm9rZVswXSl8fDA9PT1pLkZvcm1hdD8ubGVuZ3RoJiYxPT09aS5LZXlzdHJva2U/Lmxlbmd0aCYmbi50ZXN0KGkuS2V5c3Ryb2tlWzBdKXx8MD09PWkuS2V5c3Ryb2tlPy5sZW5ndGgmJjE9PT1pLkZvcm1hdD8ubGVuZ3RoJiZuLnRlc3QoaS5Gb3JtYXRbMF0pKSYmKHM9ITApO2NvbnN0IG89W107aS5Gb3JtYXQmJm8ucHVzaCguLi5pLkZvcm1hdCk7aS5LZXlzdHJva2UmJm8ucHVzaCguLi5pLktleXN0cm9rZSk7aWYocyl7ZGVsZXRlIGkuS2V5c3Ryb2tlO2kuRm9ybWF0PW99Zm9yKGNvbnN0IGUgb2Ygbyl7Y29uc3QgdD1lLm1hdGNoKG4pO2lmKCF0KWNvbnRpbnVlO2NvbnN0IGE9IkRhdGUiPT09dFsxXTtsZXQgcj10WzJdO2NvbnN0IGk9cGFyc2VJbnQociwxMCk7aXNOYU4oaSl8fE1hdGguZmxvb3IoTWF0aC5sb2cxMChpKSkrMSE9PXRbMl0ubGVuZ3RofHwocj0oYT93bjp4bilbaV0/P3IpO3RoaXMuZGF0YS5kYXRldGltZUZvcm1hdD1yO2lmKCFzKWJyZWFrO2lmKGEpe2lmKC9ISHxNTXxzc3xoLy50ZXN0KHIpKXt0aGlzLmRhdGEuZGF0ZXRpbWVUeXBlPSJkYXRldGltZS1sb2NhbCI7dGhpcy5kYXRhLnRpbWVTdGVwPS9zcy8udGVzdChyKT8xOjYwfWVsc2UgdGhpcy5kYXRhLmRhdGV0aW1lVHlwZT0iZGF0ZSI7YnJlYWt9dGhpcy5kYXRhLmRhdGV0aW1lVHlwZT0idGltZSI7dGhpcy5kYXRhLnRpbWVTdGVwPS9zcy8udGVzdChyKT8xOjYwO2JyZWFrfX1nZXQgaGFzVGV4dENvbnRlbnQoKXtyZXR1cm4hIXRoaXMuYXBwZWFyYW5jZSYmIXRoaXMuX25lZWRBcHBlYXJhbmNlc31fZ2V0Q29tYkFwcGVhcmFuY2UoZSx0LGEscixpLG4scyxvLGMsbCxoKXtjb25zdCB1PWkvdGhpcy5kYXRhLm1heExlbixkPXRoaXMuZ2V0Qm9yZGVyQW5kQmFja2dyb3VuZEFwcGVhcmFuY2VzKGgpLGY9W10sZz10LmdldENoYXJQb3NpdGlvbnMoYSk7Zm9yKGNvbnN0W2UsdF1vZiBnKWYucHVzaChgKCR7ZXNjYXBlU3RyaW5nKGEuc3Vic3RyaW5nKGUsdCkpfSkgVGpgKTtjb25zdCBwPWYuam9pbihgICR7bnVtYmVyVG9TdHJpbmcodSl9IDAgVGQgYCk7cmV0dXJuYC9UeCBCTUMgcSAke2R9QlQgYCtlK2AgMSAwIDAgMSAke251bWJlclRvU3RyaW5nKHMpfSAke251bWJlclRvU3RyaW5nKG8rYyl9IFRtICR7cH0gRVQgUSBFTUNgfV9nZXRNdWx0aWxpbmVBcHBlYXJhbmNlKGUsdCxhLHIsaSxuLHMsbyxjLGwsaCx1KXtjb25zdCBkPVtdLGY9aS0yKm8sZz17c2hpZnQ6MH07Zm9yKGxldCBlPTAsbj10Lmxlbmd0aDtlPG47ZSsrKXtjb25zdCBuPXRbZV0sdT10aGlzLl9zcGxpdExpbmUobixhLHIsZik7Zm9yKGxldCB0PTAsbj11Lmxlbmd0aDt0PG47dCsrKXtjb25zdCBuPXVbdF0sZj0wPT09ZSYmMD09PXQ/LWMtKGgtbCk6LWg7ZC5wdXNoKHRoaXMuX3JlbmRlclRleHQobixhLHIsaSxzLGcsbyxmKSl9fWNvbnN0IHA9dGhpcy5nZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQXBwZWFyYW5jZXModSksbT1kLmpvaW4oIlxuIik7cmV0dXJuYC9UeCBCTUMgcSAke3B9QlQgYCtlK2AgMSAwIDAgMSAwICR7bnVtYmVyVG9TdHJpbmcobil9IFRtICR7bX0gRVQgUSBFTUNgfV9zcGxpdExpbmUoZSx0LGEscixpPXt9KXtlPWkubGluZXx8ZTtjb25zdCBuPWkuZ2x5cGhzfHx0LmNoYXJzVG9HbHlwaHMoZSk7aWYobi5sZW5ndGg8PTEpcmV0dXJuW2VdO2NvbnN0IHM9aS5wb3NpdGlvbnN8fHQuZ2V0Q2hhclBvc2l0aW9ucyhlKSxvPWEvMWUzLGM9W107bGV0IGw9LTEsaD0tMSx1PS0xLGQ9MCxmPTA7Zm9yKGxldCB0PTAsYT1uLmxlbmd0aDt0PGE7dCsrKXtjb25zdFthLGldPXNbdF0sZz1uW3RdLHA9Zy53aWR0aCpvO2lmKCIgIj09PWcudW5pY29kZSlpZihmK3A+cil7Yy5wdXNoKGUuc3Vic3RyaW5nKGQsYSkpO2Q9YTtmPXA7bD0tMTt1PS0xfWVsc2V7Zis9cDtsPWE7aD1pO3U9dH1lbHNlIGlmKGYrcD5yKWlmKC0xIT09bCl7Yy5wdXNoKGUuc3Vic3RyaW5nKGQsaCkpO2Q9aDt0PXUrMTtsPS0xO2Y9MH1lbHNle2MucHVzaChlLnN1YnN0cmluZyhkLGEpKTtkPWE7Zj1wfWVsc2UgZis9cH1kPGUubGVuZ3RoJiZjLnB1c2goZS5zdWJzdHJpbmcoZCxlLmxlbmd0aCkpO3JldHVybiBjfWFzeW5jIGV4dHJhY3RUZXh0Q29udGVudChlLHQsYSl7YXdhaXQgc3VwZXIuZXh0cmFjdFRleHRDb250ZW50KGUsdCxhKTtjb25zdCByPXRoaXMuZGF0YS50ZXh0Q29udGVudDtpZighcilyZXR1cm47Y29uc3QgaT1yLmpvaW4oIlxuIik7aWYoaT09PXRoaXMuZGF0YS5maWVsZFZhbHVlKXJldHVybjtjb25zdCBuPWkucmVwbGFjZUFsbCgvKFsuKis/XiR7fSgpfFtcXVxcXSl8KFxzKykvZywoKGUsdCk9PnQ/YFxcJHt0fWA6IlxccysiKSk7bmV3IFJlZ0V4cChgXlxccyoke259XFxzKiRgKS50ZXN0KHRoaXMuZGF0YS5maWVsZFZhbHVlKSYmKHRoaXMuZGF0YS50ZXh0Q29udGVudD10aGlzLmRhdGEuZmllbGRWYWx1ZS5zcGxpdCgiXG4iKSl9Z2V0RmllbGRPYmplY3QoKXtyZXR1cm57aWQ6dGhpcy5kYXRhLmlkLHZhbHVlOnRoaXMuZGF0YS5maWVsZFZhbHVlLGRlZmF1bHRWYWx1ZTp0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWV8fCIiLG11bHRpbGluZTp0aGlzLmRhdGEubXVsdGlMaW5lLHBhc3N3b3JkOnRoaXMuZGF0YS5wYXNzd29yZCxjaGFyTGltaXQ6dGhpcy5kYXRhLm1heExlbixjb21iOnRoaXMuZGF0YS5jb21iLGVkaXRhYmxlOiF0aGlzLmRhdGEucmVhZE9ubHksaGlkZGVuOnRoaXMuZGF0YS5oaWRkZW4sbmFtZTp0aGlzLmRhdGEuZmllbGROYW1lLHJlY3Q6dGhpcy5kYXRhLnJlY3QsYWN0aW9uczp0aGlzLmRhdGEuYWN0aW9ucyxwYWdlOnRoaXMuZGF0YS5wYWdlSW5kZXgsc3Ryb2tlQ29sb3I6dGhpcy5kYXRhLmJvcmRlckNvbG9yLGZpbGxDb2xvcjp0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yLHJvdGF0aW9uOnRoaXMucm90YXRpb24sZGF0ZXRpbWVGb3JtYXQ6dGhpcy5kYXRhLmRhdGV0aW1lRm9ybWF0LGhhc0RhdGV0aW1lSFRNTDohIXRoaXMuZGF0YS5kYXRldGltZVR5cGUsdHlwZToidGV4dCJ9fX1jbGFzcyBCdXR0b25XaWRnZXRBbm5vdGF0aW9uIGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmNoZWNrZWRBcHBlYXJhbmNlPW51bGw7dGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlPW51bGw7Y29uc3QgdD10aGlzLmhhc0ZpZWxkRmxhZyhIKSxhPXRoaXMuaGFzRmllbGRGbGFnKFcpO3RoaXMuZGF0YS5jaGVja0JveD0hdCYmIWE7dGhpcy5kYXRhLnJhZGlvQnV0dG9uPXQmJiFhO3RoaXMuZGF0YS5wdXNoQnV0dG9uPWE7dGhpcy5kYXRhLmlzVG9vbHRpcE9ubHk9ITE7aWYodGhpcy5kYXRhLmNoZWNrQm94KXRoaXMuX3Byb2Nlc3NDaGVja0JveChlKTtlbHNlIGlmKHRoaXMuZGF0YS5yYWRpb0J1dHRvbil0aGlzLl9wcm9jZXNzUmFkaW9CdXR0b24oZSk7ZWxzZSBpZih0aGlzLmRhdGEucHVzaEJ1dHRvbil7dGhpcy5kYXRhLmhhc093bkNhbnZhcz0hMDt0aGlzLmRhdGEubm9IVE1MPSExO3RoaXMuX3Byb2Nlc3NQdXNoQnV0dG9uKGUpfWVsc2Ugd2FybigiSW52YWxpZCBmaWVsZCBmbGFncyBmb3IgYnV0dG9uIHdpZGdldCBhbm5vdGF0aW9uIil9YXN5bmMgZ2V0T3BlcmF0b3JMaXN0KGUsdCxhLHIpe2lmKHRoaXMuZGF0YS5wdXNoQnV0dG9uKXJldHVybiBzdXBlci5nZXRPcGVyYXRvckxpc3QoZSx0LGEsITEscik7bGV0IGk9bnVsbCxuPW51bGw7aWYocil7Y29uc3QgZT1yLmdldCh0aGlzLmRhdGEuaWQpO2k9ZT9lLnZhbHVlOm51bGw7bj1lP2Uucm90YXRpb246bnVsbH1pZihudWxsPT09aSYmdGhpcy5hcHBlYXJhbmNlKXJldHVybiBzdXBlci5nZXRPcGVyYXRvckxpc3QoZSx0LGEscik7bnVsbD09aSYmKGk9dGhpcy5kYXRhLmNoZWNrQm94P3RoaXMuZGF0YS5maWVsZFZhbHVlPT09dGhpcy5kYXRhLmV4cG9ydFZhbHVlOnRoaXMuZGF0YS5maWVsZFZhbHVlPT09dGhpcy5kYXRhLmJ1dHRvblZhbHVlKTtjb25zdCBzPWk/dGhpcy5jaGVja2VkQXBwZWFyYW5jZTp0aGlzLnVuY2hlY2tlZEFwcGVhcmFuY2U7aWYocyl7Y29uc3QgaT10aGlzLmFwcGVhcmFuY2Usbz1sb29rdXBNYXRyaXgocy5kaWN0LmdldEFycmF5KCJNYXRyaXgiKSxsYSk7biYmcy5kaWN0LnNldCgiTWF0cml4Iix0aGlzLmdldFJvdGF0aW9uTWF0cml4KHIpKTt0aGlzLmFwcGVhcmFuY2U9cztjb25zdCBjPXN1cGVyLmdldE9wZXJhdG9yTGlzdChlLHQsYSxyKTt0aGlzLmFwcGVhcmFuY2U9aTtzLmRpY3Quc2V0KCJNYXRyaXgiLG8pO3JldHVybiBjfXJldHVybntvcExpc3Q6bmV3IE9wZXJhdG9yTGlzdCxzZXBhcmF0ZUZvcm06ITEsc2VwYXJhdGVDYW52YXM6ITF9fWFzeW5jIHNhdmUoZSx0LGEscil7dGhpcy5kYXRhLmNoZWNrQm94P3RoaXMuX3NhdmVDaGVja2JveChlLHQsYSxyKTp0aGlzLmRhdGEucmFkaW9CdXR0b24mJnRoaXMuX3NhdmVSYWRpb0J1dHRvbihlLHQsYSxyKX1hc3luYyBfc2F2ZUNoZWNrYm94KGUsdCxhLHIpe2lmKCFhKXJldHVybjtjb25zdCBpPWEuZ2V0KHRoaXMuZGF0YS5pZCksbj10aGlzLl9idWlsZEZsYWdzKGk/Lm5vVmlldyxpPy5ub1ByaW50KTtsZXQgcz1pPy5yb3RhdGlvbixvPWk/LnZhbHVlO2lmKHZvaWQgMD09PXMmJnZvaWQgMD09PW4pe2lmKHZvaWQgMD09PW8pcmV0dXJuO2lmKHRoaXMuZGF0YS5maWVsZFZhbHVlPT09dGhpcy5kYXRhLmV4cG9ydFZhbHVlPT09bylyZXR1cm59bGV0IGM9ZS54cmVmLmZldGNoSWZSZWYodGhpcy5yZWYpO2lmKCEoYyBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtjPWMuY2xvbmUoKTt2b2lkIDA9PT1zJiYocz10aGlzLnJvdGF0aW9uKTt2b2lkIDA9PT1vJiYobz10aGlzLmRhdGEuZmllbGRWYWx1ZT09PXRoaXMuZGF0YS5leHBvcnRWYWx1ZSk7Y29uc3QgbD17cGF0aDp0aGlzLmRhdGEuZmllbGROYW1lLHZhbHVlOm8/dGhpcy5kYXRhLmV4cG9ydFZhbHVlOiIifSxoPU5hbWUuZ2V0KG8/dGhpcy5kYXRhLmV4cG9ydFZhbHVlOiJPZmYiKTt0aGlzLnNldFZhbHVlKGMsaCxlLnhyZWYscik7Yy5zZXQoIkFTIixoKTtjLnNldCgiTSIsYEQ6JHtnZXRNb2RpZmljYXRpb25EYXRlKCl9YCk7dm9pZCAwIT09biYmYy5zZXQoIkYiLG4pO2NvbnN0IHU9dGhpcy5fZ2V0TUtEaWN0KHMpO3UmJmMuc2V0KCJNSyIsdSk7ci5wdXQodGhpcy5yZWYse2RhdGE6Yyx4ZmE6bCxuZWVkQXBwZWFyYW5jZXM6ITF9KX1hc3luYyBfc2F2ZVJhZGlvQnV0dG9uKGUsdCxhLHIpe2lmKCFhKXJldHVybjtjb25zdCBpPWEuZ2V0KHRoaXMuZGF0YS5pZCksbj10aGlzLl9idWlsZEZsYWdzKGk/Lm5vVmlldyxpPy5ub1ByaW50KTtsZXQgcz1pPy5yb3RhdGlvbixvPWk/LnZhbHVlO2lmKHZvaWQgMD09PXMmJnZvaWQgMD09PW4pe2lmKHZvaWQgMD09PW8pcmV0dXJuO2lmKHRoaXMuZGF0YS5maWVsZFZhbHVlPT09dGhpcy5kYXRhLmJ1dHRvblZhbHVlPT09bylyZXR1cm59bGV0IGM9ZS54cmVmLmZldGNoSWZSZWYodGhpcy5yZWYpO2lmKCEoYyBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtjPWMuY2xvbmUoKTt2b2lkIDA9PT1vJiYobz10aGlzLmRhdGEuZmllbGRWYWx1ZT09PXRoaXMuZGF0YS5idXR0b25WYWx1ZSk7dm9pZCAwPT09cyYmKHM9dGhpcy5yb3RhdGlvbik7Y29uc3QgbD17cGF0aDp0aGlzLmRhdGEuZmllbGROYW1lLHZhbHVlOm8/dGhpcy5kYXRhLmJ1dHRvblZhbHVlOiIifSxoPU5hbWUuZ2V0KG8/dGhpcy5kYXRhLmJ1dHRvblZhbHVlOiJPZmYiKTtvJiZ0aGlzLnNldFZhbHVlKGMsaCxlLnhyZWYscik7Yy5zZXQoIkFTIixoKTtjLnNldCgiTSIsYEQ6JHtnZXRNb2RpZmljYXRpb25EYXRlKCl9YCk7dm9pZCAwIT09biYmYy5zZXQoIkYiLG4pO2NvbnN0IHU9dGhpcy5fZ2V0TUtEaWN0KHMpO3UmJmMuc2V0KCJNSyIsdSk7ci5wdXQodGhpcy5yZWYse2RhdGE6Yyx4ZmE6bCxuZWVkQXBwZWFyYW5jZXM6ITF9KX1fZ2V0RGVmYXVsdENoZWNrZWRBcHBlYXJhbmNlKGUsdCl7Y29uc3R7d2lkdGg6YSxoZWlnaHQ6cn09dGhpcyxpPVswLDAsYSxyXSxuPS44Kk1hdGgubWluKGEscik7bGV0IHMsbztpZigiY2hlY2siPT09dCl7cz17d2lkdGg6Ljc1NSpuLGhlaWdodDouNzA1Km59O289IjMifWVsc2UgaWYoImRpc2MiPT09dCl7cz17d2lkdGg6Ljc5MSpuLGhlaWdodDouNzA1Km59O289ImwifWVsc2UgdW5yZWFjaGFibGUoYF9nZXREZWZhdWx0Q2hlY2tlZEFwcGVhcmFuY2UgLSB1bnN1cHBvcnRlZCB0eXBlOiAke3R9YCk7Y29uc3QgYz1gcSBCVCAvUGRmSnNaYURiICR7bn0gVGYgMCBnICR7bnVtYmVyVG9TdHJpbmcoKGEtcy53aWR0aCkvMil9ICR7bnVtYmVyVG9TdHJpbmcoKHItcy5oZWlnaHQpLzIpfSBUZCAoJHtvfSkgVGogRVQgUWAsbD1uZXcgRGljdChlLnhyZWYpO2wuc2V0KCJGb3JtVHlwZSIsMSk7bC5zZXRJZk5hbWUoIlN1YnR5cGUiLCJGb3JtIik7bC5zZXRJZk5hbWUoIlR5cGUiLCJYT2JqZWN0Iik7bC5zZXQoIkJCb3giLGkpO2wuc2V0KCJNYXRyaXgiLFsxLDAsMCwxLDAsMF0pO2wuc2V0KCJMZW5ndGgiLGMubGVuZ3RoKTtjb25zdCBoPW5ldyBEaWN0KGUueHJlZiksdT1uZXcgRGljdChlLnhyZWYpO3Uuc2V0KCJQZGZKc1phRGIiLHRoaXMuZmFsbGJhY2tGb250RGljdCk7aC5zZXQoIkZvbnQiLHUpO2wuc2V0KCJSZXNvdXJjZXMiLGgpO3RoaXMuY2hlY2tlZEFwcGVhcmFuY2U9bmV3IFN0cmluZ1N0cmVhbShjKTt0aGlzLmNoZWNrZWRBcHBlYXJhbmNlLmRpY3Q9bDt0aGlzLl9zdHJlYW1zLnB1c2godGhpcy5jaGVja2VkQXBwZWFyYW5jZSl9X3Byb2Nlc3NDaGVja0JveChlKXtjb25zdCB0PWUuZGljdC5nZXQoIkFQIik7aWYoISh0IGluc3RhbmNlb2YgRGljdCkpcmV0dXJuO2NvbnN0IGE9dC5nZXQoIk4iKTtpZighKGEgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm47Y29uc3Qgcj10aGlzLl9kZWNvZGVGb3JtVmFsdWUoZS5kaWN0LmdldCgiQVMiKSk7InN0cmluZyI9PXR5cGVvZiByJiYodGhpcy5kYXRhLmZpZWxkVmFsdWU9cik7Y29uc3QgaT1udWxsIT09dGhpcy5kYXRhLmZpZWxkVmFsdWUmJiJPZmYiIT09dGhpcy5kYXRhLmZpZWxkVmFsdWU/dGhpcy5kYXRhLmZpZWxkVmFsdWU6IlllcyIsbj10aGlzLl9kZWNvZGVGb3JtVmFsdWUoYS5nZXRLZXlzKCkpO2lmKDA9PT1uLmxlbmd0aCluLnB1c2goIk9mZiIsaSk7ZWxzZSBpZigxPT09bi5sZW5ndGgpIk9mZiI9PT1uWzBdP24ucHVzaChpKTpuLnVuc2hpZnQoIk9mZiIpO2Vsc2UgaWYobi5pbmNsdWRlcyhpKSl7bi5sZW5ndGg9MDtuLnB1c2goIk9mZiIsaSl9ZWxzZXtjb25zdCBlPW4uZmluZCgoZT0+Ik9mZiIhPT1lKSk7bi5sZW5ndGg9MDtuLnB1c2goIk9mZiIsZSl9bi5pbmNsdWRlcyh0aGlzLmRhdGEuZmllbGRWYWx1ZSl8fCh0aGlzLmRhdGEuZmllbGRWYWx1ZT0iT2ZmIik7dGhpcy5kYXRhLmV4cG9ydFZhbHVlPW5bMV07Y29uc3Qgcz1hLmdldCh0aGlzLmRhdGEuZXhwb3J0VmFsdWUpO3RoaXMuY2hlY2tlZEFwcGVhcmFuY2U9cyBpbnN0YW5jZW9mIEJhc2VTdHJlYW0/czpudWxsO2NvbnN0IG89YS5nZXQoIk9mZiIpO3RoaXMudW5jaGVja2VkQXBwZWFyYW5jZT1vIGluc3RhbmNlb2YgQmFzZVN0cmVhbT9vOm51bGw7dGhpcy5jaGVja2VkQXBwZWFyYW5jZT90aGlzLl9zdHJlYW1zLnB1c2godGhpcy5jaGVja2VkQXBwZWFyYW5jZSk6dGhpcy5fZ2V0RGVmYXVsdENoZWNrZWRBcHBlYXJhbmNlKGUsImNoZWNrIik7dGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlJiZ0aGlzLl9zdHJlYW1zLnB1c2godGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlKTt0aGlzLl9mYWxsYmFja0ZvbnREaWN0PXRoaXMuZmFsbGJhY2tGb250RGljdDtudWxsPT09dGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlJiYodGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlPSJPZmYiKX1fcHJvY2Vzc1JhZGlvQnV0dG9uKGUpe3RoaXMuZGF0YS5idXR0b25WYWx1ZT1udWxsO2NvbnN0IHQ9ZS5kaWN0LmdldCgiUGFyZW50Iik7aWYodCBpbnN0YW5jZW9mIERpY3Qpe3RoaXMucGFyZW50PWUuZGljdC5nZXRSYXcoIlBhcmVudCIpO2NvbnN0IGE9dC5nZXQoIlYiKTthIGluc3RhbmNlb2YgTmFtZSYmKHRoaXMuZGF0YS5maWVsZFZhbHVlPXRoaXMuX2RlY29kZUZvcm1WYWx1ZShhKSl9Y29uc3QgYT1lLmRpY3QuZ2V0KCJBUCIpO2lmKCEoYSBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtjb25zdCByPWEuZ2V0KCJOIik7aWYoIShyIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuO2Zvcihjb25zdCBlIG9mIHIuZ2V0S2V5cygpKWlmKCJPZmYiIT09ZSl7dGhpcy5kYXRhLmJ1dHRvblZhbHVlPXRoaXMuX2RlY29kZUZvcm1WYWx1ZShlKTticmVha31jb25zdCBpPXIuZ2V0KHRoaXMuZGF0YS5idXR0b25WYWx1ZSk7dGhpcy5jaGVja2VkQXBwZWFyYW5jZT1pIGluc3RhbmNlb2YgQmFzZVN0cmVhbT9pOm51bGw7Y29uc3Qgbj1yLmdldCgiT2ZmIik7dGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlPW4gaW5zdGFuY2VvZiBCYXNlU3RyZWFtP246bnVsbDt0aGlzLmNoZWNrZWRBcHBlYXJhbmNlP3RoaXMuX3N0cmVhbXMucHVzaCh0aGlzLmNoZWNrZWRBcHBlYXJhbmNlKTp0aGlzLl9nZXREZWZhdWx0Q2hlY2tlZEFwcGVhcmFuY2UoZSwiZGlzYyIpO3RoaXMudW5jaGVja2VkQXBwZWFyYW5jZSYmdGhpcy5fc3RyZWFtcy5wdXNoKHRoaXMudW5jaGVja2VkQXBwZWFyYW5jZSk7dGhpcy5fZmFsbGJhY2tGb250RGljdD10aGlzLmZhbGxiYWNrRm9udERpY3Q7bnVsbD09PXRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSYmKHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZT0iT2ZmIil9X3Byb2Nlc3NQdXNoQnV0dG9uKGUpe2NvbnN0e2RpY3Q6dCxhbm5vdGF0aW9uR2xvYmFsczphfT1lO2lmKHQuaGFzKCJBIil8fHQuaGFzKCJBQSIpfHx0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0KXt0aGlzLmRhdGEuaXNUb29sdGlwT25seT0hdC5oYXMoIkEiKSYmIXQuaGFzKCJBQSIpO0NhdGFsb2cucGFyc2VEZXN0RGljdGlvbmFyeSh7ZGVzdERpY3Q6dCxyZXN1bHRPYmo6dGhpcy5kYXRhLGRvY0Jhc2VVcmw6YS5iYXNlVXJsLGRvY0F0dGFjaG1lbnRzOmEuYXR0YWNobWVudHN9KX1lbHNlIHdhcm4oIlB1c2ggYnV0dG9ucyB3aXRob3V0IGFjdGlvbiBkaWN0aW9uYXJpZXMgYXJlIG5vdCBzdXBwb3J0ZWQiKX1nZXRGaWVsZE9iamVjdCgpe2xldCBlLHQ9ImJ1dHRvbiI7aWYodGhpcy5kYXRhLmNoZWNrQm94KXt0PSJjaGVja2JveCI7ZT10aGlzLmRhdGEuZXhwb3J0VmFsdWV9ZWxzZSBpZih0aGlzLmRhdGEucmFkaW9CdXR0b24pe3Q9InJhZGlvYnV0dG9uIjtlPXRoaXMuZGF0YS5idXR0b25WYWx1ZX1yZXR1cm57aWQ6dGhpcy5kYXRhLmlkLHZhbHVlOnRoaXMuZGF0YS5maWVsZFZhbHVlfHwiT2ZmIixkZWZhdWx0VmFsdWU6dGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlLGV4cG9ydFZhbHVlczplLGVkaXRhYmxlOiF0aGlzLmRhdGEucmVhZE9ubHksbmFtZTp0aGlzLmRhdGEuZmllbGROYW1lLHJlY3Q6dGhpcy5kYXRhLnJlY3QsaGlkZGVuOnRoaXMuZGF0YS5oaWRkZW4sYWN0aW9uczp0aGlzLmRhdGEuYWN0aW9ucyxwYWdlOnRoaXMuZGF0YS5wYWdlSW5kZXgsc3Ryb2tlQ29sb3I6dGhpcy5kYXRhLmJvcmRlckNvbG9yLGZpbGxDb2xvcjp0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yLHJvdGF0aW9uOnRoaXMucm90YXRpb24sdHlwZTp0fX1nZXQgZmFsbGJhY2tGb250RGljdCgpe2NvbnN0IGU9bmV3IERpY3Q7ZS5zZXRJZk5hbWUoIkJhc2VGb250IiwiWmFwZkRpbmdiYXRzIik7ZS5zZXRJZk5hbWUoIlR5cGUiLCJGYWxsYmFja1R5cGUiKTtlLnNldElmTmFtZSgiU3VidHlwZSIsIkZhbGxiYWNrVHlwZSIpO2Uuc2V0SWZOYW1lKCJFbmNvZGluZyIsIlphcGZEaW5nYmF0c0VuY29kaW5nIik7cmV0dXJuIHNoYWRvdyh0aGlzLCJmYWxsYmFja0ZvbnREaWN0IixlKX19Y2xhc3MgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbiBleHRlbmRzIFdpZGdldEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0LHhyZWY6YX09ZTt0aGlzLmluZGljZXM9dC5nZXRBcnJheSgiSSIpO3RoaXMuaGFzSW5kaWNlcz1BcnJheS5pc0FycmF5KHRoaXMuaW5kaWNlcykmJnRoaXMuaW5kaWNlcy5sZW5ndGg+MDt0aGlzLmRhdGEub3B0aW9ucz1bXTtjb25zdCByPWdldEluaGVyaXRhYmxlUHJvcGVydHkoe2RpY3Q6dCxrZXk6Ik9wdCJ9KTtpZihBcnJheS5pc0FycmF5KHIpKWZvcihsZXQgZT0wLHQ9ci5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1hLmZldGNoSWZSZWYocltlXSksaT1BcnJheS5pc0FycmF5KHQpO3RoaXMuZGF0YS5vcHRpb25zW2VdPXtleHBvcnRWYWx1ZTp0aGlzLl9kZWNvZGVGb3JtVmFsdWUoaT9hLmZldGNoSWZSZWYodFswXSk6dCksZGlzcGxheVZhbHVlOnRoaXMuX2RlY29kZUZvcm1WYWx1ZShpP2EuZmV0Y2hJZlJlZih0WzFdKTp0KX19aWYodGhpcy5oYXNJbmRpY2VzKXt0aGlzLmRhdGEuZmllbGRWYWx1ZT1bXTtjb25zdCBlPXRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtmb3IoY29uc3QgdCBvZiB0aGlzLmluZGljZXMpTnVtYmVyLmlzSW50ZWdlcih0KSYmdD49MCYmdDxlJiZ0aGlzLmRhdGEuZmllbGRWYWx1ZS5wdXNoKHRoaXMuZGF0YS5vcHRpb25zW3RdLmV4cG9ydFZhbHVlKX1lbHNlInN0cmluZyI9PXR5cGVvZiB0aGlzLmRhdGEuZmllbGRWYWx1ZT90aGlzLmRhdGEuZmllbGRWYWx1ZT1bdGhpcy5kYXRhLmZpZWxkVmFsdWVdOnRoaXMuZGF0YS5maWVsZFZhbHVlfHw9W107MD09PXRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aCYmdGhpcy5kYXRhLmZpZWxkVmFsdWUubGVuZ3RoPjAmJih0aGlzLmRhdGEub3B0aW9ucz10aGlzLmRhdGEuZmllbGRWYWx1ZS5tYXAoKGU9Pih7ZXhwb3J0VmFsdWU6ZSxkaXNwbGF5VmFsdWU6ZX0pKSkpO3RoaXMuZGF0YS5jb21ibz10aGlzLmhhc0ZpZWxkRmxhZyh6KTt0aGlzLmRhdGEubXVsdGlTZWxlY3Q9dGhpcy5oYXNGaWVsZEZsYWcoRyk7dGhpcy5faGFzVGV4dD0hMH1nZXRGaWVsZE9iamVjdCgpe2NvbnN0IGU9dGhpcy5kYXRhLmNvbWJvPyJjb21ib2JveCI6Imxpc3Rib3giLHQ9dGhpcy5kYXRhLmZpZWxkVmFsdWUubGVuZ3RoPjA/dGhpcy5kYXRhLmZpZWxkVmFsdWVbMF06bnVsbDtyZXR1cm57aWQ6dGhpcy5kYXRhLmlkLHZhbHVlOnQsZGVmYXVsdFZhbHVlOnRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSxlZGl0YWJsZTohdGhpcy5kYXRhLnJlYWRPbmx5LG5hbWU6dGhpcy5kYXRhLmZpZWxkTmFtZSxyZWN0OnRoaXMuZGF0YS5yZWN0LG51bUl0ZW1zOnRoaXMuZGF0YS5maWVsZFZhbHVlLmxlbmd0aCxtdWx0aXBsZVNlbGVjdGlvbjp0aGlzLmRhdGEubXVsdGlTZWxlY3QsaGlkZGVuOnRoaXMuZGF0YS5oaWRkZW4sYWN0aW9uczp0aGlzLmRhdGEuYWN0aW9ucyxpdGVtczp0aGlzLmRhdGEub3B0aW9ucyxwYWdlOnRoaXMuZGF0YS5wYWdlSW5kZXgsc3Ryb2tlQ29sb3I6dGhpcy5kYXRhLmJvcmRlckNvbG9yLGZpbGxDb2xvcjp0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yLHJvdGF0aW9uOnRoaXMucm90YXRpb24sdHlwZTplfX1hbWVuZFNhdmVkRGljdChlLHQpe2lmKCF0aGlzLmhhc0luZGljZXMpcmV0dXJuO2xldCBhPWU/LmdldCh0aGlzLmRhdGEuaWQpPy52YWx1ZTtBcnJheS5pc0FycmF5KGEpfHwoYT1bYV0pO2NvbnN0IHI9W10se29wdGlvbnM6aX09dGhpcy5kYXRhO2ZvcihsZXQgZT0wLHQ9MCxuPWkubGVuZ3RoO2U8bjtlKyspaWYoaVtlXS5leHBvcnRWYWx1ZT09PWFbdF0pe3IucHVzaChlKTt0Kz0xfXQuc2V0KCJJIixyKX1hc3luYyBfZ2V0QXBwZWFyYW5jZShlLHQscixpKXtpZih0aGlzLmRhdGEuY29tYm8pcmV0dXJuIHN1cGVyLl9nZXRBcHBlYXJhbmNlKGUsdCxyLGkpO2xldCBuLHM7Y29uc3Qgbz1pPy5nZXQodGhpcy5kYXRhLmlkKTtpZihvKXtzPW8ucm90YXRpb247bj1vLnZhbHVlfWlmKHZvaWQgMD09PXMmJnZvaWQgMD09PW4mJiF0aGlzLl9uZWVkQXBwZWFyYW5jZXMpcmV0dXJuIG51bGw7dm9pZCAwPT09bj9uPXRoaXMuZGF0YS5maWVsZFZhbHVlOkFycmF5LmlzQXJyYXkobil8fChuPVtuXSk7bGV0e3dpZHRoOmMsaGVpZ2h0Omx9PXRoaXM7OTAhPT1zJiYyNzAhPT1zfHwoW2MsbF09W2wsY10pO2NvbnN0IGg9dGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoLHU9W107Zm9yKGxldCBlPTA7ZTxoO2UrKyl7Y29uc3R7ZXhwb3J0VmFsdWU6dH09dGhpcy5kYXRhLm9wdGlvbnNbZV07bi5pbmNsdWRlcyh0KSYmdS5wdXNoKGUpfXRoaXMuX2RlZmF1bHRBcHBlYXJhbmNlfHwodGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YT1wYXJzZURlZmF1bHRBcHBlYXJhbmNlKHRoaXMuX2RlZmF1bHRBcHBlYXJhbmNlPSIvSGVsdmV0aWNhIDAgVGYgMCBnIikpO2NvbnN0IGQ9YXdhaXQgV2lkZ2V0QW5ub3RhdGlvbi5fZ2V0Rm9udERhdGEoZSx0LHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEsdGhpcy5fZmllbGRSZXNvdXJjZXMubWVyZ2VkUmVzb3VyY2VzKTtsZXQgZix7Zm9udFNpemU6Z309dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTtpZihnKWY9dGhpcy5fZGVmYXVsdEFwcGVhcmFuY2U7ZWxzZXtjb25zdCBlPShsLTEpL2g7bGV0IHQsYT0tMTtmb3IoY29uc3R7ZGlzcGxheVZhbHVlOmV9b2YgdGhpcy5kYXRhLm9wdGlvbnMpe2NvbnN0IHI9dGhpcy5fZ2V0VGV4dFdpZHRoKGUsZCk7aWYocj5hKXthPXI7dD1lfX1bZixnXT10aGlzLl9jb21wdXRlRm9udFNpemUoZSxjLTQsdCxkLC0xKX1jb25zdCBwPWcqYSxtPShwLWcpLzIsYj1NYXRoLmZsb29yKGwvcCk7bGV0IHk9MDtpZih1Lmxlbmd0aD4wKXtjb25zdCBlPU1hdGgubWluKC4uLnUpLHQ9TWF0aC5tYXgoLi4udSk7eT1NYXRoLm1heCgwLHQtYisxKTt5PmUmJih5PWUpfWNvbnN0IHc9TWF0aC5taW4oeStiKzEsaCkseD1bIi9UeCBCTUMgcSIsYDEgMSAke2N9ICR7bH0gcmUgVyBuYF07aWYodS5sZW5ndGgpe3gucHVzaCgiMC42MDAwMDYgMC43NTY4NjYgMC44NTQ5MDQgcmciKTtmb3IoY29uc3QgZSBvZiB1KXk8PWUmJmU8dyYmeC5wdXNoKGAxICR7bC0oZS15KzEpKnB9ICR7Y30gJHtwfSByZSBmYCl9eC5wdXNoKCJCVCIsZixgMSAwIDAgMSAwICR7bH0gVG1gKTtjb25zdCBTPXtzaGlmdDowfTtmb3IobGV0IGU9eTtlPHc7ZSsrKXtjb25zdHtkaXNwbGF5VmFsdWU6dH09dGhpcy5kYXRhLm9wdGlvbnNbZV0sYT1lPT09eT9tOjA7eC5wdXNoKHRoaXMuX3JlbmRlclRleHQodCxkLGcsYywwLFMsMiwtcCthKSl9eC5wdXNoKCJFVCBRIEVNQyIpO3JldHVybiB4LmpvaW4oIlxuIil9fWNsYXNzIFNpZ25hdHVyZVdpZGdldEFubm90YXRpb24gZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5maWVsZFZhbHVlPW51bGw7dGhpcy5kYXRhLmhhc093bkNhbnZhcz10aGlzLmRhdGEubm9Sb3RhdGU7dGhpcy5kYXRhLm5vSFRNTD0hdGhpcy5kYXRhLmhhc093bkNhbnZhc31nZXRGaWVsZE9iamVjdCgpe3JldHVybntpZDp0aGlzLmRhdGEuaWQsdmFsdWU6bnVsbCxwYWdlOnRoaXMuZGF0YS5wYWdlSW5kZXgsdHlwZToic2lnbmF0dXJlIn19fWNsYXNzIFRleHRBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEubm9Sb3RhdGU9ITA7dGhpcy5kYXRhLmhhc093bkNhbnZhcz10aGlzLmRhdGEubm9Sb3RhdGU7dGhpcy5kYXRhLm5vSFRNTD0hMTtjb25zdHtkaWN0OnR9PWU7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPUYuVEVYVDtpZih0aGlzLmRhdGEuaGFzQXBwZWFyYW5jZSl0aGlzLmRhdGEubmFtZT0iTm9JY29uIjtlbHNle3RoaXMuZGF0YS5yZWN0WzFdPXRoaXMuZGF0YS5yZWN0WzNdLTIyO3RoaXMuZGF0YS5yZWN0WzJdPXRoaXMuZGF0YS5yZWN0WzBdKzIyO3RoaXMuZGF0YS5uYW1lPXQuaGFzKCJOYW1lIik/dC5nZXQoIk5hbWUiKS5uYW1lOiJOb3RlIn1pZih0LmhhcygiU3RhdGUiKSl7dGhpcy5kYXRhLnN0YXRlPXQuZ2V0KCJTdGF0ZSIpfHxudWxsO3RoaXMuZGF0YS5zdGF0ZU1vZGVsPXQuZ2V0KCJTdGF0ZU1vZGVsIil8fG51bGx9ZWxzZXt0aGlzLmRhdGEuc3RhdGU9bnVsbDt0aGlzLmRhdGEuc3RhdGVNb2RlbD1udWxsfX19Y2xhc3MgTGlua0Fubm90YXRpb24gZXh0ZW5kcyBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0e2RpY3Q6dCxhbm5vdGF0aW9uR2xvYmFsczphfT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1GLkxJTks7dGhpcy5kYXRhLm5vSFRNTD0hMTtjb25zdCByPWdldFF1YWRQb2ludHModCx0aGlzLnJlY3RhbmdsZSk7ciYmKHRoaXMuZGF0YS5xdWFkUG9pbnRzPXIpO3RoaXMuZGF0YS5ib3JkZXJDb2xvcnx8PXRoaXMuZGF0YS5jb2xvcjtDYXRhbG9nLnBhcnNlRGVzdERpY3Rpb25hcnkoe2Rlc3REaWN0OnQscmVzdWx0T2JqOnRoaXMuZGF0YSxkb2NCYXNlVXJsOmEuYmFzZVVybCxkb2NBdHRhY2htZW50czphLmF0dGFjaG1lbnRzfSl9Z2V0IG92ZXJsYXlzVGV4dENvbnRlbnQoKXtyZXR1cm4hMH19Y2xhc3MgUG9wdXBBbm5vdGF0aW9uIGV4dGVuZHMgQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnR9PWU7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPUYuUE9QVVA7dGhpcy5kYXRhLm5vSFRNTD0hMTswIT09dGhpcy53aWR0aCYmMCE9PXRoaXMuaGVpZ2h0fHwodGhpcy5kYXRhLnJlY3Q9bnVsbCk7bGV0IGE9dC5nZXQoIlBhcmVudCIpO2lmKCFhKXt3YXJuKCJQb3B1cCBhbm5vdGF0aW9uIGhhcyBhIG1pc3Npbmcgb3IgaW52YWxpZCBwYXJlbnQgYW5ub3RhdGlvbi4iKTtyZXR1cm59dGhpcy5kYXRhLnBhcmVudFJlY3Q9bG9va3VwTm9ybWFsUmVjdChhLmdldEFycmF5KCJSZWN0IiksbnVsbCk7dGhpcy5kYXRhLmNyZWF0aW9uRGF0ZT1hLmdldCgiQ3JlYXRpb25EYXRlIil8fCIiO2lzTmFtZShhLmdldCgiUlQiKSxUKSYmKGE9YS5nZXQoIklSVCIpKTtpZihhLmhhcygiTSIpKXt0aGlzLnNldE1vZGlmaWNhdGlvbkRhdGUoYS5nZXQoIk0iKSk7dGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGU9dGhpcy5tb2RpZmljYXRpb25EYXRlfWVsc2UgdGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGU9bnVsbDtpZihhLmhhcygiQyIpKXt0aGlzLnNldENvbG9yKGEuZ2V0QXJyYXkoIkMiKSk7dGhpcy5kYXRhLmNvbG9yPXRoaXMuY29sb3J9ZWxzZSB0aGlzLmRhdGEuY29sb3I9bnVsbDtpZighdGhpcy52aWV3YWJsZSl7Y29uc3QgZT1hLmdldCgiRiIpO3RoaXMuX2lzVmlld2FibGUoZSkmJnRoaXMuc2V0RmxhZ3MoZSl9dGhpcy5zZXRUaXRsZShhLmdldCgiVCIpKTt0aGlzLmRhdGEudGl0bGVPYmo9dGhpcy5fdGl0bGU7dGhpcy5zZXRDb250ZW50cyhhLmdldCgiQ29udGVudHMiKSk7dGhpcy5kYXRhLmNvbnRlbnRzT2JqPXRoaXMuX2NvbnRlbnRzO2EuaGFzKCJSQyIpJiYodGhpcy5kYXRhLnJpY2hUZXh0PVhGQUZhY3RvcnkuZ2V0UmljaFRleHRBc0h0bWwoYS5nZXQoIlJDIikpKTt0aGlzLmRhdGEub3Blbj0hIXQuZ2V0KCJPcGVuIil9c3RhdGljIGNyZWF0ZU5ld0RpY3QoZSx0LGEpe2NvbnN0e29sZEFubm90YXRpb246cixyZWN0OmkscGFyZW50Om59PWUscz1yfHxuZXcgRGljdCh0KTtzLnNldElmTm90RXhpc3RzKCJUeXBlIixOYW1lLmdldCgiQW5ub3QiKSk7cy5zZXRJZk5vdEV4aXN0cygiU3VidHlwZSIsTmFtZS5nZXQoIlBvcHVwIikpO3Muc2V0SWZOb3RFeGlzdHMoIk9wZW4iLCExKTtzLnNldElmQXJyYXkoIlJlY3QiLGkpO3Muc2V0KCJQYXJlbnQiLG4pO3JldHVybiBzfXN0YXRpYyBhc3luYyBjcmVhdGVOZXdBcHBlYXJhbmNlU3RyZWFtKGUsdCxhKXtyZXR1cm4gbnVsbH19Y2xhc3MgRnJlZVRleHRBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuZGF0YS5ub1JvdGF0ZTt0aGlzLmRhdGEuaXNFZGl0YWJsZT0hdGhpcy5kYXRhLm5vSFRNTDt0aGlzLmRhdGEubm9IVE1MPSExO2NvbnN0e2Fubm90YXRpb25HbG9iYWxzOnQsZXZhbHVhdG9yT3B0aW9uczphLHhyZWY6cn09ZTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9Ri5GUkVFVEVYVDt0aGlzLnNldERlZmF1bHRBcHBlYXJhbmNlKGUpO3RoaXMuX2hhc0FwcGVhcmFuY2U9ISF0aGlzLmFwcGVhcmFuY2U7aWYodGhpcy5faGFzQXBwZWFyYW5jZSl7Y29uc3R7Zm9udENvbG9yOmUsZm9udFNpemU6aX09ZnVuY3Rpb24gcGFyc2VBcHBlYXJhbmNlU3RyZWFtKGUsdCxhLHIpe3JldHVybiBuZXcgQXBwZWFyYW5jZVN0cmVhbUV2YWx1YXRvcihlLHQsYSxyKS5wYXJzZSgpfSh0aGlzLmFwcGVhcmFuY2UsYSxyLHQuZ2xvYmFsQ29sb3JTcGFjZUNhY2hlKTt0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRDb2xvcj1lO3RoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEuZm9udFNpemU9aXx8MTB9ZWxzZXt0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRTaXplfHw9MTA7Y29uc3R7Zm9udENvbG9yOnQsZm9udFNpemU6YX09dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTtpZih0aGlzLl9jb250ZW50cy5zdHIpe3RoaXMuZGF0YS50ZXh0Q29udGVudD10aGlzLl9jb250ZW50cy5zdHIuc3BsaXQoL1xyXG4/fFxuLykubWFwKChlPT5lLnRyaW1FbmQoKSkpO2NvbnN0e2Nvb3JkczplLGJib3g6dCxtYXRyaXg6cn09RmFrZVVuaWNvZGVGb250LmdldEZpcnN0UG9zaXRpb25JbmZvKHRoaXMucmVjdGFuZ2xlLHRoaXMucm90YXRpb24sYSk7dGhpcy5kYXRhLnRleHRQb3NpdGlvbj10aGlzLl90cmFuc2Zvcm1Qb2ludChlLHQscil9aWYodGhpcy5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpe2NvbnN0IGk9ZS5kaWN0LmdldCgiQ0EiKSxuPW5ldyBGYWtlVW5pY29kZUZvbnQociwic2Fucy1zZXJpZiIpO3RoaXMuYXBwZWFyYW5jZT1uLmNyZWF0ZUFwcGVhcmFuY2UodGhpcy5fY29udGVudHMuc3RyLHRoaXMucmVjdGFuZ2xlLHRoaXMucm90YXRpb24sYSx0LGkpO3RoaXMuX3N0cmVhbXMucHVzaCh0aGlzLmFwcGVhcmFuY2UpfWVsc2Ugd2FybigiRnJlZVRleHRBbm5vdGF0aW9uOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZCwgYW5ub3RhdGlvbiBtYXkgbm90IHJlbmRlciBjb3JyZWN0bHkuIil9fWdldCBoYXNUZXh0Q29udGVudCgpe3JldHVybiB0aGlzLl9oYXNBcHBlYXJhbmNlfXN0YXRpYyBjcmVhdGVOZXdEaWN0KGUsdCx7YXBSZWY6YSxhcDpyfSl7Y29uc3R7Y29sb3I6aSxkYXRlOm4sZm9udFNpemU6cyxvbGRBbm5vdGF0aW9uOm8scmVjdDpjLHJvdGF0aW9uOmwsdXNlcjpoLHZhbHVlOnV9PWUsZD1vfHxuZXcgRGljdCh0KTtkLnNldElmTm90RXhpc3RzKCJUeXBlIixOYW1lLmdldCgiQW5ub3QiKSk7ZC5zZXRJZk5vdEV4aXN0cygiU3VidHlwZSIsTmFtZS5nZXQoIkZyZWVUZXh0IikpO2Quc2V0KG8/Ik0iOiJDcmVhdGlvbkRhdGUiLGBEOiR7Z2V0TW9kaWZpY2F0aW9uRGF0ZShuKX1gKTtvJiZkLmRlbGV0ZSgiUkMiKTtkLnNldElmQXJyYXkoIlJlY3QiLGMpO2NvbnN0IGY9YC9IZWx2ICR7c30gVGYgJHtnZXRQZGZDb2xvcihpLCEwKX1gO2Quc2V0KCJEQSIsZik7ZC5zZXRJZkRlZmluZWQoIkNvbnRlbnRzIixzdHJpbmdUb0FzY2lpT3JVVEYxNkJFKHUpKTtkLnNldElmTm90RXhpc3RzKCJGIiw0KTtkLnNldElmTm90RXhpc3RzKCJCb3JkZXIiLFswLDAsMF0pO2Quc2V0SWZOdW1iZXIoIlJvdGF0ZSIsbCk7ZC5zZXRJZkRlZmluZWQoIlQiLHN0cmluZ1RvQXNjaWlPclVURjE2QkUoaCkpO2lmKGF8fHIpe2NvbnN0IGU9bmV3IERpY3QodCk7ZC5zZXQoIkFQIixlKTtlLnNldCgiTiIsYXx8cil9cmV0dXJuIGR9c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW0oZSx0LHIpe2NvbnN0e2Jhc2VGb250UmVmOmksZXZhbHVhdG9yOm4sdGFzazpzfT1yLHtjb2xvcjpvLGZvbnRTaXplOmMscmVjdDpsLHJvdGF0aW9uOmgsdmFsdWU6dX09ZTtpZighbylyZXR1cm4gbnVsbDtjb25zdCBkPW5ldyBEaWN0KHQpLGY9bmV3IERpY3QodCk7aWYoaSlmLnNldCgiSGVsdiIsaSk7ZWxzZXtjb25zdCBlPW5ldyBEaWN0KHQpO2Uuc2V0SWZOYW1lKCJCYXNlRm9udCIsIkhlbHZldGljYSIpO2Uuc2V0SWZOYW1lKCJUeXBlIiwiRm9udCIpO2Uuc2V0SWZOYW1lKCJTdWJ0eXBlIiwiVHlwZTEiKTtlLnNldElmTmFtZSgiRW5jb2RpbmciLCJXaW5BbnNpRW5jb2RpbmciKTtmLnNldCgiSGVsdiIsZSl9ZC5zZXQoIkZvbnQiLGYpO2NvbnN0IGc9YXdhaXQgV2lkZ2V0QW5ub3RhdGlvbi5fZ2V0Rm9udERhdGEobixzLHtmb250TmFtZToiSGVsdiIsZm9udFNpemU6Y30sZCksW3AsbSxiLHldPWw7bGV0IHc9Yi1wLHg9eS1tO2glMTgwIT0wJiYoW3cseF09W3gsd10pO2NvbnN0IFM9dS5zcGxpdCgiXG4iKSxrPWMvMWUzO2xldCBDPS0xLzA7Y29uc3Qgdj1bXTtmb3IobGV0IGUgb2YgUyl7Y29uc3QgdD1nLmVuY29kZVN0cmluZyhlKTtpZih0Lmxlbmd0aD4xKXJldHVybiBudWxsO2U9dC5qb2luKCIiKTt2LnB1c2goZSk7bGV0IGE9MDtjb25zdCByPWcuY2hhcnNUb0dseXBocyhlKTtmb3IoY29uc3QgZSBvZiByKWErPWUud2lkdGgqaztDPU1hdGgubWF4KEMsYSl9bGV0IEY9MTtDPncmJihGPXcvQyk7bGV0IFQ9MTtjb25zdCBPPWEqYyxNPTEqYyxEPU8qUy5sZW5ndGg7RD54JiYoVD14L0QpO2NvbnN0IFI9YypNYXRoLm1pbihGLFQpO2xldCBOLEUsTDtzd2l0Y2goaCl7Y2FzZSAwOkw9WzEsMCwwLDFdO0U9W2xbMF0sbFsxXSx3LHhdO049W2xbMF0sbFszXS1NXTticmVhaztjYXNlIDkwOkw9WzAsMSwtMSwwXTtFPVtsWzFdLC1sWzJdLHcseF07Tj1bbFsxXSwtbFswXS1NXTticmVhaztjYXNlIDE4MDpMPVstMSwwLDAsLTFdO0U9Wy1sWzJdLC1sWzNdLHcseF07Tj1bLWxbMl0sLWxbMV0tTV07YnJlYWs7Y2FzZSAyNzA6TD1bMCwtMSwxLDBdO0U9Wy1sWzNdLGxbMF0sdyx4XTtOPVstbFszXSxsWzJdLU1dfWNvbnN0IGo9WyJxIixgJHtMLmpvaW4oIiAiKX0gMCAwIGNtYCxgJHtFLmpvaW4oIiAiKX0gcmUgVyBuYCwiQlQiLGAke2dldFBkZkNvbG9yKG8sITApfWAsYDAgVGMgL0hlbHYgJHtudW1iZXJUb1N0cmluZyhSKX0gVGZgXTtqLnB1c2goYCR7Ti5qb2luKCIgIil9IFRkICgke2VzY2FwZVN0cmluZyh2WzBdKX0pIFRqYCk7Y29uc3QgXz1udW1iZXJUb1N0cmluZyhPKTtmb3IobGV0IGU9MSx0PXYubGVuZ3RoO2U8dDtlKyspe2NvbnN0IHQ9dltlXTtqLnB1c2goYDAgLSR7X30gVGQgKCR7ZXNjYXBlU3RyaW5nKHQpfSkgVGpgKX1qLnB1c2goIkVUIiwiUSIpO2NvbnN0IFU9ai5qb2luKCJcbiIpLFg9bmV3IERpY3QodCk7WC5zZXQoIkZvcm1UeXBlIiwxKTtYLnNldElmTmFtZSgiU3VidHlwZSIsIkZvcm0iKTtYLnNldElmTmFtZSgiVHlwZSIsIlhPYmplY3QiKTtYLnNldCgiQkJveCIsbCk7WC5zZXQoIlJlc291cmNlcyIsZCk7WC5zZXQoIk1hdHJpeCIsWzEsMCwwLDEsLWxbMF0sLWxbMV1dKTtjb25zdCBxPW5ldyBTdHJpbmdTdHJlYW0oVSk7cS5kaWN0PVg7cmV0dXJuIHF9fWNsYXNzIExpbmVBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnQseHJlZjphfT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1GLkxJTkU7dGhpcy5kYXRhLmhhc093bkNhbnZhcz10aGlzLmRhdGEubm9Sb3RhdGU7dGhpcy5kYXRhLm5vSFRNTD0hMTtjb25zdCByPWxvb2t1cFJlY3QodC5nZXRBcnJheSgiTCIpLFswLDAsMCwwXSk7dGhpcy5kYXRhLmxpbmVDb29yZGluYXRlcz1VdGlsLm5vcm1hbGl6ZVJlY3Qocik7dGhpcy5zZXRMaW5lRW5kaW5ncyh0LmdldEFycmF5KCJMRSIpKTt0aGlzLmRhdGEubGluZUVuZGluZ3M9dGhpcy5saW5lRW5kaW5ncztpZighdGhpcy5hcHBlYXJhbmNlKXtjb25zdCBlPWdldFBkZkNvbG9yQXJyYXkodGhpcy5jb2xvcixbMCwwLDBdKSxpPXQuZ2V0KCJDQSIpLG49Z2V0UGRmQ29sb3JBcnJheShnZXRSZ2JDb2xvcih0LmdldEFycmF5KCJJQyIpLG51bGwpKSxzPW4/aTpudWxsLG89dGhpcy5ib3JkZXJTdHlsZS53aWR0aHx8MSxjPTIqbyxsPVt0aGlzLmRhdGEubGluZUNvb3JkaW5hdGVzWzBdLWMsdGhpcy5kYXRhLmxpbmVDb29yZGluYXRlc1sxXS1jLHRoaXMuZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0rYyx0aGlzLmRhdGEubGluZUNvb3JkaW5hdGVzWzNdK2NdO1V0aWwuaW50ZXJzZWN0KHRoaXMucmVjdGFuZ2xlLGwpfHwodGhpcy5yZWN0YW5nbGU9bCk7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6YSxleHRyYTpgJHtvfSB3YCxzdHJva2VDb2xvcjplLGZpbGxDb2xvcjpuLHN0cm9rZUFscGhhOmksZmlsbEFscGhhOnMscG9pbnRzQ2FsbGJhY2s6KGUsdCk9PntlLnB1c2goYCR7clswXX0gJHtyWzFdfSBtYCxgJHtyWzJdfSAke3JbM119IGxgLCJTIik7cmV0dXJuW3RbMF0tbyx0WzddLW8sdFsyXStvLHRbM10rb119fSl9fX1jbGFzcyBTcXVhcmVBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnQseHJlZjphfT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1GLlNRVUFSRTt0aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuZGF0YS5ub1JvdGF0ZTt0aGlzLmRhdGEubm9IVE1MPSExO2lmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IGU9Z2V0UGRmQ29sb3JBcnJheSh0aGlzLmNvbG9yLFswLDAsMF0pLHI9dC5nZXQoIkNBIiksaT1nZXRQZGZDb2xvckFycmF5KGdldFJnYkNvbG9yKHQuZ2V0QXJyYXkoIklDIiksbnVsbCkpLG49aT9yOm51bGw7aWYoMD09PXRoaXMuYm9yZGVyU3R5bGUud2lkdGgmJiFpKXJldHVybjt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjphLGV4dHJhOmAke3RoaXMuYm9yZGVyU3R5bGUud2lkdGh9IHdgLHN0cm9rZUNvbG9yOmUsZmlsbENvbG9yOmksc3Ryb2tlQWxwaGE6cixmaWxsQWxwaGE6bixwb2ludHNDYWxsYmFjazooZSx0KT0+e2NvbnN0IGE9dFs0XSt0aGlzLmJvcmRlclN0eWxlLndpZHRoLzIscj10WzVdK3RoaXMuYm9yZGVyU3R5bGUud2lkdGgvMixuPXRbNl0tdFs0XS10aGlzLmJvcmRlclN0eWxlLndpZHRoLHM9dFszXS10WzddLXRoaXMuYm9yZGVyU3R5bGUud2lkdGg7ZS5wdXNoKGAke2F9ICR7cn0gJHtufSAke3N9IHJlYCk7aT9lLnB1c2goIkIiKTplLnB1c2goIlMiKTtyZXR1cm5bdFswXSx0WzddLHRbMl0sdFszXV19fSl9fX1jbGFzcyBDaXJjbGVBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnQseHJlZjphfT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1GLkNJUkNMRTtpZighdGhpcy5hcHBlYXJhbmNlKXtjb25zdCBlPWdldFBkZkNvbG9yQXJyYXkodGhpcy5jb2xvcixbMCwwLDBdKSxyPXQuZ2V0KCJDQSIpLGk9Z2V0UGRmQ29sb3JBcnJheShnZXRSZ2JDb2xvcih0LmdldEFycmF5KCJJQyIpLG51bGwpKSxuPWk/cjpudWxsO2lmKDA9PT10aGlzLmJvcmRlclN0eWxlLndpZHRoJiYhaSlyZXR1cm47Y29uc3Qgcz00LzMqTWF0aC50YW4oTWF0aC5QSS84KTt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjphLGV4dHJhOmAke3RoaXMuYm9yZGVyU3R5bGUud2lkdGh9IHdgLHN0cm9rZUNvbG9yOmUsZmlsbENvbG9yOmksc3Ryb2tlQWxwaGE6cixmaWxsQWxwaGE6bixwb2ludHNDYWxsYmFjazooZSx0KT0+e2NvbnN0IGE9dFswXSt0aGlzLmJvcmRlclN0eWxlLndpZHRoLzIscj10WzFdLXRoaXMuYm9yZGVyU3R5bGUud2lkdGgvMixuPXRbNl0tdGhpcy5ib3JkZXJTdHlsZS53aWR0aC8yLG89dFs3XSt0aGlzLmJvcmRlclN0eWxlLndpZHRoLzIsYz1hKyhuLWEpLzIsbD1yKyhvLXIpLzIsaD0obi1hKS8yKnMsdT0oby1yKS8yKnM7ZS5wdXNoKGAke2N9ICR7b30gbWAsYCR7YytofSAke299ICR7bn0gJHtsK3V9ICR7bn0gJHtsfSBjYCxgJHtufSAke2wtdX0gJHtjK2h9ICR7cn0gJHtjfSAke3J9IGNgLGAke2MtaH0gJHtyfSAke2F9ICR7bC11fSAke2F9ICR7bH0gY2AsYCR7YX0gJHtsK3V9ICR7Yy1ofSAke299ICR7Y30gJHtvfSBjYCwiaCIpO2k/ZS5wdXNoKCJCIik6ZS5wdXNoKCJTIik7cmV0dXJuW3RbMF0sdFs3XSx0WzJdLHRbM11dfX0pfX19Y2xhc3MgUG9seWxpbmVBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnQseHJlZjphfT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1GLlBPTFlMSU5FO3RoaXMuZGF0YS5oYXNPd25DYW52YXM9dGhpcy5kYXRhLm5vUm90YXRlO3RoaXMuZGF0YS5ub0hUTUw9ITE7dGhpcy5kYXRhLnZlcnRpY2VzPW51bGw7aWYoISh0aGlzIGluc3RhbmNlb2YgUG9seWdvbkFubm90YXRpb24pKXt0aGlzLnNldExpbmVFbmRpbmdzKHQuZ2V0QXJyYXkoIkxFIikpO3RoaXMuZGF0YS5saW5lRW5kaW5ncz10aGlzLmxpbmVFbmRpbmdzfWNvbnN0IHI9dC5nZXRBcnJheSgiVmVydGljZXMiKTtpZighaXNOdW1iZXJBcnJheShyLG51bGwpKXJldHVybjtjb25zdCBpPXRoaXMuZGF0YS52ZXJ0aWNlcz1GbG9hdDMyQXJyYXkuZnJvbShyKTtpZighdGhpcy5hcHBlYXJhbmNlKXtjb25zdCBlPWdldFBkZkNvbG9yQXJyYXkodGhpcy5jb2xvcixbMCwwLDBdKSxyPXQuZ2V0KCJDQSIpO2xldCBuLHM9Z2V0UmdiQ29sb3IodC5nZXRBcnJheSgiSUMiKSxudWxsKTtzJiYocz1nZXRQZGZDb2xvckFycmF5KHMpKTtuPXM/dGhpcy5jb2xvcj9zLmV2ZXJ5KCgodCxhKT0+dD09PWVbYV0pKT8iZiI6IkIiOiJmIjoiUyI7Y29uc3Qgbz10aGlzLmJvcmRlclN0eWxlLndpZHRofHwxLGM9MipvLGw9WzEvMCwxLzAsLTEvMCwtMS8wXTtmb3IobGV0IGU9MCx0PWkubGVuZ3RoO2U8dDtlKz0yKVV0aWwucmVjdEJvdW5kaW5nQm94KGlbZV0tYyxpW2UrMV0tYyxpW2VdK2MsaVtlKzFdK2MsbCk7VXRpbC5pbnRlcnNlY3QodGhpcy5yZWN0YW5nbGUsbCl8fCh0aGlzLnJlY3RhbmdsZT1sKTt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjphLGV4dHJhOmAke299IHdgLHN0cm9rZUNvbG9yOmUsc3Ryb2tlQWxwaGE6cixmaWxsQ29sb3I6cyxmaWxsQWxwaGE6cz9yOm51bGwscG9pbnRzQ2FsbGJhY2s6KGUsdCk9Pntmb3IobGV0IHQ9MCxhPWkubGVuZ3RoO3Q8YTt0Kz0yKWUucHVzaChgJHtpW3RdfSAke2lbdCsxXX0gJHswPT09dD8ibSI6ImwifWApO2UucHVzaChuKTtyZXR1cm5bdFswXSx0WzddLHRbMl0sdFszXV19fSl9fX1jbGFzcyBQb2x5Z29uQW5ub3RhdGlvbiBleHRlbmRzIFBvbHlsaW5lQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9Ri5QT0xZR09OfX1jbGFzcyBDYXJldEFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1GLkNBUkVUfX1jbGFzcyBJbmtBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuZGF0YS5ub1JvdGF0ZTt0aGlzLmRhdGEubm9IVE1MPSExO2NvbnN0e2RpY3Q6dCx4cmVmOmF9PWU7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPUYuSU5LO3RoaXMuZGF0YS5pbmtMaXN0cz1bXTt0aGlzLmRhdGEuaXNFZGl0YWJsZT0hdGhpcy5kYXRhLm5vSFRNTDt0aGlzLmRhdGEubm9IVE1MPSExO3RoaXMuZGF0YS5vcGFjaXR5PXQuZ2V0KCJDQSIpfHwxO2NvbnN0IHI9dC5nZXRBcnJheSgiSW5rTGlzdCIpO2lmKEFycmF5LmlzQXJyYXkocikpe2ZvcihsZXQgZT0wLHQ9ci5sZW5ndGg7ZTx0OysrZSl7aWYoIUFycmF5LmlzQXJyYXkocltlXSkpY29udGludWU7Y29uc3QgdD1uZXcgRmxvYXQzMkFycmF5KHJbZV0ubGVuZ3RoKTt0aGlzLmRhdGEuaW5rTGlzdHMucHVzaCh0KTtmb3IobGV0IGk9MCxuPXJbZV0ubGVuZ3RoO2k8bjtpKz0yKXtjb25zdCBuPWEuZmV0Y2hJZlJlZihyW2VdW2ldKSxzPWEuZmV0Y2hJZlJlZihyW2VdW2krMV0pO2lmKCJudW1iZXIiPT10eXBlb2YgbiYmIm51bWJlciI9PXR5cGVvZiBzKXt0W2ldPW47dFtpKzFdPXN9fX1pZighdGhpcy5hcHBlYXJhbmNlKXtjb25zdCBlPWdldFBkZkNvbG9yQXJyYXkodGhpcy5jb2xvcixbMCwwLDBdKSxyPXQuZ2V0KCJDQSIpLGk9dGhpcy5ib3JkZXJTdHlsZS53aWR0aHx8MSxuPTIqaSxzPVsxLzAsMS8wLC0xLzAsLTEvMF07Zm9yKGNvbnN0IGUgb2YgdGhpcy5kYXRhLmlua0xpc3RzKWZvcihsZXQgdD0wLGE9ZS5sZW5ndGg7dDxhO3QrPTIpVXRpbC5yZWN0Qm91bmRpbmdCb3goZVt0XS1uLGVbdCsxXS1uLGVbdF0rbixlW3QrMV0rbixzKTtVdGlsLmludGVyc2VjdCh0aGlzLnJlY3RhbmdsZSxzKXx8KHRoaXMucmVjdGFuZ2xlPXMpO3RoaXMuX3NldERlZmF1bHRBcHBlYXJhbmNlKHt4cmVmOmEsZXh0cmE6YCR7aX0gd2Asc3Ryb2tlQ29sb3I6ZSxzdHJva2VBbHBoYTpyLHBvaW50c0NhbGxiYWNrOihlLHQpPT57Zm9yKGNvbnN0IHQgb2YgdGhpcy5kYXRhLmlua0xpc3RzKXtmb3IobGV0IGE9MCxyPXQubGVuZ3RoO2E8cjthKz0yKWUucHVzaChgJHt0W2FdfSAke3RbYSsxXX0gJHswPT09YT8ibSI6ImwifWApO2UucHVzaCgiUyIpfXJldHVyblt0WzBdLHRbN10sdFsyXSx0WzNdXX19KX19fXN0YXRpYyBjcmVhdGVOZXdEaWN0KGUsdCx7YXBSZWY6YSxhcDpyfSl7Y29uc3R7b2xkQW5ub3RhdGlvbjppLGNvbG9yOm4sZGF0ZTpzLG9wYWNpdHk6byxwYXRoczpjLG91dGxpbmVzOmwscmVjdDpoLHJvdGF0aW9uOnUsdGhpY2tuZXNzOmQsdXNlcjpmfT1lLGc9aXx8bmV3IERpY3QodCk7Zy5zZXRJZk5vdEV4aXN0cygiVHlwZSIsTmFtZS5nZXQoIkFubm90IikpO2cuc2V0SWZOb3RFeGlzdHMoIlN1YnR5cGUiLE5hbWUuZ2V0KCJJbmsiKSk7Zy5zZXQoaT8iTSI6IkNyZWF0aW9uRGF0ZSIsYEQ6JHtnZXRNb2RpZmljYXRpb25EYXRlKHMpfWApO2cuc2V0SWZBcnJheSgiUmVjdCIsaCk7Zy5zZXRJZkFycmF5KCJJbmtMaXN0IixsPy5wb2ludHN8fGM/LnBvaW50cyk7Zy5zZXRJZk5vdEV4aXN0cygiRiIsNCk7Zy5zZXRJZk51bWJlcigiUm90YXRlIix1KTtnLnNldElmRGVmaW5lZCgiVCIsc3RyaW5nVG9Bc2NpaU9yVVRGMTZCRShmKSk7bCYmZy5zZXRJZk5hbWUoIklUIiwiSW5rSGlnaGxpZ2h0Iik7aWYoZD4wKXtjb25zdCBlPW5ldyBEaWN0KHQpO2cuc2V0KCJCUyIsZSk7ZS5zZXQoIlciLGQpfWcuc2V0SWZBcnJheSgiQyIsZ2V0UGRmQ29sb3JBcnJheShuKSk7Zy5zZXRJZk51bWJlcigiQ0EiLG8pO2lmKHJ8fGEpe2NvbnN0IGU9bmV3IERpY3QodCk7Zy5zZXQoIkFQIixlKTtlLnNldCgiTiIsYXx8cil9cmV0dXJuIGd9c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW0oZSx0LGEpe2lmKGUub3V0bGluZXMpcmV0dXJuIHRoaXMuY3JlYXRlTmV3QXBwZWFyYW5jZVN0cmVhbUZvckhpZ2hsaWdodChlLHQsYSk7Y29uc3R7Y29sb3I6cixyZWN0OmkscGF0aHM6bix0aGlja25lc3M6cyxvcGFjaXR5Om99PWU7aWYoIXIpcmV0dXJuIG51bGw7Y29uc3QgYz1bYCR7c30gdyAxIEogMSBqYCxgJHtnZXRQZGZDb2xvcihyLCExKX1gXTsxIT09byYmYy5wdXNoKCIvUjAgZ3MiKTtmb3IoY29uc3QgZSBvZiBuLmxpbmVzKXtjLnB1c2goYCR7bnVtYmVyVG9TdHJpbmcoZVs0XSl9ICR7bnVtYmVyVG9TdHJpbmcoZVs1XSl9IG1gKTtmb3IobGV0IHQ9NixhPWUubGVuZ3RoO3Q8YTt0Kz02KWlmKGlzTmFOKGVbdF0pKWMucHVzaChgJHtudW1iZXJUb1N0cmluZyhlW3QrNF0pfSAke251bWJlclRvU3RyaW5nKGVbdCs1XSl9IGxgKTtlbHNle2NvbnN0W2EscixpLG4scyxvXT1lLnNsaWNlKHQsdCs2KTtjLnB1c2goW2EscixpLG4scyxvXS5tYXAobnVtYmVyVG9TdHJpbmcpLmpvaW4oIiAiKSsiIGMiKX02PT09ZS5sZW5ndGgmJmMucHVzaChgJHtudW1iZXJUb1N0cmluZyhlWzRdKX0gJHtudW1iZXJUb1N0cmluZyhlWzVdKX0gbGApfWMucHVzaCgiUyIpO2NvbnN0IGw9Yy5qb2luKCJcbiIpLGg9bmV3IERpY3QodCk7aC5zZXQoIkZvcm1UeXBlIiwxKTtoLnNldElmTmFtZSgiU3VidHlwZSIsIkZvcm0iKTtoLnNldElmTmFtZSgiVHlwZSIsIlhPYmplY3QiKTtoLnNldCgiQkJveCIsaSk7aC5zZXQoIkxlbmd0aCIsbC5sZW5ndGgpO2lmKDEhPT1vKXtjb25zdCBlPW5ldyBEaWN0KHQpLGE9bmV3IERpY3QodCkscj1uZXcgRGljdCh0KTtyLnNldCgiQ0EiLG8pO3Iuc2V0SWZOYW1lKCJUeXBlIiwiRXh0R1N0YXRlIik7YS5zZXQoIlIwIixyKTtlLnNldCgiRXh0R1N0YXRlIixhKTtoLnNldCgiUmVzb3VyY2VzIixlKX1jb25zdCB1PW5ldyBTdHJpbmdTdHJlYW0obCk7dS5kaWN0PWg7cmV0dXJuIHV9c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW1Gb3JIaWdobGlnaHQoZSx0LGEpe2NvbnN0e2NvbG9yOnIscmVjdDppLG91dGxpbmVzOntvdXRsaW5lOm59LG9wYWNpdHk6c309ZTtpZighcilyZXR1cm4gbnVsbDtjb25zdCBvPVtgJHtnZXRQZGZDb2xvcihyLCEwKX1gLCIvUjAgZ3MiXTtvLnB1c2goYCR7bnVtYmVyVG9TdHJpbmcobls0XSl9ICR7bnVtYmVyVG9TdHJpbmcobls1XSl9IG1gKTtmb3IobGV0IGU9Nix0PW4ubGVuZ3RoO2U8dDtlKz02KWlmKGlzTmFOKG5bZV0pKW8ucHVzaChgJHtudW1iZXJUb1N0cmluZyhuW2UrNF0pfSAke251bWJlclRvU3RyaW5nKG5bZSs1XSl9IGxgKTtlbHNle2NvbnN0W3QsYSxyLGkscyxjXT1uLnNsaWNlKGUsZSs2KTtvLnB1c2goW3QsYSxyLGkscyxjXS5tYXAobnVtYmVyVG9TdHJpbmcpLmpvaW4oIiAiKSsiIGMiKX1vLnB1c2goImggZiIpO2NvbnN0IGM9by5qb2luKCJcbiIpLGw9bmV3IERpY3QodCk7bC5zZXQoIkZvcm1UeXBlIiwxKTtsLnNldElmTmFtZSgiU3VidHlwZSIsIkZvcm0iKTtsLnNldElmTmFtZSgiVHlwZSIsIlhPYmplY3QiKTtsLnNldCgiQkJveCIsaSk7bC5zZXQoIkxlbmd0aCIsYy5sZW5ndGgpO2NvbnN0IGg9bmV3IERpY3QodCksdT1uZXcgRGljdCh0KTtoLnNldCgiRXh0R1N0YXRlIix1KTtsLnNldCgiUmVzb3VyY2VzIixoKTtjb25zdCBkPW5ldyBEaWN0KHQpO3Uuc2V0KCJSMCIsZCk7ZC5zZXRJZk5hbWUoIkJNIiwiTXVsdGlwbHkiKTtpZigxIT09cyl7ZC5zZXQoImNhIixzKTtkLnNldElmTmFtZSgiVHlwZSIsIkV4dEdTdGF0ZSIpfWNvbnN0IGY9bmV3IFN0cmluZ1N0cmVhbShjKTtmLmRpY3Q9bDtyZXR1cm4gZn19Y2xhc3MgSGlnaGxpZ2h0QW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0LHhyZWY6YX09ZTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9Ri5ISUdITElHSFQ7dGhpcy5kYXRhLmlzRWRpdGFibGU9IXRoaXMuZGF0YS5ub0hUTUw7dGhpcy5kYXRhLm5vSFRNTD0hMTt0aGlzLmRhdGEub3BhY2l0eT10LmdldCgiQ0EiKXx8MTtpZih0aGlzLmRhdGEucXVhZFBvaW50cz1nZXRRdWFkUG9pbnRzKHQsbnVsbCkpe2NvbnN0IGU9dGhpcy5hcHBlYXJhbmNlPy5kaWN0LmdldCgiUmVzb3VyY2VzIik7aWYoIXRoaXMuYXBwZWFyYW5jZXx8IWU/LmhhcygiRXh0R1N0YXRlIikpe3RoaXMuYXBwZWFyYW5jZSYmd2FybigiSGlnaGxpZ2h0QW5ub3RhdGlvbiAtIGlnbm9yaW5nIGJ1aWx0LWluIGFwcGVhcmFuY2Ugc3RyZWFtLiIpO2NvbnN0IGU9Z2V0UGRmQ29sb3JBcnJheSh0aGlzLmNvbG9yLFsxLDEsMF0pLHI9dC5nZXQoIkNBIik7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6YSxmaWxsQ29sb3I6ZSxibGVuZE1vZGU6Ik11bHRpcGx5IixmaWxsQWxwaGE6cixwb2ludHNDYWxsYmFjazooZSx0KT0+e2UucHVzaChgJHt0WzBdfSAke3RbMV19IG1gLGAke3RbMl19ICR7dFszXX0gbGAsYCR7dFs2XX0gJHt0WzddfSBsYCxgJHt0WzRdfSAke3RbNV19IGxgLCJmIik7cmV0dXJuW3RbMF0sdFs3XSx0WzJdLHRbM11dfX0pfX1lbHNlIHRoaXMuZGF0YS5wb3B1cFJlZj1udWxsfWdldCBvdmVybGF5c1RleHRDb250ZW50KCl7cmV0dXJuITB9c3RhdGljIGNyZWF0ZU5ld0RpY3QoZSx0LHthcFJlZjphLGFwOnJ9KXtjb25zdHtjb2xvcjppLGRhdGU6bixvbGRBbm5vdGF0aW9uOnMsb3BhY2l0eTpvLHJlY3Q6Yyxyb3RhdGlvbjpsLHVzZXI6aCxxdWFkUG9pbnRzOnV9PWUsZD1zfHxuZXcgRGljdCh0KTtkLnNldElmTm90RXhpc3RzKCJUeXBlIixOYW1lLmdldCgiQW5ub3QiKSk7ZC5zZXRJZk5vdEV4aXN0cygiU3VidHlwZSIsTmFtZS5nZXQoIkhpZ2hsaWdodCIpKTtkLnNldChzPyJNIjoiQ3JlYXRpb25EYXRlIixgRDoke2dldE1vZGlmaWNhdGlvbkRhdGUobil9YCk7ZC5zZXRJZkFycmF5KCJSZWN0IixjKTtkLnNldElmTm90RXhpc3RzKCJGIiw0KTtkLnNldElmTm90RXhpc3RzKCJCb3JkZXIiLFswLDAsMF0pO2Quc2V0SWZOdW1iZXIoIlJvdGF0ZSIsbCk7ZC5zZXRJZkFycmF5KCJRdWFkUG9pbnRzIix1KTtkLnNldElmQXJyYXkoIkMiLGdldFBkZkNvbG9yQXJyYXkoaSkpO2Quc2V0SWZOdW1iZXIoIkNBIixvKTtkLnNldElmRGVmaW5lZCgiVCIsc3RyaW5nVG9Bc2NpaU9yVVRGMTZCRShoKSk7aWYoYXx8cil7Y29uc3QgZT1uZXcgRGljdCh0KTtkLnNldCgiQVAiLGUpO2Uuc2V0KCJOIixhfHxyKX1yZXR1cm4gZH1zdGF0aWMgYXN5bmMgY3JlYXRlTmV3QXBwZWFyYW5jZVN0cmVhbShlLHQsYSl7Y29uc3R7Y29sb3I6cixyZWN0Omksb3V0bGluZXM6bixvcGFjaXR5OnN9PWU7aWYoIXIpcmV0dXJuIG51bGw7Y29uc3Qgbz1bYCR7Z2V0UGRmQ29sb3IociwhMCl9YCwiL1IwIGdzIl0sYz1bXTtmb3IoY29uc3QgZSBvZiBuKXtjLmxlbmd0aD0wO2MucHVzaChgJHtudW1iZXJUb1N0cmluZyhlWzBdKX0gJHtudW1iZXJUb1N0cmluZyhlWzFdKX0gbWApO2ZvcihsZXQgdD0yLGE9ZS5sZW5ndGg7dDxhO3QrPTIpYy5wdXNoKGAke251bWJlclRvU3RyaW5nKGVbdF0pfSAke251bWJlclRvU3RyaW5nKGVbdCsxXSl9IGxgKTtjLnB1c2goImgiKTtvLnB1c2goYy5qb2luKCJcbiIpKX1vLnB1c2goImYqIik7Y29uc3QgbD1vLmpvaW4oIlxuIiksaD1uZXcgRGljdCh0KTtoLnNldCgiRm9ybVR5cGUiLDEpO2guc2V0SWZOYW1lKCJTdWJ0eXBlIiwiRm9ybSIpO2guc2V0SWZOYW1lKCJUeXBlIiwiWE9iamVjdCIpO2guc2V0KCJCQm94IixpKTtoLnNldCgiTGVuZ3RoIixsLmxlbmd0aCk7Y29uc3QgdT1uZXcgRGljdCh0KSxkPW5ldyBEaWN0KHQpO3Uuc2V0KCJFeHRHU3RhdGUiLGQpO2guc2V0KCJSZXNvdXJjZXMiLHUpO2NvbnN0IGY9bmV3IERpY3QodCk7ZC5zZXQoIlIwIixmKTtmLnNldElmTmFtZSgiQk0iLCJNdWx0aXBseSIpO2lmKDEhPT1zKXtmLnNldCgiY2EiLHMpO2Yuc2V0SWZOYW1lKCJUeXBlIiwiRXh0R1N0YXRlIil9Y29uc3QgZz1uZXcgU3RyaW5nU3RyZWFtKGwpO2cuZGljdD1oO3JldHVybiBnfX1jbGFzcyBVbmRlcmxpbmVBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnQseHJlZjphfT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1GLlVOREVSTElORTtpZih0aGlzLmRhdGEucXVhZFBvaW50cz1nZXRRdWFkUG9pbnRzKHQsbnVsbCkpe2lmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IGU9Z2V0UGRmQ29sb3JBcnJheSh0aGlzLmNvbG9yLFswLDAsMF0pLHI9dC5nZXQoIkNBIik7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6YSxleHRyYToiW10gMCBkIDAuNTcxIHciLHN0cm9rZUNvbG9yOmUsc3Ryb2tlQWxwaGE6cixwb2ludHNDYWxsYmFjazooZSx0KT0+e2UucHVzaChgJHt0WzRdfSAke3RbNV0rMS4zfSBtYCxgJHt0WzZdfSAke3RbN10rMS4zfSBsYCwiUyIpO3JldHVyblt0WzBdLHRbN10sdFsyXSx0WzNdXX19KX19ZWxzZSB0aGlzLmRhdGEucG9wdXBSZWY9bnVsbH1nZXQgb3ZlcmxheXNUZXh0Q29udGVudCgpe3JldHVybiEwfX1jbGFzcyBTcXVpZ2dseUFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0e2RpY3Q6dCx4cmVmOmF9PWU7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPUYuU1FVSUdHTFk7aWYodGhpcy5kYXRhLnF1YWRQb2ludHM9Z2V0UXVhZFBvaW50cyh0LG51bGwpKXtpZighdGhpcy5hcHBlYXJhbmNlKXtjb25zdCBlPWdldFBkZkNvbG9yQXJyYXkodGhpcy5jb2xvcixbMCwwLDBdKSxyPXQuZ2V0KCJDQSIpO3RoaXMuX3NldERlZmF1bHRBcHBlYXJhbmNlKHt4cmVmOmEsZXh0cmE6IltdIDAgZCAxIHciLHN0cm9rZUNvbG9yOmUsc3Ryb2tlQWxwaGE6cixwb2ludHNDYWxsYmFjazooZSx0KT0+e2NvbnN0IGE9KHRbMV0tdFs1XSkvNjtsZXQgcj1hLGk9dFs0XTtjb25zdCBuPXRbNV0scz10WzZdO2UucHVzaChgJHtpfSAke24rcn0gbWApO2Rve2krPTI7cj0wPT09cj9hOjA7ZS5wdXNoKGAke2l9ICR7bityfSBsYCl9d2hpbGUoaTxzKTtlLnB1c2goIlMiKTtyZXR1cm5bdFs0XSxuLTIqYSxzLG4rMiphXX19KX19ZWxzZSB0aGlzLmRhdGEucG9wdXBSZWY9bnVsbH1nZXQgb3ZlcmxheXNUZXh0Q29udGVudCgpe3JldHVybiEwfX1jbGFzcyBTdHJpa2VPdXRBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnQseHJlZjphfT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1GLlNUUklLRU9VVDtpZih0aGlzLmRhdGEucXVhZFBvaW50cz1nZXRRdWFkUG9pbnRzKHQsbnVsbCkpe2lmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IGU9Z2V0UGRmQ29sb3JBcnJheSh0aGlzLmNvbG9yLFswLDAsMF0pLHI9dC5nZXQoIkNBIik7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6YSxleHRyYToiW10gMCBkIDEgdyIsc3Ryb2tlQ29sb3I6ZSxzdHJva2VBbHBoYTpyLHBvaW50c0NhbGxiYWNrOihlLHQpPT57ZS5wdXNoKCh0WzBdK3RbNF0pLzIrIiAiKyh0WzFdK3RbNV0pLzIrIiBtIiwodFsyXSt0WzZdKS8yKyIgIisodFszXSt0WzddKS8yKyIgbCIsIlMiKTtyZXR1cm5bdFswXSx0WzddLHRbMl0sdFszXV19fSl9fWVsc2UgdGhpcy5kYXRhLnBvcHVwUmVmPW51bGx9Z2V0IG92ZXJsYXlzVGV4dENvbnRlbnQoKXtyZXR1cm4hMH19Y2xhc3MgU3RhbXBBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbnsjcGU9bnVsbDtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9Ri5TVEFNUDt0aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuZGF0YS5ub1JvdGF0ZTt0aGlzLmRhdGEuaXNFZGl0YWJsZT0hdGhpcy5kYXRhLm5vSFRNTDt0aGlzLmRhdGEubm9IVE1MPSExfW11c3RCZVZpZXdlZFdoZW5FZGl0aW5nKGUsdD1udWxsKXtpZihlKXtpZighdGhpcy5kYXRhLmlzRWRpdGFibGUpcmV0dXJuITA7dGhpcy4jcGU/Pz10aGlzLmRhdGEuaGFzT3duQ2FudmFzO3RoaXMuZGF0YS5oYXNPd25DYW52YXM9ITA7cmV0dXJuITB9aWYobnVsbCE9PXRoaXMuI3BlKXt0aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuI3BlO3RoaXMuI3BlPW51bGx9cmV0dXJuIXQ/Lmhhcyh0aGlzLmRhdGEuaWQpfXN0YXRpYyBhc3luYyBjcmVhdGVJbWFnZShlLHQpe2NvbnN0e3dpZHRoOmEsaGVpZ2h0OnJ9PWUsaT1uZXcgT2Zmc2NyZWVuQ2FudmFzKGEsciksbj1pLmdldENvbnRleHQoIjJkIix7YWxwaGE6ITB9KTtuLmRyYXdJbWFnZShlLDAsMCk7Y29uc3Qgcz1uLmdldEltYWdlRGF0YSgwLDAsYSxyKS5kYXRhLG89bmV3IFVpbnQzMkFycmF5KHMuYnVmZmVyKSxjPW8uc29tZShGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbj9lPT5lPj4+MjQhPTI1NTplPT4hISgyNTUmfmUpKTtpZihjKXtuLmZpbGxTdHlsZT0id2hpdGUiO24uZmlsbFJlY3QoMCwwLGEscik7bi5kcmF3SW1hZ2UoZSwwLDApfWNvbnN0IGw9aS5jb252ZXJ0VG9CbG9iKHt0eXBlOiJpbWFnZS9qcGVnIixxdWFsaXR5OjF9KS50aGVuKChlPT5lLmFycmF5QnVmZmVyKCkpKSxoPU5hbWUuZ2V0KCJYT2JqZWN0IiksdT1OYW1lLmdldCgiSW1hZ2UiKSxkPW5ldyBEaWN0KHQpO2Quc2V0KCJUeXBlIixoKTtkLnNldCgiU3VidHlwZSIsdSk7ZC5zZXQoIkJpdHNQZXJDb21wb25lbnQiLDgpO2Quc2V0SWZOYW1lKCJDb2xvclNwYWNlIiwiRGV2aWNlUkdCIik7ZC5zZXRJZk5hbWUoIkZpbHRlciIsIkRDVERlY29kZSIpO2Quc2V0KCJCQm94IixbMCwwLGEscl0pO2Quc2V0KCJXaWR0aCIsYSk7ZC5zZXQoIkhlaWdodCIscik7bGV0IGY9bnVsbDtpZihjKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KG8ubGVuZ3RoKTtpZihGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbilmb3IobGV0IHQ9MCxhPW8ubGVuZ3RoO3Q8YTt0KyspZVt0XT1vW3RdPj4+MjQ7ZWxzZSBmb3IobGV0IHQ9MCxhPW8ubGVuZ3RoO3Q8YTt0KyspZVt0XT0yNTUmb1t0XTtjb25zdCBpPW5ldyBEaWN0KHQpO2kuc2V0KCJUeXBlIixoKTtpLnNldCgiU3VidHlwZSIsdSk7aS5zZXQoIkJpdHNQZXJDb21wb25lbnQiLDgpO2kuc2V0SWZOYW1lKCJDb2xvclNwYWNlIiwiRGV2aWNlR3JheSIpO2kuc2V0KCJXaWR0aCIsYSk7aS5zZXQoIkhlaWdodCIscik7Zj1uZXcgU3RyZWFtKGUsMCwwLGkpfXJldHVybntpbWFnZVN0cmVhbTpuZXcgU3RyZWFtKGF3YWl0IGwsMCwwLGQpLHNtYXNrU3RyZWFtOmYsd2lkdGg6YSxoZWlnaHQ6cn19c3RhdGljIGNyZWF0ZU5ld0RpY3QoZSx0LHthcFJlZjphLGFwOnJ9KXtjb25zdHtkYXRlOmksb2xkQW5ub3RhdGlvbjpuLHJlY3Q6cyxyb3RhdGlvbjpvLHVzZXI6Y309ZSxsPW58fG5ldyBEaWN0KHQpO2wuc2V0SWZOb3RFeGlzdHMoIlR5cGUiLE5hbWUuZ2V0KCJBbm5vdCIpKTtsLnNldElmTm90RXhpc3RzKCJTdWJ0eXBlIixOYW1lLmdldCgiU3RhbXAiKSk7bC5zZXQobj8iTSI6IkNyZWF0aW9uRGF0ZSIsYEQ6JHtnZXRNb2RpZmljYXRpb25EYXRlKGkpfWApO2wuc2V0SWZBcnJheSgiUmVjdCIscyk7bC5zZXRJZk5vdEV4aXN0cygiRiIsNCk7bC5zZXRJZk5vdEV4aXN0cygiQm9yZGVyIixbMCwwLDBdKTtsLnNldElmTnVtYmVyKCJSb3RhdGUiLG8pO2wuc2V0SWZEZWZpbmVkKCJUIixzdHJpbmdUb0FzY2lpT3JVVEYxNkJFKGMpKTtpZihhfHxyKXtjb25zdCBlPW5ldyBEaWN0KHQpO2wuc2V0KCJBUCIsZSk7ZS5zZXQoIk4iLGF8fHIpfXJldHVybiBsfXN0YXRpYyBhc3luYyNtZShlLHQpe2NvbnN0e2FyZUNvbnRvdXJzOmEsY29sb3I6cixyZWN0OmksbGluZXM6bix0aGlja25lc3M6c309ZTtpZighcilyZXR1cm4gbnVsbDtjb25zdCBvPVtgJHtzfSB3IDEgSiAxIGpgLGAke2dldFBkZkNvbG9yKHIsYSl9YF07Zm9yKGNvbnN0IGUgb2Ygbil7by5wdXNoKGAke251bWJlclRvU3RyaW5nKGVbNF0pfSAke251bWJlclRvU3RyaW5nKGVbNV0pfSBtYCk7Zm9yKGxldCB0PTYsYT1lLmxlbmd0aDt0PGE7dCs9NilpZihpc05hTihlW3RdKSlvLnB1c2goYCR7bnVtYmVyVG9TdHJpbmcoZVt0KzRdKX0gJHtudW1iZXJUb1N0cmluZyhlW3QrNV0pfSBsYCk7ZWxzZXtjb25zdFthLHIsaSxuLHMsY109ZS5zbGljZSh0LHQrNik7by5wdXNoKFthLHIsaSxuLHMsY10ubWFwKG51bWJlclRvU3RyaW5nKS5qb2luKCIgIikrIiBjIil9Nj09PWUubGVuZ3RoJiZvLnB1c2goYCR7bnVtYmVyVG9TdHJpbmcoZVs0XSl9ICR7bnVtYmVyVG9TdHJpbmcoZVs1XSl9IGxgKX1vLnB1c2goYT8iRiI6IlMiKTtjb25zdCBjPW8uam9pbigiXG4iKSxsPW5ldyBEaWN0KHQpO2wuc2V0KCJGb3JtVHlwZSIsMSk7bC5zZXRJZk5hbWUoIlN1YnR5cGUiLCJGb3JtIik7bC5zZXRJZk5hbWUoIlR5cGUiLCJYT2JqZWN0Iik7bC5zZXQoIkJCb3giLGkpO2wuc2V0KCJMZW5ndGgiLGMubGVuZ3RoKTtjb25zdCBoPW5ldyBTdHJpbmdTdHJlYW0oYyk7aC5kaWN0PWw7cmV0dXJuIGh9c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW0oZSx0LGEpe2lmKGUub2xkQW5ub3RhdGlvbilyZXR1cm4gbnVsbDtpZihlLmlzU2lnbmF0dXJlKXJldHVybiB0aGlzLiNtZShlLHQpO2NvbnN0e3JvdGF0aW9uOnJ9PWUse2ltYWdlUmVmOmksd2lkdGg6bixoZWlnaHQ6c309YS5pbWFnZSxvPW5ldyBEaWN0KHQpLGM9bmV3IERpY3QodCk7by5zZXQoIlhPYmplY3QiLGMpO2Muc2V0KCJJbTAiLGkpO2NvbnN0IGw9YHEgJHtufSAwIDAgJHtzfSAwIDAgY20gL0ltMCBEbyBRYCxoPW5ldyBEaWN0KHQpO2guc2V0KCJGb3JtVHlwZSIsMSk7aC5zZXRJZk5hbWUoIlN1YnR5cGUiLCJGb3JtIik7aC5zZXRJZk5hbWUoIlR5cGUiLCJYT2JqZWN0Iik7aC5zZXQoIkJCb3giLFswLDAsbixzXSk7aC5zZXQoIlJlc291cmNlcyIsbyk7aWYocil7Y29uc3QgZT1nZXRSb3RhdGlvbk1hdHJpeChyLG4scyk7aC5zZXQoIk1hdHJpeCIsZSl9Y29uc3QgdT1uZXcgU3RyaW5nU3RyZWFtKGwpO3UuZGljdD1oO3JldHVybiB1fX1jbGFzcyBGaWxlQXR0YWNobWVudEFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0e2RpY3Q6dCx4cmVmOmF9PWUscj1uZXcgRmlsZVNwZWModC5nZXQoIkZTIiksYSk7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPUYuRklMRUFUVEFDSE1FTlQ7dGhpcy5kYXRhLmhhc093bkNhbnZhcz10aGlzLmRhdGEubm9Sb3RhdGU7dGhpcy5kYXRhLm5vSFRNTD0hMTt0aGlzLmRhdGEuZmlsZT1yLnNlcmlhbGl6YWJsZTtjb25zdCBpPXQuZ2V0KCJOYW1lIik7dGhpcy5kYXRhLm5hbWU9aSBpbnN0YW5jZW9mIE5hbWU/c3RyaW5nVG9QREZTdHJpbmcoaS5uYW1lKToiUHVzaFBpbiI7Y29uc3Qgbj10LmdldCgiY2EiKTt0aGlzLmRhdGEuZmlsbEFscGhhPSJudW1iZXIiPT10eXBlb2YgbiYmbj49MCYmbjw9MT9uOm51bGx9fWNvbnN0IFpvPXtnZXQgcigpe3JldHVybiBzaGFkb3codGhpcywiciIsbmV3IFVpbnQ4QXJyYXkoWzcsMTIsMTcsMjIsNywxMiwxNywyMiw3LDEyLDE3LDIyLDcsMTIsMTcsMjIsNSw5LDE0LDIwLDUsOSwxNCwyMCw1LDksMTQsMjAsNSw5LDE0LDIwLDQsMTEsMTYsMjMsNCwxMSwxNiwyMyw0LDExLDE2LDIzLDQsMTEsMTYsMjMsNiwxMCwxNSwyMSw2LDEwLDE1LDIxLDYsMTAsMTUsMjEsNiwxMCwxNSwyMV0pKX0sZ2V0IGsoKXtyZXR1cm4gc2hhZG93KHRoaXMsImsiLG5ldyBJbnQzMkFycmF5KFstNjgwODc2OTM2LC0zODk1NjQ1ODYsNjA2MTA1ODE5LC0xMDQ0NTI1MzMwLC0xNzY0MTg4OTcsMTIwMDA4MDQyNiwtMTQ3MzIzMTM0MSwtNDU3MDU5ODMsMTc3MDAzNTQxNiwtMTk1ODQxNDQxNywtNDIwNjMsLTE5OTA0MDQxNjIsMTgwNDYwMzY4MiwtNDAzNDExMDEsLTE1MDIwMDIyOTAsMTIzNjUzNTMyOSwtMTY1Nzk2NTEwLC0xMDY5NTAxNjMyLDY0MzcxNzcxMywtMzczODk3MzAyLC03MDE1NTg2OTEsMzgwMTYwODMsLTY2MDQ3ODMzNSwtNDA1NTM3ODQ4LDU2ODQ0NjQzOCwtMTAxOTgwMzY5MCwtMTg3MzYzOTYxLDExNjM1MzE1MDEsLTE0NDQ2ODE0NjcsLTUxNDAzNzg0LDE3MzUzMjg0NzMsLTE5MjY2MDc3MzQsLTM3ODU1OCwtMjAyMjU3NDQ2MywxODM5MDMwNTYyLC0zNTMwOTU1NiwtMTUzMDk5MjA2MCwxMjcyODkzMzUzLC0xNTU0OTc2MzIsLTEwOTQ3MzA2NDAsNjgxMjc5MTc0LC0zNTg1MzcyMjIsLTcyMjUyMTk3OSw3NjAyOTE4OSwtNjQwMzY0NDg3LC00MjE4MTU4MzUsNTMwNzQyNTIwLC05OTUzMzg2NTEsLTE5ODYzMDg0NCwxMTI2ODkxNDE1LC0xNDE2MzU0OTA1LC01NzQzNDA1NSwxNzAwNDg1NTcxLC0xODk0OTg2NjA2LC0xMDUxNTIzLC0yMDU0OTIyNzk5LDE4NzMzMTMzNTksLTMwNjExNzQ0LC0xNTYwMTk4MzgwLDEzMDkxNTE2NDksLTE0NTUyMzA3MCwtMTEyMDIxMDM3OSw3MTg3ODcyNTksLTM0MzQ4NTU1MV0pKX19O2Z1bmN0aW9uIGNhbGN1bGF0ZU1ENShlLHQsYSl7bGV0IHI9MTczMjU4NDE5MyxpPS0yNzE3MzM4Nzksbj0tMTczMjU4NDE5NCxzPTI3MTczMzg3ODtjb25zdCBvPWErNzImLTY0LGM9bmV3IFVpbnQ4QXJyYXkobyk7bGV0IGwsaDtmb3IobD0wO2w8YTsrK2wpY1tsXT1lW3QrK107Y1tsKytdPTEyODtjb25zdCB1PW8tODtsPHUmJihsPXUpO2NbbCsrXT1hPDwzJjI1NTtjW2wrK109YT4+NSYyNTU7Y1tsKytdPWE+PjEzJjI1NTtjW2wrK109YT4+MjEmMjU1O2NbbCsrXT1hPj4+MjkmMjU1O2wrPTM7Y29uc3QgZD1uZXcgSW50MzJBcnJheSgxNikse2s6ZixyOmd9PVpvO2ZvcihsPTA7bDxvOyl7Zm9yKGg9MDtoPDE2OysraCxsKz00KWRbaF09Y1tsXXxjW2wrMV08PDh8Y1tsKzJdPDwxNnxjW2wrM108PDI0O2xldCBlLHQsYT1yLG89aSx1PW4scD1zO2ZvcihoPTA7aDw2NDsrK2gpe2lmKGg8MTYpe2U9byZ1fH5vJnA7dD1ofWVsc2UgaWYoaDwzMil7ZT1wJm98fnAmdTt0PTUqaCsxJjE1fWVsc2UgaWYoaDw0OCl7ZT1vXnVecDt0PTMqaCs1JjE1fWVsc2V7ZT11XihvfH5wKTt0PTcqaCYxNX1jb25zdCByPXAsaT1hK2UrZltoXStkW3RdfDAsbj1nW2hdO3A9dTt1PW87bz1vKyhpPDxufGk+Pj4zMi1uKXwwO2E9cn1yPXIrYXwwO2k9aStvfDA7bj1uK3V8MDtzPXMrcHwwfXJldHVybiBuZXcgVWludDhBcnJheShbMjU1JnIscj4+OCYyNTUscj4+MTYmMjU1LHI+Pj4yNCYyNTUsMjU1JmksaT4+OCYyNTUsaT4+MTYmMjU1LGk+Pj4yNCYyNTUsMjU1Jm4sbj4+OCYyNTUsbj4+MTYmMjU1LG4+Pj4yNCYyNTUsMjU1JnMscz4+OCYyNTUscz4+MTYmMjU1LHM+Pj4yNCYyNTVdKX1mdW5jdGlvbiBkZWNvZGVTdHJpbmcoZSl7dHJ5e3JldHVybiBzdHJpbmdUb1VURjhTdHJpbmcoZSl9Y2F0Y2godCl7d2FybihgVVRGLTggZGVjb2RpbmcgZmFpbGVkOiAiJHt0fSIuYCk7cmV0dXJuIGV9fWNsYXNzIERhdGFzZXRYTUxQYXJzZXIgZXh0ZW5kcyBTaW1wbGVYTUxQYXJzZXJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5ub2RlPW51bGx9b25FbmRFbGVtZW50KGUpe2NvbnN0IHQ9c3VwZXIub25FbmRFbGVtZW50KGUpO2lmKHQmJiJ4ZmE6ZGF0YXNldHMiPT09ZSl7dGhpcy5ub2RlPXQ7dGhyb3cgbmV3IEVycm9yKCJBYm9ydGluZyBEYXRhc2V0WE1MUGFyc2VyLiIpfX19Y2xhc3MgRGF0YXNldFJlYWRlcntjb25zdHJ1Y3RvcihlKXtpZihlLmRhdGFzZXRzKXRoaXMubm9kZT1uZXcgU2ltcGxlWE1MUGFyc2VyKHtoYXNBdHRyaWJ1dGVzOiEwfSkucGFyc2VGcm9tU3RyaW5nKGUuZGF0YXNldHMpLmRvY3VtZW50RWxlbWVudDtlbHNle2NvbnN0IHQ9bmV3IERhdGFzZXRYTUxQYXJzZXIoe2hhc0F0dHJpYnV0ZXM6ITB9KTt0cnl7dC5wYXJzZUZyb21TdHJpbmcoZVsieGRwOnhkcCJdKX1jYXRjaHt9dGhpcy5ub2RlPXQubm9kZX19Z2V0VmFsdWUoZSl7aWYoIXRoaXMubm9kZXx8IWUpcmV0dXJuIiI7Y29uc3QgdD10aGlzLm5vZGUuc2VhcmNoTm9kZShwYXJzZVhGQVBhdGgoZSksMCk7aWYoIXQpcmV0dXJuIiI7Y29uc3QgYT10LmZpcnN0Q2hpbGQ7cmV0dXJuInZhbHVlIj09PWE/Lm5vZGVOYW1lP3QuY2hpbGRyZW4ubWFwKChlPT5kZWNvZGVTdHJpbmcoZS50ZXh0Q29udGVudCkpKTpkZWNvZGVTdHJpbmcodC50ZXh0Q29udGVudCl9fWNsYXNzIFNpbmdsZUludGVyc2VjdG9yeyNiZTsjeWU9MS8wOyN3ZT0xLzA7I3hlPS0xLzA7I1NlPS0xLzA7I0FlPW51bGw7I2tlPVtdOyNDZT1bXTsjdmU9LTE7I0ZlPSExO2NvbnN0cnVjdG9yKGUpe3RoaXMuI2JlPWU7Y29uc3QgdD1lLmRhdGEucXVhZFBvaW50cztpZih0KXtmb3IobGV0IGU9MCxhPXQubGVuZ3RoO2U8YTtlKz04KXt0aGlzLiN5ZT1NYXRoLm1pbih0aGlzLiN5ZSx0W2VdKTt0aGlzLiN4ZT1NYXRoLm1heCh0aGlzLiN4ZSx0W2UrMl0pO3RoaXMuI3dlPU1hdGgubWluKHRoaXMuI3dlLHRbZSs1XSk7dGhpcy4jU2U9TWF0aC5tYXgodGhpcy4jU2UsdFtlKzFdKX10Lmxlbmd0aD44JiYodGhpcy4jQWU9dCl9ZWxzZVt0aGlzLiN5ZSx0aGlzLiN3ZSx0aGlzLiN4ZSx0aGlzLiNTZV09ZS5kYXRhLnJlY3R9b3ZlcmxhcHMoZSl7cmV0dXJuISh0aGlzLiN5ZT49ZS4jeGV8fHRoaXMuI3hlPD1lLiN5ZXx8dGhpcy4jd2U+PWUuI1NlfHx0aGlzLiNTZTw9ZS4jd2UpfSNJZShlLHQpe2lmKHRoaXMuI3llPj1lfHx0aGlzLiN4ZTw9ZXx8dGhpcy4jd2U+PXR8fHRoaXMuI1NlPD10KXJldHVybiExO2NvbnN0IGE9dGhpcy4jQWU7aWYoIWEpcmV0dXJuITA7aWYodGhpcy4jdmU+PTApe2NvbnN0IHI9dGhpcy4jdmU7aWYoIShhW3JdPj1lfHxhW3IrMl08PWV8fGFbcis1XT49dHx8YVtyKzFdPD10KSlyZXR1cm4hMDt0aGlzLiN2ZT0tMX1mb3IobGV0IHI9MCxpPWEubGVuZ3RoO3I8aTtyKz04KWlmKCEoYVtyXT49ZXx8YVtyKzJdPD1lfHxhW3IrNV0+PXR8fGFbcisxXTw9dCkpe3RoaXMuI3ZlPXI7cmV0dXJuITB9cmV0dXJuITF9YWRkR2x5cGgoZSx0LGEpe2lmKCF0aGlzLiNJZShlLHQpKXt0aGlzLmRpc2FibGVFeHRyYUNoYXJzKCk7cmV0dXJuITF9aWYodGhpcy4jQ2UubGVuZ3RoPjApe3RoaXMuI2tlLnB1c2godGhpcy4jQ2Uuam9pbigiIikpO3RoaXMuI0NlLmxlbmd0aD0wfXRoaXMuI2tlLnB1c2goYSk7dGhpcy4jRmU9ITA7cmV0dXJuITB9YWRkRXh0cmFDaGFyKGUpe3RoaXMuI0ZlJiZ0aGlzLiNDZS5wdXNoKGUpfWRpc2FibGVFeHRyYUNoYXJzKCl7aWYodGhpcy4jRmUpe3RoaXMuI0ZlPSExO3RoaXMuI0NlLmxlbmd0aD0wfX1zZXRUZXh0KCl7dGhpcy4jYmUuZGF0YS5vdmVybGFpZFRleHQ9dGhpcy4ja2Uuam9pbigiIil9fWNsYXNzIEludGVyc2VjdG9yeyNUZT1uZXcgTWFwO2NvbnN0cnVjdG9yKGUpe2Zvcihjb25zdCB0IG9mIGUpe2lmKCF0LmRhdGEucXVhZFBvaW50cyYmIXQuZGF0YS5yZWN0KWNvbnRpbnVlO2NvbnN0IGU9bmV3IFNpbmdsZUludGVyc2VjdG9yKHQpO2Zvcihjb25zdFt0LGFdb2YgdGhpcy4jVGUpdC5vdmVybGFwcyhlKSYmKGE/YS5hZGQoZSk6dGhpcy4jVGUuc2V0KHQsbmV3IFNldChbZV0pKSk7dGhpcy4jVGUuc2V0KGUsbnVsbCl9fWFkZEdseXBoKGUsdCxhLHIpe2NvbnN0IGk9ZVs0XSt0LzIsbj1lWzVdK2EvMjtsZXQgcztmb3IoY29uc3RbZSx0XW9mIHRoaXMuI1RlKXM/cy5oYXMoZSk/ZS5hZGRHbHlwaChpLG4scik6ZS5kaXNhYmxlRXh0cmFDaGFycygpOmUuYWRkR2x5cGgoaSxuLHIpJiYocz10KX1hZGRFeHRyYUNoYXIoZSl7Zm9yKGNvbnN0IHQgb2YgdGhpcy4jVGUua2V5cygpKXQuYWRkRXh0cmFDaGFyKGUpfXNldFRleHQoKXtmb3IoY29uc3QgZSBvZiB0aGlzLiNUZS5rZXlzKCkpZS5zZXRUZXh0KCl9fWNsYXNzIFdvcmQ2NHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuaGlnaD0wfGU7dGhpcy5sb3c9MHx0fWFuZChlKXt0aGlzLmhpZ2gmPWUuaGlnaDt0aGlzLmxvdyY9ZS5sb3d9eG9yKGUpe3RoaXMuaGlnaF49ZS5oaWdoO3RoaXMubG93Xj1lLmxvd31zaGlmdFJpZ2h0KGUpe2lmKGU+PTMyKXt0aGlzLmxvdz10aGlzLmhpZ2g+Pj5lLTMyfDA7dGhpcy5oaWdoPTB9ZWxzZXt0aGlzLmxvdz10aGlzLmxvdz4+PmV8dGhpcy5oaWdoPDwzMi1lO3RoaXMuaGlnaD10aGlzLmhpZ2g+Pj5lfDB9fXJvdGF0ZVJpZ2h0KGUpe2xldCB0LGE7aWYoMzImZSl7YT10aGlzLmxvdzt0PXRoaXMuaGlnaH1lbHNle3Q9dGhpcy5sb3c7YT10aGlzLmhpZ2h9ZSY9MzE7dGhpcy5sb3c9dD4+PmV8YTw8MzItZTt0aGlzLmhpZ2g9YT4+PmV8dDw8MzItZX1ub3QoKXt0aGlzLmhpZ2g9fnRoaXMuaGlnaDt0aGlzLmxvdz1+dGhpcy5sb3d9YWRkKGUpe2NvbnN0IHQ9KHRoaXMubG93Pj4+MCkrKGUubG93Pj4+MCk7bGV0IGE9KHRoaXMuaGlnaD4+PjApKyhlLmhpZ2g+Pj4wKTt0PjQyOTQ5NjcyOTUmJihhKz0xKTt0aGlzLmxvdz0wfHQ7dGhpcy5oaWdoPTB8YX1jb3B5VG8oZSx0KXtlW3RdPXRoaXMuaGlnaD4+PjI0JjI1NTtlW3QrMV09dGhpcy5oaWdoPj4xNiYyNTU7ZVt0KzJdPXRoaXMuaGlnaD4+OCYyNTU7ZVt0KzNdPTI1NSZ0aGlzLmhpZ2g7ZVt0KzRdPXRoaXMubG93Pj4+MjQmMjU1O2VbdCs1XT10aGlzLmxvdz4+MTYmMjU1O2VbdCs2XT10aGlzLmxvdz4+OCYyNTU7ZVt0KzddPTI1NSZ0aGlzLmxvd31hc3NpZ24oZSl7dGhpcy5oaWdoPWUuaGlnaDt0aGlzLmxvdz1lLmxvd319Y29uc3QgUW89e2dldCBrKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJrIixbbmV3IFdvcmQ2NCgxMTE2MzUyNDA4LDM2MDk3Njc0NTgpLG5ldyBXb3JkNjQoMTg5OTQ0NzQ0MSw2MDI4OTE3MjUpLG5ldyBXb3JkNjQoMzA0OTMyMzQ3MSwzOTY0NDg0Mzk5KSxuZXcgV29yZDY0KDM5MjEwMDk1NzMsMjE3MzI5NTU0OCksbmV3IFdvcmQ2NCg5NjE5ODcxNjMsNDA4MTYyODQ3MiksbmV3IFdvcmQ2NCgxNTA4OTcwOTkzLDMwNTM4MzQyNjUpLG5ldyBXb3JkNjQoMjQ1MzYzNTc0OCwyOTM3NjcxNTc5KSxuZXcgV29yZDY0KDI4NzA3NjMyMjEsMzY2NDYwOTU2MCksbmV3IFdvcmQ2NCgzNjI0MzgxMDgwLDI3MzQ4ODMzOTQpLG5ldyBXb3JkNjQoMzEwNTk4NDAxLDExNjQ5OTY1NDIpLG5ldyBXb3JkNjQoNjA3MjI1Mjc4LDEzMjM2MTA3NjQpLG5ldyBXb3JkNjQoMTQyNjg4MTk4NywzNTkwMzA0OTk0KSxuZXcgV29yZDY0KDE5MjUwNzgzODgsNDA2ODE4MjM4MyksbmV3IFdvcmQ2NCgyMTYyMDc4MjA2LDk5MTMzNjExMyksbmV3IFdvcmQ2NCgyNjE0ODg4MTAzLDYzMzgwMzMxNyksbmV3IFdvcmQ2NCgzMjQ4MjIyNTgwLDM0Nzk3NzQ4NjgpLG5ldyBXb3JkNjQoMzgzNTM5MDQwMSwyNjY2NjEzNDU4KSxuZXcgV29yZDY0KDQwMjIyMjQ3NzQsOTQ0NzExMTM5KSxuZXcgV29yZDY0KDI2NDM0NzA3OCwyMzQxMjYyNzczKSxuZXcgV29yZDY0KDYwNDgwNzYyOCwyMDA3ODAwOTMzKSxuZXcgV29yZDY0KDc3MDI1NTk4MywxNDk1OTkwOTAxKSxuZXcgV29yZDY0KDEyNDkxNTAxMjIsMTg1NjQzMTIzNSksbmV3IFdvcmQ2NCgxNTU1MDgxNjkyLDMxNzUyMTgxMzIpLG5ldyBXb3JkNjQoMTk5NjA2NDk4NiwyMTk4OTUwODM3KSxuZXcgV29yZDY0KDI1NTQyMjA4ODIsMzk5OTcxOTMzOSksbmV3IFdvcmQ2NCgyODIxODM0MzQ5LDc2Njc4NDAxNiksbmV3IFdvcmQ2NCgyOTUyOTk2ODA4LDI1NjY1OTQ4NzkpLG5ldyBXb3JkNjQoMzIxMDMxMzY3MSwzMjAzMzM3OTU2KSxuZXcgV29yZDY0KDMzMzY1NzE4OTEsMTAzNDQ1NzAyNiksbmV3IFdvcmQ2NCgzNTg0NTI4NzExLDI0NjY5NDg5MDEpLG5ldyBXb3JkNjQoMTEzOTI2OTkzLDM3NTgzMjYzODMpLG5ldyBXb3JkNjQoMzM4MjQxODk1LDE2ODcxNzkzNiksbmV3IFdvcmQ2NCg2NjYzMDcyMDUsMTE4ODE3OTk2NCksbmV3IFdvcmQ2NCg3NzM1Mjk5MTIsMTU0NjA0NTczNCksbmV3IFdvcmQ2NCgxMjk0NzU3MzcyLDE1MjI4MDU0ODUpLG5ldyBXb3JkNjQoMTM5NjE4MjI5MSwyNjQzODMzODIzKSxuZXcgV29yZDY0KDE2OTUxODM3MDAsMjM0MzUyNzM5MCksbmV3IFdvcmQ2NCgxOTg2NjYxMDUxLDEwMTQ0Nzc0ODApLG5ldyBXb3JkNjQoMjE3NzAyNjM1MCwxMjA2NzU5MTQyKSxuZXcgV29yZDY0KDI0NTY5NTYwMzcsMzQ0MDc3NjI3KSxuZXcgV29yZDY0KDI3MzA0ODU5MjEsMTI5MDg2MzQ2MCksbmV3IFdvcmQ2NCgyODIwMzAyNDExLDMxNTg0NTQyNzMpLG5ldyBXb3JkNjQoMzI1OTczMDgwMCwzNTA1OTUyNjU3KSxuZXcgV29yZDY0KDMzNDU3NjQ3NzEsMTA2MjE3MDA4KSxuZXcgV29yZDY0KDM1MTYwNjU4MTcsMzYwNjAwODM0NCksbmV3IFdvcmQ2NCgzNjAwMzUyODA0LDE0MzI3MjU3NzYpLG5ldyBXb3JkNjQoNDA5NDU3MTkwOSwxNDY3MDMxNTk0KSxuZXcgV29yZDY0KDI3NTQyMzM0NCw4NTExNjk3MjApLG5ldyBXb3JkNjQoNDMwMjI3NzM0LDMxMDA4MjM3NTIpLG5ldyBXb3JkNjQoNTA2OTQ4NjE2LDEzNjMyNTgxOTUpLG5ldyBXb3JkNjQoNjU5MDYwNTU2LDM3NTA2ODU1OTMpLG5ldyBXb3JkNjQoODgzOTk3ODc3LDM3ODUwNTAyODApLG5ldyBXb3JkNjQoOTU4MTM5NTcxLDMzMTgzMDc0MjcpLG5ldyBXb3JkNjQoMTMyMjgyMjIxOCwzODEyNzIzNDAzKSxuZXcgV29yZDY0KDE1MzcwMDIwNjMsMjAwMzAzNDk5NSksbmV3IFdvcmQ2NCgxNzQ3ODczNzc5LDM2MDIwMzY4OTkpLG5ldyBXb3JkNjQoMTk1NTU2MjIyMiwxNTc1OTkwMDEyKSxuZXcgV29yZDY0KDIwMjQxMDQ4MTUsMTEyNTU5MjkyOCksbmV3IFdvcmQ2NCgyMjI3NzMwNDUyLDI3MTY5MDQzMDYpLG5ldyBXb3JkNjQoMjM2MTg1MjQyNCw0NDI3NzYwNDQpLG5ldyBXb3JkNjQoMjQyODQzNjQ3NCw1OTM2OTgzNDQpLG5ldyBXb3JkNjQoMjc1NjczNDE4NywzNzMzMTEwMjQ5KSxuZXcgV29yZDY0KDMyMDQwMzE0NzksMjk5OTM1MTU3MyksbmV3IFdvcmQ2NCgzMzI5MzI1Mjk4LDM4MTU5MjA0MjcpLG5ldyBXb3JkNjQoMzM5MTU2OTYxNCwzOTI4MzgzOTAwKSxuZXcgV29yZDY0KDM1MTUyNjcyNzEsNTY2MjgwNzExKSxuZXcgV29yZDY0KDM5NDAxODc2MDYsMzQ1NDA2OTUzNCksbmV3IFdvcmQ2NCg0MTE4NjMwMjcxLDQwMDAyMzk5OTIpLG5ldyBXb3JkNjQoMTE2NDE4NDc0LDE5MTQxMzg1NTQpLG5ldyBXb3JkNjQoMTc0MjkyNDIxLDI3MzEwNTUyNzApLG5ldyBXb3JkNjQoMjg5MzgwMzU2LDMyMDM5OTMwMDYpLG5ldyBXb3JkNjQoNDYwMzkzMjY5LDMyMDYyMDMxNSksbmV3IFdvcmQ2NCg2ODU0NzE3MzMsNTg3NDk2ODM2KSxuZXcgV29yZDY0KDg1MjE0Mjk3MSwxMDg2NzkyODUxKSxuZXcgV29yZDY0KDEwMTcwMzYyOTgsMzY1NTQzMTAwKSxuZXcgV29yZDY0KDExMjYwMDA1ODAsMjYxODI5NzY3NiksbmV3IFdvcmQ2NCgxMjg4MDMzNDcwLDM0MDk4NTUxNTgpLG5ldyBXb3JkNjQoMTUwMTUwNTk0OCw0MjM0NTA5ODY2KSxuZXcgV29yZDY0KDE2MDcxNjc5MTUsOTg3MTY3NDY4KSxuZXcgV29yZDY0KDE4MTY0MDIzMTYsMTI0NjE4OTU5MSldKX19O2Z1bmN0aW9uIGNoKGUsdCxhLHIsaSl7ZS5hc3NpZ24odCk7ZS5hbmQoYSk7aS5hc3NpZ24odCk7aS5ub3QoKTtpLmFuZChyKTtlLnhvcihpKX1mdW5jdGlvbiBtYWooZSx0LGEscixpKXtlLmFzc2lnbih0KTtlLmFuZChhKTtpLmFzc2lnbih0KTtpLmFuZChyKTtlLnhvcihpKTtpLmFzc2lnbihhKTtpLmFuZChyKTtlLnhvcihpKX1mdW5jdGlvbiBzaWdtYShlLHQsYSl7ZS5hc3NpZ24odCk7ZS5yb3RhdGVSaWdodCgyOCk7YS5hc3NpZ24odCk7YS5yb3RhdGVSaWdodCgzNCk7ZS54b3IoYSk7YS5hc3NpZ24odCk7YS5yb3RhdGVSaWdodCgzOSk7ZS54b3IoYSl9ZnVuY3Rpb24gc2lnbWFQcmltZShlLHQsYSl7ZS5hc3NpZ24odCk7ZS5yb3RhdGVSaWdodCgxNCk7YS5hc3NpZ24odCk7YS5yb3RhdGVSaWdodCgxOCk7ZS54b3IoYSk7YS5hc3NpZ24odCk7YS5yb3RhdGVSaWdodCg0MSk7ZS54b3IoYSl9ZnVuY3Rpb24gbGl0dGxlU2lnbWEoZSx0LGEpe2UuYXNzaWduKHQpO2Uucm90YXRlUmlnaHQoMSk7YS5hc3NpZ24odCk7YS5yb3RhdGVSaWdodCg4KTtlLnhvcihhKTthLmFzc2lnbih0KTthLnNoaWZ0UmlnaHQoNyk7ZS54b3IoYSl9ZnVuY3Rpb24gbGl0dGxlU2lnbWFQcmltZShlLHQsYSl7ZS5hc3NpZ24odCk7ZS5yb3RhdGVSaWdodCgxOSk7YS5hc3NpZ24odCk7YS5yb3RhdGVSaWdodCg2MSk7ZS54b3IoYSk7YS5hc3NpZ24odCk7YS5zaGlmdFJpZ2h0KDYpO2UueG9yKGEpfWZ1bmN0aW9uIGNhbGN1bGF0ZVNIQTUxMihlLHQsYSxyPSExKXtsZXQgaSxuLHMsbyxjLGwsaCx1O2lmKHIpe2k9bmV3IFdvcmQ2NCgzNDE4MDcwMzY1LDMyMzgzNzEwMzIpO249bmV3IFdvcmQ2NCgxNjU0MjcwMjUwLDkxNDE1MDY2Myk7cz1uZXcgV29yZDY0KDI0Mzg1MjkzNzAsODEyNzAyOTk5KTtvPW5ldyBXb3JkNjQoMzU1NDYyMzYwLDQxNDQ5MTI2OTcpO2M9bmV3IFdvcmQ2NCgxNzMxNDA1NDE1LDQyOTA3NzU4NTcpO2w9bmV3IFdvcmQ2NCgyMzk0MTgwMjMxLDE3NTA2MDMwMjUpO2g9bmV3IFdvcmQ2NCgzNjc1MDA4NTI1LDE2OTQwNzY4MzkpO3U9bmV3IFdvcmQ2NCgxMjAzMDYyODEzLDMyMDQwNzU0MjgpfWVsc2V7aT1uZXcgV29yZDY0KDE3NzkwMzM3MDMsNDA4OTIzNTcyMCk7bj1uZXcgV29yZDY0KDMxNDQxMzQyNzcsMjIyNzg3MzU5NSk7cz1uZXcgV29yZDY0KDEwMTM5MDQyNDIsNDI3MTE3NTcyMyk7bz1uZXcgV29yZDY0KDI3NzM0ODA3NjIsMTU5NTc1MDEyOSk7Yz1uZXcgV29yZDY0KDEzNTk4OTMxMTksMjkxNzU2NTEzNyk7bD1uZXcgV29yZDY0KDI2MDA4MjI5MjQsNzI1NTExMTk5KTtoPW5ldyBXb3JkNjQoNTI4NzM0NjM1LDQyMTUzODk1NDcpO3U9bmV3IFdvcmQ2NCgxNTQxNDU5MjI1LDMyNzAzMzIwOSl9Y29uc3QgZD0xMjgqTWF0aC5jZWlsKChhKzE3KS8xMjgpLGY9bmV3IFVpbnQ4QXJyYXkoZCk7bGV0IGcscDtmb3IoZz0wO2c8YTsrK2cpZltnXT1lW3QrK107ZltnKytdPTEyODtjb25zdCBtPWQtMTY7ZzxtJiYoZz1tKTtnKz0xMTtmW2crK109YT4+PjI5JjI1NTtmW2crK109YT4+MjEmMjU1O2ZbZysrXT1hPj4xMyYyNTU7ZltnKytdPWE+PjUmMjU1O2ZbZysrXT1hPDwzJjI1NTtjb25zdCBiPW5ldyBBcnJheSg4MCk7Zm9yKGc9MDtnPDgwO2crKyliW2ddPW5ldyBXb3JkNjQoMCwwKTtjb25zdHtrOnl9PVFvO2xldCB3PW5ldyBXb3JkNjQoMCwwKSx4PW5ldyBXb3JkNjQoMCwwKSxTPW5ldyBXb3JkNjQoMCwwKSxrPW5ldyBXb3JkNjQoMCwwKSxDPW5ldyBXb3JkNjQoMCwwKSx2PW5ldyBXb3JkNjQoMCwwKSxGPW5ldyBXb3JkNjQoMCwwKSxUPW5ldyBXb3JkNjQoMCwwKTtjb25zdCBPPW5ldyBXb3JkNjQoMCwwKSxNPW5ldyBXb3JkNjQoMCwwKSxEPW5ldyBXb3JkNjQoMCwwKSxSPW5ldyBXb3JkNjQoMCwwKTtsZXQgTixFO2ZvcihnPTA7ZzxkOyl7Zm9yKHA9MDtwPDE2OysrcCl7YltwXS5oaWdoPWZbZ108PDI0fGZbZysxXTw8MTZ8ZltnKzJdPDw4fGZbZyszXTtiW3BdLmxvdz1mW2crNF08PDI0fGZbZys1XTw8MTZ8ZltnKzZdPDw4fGZbZys3XTtnKz04fWZvcihwPTE2O3A8ODA7KytwKXtOPWJbcF07bGl0dGxlU2lnbWFQcmltZShOLGJbcC0yXSxSKTtOLmFkZChiW3AtN10pO2xpdHRsZVNpZ21hKEQsYltwLTE1XSxSKTtOLmFkZChEKTtOLmFkZChiW3AtMTZdKX13LmFzc2lnbihpKTt4LmFzc2lnbihuKTtTLmFzc2lnbihzKTtrLmFzc2lnbihvKTtDLmFzc2lnbihjKTt2LmFzc2lnbihsKTtGLmFzc2lnbihoKTtULmFzc2lnbih1KTtmb3IocD0wO3A8ODA7KytwKXtPLmFzc2lnbihUKTtzaWdtYVByaW1lKEQsQyxSKTtPLmFkZChEKTtjaChELEMsdixGLFIpO08uYWRkKEQpO08uYWRkKHlbcF0pO08uYWRkKGJbcF0pO3NpZ21hKE0sdyxSKTttYWooRCx3LHgsUyxSKTtNLmFkZChEKTtOPVQ7VD1GO0Y9djt2PUM7ay5hZGQoTyk7Qz1rO2s9UztTPXg7eD13O04uYXNzaWduKE8pO04uYWRkKE0pO3c9Tn1pLmFkZCh3KTtuLmFkZCh4KTtzLmFkZChTKTtvLmFkZChrKTtjLmFkZChDKTtsLmFkZCh2KTtoLmFkZChGKTt1LmFkZChUKX1pZihyKXtFPW5ldyBVaW50OEFycmF5KDQ4KTtpLmNvcHlUbyhFLDApO24uY29weVRvKEUsOCk7cy5jb3B5VG8oRSwxNik7by5jb3B5VG8oRSwyNCk7Yy5jb3B5VG8oRSwzMik7bC5jb3B5VG8oRSw0MCl9ZWxzZXtFPW5ldyBVaW50OEFycmF5KDY0KTtpLmNvcHlUbyhFLDApO24uY29weVRvKEUsOCk7cy5jb3B5VG8oRSwxNik7by5jb3B5VG8oRSwyNCk7Yy5jb3B5VG8oRSwzMik7bC5jb3B5VG8oRSw0MCk7aC5jb3B5VG8oRSw0OCk7dS5jb3B5VG8oRSw1Nil9cmV0dXJuIEV9Y29uc3QgZWM9e2dldCBrKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJrIixbMTExNjM1MjQwOCwxODk5NDQ3NDQxLDMwNDkzMjM0NzEsMzkyMTAwOTU3Myw5NjE5ODcxNjMsMTUwODk3MDk5MywyNDUzNjM1NzQ4LDI4NzA3NjMyMjEsMzYyNDM4MTA4MCwzMTA1OTg0MDEsNjA3MjI1Mjc4LDE0MjY4ODE5ODcsMTkyNTA3ODM4OCwyMTYyMDc4MjA2LDI2MTQ4ODgxMDMsMzI0ODIyMjU4MCwzODM1MzkwNDAxLDQwMjIyMjQ3NzQsMjY0MzQ3MDc4LDYwNDgwNzYyOCw3NzAyNTU5ODMsMTI0OTE1MDEyMiwxNTU1MDgxNjkyLDE5OTYwNjQ5ODYsMjU1NDIyMDg4MiwyODIxODM0MzQ5LDI5NTI5OTY4MDgsMzIxMDMxMzY3MSwzMzM2NTcxODkxLDM1ODQ1Mjg3MTEsMTEzOTI2OTkzLDMzODI0MTg5NSw2NjYzMDcyMDUsNzczNTI5OTEyLDEyOTQ3NTczNzIsMTM5NjE4MjI5MSwxNjk1MTgzNzAwLDE5ODY2NjEwNTEsMjE3NzAyNjM1MCwyNDU2OTU2MDM3LDI3MzA0ODU5MjEsMjgyMDMwMjQxMSwzMjU5NzMwODAwLDMzNDU3NjQ3NzEsMzUxNjA2NTgxNywzNjAwMzUyODA0LDQwOTQ1NzE5MDksMjc1NDIzMzQ0LDQzMDIyNzczNCw1MDY5NDg2MTYsNjU5MDYwNTU2LDg4Mzk5Nzg3Nyw5NTgxMzk1NzEsMTMyMjgyMjIxOCwxNTM3MDAyMDYzLDE3NDc4NzM3NzksMTk1NTU2MjIyMiwyMDI0MTA0ODE1LDIyMjc3MzA0NTIsMjM2MTg1MjQyNCwyNDI4NDM2NDc0LDI3NTY3MzQxODcsMzIwNDAzMTQ3OSwzMzI5MzI1Mjk4XSl9fTtmdW5jdGlvbiByb3RyKGUsdCl7cmV0dXJuIGU+Pj50fGU8PDMyLXR9ZnVuY3Rpb24gY2FsY3VsYXRlX3NoYTI1Nl9jaChlLHQsYSl7cmV0dXJuIGUmdF5+ZSZhfWZ1bmN0aW9uIGNhbGN1bGF0ZV9zaGEyNTZfbWFqKGUsdCxhKXtyZXR1cm4gZSZ0XmUmYV50JmF9ZnVuY3Rpb24gY2FsY3VsYXRlX3NoYTI1Nl9zaWdtYShlKXtyZXR1cm4gcm90cihlLDIpXnJvdHIoZSwxMylecm90cihlLDIyKX1mdW5jdGlvbiBjYWxjdWxhdGVfc2hhMjU2X3NpZ21hUHJpbWUoZSl7cmV0dXJuIHJvdHIoZSw2KV5yb3RyKGUsMTEpXnJvdHIoZSwyNSl9ZnVuY3Rpb24gY2FsY3VsYXRlX3NoYTI1Nl9saXR0bGVTaWdtYShlKXtyZXR1cm4gcm90cihlLDcpXnJvdHIoZSwxOCleZT4+PjN9ZnVuY3Rpb24gY2FsY3VsYXRlU0hBMjU2KGUsdCxhKXtsZXQgcj0xNzc5MDMzNzAzLGk9MzE0NDEzNDI3NyxuPTEwMTM5MDQyNDIscz0yNzczNDgwNzYyLG89MTM1OTg5MzExOSxjPTI2MDA4MjI5MjQsbD01Mjg3MzQ2MzUsaD0xNTQxNDU5MjI1O2NvbnN0IHU9NjQqTWF0aC5jZWlsKChhKzkpLzY0KSxkPW5ldyBVaW50OEFycmF5KHUpO2xldCBmLGc7Zm9yKGY9MDtmPGE7KytmKWRbZl09ZVt0KytdO2RbZisrXT0xMjg7Y29uc3QgcD11LTg7ZjxwJiYoZj1wKTtmKz0zO2RbZisrXT1hPj4+MjkmMjU1O2RbZisrXT1hPj4yMSYyNTU7ZFtmKytdPWE+PjEzJjI1NTtkW2YrK109YT4+NSYyNTU7ZFtmKytdPWE8PDMmMjU1O2NvbnN0IG09bmV3IFVpbnQzMkFycmF5KDY0KSx7azpifT1lYztmb3IoZj0wO2Y8dTspe2ZvcihnPTA7ZzwxNjsrK2cpe21bZ109ZFtmXTw8MjR8ZFtmKzFdPDwxNnxkW2YrMl08PDh8ZFtmKzNdO2YrPTR9Zm9yKGc9MTY7Zzw2NDsrK2cpbVtnXT0ocm90cih5PW1bZy0yXSwxNylecm90cih5LDE5KV55Pj4+MTApK21bZy03XStjYWxjdWxhdGVfc2hhMjU2X2xpdHRsZVNpZ21hKG1bZy0xNV0pK21bZy0xNl18MDtsZXQgZSx0LGE9cix1PWkscD1uLHc9cyx4PW8sUz1jLGs9bCxDPWg7Zm9yKGc9MDtnPDY0OysrZyl7ZT1DK2NhbGN1bGF0ZV9zaGEyNTZfc2lnbWFQcmltZSh4KStjYWxjdWxhdGVfc2hhMjU2X2NoKHgsUyxrKStiW2ddK21bZ107dD1jYWxjdWxhdGVfc2hhMjU2X3NpZ21hKGEpK2NhbGN1bGF0ZV9zaGEyNTZfbWFqKGEsdSxwKTtDPWs7az1TO1M9eDt4PXcrZXwwO3c9cDtwPXU7dT1hO2E9ZSt0fDB9cj1yK2F8MDtpPWkrdXwwO249bitwfDA7cz1zK3d8MDtvPW8reHwwO2M9YytTfDA7bD1sK2t8MDtoPWgrQ3wwfXZhciB5O3JldHVybiBuZXcgVWludDhBcnJheShbcj4+MjQmMjU1LHI+PjE2JjI1NSxyPj44JjI1NSwyNTUmcixpPj4yNCYyNTUsaT4+MTYmMjU1LGk+PjgmMjU1LDI1NSZpLG4+PjI0JjI1NSxuPj4xNiYyNTUsbj4+OCYyNTUsMjU1Jm4scz4+MjQmMjU1LHM+PjE2JjI1NSxzPj44JjI1NSwyNTUmcyxvPj4yNCYyNTUsbz4+MTYmMjU1LG8+PjgmMjU1LDI1NSZvLGM+PjI0JjI1NSxjPj4xNiYyNTUsYz4+OCYyNTUsMjU1JmMsbD4+MjQmMjU1LGw+PjE2JjI1NSxsPj44JjI1NSwyNTUmbCxoPj4yNCYyNTUsaD4+MTYmMjU1LGg+PjgmMjU1LDI1NSZoXSl9Y2xhc3MgRGVjcnlwdFN0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQsYSl7c3VwZXIodCk7dGhpcy5zdHI9ZTt0aGlzLmRpY3Q9ZS5kaWN0O3RoaXMuZGVjcnlwdD1hO3RoaXMubmV4dENodW5rPW51bGw7dGhpcy5pbml0aWFsaXplZD0hMX1yZWFkQmxvY2soKXtsZXQgZTtpZih0aGlzLmluaXRpYWxpemVkKWU9dGhpcy5uZXh0Q2h1bms7ZWxzZXtlPXRoaXMuc3RyLmdldEJ5dGVzKDUxMik7dGhpcy5pbml0aWFsaXplZD0hMH1pZighZT8ubGVuZ3RoKXt0aGlzLmVvZj0hMDtyZXR1cm59dGhpcy5uZXh0Q2h1bms9dGhpcy5zdHIuZ2V0Qnl0ZXMoNTEyKTtjb25zdCB0PXRoaXMubmV4dENodW5rPy5sZW5ndGg+MDtlPSgwLHRoaXMuZGVjcnlwdCkoZSwhdCk7Y29uc3QgYT10aGlzLmJ1ZmZlckxlbmd0aCxyPWErZS5sZW5ndGg7dGhpcy5lbnN1cmVCdWZmZXIocikuc2V0KGUsYSk7dGhpcy5idWZmZXJMZW5ndGg9cn19Y2xhc3MgQVJDRm91ckNpcGhlcntjb25zdHJ1Y3RvcihlKXt0aGlzLmE9MDt0aGlzLmI9MDtjb25zdCB0PW5ldyBVaW50OEFycmF5KDI1NiksYT1lLmxlbmd0aDtmb3IobGV0IGU9MDtlPDI1NjsrK2UpdFtlXT1lO2ZvcihsZXQgcj0wLGk9MDtyPDI1NjsrK3Ipe2NvbnN0IG49dFtyXTtpPWkrbitlW3IlYV0mMjU1O3Rbcl09dFtpXTt0W2ldPW59dGhpcy5zPXR9ZW5jcnlwdEJsb2NrKGUpe2xldCB0PXRoaXMuYSxhPXRoaXMuYjtjb25zdCByPXRoaXMucyxpPWUubGVuZ3RoLG49bmV3IFVpbnQ4QXJyYXkoaSk7Zm9yKGxldCBzPTA7czxpOysrcyl7dD10KzEmMjU1O2NvbnN0IGk9clt0XTthPWEraSYyNTU7Y29uc3Qgbz1yW2FdO3JbdF09bztyW2FdPWk7bltzXT1lW3NdXnJbaStvJjI1NV19dGhpcy5hPXQ7dGhpcy5iPWE7cmV0dXJuIG59ZGVjcnlwdEJsb2NrKGUpe3JldHVybiB0aGlzLmVuY3J5cHRCbG9jayhlKX1lbmNyeXB0KGUpe3JldHVybiB0aGlzLmVuY3J5cHRCbG9jayhlKX19Y2xhc3MgTnVsbENpcGhlcntkZWNyeXB0QmxvY2soZSl7cmV0dXJuIGV9ZW5jcnlwdChlKXtyZXR1cm4gZX19Y2xhc3MgQUVTQmFzZUNpcGhlcntfcz1uZXcgVWludDhBcnJheShbOTksMTI0LDExOSwxMjMsMjQyLDEwNywxMTEsMTk3LDQ4LDEsMTAzLDQzLDI1NCwyMTUsMTcxLDExOCwyMDIsMTMwLDIwMSwxMjUsMjUwLDg5LDcxLDI0MCwxNzMsMjEyLDE2MiwxNzUsMTU2LDE2NCwxMTQsMTkyLDE4MywyNTMsMTQ3LDM4LDU0LDYzLDI0NywyMDQsNTIsMTY1LDIyOSwyNDEsMTEzLDIxNiw0OSwyMSw0LDE5OSwzNSwxOTUsMjQsMTUwLDUsMTU0LDcsMTgsMTI4LDIyNiwyMzUsMzksMTc4LDExNyw5LDEzMSw0NCwyNiwyNywxMTAsOTAsMTYwLDgyLDU5LDIxNCwxNzksNDEsMjI3LDQ3LDEzMiw4MywyMDksMCwyMzcsMzIsMjUyLDE3Nyw5MSwxMDYsMjAzLDE5MCw1Nyw3NCw3Niw4OCwyMDcsMjA4LDIzOSwxNzAsMjUxLDY3LDc3LDUxLDEzMyw2OSwyNDksMiwxMjcsODAsNjAsMTU5LDE2OCw4MSwxNjMsNjQsMTQzLDE0NiwxNTcsNTYsMjQ1LDE4OCwxODIsMjE4LDMzLDE2LDI1NSwyNDMsMjEwLDIwNSwxMiwxOSwyMzYsOTUsMTUxLDY4LDIzLDE5NiwxNjcsMTI2LDYxLDEwMCw5MywyNSwxMTUsOTYsMTI5LDc5LDIyMCwzNCw0MiwxNDQsMTM2LDcwLDIzOCwxODQsMjAsMjIyLDk0LDExLDIxOSwyMjQsNTAsNTgsMTAsNzMsNiwzNiw5MiwxOTQsMjExLDE3Miw5OCwxNDUsMTQ5LDIyOCwxMjEsMjMxLDIwMCw1NSwxMDksMTQxLDIxMyw3OCwxNjksMTA4LDg2LDI0NCwyMzQsMTAxLDEyMiwxNzQsOCwxODYsMTIwLDM3LDQ2LDI4LDE2NiwxODAsMTk4LDIzMiwyMjEsMTE2LDMxLDc1LDE4OSwxMzksMTM4LDExMiw2MiwxODEsMTAyLDcyLDMsMjQ2LDE0LDk3LDUzLDg3LDE4NSwxMzQsMTkzLDI5LDE1OCwyMjUsMjQ4LDE1MiwxNywxMDUsMjE3LDE0MiwxNDgsMTU1LDMwLDEzNSwyMzMsMjA2LDg1LDQwLDIyMywxNDAsMTYxLDEzNywxMywxOTEsMjMwLDY2LDEwNCw2NSwxNTMsNDUsMTUsMTc2LDg0LDE4NywyMl0pO19pbnZfcz1uZXcgVWludDhBcnJheShbODIsOSwxMDYsMjEzLDQ4LDU0LDE2NSw1NiwxOTEsNjQsMTYzLDE1OCwxMjksMjQzLDIxNSwyNTEsMTI0LDIyNyw1NywxMzAsMTU1LDQ3LDI1NSwxMzUsNTIsMTQyLDY3LDY4LDE5NiwyMjIsMjMzLDIwMyw4NCwxMjMsMTQ4LDUwLDE2NiwxOTQsMzUsNjEsMjM4LDc2LDE0OSwxMSw2NiwyNTAsMTk1LDc4LDgsNDYsMTYxLDEwMiw0MCwyMTcsMzYsMTc4LDExOCw5MSwxNjIsNzMsMTA5LDEzOSwyMDksMzcsMTE0LDI0OCwyNDYsMTAwLDEzNCwxMDQsMTUyLDIyLDIxMiwxNjQsOTIsMjA0LDkzLDEwMSwxODIsMTQ2LDEwOCwxMTIsNzIsODAsMjUzLDIzNywxODUsMjE4LDk0LDIxLDcwLDg3LDE2NywxNDEsMTU3LDEzMiwxNDQsMjE2LDE3MSwwLDE0MCwxODgsMjExLDEwLDI0NywyMjgsODgsNSwxODQsMTc5LDY5LDYsMjA4LDQ0LDMwLDE0MywyMDIsNjMsMTUsMiwxOTMsMTc1LDE4OSwzLDEsMTksMTM4LDEwNyw1OCwxNDUsMTcsNjUsNzksMTAzLDIyMCwyMzQsMTUxLDI0MiwyMDcsMjA2LDI0MCwxODAsMjMwLDExNSwxNTAsMTcyLDExNiwzNCwyMzEsMTczLDUzLDEzMywyMjYsMjQ5LDU1LDIzMiwyOCwxMTcsMjIzLDExMCw3MSwyNDEsMjYsMTEzLDI5LDQxLDE5NywxMzcsMTExLDE4Myw5OCwxNCwxNzAsMjQsMTkwLDI3LDI1Miw4Niw2Miw3NSwxOTgsMjEwLDEyMSwzMiwxNTQsMjE5LDE5MiwyNTQsMTIwLDIwNSw5MCwyNDQsMzEsMjIxLDE2OCw1MSwxMzYsNywxOTksNDksMTc3LDE4LDE2LDg5LDM5LDEyOCwyMzYsOTUsOTYsODEsMTI3LDE2OSwyNSwxODEsNzQsMTMsNDUsMjI5LDEyMiwxNTksMTQ3LDIwMSwxNTYsMjM5LDE2MCwyMjQsNTksNzcsMTc0LDQyLDI0NSwxNzYsMjAwLDIzNSwxODcsNjAsMTMxLDgzLDE1Myw5NywyMyw0Myw0LDEyNiwxODYsMTE5LDIxNCwzOCwyMjUsMTA1LDIwLDk5LDg1LDMzLDEyLDEyNV0pO19taXg9bmV3IFVpbnQzMkFycmF5KFswLDIzNTQ3NDE4Nyw0NzA5NDgzNzQsMzAzNzY1Mjc3LDk0MTg5Njc0OCw5MDg5MzM0MTUsNjA3NTMwNTU0LDcwODc4MDg0OSwxODgzNzkzNDk2LDIxMTgyMTQ5OTUsMTgxNzg2NjgzMCwxNjQ5NjM5MjM3LDEyMTUwNjExMDgsMTE4MTA0NTExOSwxNDE3NTYxNjk4LDE1MTc3Njc1MjksMzc2NzU4Njk5Miw0MDAzMDYxMTc5LDQyMzY0Mjk5OTAsNDA2OTI0Njg5MywzNjM1NzMzNjYwLDM2MDI3NzAzMjcsMzI5OTI3ODQ3NCwzNDAwNTI4NzY5LDI0MzAxMjIyMTYsMjY2NDU0MzcxNSwyMzYyMDkwMjM4LDIxOTM4NjI2NDUsMjgzNTEyMzM5NiwyODAxMTA3NDA3LDMwMzU1MzUwNTgsMzEzNTc0MDg4OSwzNjc4MTI0OTIzLDM1NzY4NzA1MTIsMzM0MTM5NDI4NSwzMzc0MzYxNzAyLDM4MTA0OTYzNDMsMzk3NzY3NTM1Niw0Mjc5MDgwMjU3LDQwNDM2MTAxODYsMjg3NjQ5NDYyNywyNzc2MjkyOTA0LDMwNzY2MzkwMjksMzExMDY1MDk0MiwyNDcyMDExNTM1LDI2NDAyNDMyMDQsMjQwMzcyODY2NSwyMTY5MzAzMDU4LDEwMDEwODk5OTUsODk5ODM1NTg0LDY2NjQ2NDczMyw2OTk0MzIxNTAsNTk3Mjc4NDcsMjI2OTA2ODYwLDUzMDQwMDc1MywyOTQ5MzA2ODIsMTI3MzE2ODc4NywxMTcyOTY3MDY0LDE0NzU0MTg1MDEsMTUwOTQzMDQxNCwxOTQyNDM1Nzc1LDIxMTA2Njc0NDQsMTg3NjI0MTgzMywxNjQxODE2MjI2LDI5MTAyMTk3NjYsMjc0MzAzNDEwOSwyOTc2MTUxNTIwLDMyMTE2MjMxNDcsMjUwNTIwMjEzOCwyNjA2NDUzOTY5LDIzMDI2OTAyNTIsMjI2OTcyODQ1NSwzNzExODI5NDIyLDM1NDM1OTkyNjksMzI0MDg5NDM5MiwzNDc1MzEzMzMxLDM4NDM2OTkwNzQsMzk0MzkwNjQ0MSw0MTc4MDYyMjI4LDQxNDQwNDc3NzUsMTMwNjk2NzM2NiwxMTM5NzgxNzA5LDEzNzQ5ODgxMTIsMTYxMDQ1OTczOSwxOTc1NjgzNDM0LDIwNzY5MzUyNjUsMTc3NTI3NjkyNCwxNzQyMzE1MTI3LDEwMzQ4Njc5OTgsODY2NjM3ODQ1LDU2NjAyMTg5Niw4MDA0NDA4MzUsOTI5ODc2OTgsMTkzMTk1MDY1LDQyOTQ1NjE2NCwzOTU0NDE3MTEsMTk4NDgxMjY4NSwyMDE3Nzc4NTY2LDE3ODQ2NjMxOTUsMTY4MzQwNzI0OCwxMzE1NTYyMTQ1LDEwODAwOTQ2MzQsMTM4Mzg1NjMxMSwxNTUxMDM3ODg0LDEwMTAzOTgyOSwxMzUwNTAyMDYsNDM3NzU3MTIzLDMzNzU1Mzg2NCwxMDQyMzg1NjU3LDgwNzk2MjYxMCw1NzM4MDQ3ODMsNzQyMDM5MDEyLDI1MzEwNjc0NTMsMjU2NDAzMzMzNCwyMzI4ODI4OTcxLDIyMjc1NzMwMjQsMjkzNTU2Njg2NSwyNzAwMDk5MzU0LDMwMDE3NTU2NTUsMzE2ODkzNzIyOCwzODY4NTUyODA1LDM5MDI1NjMxODIsNDIwMzE4MTE3MSw0MTAyOTc3OTEyLDM3MzYxNjQ5MzcsMzUwMTc0MTg5MCwzMjY1NDc4NzUxLDM0MzM3MTI5ODAsMTEwNjA0MTU5MSwxMzQwNDYzMTAwLDE1NzY5NzY2MDksMTQwODc0OTAzNCwyMDQzMjExNDgzLDIwMDkxOTU0NzIsMTcwODg0ODMzMywxODA5MDU0MTUwLDgzMjg3NzIzMSwxMDY4MzUxMzk2LDc2Njk0NTQ2NSw1OTk3NjIzNTQsMTU5NDE3OTg3LDEyNjQ1NDY2NCwzNjE5Mjk4NzcsNDYzMTgwMTkwLDI3MDkyNjA4NzEsMjk0MzY4MjM4MCwzMTc4MTA2OTYxLDMwMDk4NzkzODYsMjU3MjY5NzE5NSwyNTM4NjgxMTg0LDIyMzYyMjg3MzMsMjMzNjQzNDU1MCwzNTA5ODcxMTM1LDM3NDUzNDUzMDAsMzQ0MTg1MDM3NywzMjc0NjY3MjY2LDM5MTAxNjE5NzEsMzg3NzE5ODY0OCw0MTEwNTY4NDg1LDQyMTE4MTg3OTgsMjU5NzgwNjQ3NiwyNDk3NjA0NzQzLDIyNjEwODkxNzgsMjI5NTEwMTA3MywyNzMzODU2MTYwLDI5MDIwODc4NTEsMzIwMjQzNzA0NiwyOTY4MDExNDUzLDM5MzYyOTEyODQsMzgzNTAzNjg5NSw0MTM2NDQwNzcwLDQxNjk0MDgyMDEsMzUzNTQ4NjQ1NiwzNzAyNjY1NDU5LDM0NjcxOTIzMDIsMzIzMTcyMjIxMywyMDUxNTE4NzgwLDE5NTEzMTcwNDcsMTcxNjg5MDQxMCwxNzUwOTAyMzA1LDExMTM4MTgzODQsMTI4MjA1MDA3NSwxNTg0NTA0NTgyLDEzNTAwNzg5ODksMTY4ODEwODUyLDY3NTU2NDYzLDM3MTA0OTMzMCw0MDQwMTY3NjEsODQxNzM5NTkyLDEwMDg5MTg1OTUsNzc1NTUwODE0LDU0MDA4MDcyNSwzOTY5NTYyMzY5LDM4MDEzMzIyMzQsNDAzNTQ4OTA0Nyw0MjY5OTA3OTk2LDM1NjkyNTUyMTMsMzY2OTQ2MjU2NiwzMzY2NzU0NjE5LDMzMzI3NDAxNDQsMjYzMTA2NTQzMywyNDYzODc5NzYyLDIxNjAxMTcwNzEsMjM5NTU4ODY3NiwyNzY3NjQ1NTU3LDI4Njg4OTc0MDYsMzEwMjAxMTc0NywzMDY5MDQ5OTYwLDIwMjAwODQ5NywzMzc3ODM2MiwyNzAwNDA0ODcsNTA0NDU5NDM2LDg3NTQ1MTI5Myw5NzU2NTg2NDYsNjc1MDM5NjI3LDY0MTAyNTE1MiwyMDg0NzA0MjMzLDE5MTc1MTg1NjIsMTYxNTg2MTI0NywxODUxMzMyODUyLDExNDc1NTA2NjEsMTI0ODgwMjUxMCwxNDg0MDA1ODQzLDE0NTEwNDQwNTYsOTMzMzAxMzcwLDk2NzMxMTcyOSw3MzMxNTY5NzIsNjMyOTUzNzAzLDI2MDM4ODk1MCwyNTk2NTkxNywzMjg2NzE4MDgsNDk2OTA2MDU5LDEyMDY0Nzc4NTgsMTIzOTQ0Mzc1MywxNTQzMjA4NTAwLDE0NDE5NTI1NzUsMjE0NDE2MTgwNiwxOTA4Njk0Mjc3LDE2NzU1Nzc4ODAsMTg0Mjc1OTQ0MywzNjEwMzY5MjI2LDM2NDQzNzk1ODUsMzQwODExOTUxNiwzMzA3OTE2MjQ3LDQwMTExOTA1MDIsMzc3Njc2NzQ2OSw0MDc3Mzg0NDMyLDQyNDU2MTg2ODMsMjgwOTc3MTE1NCwyODQyNzM3MDQ5LDMxNDQzOTY0MjAsMzA0MzE0MDQ5NSwyNjczNzA1MTUwLDI0MzgyMzc2MjEsMjIwMzAzMjIzMiwyMzcwMjEzNzk1XSk7X21peENvbD1uZXcgVWludDhBcnJheSgyNTYpLm1hcCgoKGUsdCk9PnQ8MTI4P3Q8PDE6dDw8MV4yNykpO2NvbnN0cnVjdG9yKCl7dGhpcy5idWZmZXI9bmV3IFVpbnQ4QXJyYXkoMTYpO3RoaXMuYnVmZmVyUG9zaXRpb249MH1fZXhwYW5kS2V5KGUpe3VucmVhY2hhYmxlKCJDYW5ub3QgY2FsbCBgX2V4cGFuZEtleWAgb24gdGhlIGJhc2UgY2xhc3MiKX1fZGVjcnlwdChlLHQpe2xldCBhLHIsaTtjb25zdCBuPW5ldyBVaW50OEFycmF5KDE2KTtuLnNldChlKTtmb3IobGV0IGU9MCxhPXRoaXMuX2tleVNpemU7ZTwxNjsrK2UsKythKW5bZV1ePXRbYV07Zm9yKGxldCBlPXRoaXMuX2N5Y2xlc09mUmVwZXRpdGlvbi0xO2U+PTE7LS1lKXthPW5bMTNdO25bMTNdPW5bOV07bls5XT1uWzVdO25bNV09blsxXTtuWzFdPWE7YT1uWzE0XTtyPW5bMTBdO25bMTRdPW5bNl07blsxMF09blsyXTtuWzZdPWE7blsyXT1yO2E9blsxNV07cj1uWzExXTtpPW5bN107blsxNV09blszXTtuWzExXT1hO25bN109cjtuWzNdPWk7Zm9yKGxldCBlPTA7ZTwxNjsrK2UpbltlXT10aGlzLl9pbnZfc1tuW2VdXTtmb3IobGV0IGE9MCxyPTE2KmU7YTwxNjsrK2EsKytyKW5bYV1ePXRbcl07Zm9yKGxldCBlPTA7ZTwxNjtlKz00KXtjb25zdCB0PXRoaXMuX21peFtuW2VdXSxyPXRoaXMuX21peFtuW2UrMV1dLGk9dGhpcy5fbWl4W25bZSsyXV0scz10aGlzLl9taXhbbltlKzNdXTthPXRecj4+Pjhecjw8MjReaT4+PjE2Xmk8PDE2XnM+Pj4yNF5zPDw4O25bZV09YT4+PjI0JjI1NTtuW2UrMV09YT4+MTYmMjU1O25bZSsyXT1hPj44JjI1NTtuW2UrM109MjU1JmF9fWE9blsxM107blsxM109bls5XTtuWzldPW5bNV07bls1XT1uWzFdO25bMV09YTthPW5bMTRdO3I9blsxMF07blsxNF09bls2XTtuWzEwXT1uWzJdO25bNl09YTtuWzJdPXI7YT1uWzE1XTtyPW5bMTFdO2k9bls3XTtuWzE1XT1uWzNdO25bMTFdPWE7bls3XT1yO25bM109aTtmb3IobGV0IGU9MDtlPDE2OysrZSl7bltlXT10aGlzLl9pbnZfc1tuW2VdXTtuW2VdXj10W2VdfXJldHVybiBufV9lbmNyeXB0KGUsdCl7Y29uc3QgYT10aGlzLl9zO2xldCByLGksbjtjb25zdCBzPW5ldyBVaW50OEFycmF5KDE2KTtzLnNldChlKTtmb3IobGV0IGU9MDtlPDE2OysrZSlzW2VdXj10W2VdO2ZvcihsZXQgZT0xO2U8dGhpcy5fY3ljbGVzT2ZSZXBldGl0aW9uO2UrKyl7Zm9yKGxldCBlPTA7ZTwxNjsrK2Upc1tlXT1hW3NbZV1dO249c1sxXTtzWzFdPXNbNV07c1s1XT1zWzldO3NbOV09c1sxM107c1sxM109bjtuPXNbMl07aT1zWzZdO3NbMl09c1sxMF07c1s2XT1zWzE0XTtzWzEwXT1uO3NbMTRdPWk7bj1zWzNdO2k9c1s3XTtyPXNbMTFdO3NbM109c1sxNV07c1s3XT1uO3NbMTFdPWk7c1sxNV09cjtmb3IobGV0IGU9MDtlPDE2O2UrPTQpe2NvbnN0IHQ9c1tlXSxhPXNbZSsxXSxpPXNbZSsyXSxuPXNbZSszXTtyPXReYV5pXm47c1tlXV49cl50aGlzLl9taXhDb2xbdF5hXTtzW2UrMV1ePXJedGhpcy5fbWl4Q29sW2FeaV07c1tlKzJdXj1yXnRoaXMuX21peENvbFtpXm5dO3NbZSszXV49cl50aGlzLl9taXhDb2xbbl50XX1mb3IobGV0IGE9MCxyPTE2KmU7YTwxNjsrK2EsKytyKXNbYV1ePXRbcl19Zm9yKGxldCBlPTA7ZTwxNjsrK2Upc1tlXT1hW3NbZV1dO249c1sxXTtzWzFdPXNbNV07c1s1XT1zWzldO3NbOV09c1sxM107c1sxM109bjtuPXNbMl07aT1zWzZdO3NbMl09c1sxMF07c1s2XT1zWzE0XTtzWzEwXT1uO3NbMTRdPWk7bj1zWzNdO2k9c1s3XTtyPXNbMTFdO3NbM109c1sxNV07c1s3XT1uO3NbMTFdPWk7c1sxNV09cjtmb3IobGV0IGU9MCxhPXRoaXMuX2tleVNpemU7ZTwxNjsrK2UsKythKXNbZV1ePXRbYV07cmV0dXJuIHN9X2RlY3J5cHRCbG9jazIoZSx0KXtjb25zdCBhPWUubGVuZ3RoO2xldCByPXRoaXMuYnVmZmVyLGk9dGhpcy5idWZmZXJQb3NpdGlvbjtjb25zdCBuPVtdO2xldCBzPXRoaXMuaXY7Zm9yKGxldCB0PTA7dDxhOysrdCl7cltpXT1lW3RdOysraTtpZihpPDE2KWNvbnRpbnVlO2NvbnN0IGE9dGhpcy5fZGVjcnlwdChyLHRoaXMuX2tleSk7Zm9yKGxldCBlPTA7ZTwxNjsrK2UpYVtlXV49c1tlXTtzPXI7bi5wdXNoKGEpO3I9bmV3IFVpbnQ4QXJyYXkoMTYpO2k9MH10aGlzLmJ1ZmZlcj1yO3RoaXMuYnVmZmVyTGVuZ3RoPWk7dGhpcy5pdj1zO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7bGV0IG89MTYqbi5sZW5ndGg7aWYodCl7Y29uc3QgZT1uLmF0KC0xKTtsZXQgdD1lWzE1XTtpZih0PD0xNil7Zm9yKGxldCBhPTE1LHI9MTYtdDthPj1yOy0tYSlpZihlW2FdIT09dCl7dD0wO2JyZWFrfW8tPXQ7bltuLmxlbmd0aC0xXT1lLnN1YmFycmF5KDAsMTYtdCl9fWNvbnN0IGM9bmV3IFVpbnQ4QXJyYXkobyk7Zm9yKGxldCBlPTAsdD0wLGE9bi5sZW5ndGg7ZTxhOysrZSx0Kz0xNiljLnNldChuW2VdLHQpO3JldHVybiBjfWRlY3J5cHRCbG9jayhlLHQsYT1udWxsKXtjb25zdCByPWUubGVuZ3RoLGk9dGhpcy5idWZmZXI7bGV0IG49dGhpcy5idWZmZXJQb3NpdGlvbjtpZihhKXRoaXMuaXY9YTtlbHNle2ZvcihsZXQgdD0wO248MTYmJnQ8cjsrK3QsKytuKWlbbl09ZVt0XTtpZihuPDE2KXt0aGlzLmJ1ZmZlckxlbmd0aD1uO3JldHVybiBuZXcgVWludDhBcnJheSgwKX10aGlzLml2PWk7ZT1lLnN1YmFycmF5KDE2KX10aGlzLmJ1ZmZlcj1uZXcgVWludDhBcnJheSgxNik7dGhpcy5idWZmZXJMZW5ndGg9MDt0aGlzLmRlY3J5cHRCbG9jaz10aGlzLl9kZWNyeXB0QmxvY2syO3JldHVybiB0aGlzLmRlY3J5cHRCbG9jayhlLHQpfWVuY3J5cHQoZSx0KXtjb25zdCBhPWUubGVuZ3RoO2xldCByPXRoaXMuYnVmZmVyLGk9dGhpcy5idWZmZXJQb3NpdGlvbjtjb25zdCBuPVtdO3R8fD1uZXcgVWludDhBcnJheSgxNik7Zm9yKGxldCBzPTA7czxhOysrcyl7cltpXT1lW3NdOysraTtpZihpPDE2KWNvbnRpbnVlO2ZvcihsZXQgZT0wO2U8MTY7KytlKXJbZV1ePXRbZV07Y29uc3QgYT10aGlzLl9lbmNyeXB0KHIsdGhpcy5fa2V5KTt0PWE7bi5wdXNoKGEpO3I9bmV3IFVpbnQ4QXJyYXkoMTYpO2k9MH10aGlzLmJ1ZmZlcj1yO3RoaXMuYnVmZmVyTGVuZ3RoPWk7dGhpcy5pdj10O2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7Y29uc3Qgcz0xNipuLmxlbmd0aCxvPW5ldyBVaW50OEFycmF5KHMpO2ZvcihsZXQgZT0wLHQ9MCxhPW4ubGVuZ3RoO2U8YTsrK2UsdCs9MTYpby5zZXQobltlXSx0KTtyZXR1cm4gb319Y2xhc3MgQUVTMTI4Q2lwaGVyIGV4dGVuZHMgQUVTQmFzZUNpcGhlcntfcmNvbj1uZXcgVWludDhBcnJheShbMTQxLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0LDEwOCwyMTYsMTcxLDc3LDE1NCw0Nyw5NCwxODgsOTksMTk4LDE1MSw1MywxMDYsMjEyLDE3OSwxMjUsMjUwLDIzOSwxOTcsMTQ1LDU3LDExNCwyMjgsMjExLDE4OSw5NywxOTQsMTU5LDM3LDc0LDE0OCw1MSwxMDIsMjA0LDEzMSwyOSw1OCwxMTYsMjMyLDIwMywxNDEsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTQsMTA4LDIxNiwxNzEsNzcsMTU0LDQ3LDk0LDE4OCw5OSwxOTgsMTUxLDUzLDEwNiwyMTIsMTc5LDEyNSwyNTAsMjM5LDE5NywxNDUsNTcsMTE0LDIyOCwyMTEsMTg5LDk3LDE5NCwxNTksMzcsNzQsMTQ4LDUxLDEwMiwyMDQsMTMxLDI5LDU4LDExNiwyMzIsMjAzLDE0MSwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NCwxMDgsMjE2LDE3MSw3NywxNTQsNDcsOTQsMTg4LDk5LDE5OCwxNTEsNTMsMTA2LDIxMiwxNzksMTI1LDI1MCwyMzksMTk3LDE0NSw1NywxMTQsMjI4LDIxMSwxODksOTcsMTk0LDE1OSwzNyw3NCwxNDgsNTEsMTAyLDIwNCwxMzEsMjksNTgsMTE2LDIzMiwyMDMsMTQxLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0LDEwOCwyMTYsMTcxLDc3LDE1NCw0Nyw5NCwxODgsOTksMTk4LDE1MSw1MywxMDYsMjEyLDE3OSwxMjUsMjUwLDIzOSwxOTcsMTQ1LDU3LDExNCwyMjgsMjExLDE4OSw5NywxOTQsMTU5LDM3LDc0LDE0OCw1MSwxMDIsMjA0LDEzMSwyOSw1OCwxMTYsMjMyLDIwMywxNDEsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTQsMTA4LDIxNiwxNzEsNzcsMTU0LDQ3LDk0LDE4OCw5OSwxOTgsMTUxLDUzLDEwNiwyMTIsMTc5LDEyNSwyNTAsMjM5LDE5NywxNDUsNTcsMTE0LDIyOCwyMTEsMTg5LDk3LDE5NCwxNTksMzcsNzQsMTQ4LDUxLDEwMiwyMDQsMTMxLDI5LDU4LDExNiwyMzIsMjAzLDE0MV0pO2NvbnN0cnVjdG9yKGUpe3N1cGVyKCk7dGhpcy5fY3ljbGVzT2ZSZXBldGl0aW9uPTEwO3RoaXMuX2tleVNpemU9MTYwO3RoaXMuX2tleT10aGlzLl9leHBhbmRLZXkoZSl9X2V4cGFuZEtleShlKXtjb25zdCB0PXRoaXMuX3MsYT10aGlzLl9yY29uLHI9bmV3IFVpbnQ4QXJyYXkoMTc2KTtyLnNldChlKTtmb3IobGV0IGU9MTYsaT0xO2U8MTc2OysraSl7bGV0IG49cltlLTNdLHM9cltlLTJdLG89cltlLTFdLGM9cltlLTRdO249dFtuXTtzPXRbc107bz10W29dO2M9dFtjXTtuXj1hW2ldO2ZvcihsZXQgdD0wO3Q8NDsrK3Qpe3JbZV09bl49cltlLTE2XTtlKys7cltlXT1zXj1yW2UtMTZdO2UrKztyW2VdPW9ePXJbZS0xNl07ZSsrO3JbZV09Y149cltlLTE2XTtlKyt9fXJldHVybiByfX1jbGFzcyBBRVMyNTZDaXBoZXIgZXh0ZW5kcyBBRVNCYXNlQ2lwaGVye2NvbnN0cnVjdG9yKGUpe3N1cGVyKCk7dGhpcy5fY3ljbGVzT2ZSZXBldGl0aW9uPTE0O3RoaXMuX2tleVNpemU9MjI0O3RoaXMuX2tleT10aGlzLl9leHBhbmRLZXkoZSl9X2V4cGFuZEtleShlKXtjb25zdCB0PXRoaXMuX3MsYT1uZXcgVWludDhBcnJheSgyNDApO2Euc2V0KGUpO2xldCByLGksbixzLG89MTtmb3IobGV0IGU9MzIsYz0xO2U8MjQwOysrYyl7aWYoZSUzMj09MTYpe3I9dFtyXTtpPXRbaV07bj10W25dO3M9dFtzXX1lbHNlIGlmKGUlMzI9PTApe3I9YVtlLTNdO2k9YVtlLTJdO249YVtlLTFdO3M9YVtlLTRdO3I9dFtyXTtpPXRbaV07bj10W25dO3M9dFtzXTtyXj1vOyhvPDw9MSk+PTI1NiYmKG89MjU1JigyN15vKSl9Zm9yKGxldCB0PTA7dDw0OysrdCl7YVtlXT1yXj1hW2UtMzJdO2UrKzthW2VdPWlePWFbZS0zMl07ZSsrO2FbZV09bl49YVtlLTMyXTtlKys7YVtlXT1zXj1hW2UtMzJdO2UrK319cmV0dXJuIGF9fWNsYXNzIFBERkJhc2V7X2hhc2goZSx0LGEpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBtZXRob2QgYF9oYXNoYCBjYWxsZWQiKX1jaGVja093bmVyUGFzc3dvcmQoZSx0LGEscil7Y29uc3QgaT1uZXcgVWludDhBcnJheShlLmxlbmd0aCs1Nik7aS5zZXQoZSwwKTtpLnNldCh0LGUubGVuZ3RoKTtpLnNldChhLGUubGVuZ3RoK3QubGVuZ3RoKTtyZXR1cm4gaXNBcnJheUVxdWFsKHRoaXMuX2hhc2goZSxpLGEpLHIpfWNoZWNrVXNlclBhc3N3b3JkKGUsdCxhKXtjb25zdCByPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKzgpO3Iuc2V0KGUsMCk7ci5zZXQodCxlLmxlbmd0aCk7cmV0dXJuIGlzQXJyYXlFcXVhbCh0aGlzLl9oYXNoKGUscixbXSksYSl9Z2V0T3duZXJLZXkoZSx0LGEscil7Y29uc3QgaT1uZXcgVWludDhBcnJheShlLmxlbmd0aCs1Nik7aS5zZXQoZSwwKTtpLnNldCh0LGUubGVuZ3RoKTtpLnNldChhLGUubGVuZ3RoK3QubGVuZ3RoKTtjb25zdCBuPXRoaXMuX2hhc2goZSxpLGEpO3JldHVybiBuZXcgQUVTMjU2Q2lwaGVyKG4pLmRlY3J5cHRCbG9jayhyLCExLG5ldyBVaW50OEFycmF5KDE2KSl9Z2V0VXNlcktleShlLHQsYSl7Y29uc3Qgcj1uZXcgVWludDhBcnJheShlLmxlbmd0aCs4KTtyLnNldChlLDApO3Iuc2V0KHQsZS5sZW5ndGgpO2NvbnN0IGk9dGhpcy5faGFzaChlLHIsW10pO3JldHVybiBuZXcgQUVTMjU2Q2lwaGVyKGkpLmRlY3J5cHRCbG9jayhhLCExLG5ldyBVaW50OEFycmF5KDE2KSl9fWNsYXNzIFBERjE3IGV4dGVuZHMgUERGQmFzZXtfaGFzaChlLHQsYSl7cmV0dXJuIGNhbGN1bGF0ZVNIQTI1Nih0LDAsdC5sZW5ndGgpfX1jbGFzcyBQREYyMCBleHRlbmRzIFBERkJhc2V7X2hhc2goZSx0LGEpe2xldCByPWNhbGN1bGF0ZVNIQTI1Nih0LDAsdC5sZW5ndGgpLnN1YmFycmF5KDAsMzIpLGk9WzBdLG49MDtmb3IoO248NjR8fGkuYXQoLTEpPm4tMzI7KXtjb25zdCB0PWUubGVuZ3RoK3IubGVuZ3RoK2EubGVuZ3RoLGw9bmV3IFVpbnQ4QXJyYXkodCk7bGV0IGg9MDtsLnNldChlLGgpO2grPWUubGVuZ3RoO2wuc2V0KHIsaCk7aCs9ci5sZW5ndGg7bC5zZXQoYSxoKTtjb25zdCB1PW5ldyBVaW50OEFycmF5KDY0KnQpO2ZvcihsZXQgZT0wLGE9MDtlPDY0O2UrKyxhKz10KXUuc2V0KGwsYSk7aT1uZXcgQUVTMTI4Q2lwaGVyKHIuc3ViYXJyYXkoMCwxNikpLmVuY3J5cHQodSxyLnN1YmFycmF5KDE2LDMyKSk7Y29uc3QgZD1NYXRoLnN1bVByZWNpc2UoaS5zbGljZSgwLDE2KSklMzswPT09ZD9yPWNhbGN1bGF0ZVNIQTI1NihpLDAsaS5sZW5ndGgpOjE9PT1kP3I9KHM9aSxvPTAsYz1pLmxlbmd0aCxjYWxjdWxhdGVTSEE1MTIocyxvLGMsITApKToyPT09ZCYmKHI9Y2FsY3VsYXRlU0hBNTEyKGksMCxpLmxlbmd0aCkpO24rK312YXIgcyxvLGM7cmV0dXJuIHIuc3ViYXJyYXkoMCwzMil9fWNsYXNzIENpcGhlclRyYW5zZm9ybXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuU3RyaW5nQ2lwaGVyQ29uc3RydWN0b3I9ZTt0aGlzLlN0cmVhbUNpcGhlckNvbnN0cnVjdG9yPXR9Y3JlYXRlU3RyZWFtKGUsdCl7Y29uc3QgYT1uZXcgdGhpcy5TdHJlYW1DaXBoZXJDb25zdHJ1Y3RvcjtyZXR1cm4gbmV3IERlY3J5cHRTdHJlYW0oZSx0LChmdW5jdGlvbiBjaXBoZXJUcmFuc2Zvcm1EZWNyeXB0U3RyZWFtKGUsdCl7cmV0dXJuIGEuZGVjcnlwdEJsb2NrKGUsdCl9KSl9ZGVjcnlwdFN0cmluZyhlKXtjb25zdCB0PW5ldyB0aGlzLlN0cmluZ0NpcGhlckNvbnN0cnVjdG9yO2xldCBhPXN0cmluZ1RvQnl0ZXMoZSk7YT10LmRlY3J5cHRCbG9jayhhLCEwKTtyZXR1cm4gYnl0ZXNUb1N0cmluZyhhKX1lbmNyeXB0U3RyaW5nKGUpe2NvbnN0IHQ9bmV3IHRoaXMuU3RyaW5nQ2lwaGVyQ29uc3RydWN0b3I7aWYodCBpbnN0YW5jZW9mIEFFU0Jhc2VDaXBoZXIpe2NvbnN0IGE9MTYtZS5sZW5ndGglMTY7ZSs9U3RyaW5nLmZyb21DaGFyQ29kZShhKS5yZXBlYXQoYSk7Y29uc3Qgcj1uZXcgVWludDhBcnJheSgxNik7Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyKTtsZXQgaT1zdHJpbmdUb0J5dGVzKGUpO2k9dC5lbmNyeXB0KGkscik7Y29uc3Qgbj1uZXcgVWludDhBcnJheSgxNitpLmxlbmd0aCk7bi5zZXQocik7bi5zZXQoaSwxNik7cmV0dXJuIGJ5dGVzVG9TdHJpbmcobil9bGV0IGE9c3RyaW5nVG9CeXRlcyhlKTthPXQuZW5jcnlwdChhKTtyZXR1cm4gYnl0ZXNUb1N0cmluZyhhKX19Y2xhc3MgQ2lwaGVyVHJhbnNmb3JtRmFjdG9yeXtzdGF0aWMgZ2V0IF9kZWZhdWx0UGFzc3dvcmRCeXRlcygpe3JldHVybiBzaGFkb3codGhpcywiX2RlZmF1bHRQYXNzd29yZEJ5dGVzIixuZXcgVWludDhBcnJheShbNDAsMTkxLDc4LDk0LDc4LDExNywxMzgsNjUsMTAwLDAsNzgsODYsMjU1LDI1MCwxLDgsNDYsNDYsMCwxODIsMjA4LDEwNCw2MiwxMjgsNDcsMTIsMTY5LDI1NCwxMDAsODMsMTA1LDEyMl0pKX0jT2UoZSx0LGEscixpLG4scyxvLGMsbCxoLHUpe2lmKHQpe2NvbnN0IGU9TWF0aC5taW4oMTI3LHQubGVuZ3RoKTt0PXQuc3ViYXJyYXkoMCxlKX1lbHNlIHQ9W107Y29uc3QgZD02PT09ZT9uZXcgUERGMjA6bmV3IFBERjE3O3JldHVybiBkLmNoZWNrVXNlclBhc3N3b3JkKHQsbyxzKT9kLmdldFVzZXJLZXkodCxjLGgpOnQubGVuZ3RoJiZkLmNoZWNrT3duZXJQYXNzd29yZCh0LHIsbixhKT9kLmdldE93bmVyS2V5KHQsaSxuLGwpOm51bGx9I01lKGUsdCxhLHIsaSxuLHMsbyl7Y29uc3QgYz00MCthLmxlbmd0aCtlLmxlbmd0aCxsPW5ldyBVaW50OEFycmF5KGMpO2xldCBoLHUsZD0wO2lmKHQpe3U9TWF0aC5taW4oMzIsdC5sZW5ndGgpO2Zvcig7ZDx1OysrZClsW2RdPXRbZF19aD0wO2Zvcig7ZDwzMjspbFtkKytdPUNpcGhlclRyYW5zZm9ybUZhY3RvcnkuX2RlZmF1bHRQYXNzd29yZEJ5dGVzW2grK107bC5zZXQoYSxkKTtkKz1hLmxlbmd0aDtsW2QrK109MjU1Jmk7bFtkKytdPWk+PjgmMjU1O2xbZCsrXT1pPj4xNiYyNTU7bFtkKytdPWk+Pj4yNCYyNTU7bC5zZXQoZSxkKTtkKz1lLmxlbmd0aDtpZihuPj00JiYhbyl7bC5maWxsKDI1NSxkLGQrNCk7ZCs9NH1sZXQgZj1jYWxjdWxhdGVNRDUobCwwLGQpO2NvbnN0IGc9cz4+MztpZihuPj0zKWZvcihoPTA7aDw1MDsrK2gpZj1jYWxjdWxhdGVNRDUoZiwwLGcpO2NvbnN0IHA9Zi5zdWJhcnJheSgwLGcpO2xldCBtLGI7aWYobj49Myl7ZD0wO2wuc2V0KENpcGhlclRyYW5zZm9ybUZhY3RvcnkuX2RlZmF1bHRQYXNzd29yZEJ5dGVzLGQpO2QrPTMyO2wuc2V0KGUsZCk7ZCs9ZS5sZW5ndGg7bT1uZXcgQVJDRm91ckNpcGhlcihwKTtiPW0uZW5jcnlwdEJsb2NrKGNhbGN1bGF0ZU1ENShsLDAsZCkpO3U9cC5sZW5ndGg7Y29uc3QgdD1uZXcgVWludDhBcnJheSh1KTtmb3IoaD0xO2g8PTE5OysraCl7Zm9yKGxldCBlPTA7ZTx1OysrZSl0W2VdPXBbZV1eaDttPW5ldyBBUkNGb3VyQ2lwaGVyKHQpO2I9bS5lbmNyeXB0QmxvY2soYil9fWVsc2V7bT1uZXcgQVJDRm91ckNpcGhlcihwKTtiPW0uZW5jcnlwdEJsb2NrKENpcGhlclRyYW5zZm9ybUZhY3RvcnkuX2RlZmF1bHRQYXNzd29yZEJ5dGVzKX1yZXR1cm4gYi5ldmVyeSgoKGUsdCk9PnJbdF09PT1lKSk/cDpudWxsfSNEZShlLHQsYSxyKXtjb25zdCBpPW5ldyBVaW50OEFycmF5KDMyKTtsZXQgbj0wO2NvbnN0IHM9TWF0aC5taW4oMzIsZS5sZW5ndGgpO2Zvcig7bjxzOysrbilpW25dPWVbbl07bGV0IG89MDtmb3IoO248MzI7KWlbbisrXT1DaXBoZXJUcmFuc2Zvcm1GYWN0b3J5Ll9kZWZhdWx0UGFzc3dvcmRCeXRlc1tvKytdO2xldCBjPWNhbGN1bGF0ZU1ENShpLDAsbik7Y29uc3QgbD1yPj4zO2lmKGE+PTMpZm9yKG89MDtvPDUwOysrbyljPWNhbGN1bGF0ZU1ENShjLDAsYy5sZW5ndGgpO2xldCBoLHU7aWYoYT49Myl7dT10O2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkobCk7Zm9yKG89MTk7bz49MDtvLS0pe2ZvcihsZXQgdD0wO3Q8bDsrK3QpZVt0XT1jW3RdXm87aD1uZXcgQVJDRm91ckNpcGhlcihlKTt1PWguZW5jcnlwdEJsb2NrKHUpfX1lbHNle2g9bmV3IEFSQ0ZvdXJDaXBoZXIoYy5zdWJhcnJheSgwLGwpKTt1PWguZW5jcnlwdEJsb2NrKHQpfXJldHVybiB1fSNCZShlLHQsYSxyPSExKXtjb25zdCBpPWEubGVuZ3RoLG49bmV3IFVpbnQ4QXJyYXkoaSs5KTtuLnNldChhKTtsZXQgcz1pO25bcysrXT0yNTUmZTtuW3MrK109ZT4+OCYyNTU7bltzKytdPWU+PjE2JjI1NTtuW3MrK109MjU1JnQ7bltzKytdPXQ+PjgmMjU1O2lmKHIpe25bcysrXT0xMTU7bltzKytdPTY1O25bcysrXT0xMDg7bltzKytdPTg0fXJldHVybiBjYWxjdWxhdGVNRDUobiwwLHMpLnN1YmFycmF5KDAsTWF0aC5taW4oaSs1LDE2KSl9I1JlKGUsdCxhLHIsaSl7aWYoISh0IGluc3RhbmNlb2YgTmFtZSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIGNyeXB0IGZpbHRlciBuYW1lLiIpO2NvbnN0IG49dGhpcyxzPWUuZ2V0KHQubmFtZSksbz1zPy5nZXQoIkNGTSIpO2lmKCFvfHwiTm9uZSI9PT1vLm5hbWUpcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBOdWxsQ2lwaGVyfTtpZigiVjIiPT09by5uYW1lKXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgQVJDRm91ckNpcGhlcihuLiNCZShhLHIsaSwhMSkpfTtpZigiQUVTVjIiPT09by5uYW1lKXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgQUVTMTI4Q2lwaGVyKG4uI0JlKGEscixpLCEwKSl9O2lmKCJBRVNWMyI9PT1vLm5hbWUpcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBBRVMyNTZDaXBoZXIoaSl9O3Rocm93IG5ldyBGb3JtYXRFcnJvcigiVW5rbm93biBjcnlwdG8gbWV0aG9kIil9Y29uc3RydWN0b3IoZSx0LGEpe2NvbnN0IHI9ZS5nZXQoIkZpbHRlciIpO2lmKCFpc05hbWUociwiU3RhbmRhcmQiKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoInVua25vd24gZW5jcnlwdGlvbiBtZXRob2QiKTt0aGlzLmZpbHRlck5hbWU9ci5uYW1lO3RoaXMuZGljdD1lO2NvbnN0IGk9ZS5nZXQoIlYiKTtpZighTnVtYmVyLmlzSW50ZWdlcihpKXx8MSE9PWkmJjIhPT1pJiY0IT09aSYmNSE9PWkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJ1bnN1cHBvcnRlZCBlbmNyeXB0aW9uIGFsZ29yaXRobSIpO3RoaXMuYWxnb3JpdGhtPWk7bGV0IG49ZS5nZXQoIkxlbmd0aCIpO2lmKCFuKWlmKGk8PTMpbj00MDtlbHNle2NvbnN0IHQ9ZS5nZXQoIkNGIiksYT1lLmdldCgiU3RtRiIpO2lmKHQgaW5zdGFuY2VvZiBEaWN0JiZhIGluc3RhbmNlb2YgTmFtZSl7dC5zdXBwcmVzc0VuY3J5cHRpb249ITA7Y29uc3QgZT10LmdldChhLm5hbWUpO249ZT8uZ2V0KCJMZW5ndGgiKXx8MTI4O248NDAmJihuPDw9Myl9fWlmKCFOdW1iZXIuaXNJbnRlZ2VyKG4pfHxuPDQwfHxuJTghPTApdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJpbnZhbGlkIGtleSBsZW5ndGgiKTtjb25zdCBzPXN0cmluZ1RvQnl0ZXMoZS5nZXQoIk8iKSksbz1zdHJpbmdUb0J5dGVzKGUuZ2V0KCJVIikpLGM9cy5zdWJhcnJheSgwLDMyKSxsPW8uc3ViYXJyYXkoMCwzMiksaD1lLmdldCgiUCIpLHU9ZS5nZXQoIlIiKSxkPSg0PT09aXx8NT09PWkpJiYhMSE9PWUuZ2V0KCJFbmNyeXB0TWV0YWRhdGEiKTt0aGlzLmVuY3J5cHRNZXRhZGF0YT1kO2NvbnN0IGY9c3RyaW5nVG9CeXRlcyh0KTtsZXQgZyxwO2lmKGEpe2lmKDY9PT11KXRyeXthPXV0ZjhTdHJpbmdUb1N0cmluZyhhKX1jYXRjaHt3YXJuKCJDaXBoZXJUcmFuc2Zvcm1GYWN0b3J5OiBVbmFibGUgdG8gY29udmVydCBVVEY4IGVuY29kZWQgcGFzc3dvcmQuIil9Zz1zdHJpbmdUb0J5dGVzKGEpfWlmKDUhPT1pKXA9dGhpcy4jTWUoZixnLGMsbCxoLHUsbixkKTtlbHNle2NvbnN0IHQ9cy5zdWJhcnJheSgzMiw0MCksYT1zLnN1YmFycmF5KDQwLDQ4KSxyPW8uc3ViYXJyYXkoMCw0OCksaT1vLnN1YmFycmF5KDMyLDQwKSxuPW8uc3ViYXJyYXkoNDAsNDgpLGg9c3RyaW5nVG9CeXRlcyhlLmdldCgiT0UiKSksZD1zdHJpbmdUb0J5dGVzKGUuZ2V0KCJVRSIpKSxmPXN0cmluZ1RvQnl0ZXMoZS5nZXQoIlBlcm1zIikpO3A9dGhpcy4jT2UodSxnLGMsdCxhLHIsbCxpLG4saCxkLGYpfWlmKCFwKXtpZighYSl0aHJvdyBuZXcgUGFzc3dvcmRFeGNlcHRpb24oIk5vIHBhc3N3b3JkIGdpdmVuIixHdCk7Y29uc3QgZT10aGlzLiNEZShnLGMsdSxuKTtwPXRoaXMuI01lKGYsZSxjLGwsaCx1LG4sZCl9aWYoIXApdGhyb3cgbmV3IFBhc3N3b3JkRXhjZXB0aW9uKCJJbmNvcnJlY3QgUGFzc3dvcmQiLFZ0KTtpZig0PT09aSYmcC5sZW5ndGg8MTYpe3RoaXMuZW5jcnlwdGlvbktleT1uZXcgVWludDhBcnJheSgxNik7dGhpcy5lbmNyeXB0aW9uS2V5LnNldChwKX1lbHNlIHRoaXMuZW5jcnlwdGlvbktleT1wO2lmKGk+PTQpe2NvbnN0IHQ9ZS5nZXQoIkNGIik7dCBpbnN0YW5jZW9mIERpY3QmJih0LnN1cHByZXNzRW5jcnlwdGlvbj0hMCk7dGhpcy5jZj10O3RoaXMuc3RtZj1lLmdldCgiU3RtRiIpfHxOYW1lLmdldCgiSWRlbnRpdHkiKTt0aGlzLnN0cmY9ZS5nZXQoIlN0ckYiKXx8TmFtZS5nZXQoIklkZW50aXR5Iik7dGhpcy5lZmY9ZS5nZXQoIkVGRiIpfHx0aGlzLnN0bWZ9fWNyZWF0ZUNpcGhlclRyYW5zZm9ybShlLHQpe2lmKDQ9PT10aGlzLmFsZ29yaXRobXx8NT09PXRoaXMuYWxnb3JpdGhtKXJldHVybiBuZXcgQ2lwaGVyVHJhbnNmb3JtKHRoaXMuI1JlKHRoaXMuY2YsdGhpcy5zdHJmLGUsdCx0aGlzLmVuY3J5cHRpb25LZXkpLHRoaXMuI1JlKHRoaXMuY2YsdGhpcy5zdG1mLGUsdCx0aGlzLmVuY3J5cHRpb25LZXkpKTtjb25zdCBhPXRoaXMuI0JlKGUsdCx0aGlzLmVuY3J5cHRpb25LZXksITEpLGNpcGhlckNvbnN0cnVjdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBBUkNGb3VyQ2lwaGVyKGEpfTtyZXR1cm4gbmV3IENpcGhlclRyYW5zZm9ybShjaXBoZXJDb25zdHJ1Y3RvcixjaXBoZXJDb25zdHJ1Y3Rvcil9fWNsYXNzIFhSZWZ7I05lPW51bGw7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnN0cmVhbT1lO3RoaXMucGRmTWFuYWdlcj10O3RoaXMuZW50cmllcz1bXTt0aGlzLl94cmVmU3Rtcz1uZXcgU2V0O3RoaXMuX2NhY2hlTWFwPW5ldyBNYXA7dGhpcy5fcGVuZGluZ1JlZnM9bmV3IFJlZlNldDt0aGlzLl9uZXdQZXJzaXN0ZW50UmVmTnVtPW51bGw7dGhpcy5fbmV3VGVtcG9yYXJ5UmVmTnVtPW51bGw7dGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZT1udWxsfWdldE5ld1BlcnNpc3RlbnRSZWYoZSl7bnVsbD09PXRoaXMuX25ld1BlcnNpc3RlbnRSZWZOdW0mJih0aGlzLl9uZXdQZXJzaXN0ZW50UmVmTnVtPXRoaXMuZW50cmllcy5sZW5ndGh8fDEpO2NvbnN0IHQ9dGhpcy5fbmV3UGVyc2lzdGVudFJlZk51bSsrO3RoaXMuX2NhY2hlTWFwLnNldCh0LGUpO3JldHVybiBSZWYuZ2V0KHQsMCl9Z2V0TmV3VGVtcG9yYXJ5UmVmKCl7aWYobnVsbD09PXRoaXMuX25ld1RlbXBvcmFyeVJlZk51bSl7dGhpcy5fbmV3VGVtcG9yYXJ5UmVmTnVtPXRoaXMuZW50cmllcy5sZW5ndGh8fDE7aWYodGhpcy5fbmV3UGVyc2lzdGVudFJlZk51bSl7dGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZT1uZXcgTWFwO2ZvcihsZXQgZT10aGlzLl9uZXdUZW1wb3JhcnlSZWZOdW07ZTx0aGlzLl9uZXdQZXJzaXN0ZW50UmVmTnVtO2UrKyl7dGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZS5zZXQoZSx0aGlzLl9jYWNoZU1hcC5nZXQoZSkpO3RoaXMuX2NhY2hlTWFwLmRlbGV0ZShlKX19fXJldHVybiBSZWYuZ2V0KHRoaXMuX25ld1RlbXBvcmFyeVJlZk51bSsrLDApfXJlc2V0TmV3VGVtcG9yYXJ5UmVmKCl7dGhpcy5fbmV3VGVtcG9yYXJ5UmVmTnVtPW51bGw7aWYodGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZSlmb3IoY29uc3RbZSx0XW9mIHRoaXMuX3BlcnNpc3RlbnRSZWZzQ2FjaGUpdGhpcy5fY2FjaGVNYXAuc2V0KGUsdCk7dGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZT1udWxsfXNldFN0YXJ0WFJlZihlKXt0aGlzLnN0YXJ0WFJlZlF1ZXVlPVtlXX1wYXJzZShlPSExKXtsZXQgdCxhLHI7aWYoZSl7d2FybigiSW5kZXhpbmcgYWxsIFBERiBvYmplY3RzIik7dD10aGlzLmluZGV4T2JqZWN0cygpfWVsc2UgdD10aGlzLnJlYWRYUmVmKCk7dC5hc3NpZ25YcmVmKHRoaXMpO3RoaXMudHJhaWxlcj10O3RyeXthPXQuZ2V0KCJFbmNyeXB0Iil9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybihgWFJlZi5wYXJzZSAtIEludmFsaWQgIkVuY3J5cHQiIHJlZmVyZW5jZTogIiR7ZX0iLmApfWlmKGEgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBlPXQuZ2V0KCJJRCIpLHI9ZT8ubGVuZ3RoP2VbMF06IiI7YS5zdXBwcmVzc0VuY3J5cHRpb249ITA7dGhpcy5lbmNyeXB0PW5ldyBDaXBoZXJUcmFuc2Zvcm1GYWN0b3J5KGEscix0aGlzLnBkZk1hbmFnZXIucGFzc3dvcmQpfXRyeXtyPXQuZ2V0KCJSb290Iil9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybihgWFJlZi5wYXJzZSAtIEludmFsaWQgIlJvb3QiIHJlZmVyZW5jZTogIiR7ZX0iLmApfWlmKHIgaW5zdGFuY2VvZiBEaWN0KXRyeXtpZihyLmdldCgiUGFnZXMiKWluc3RhbmNlb2YgRGljdCl7dGhpcy5yb290PXI7cmV0dXJufX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTt3YXJuKGBYUmVmLnBhcnNlIC0gSW52YWxpZCAiUGFnZXMiIHJlZmVyZW5jZTogIiR7ZX0iLmApfWlmKCFlKXRocm93IG5ldyBYUmVmUGFyc2VFeGNlcHRpb247dGhyb3cgbmV3IEludmFsaWRQREZFeGNlcHRpb24oIkludmFsaWQgUm9vdCByZWZlcmVuY2UuIil9cHJvY2Vzc1hSZWZUYWJsZShlKXsidGFibGVTdGF0ZSJpbiB0aGlzfHwodGhpcy50YWJsZVN0YXRlPXtlbnRyeU51bTowLHN0cmVhbVBvczplLmxleGVyLnN0cmVhbS5wb3MscGFyc2VyQnVmMTplLmJ1ZjEscGFyc2VyQnVmMjplLmJ1ZjJ9KTtpZighaXNDbWQodGhpcy5yZWFkWFJlZlRhYmxlKGUpLCJ0cmFpbGVyIikpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgdGFibGU6IGNvdWxkIG5vdCBmaW5kIHRyYWlsZXIgZGljdGlvbmFyeSIpO2xldCB0PWUuZ2V0T2JqKCk7dCBpbnN0YW5jZW9mIERpY3R8fCF0LmRpY3R8fCh0PXQuZGljdCk7aWYoISh0IGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgdGFibGU6IGNvdWxkIG5vdCBwYXJzZSB0cmFpbGVyIGRpY3Rpb25hcnkiKTtkZWxldGUgdGhpcy50YWJsZVN0YXRlO3JldHVybiB0fXJlYWRYUmVmVGFibGUoZSl7Y29uc3QgdD1lLmxleGVyLnN0cmVhbSxhPXRoaXMudGFibGVTdGF0ZTt0LnBvcz1hLnN0cmVhbVBvcztlLmJ1ZjE9YS5wYXJzZXJCdWYxO2UuYnVmMj1hLnBhcnNlckJ1ZjI7bGV0IHI7Zm9yKDs7KXtpZighKCJmaXJzdEVudHJ5TnVtImluIGEpfHwhKCJlbnRyeUNvdW50ImluIGEpKXtpZihpc0NtZChyPWUuZ2V0T2JqKCksInRyYWlsZXIiKSlicmVhazthLmZpcnN0RW50cnlOdW09cjthLmVudHJ5Q291bnQ9ZS5nZXRPYmooKX1sZXQgaT1hLmZpcnN0RW50cnlOdW07Y29uc3Qgbj1hLmVudHJ5Q291bnQ7aWYoIU51bWJlci5pc0ludGVnZXIoaSl8fCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBYUmVmIHRhYmxlOiB3cm9uZyB0eXBlcyBpbiBzdWJzZWN0aW9uIGhlYWRlciIpO2ZvcihsZXQgcj1hLmVudHJ5TnVtO3I8bjtyKyspe2Euc3RyZWFtUG9zPXQucG9zO2EuZW50cnlOdW09cjthLnBhcnNlckJ1ZjE9ZS5idWYxO2EucGFyc2VyQnVmMj1lLmJ1ZjI7Y29uc3Qgcz17fTtzLm9mZnNldD1lLmdldE9iaigpO3MuZ2VuPWUuZ2V0T2JqKCk7Y29uc3Qgbz1lLmdldE9iaigpO2lmKG8gaW5zdGFuY2VvZiBDbWQpc3dpdGNoKG8uY21kKXtjYXNlImYiOnMuZnJlZT0hMDticmVhaztjYXNlIm4iOnMudW5jb21wcmVzc2VkPSEwfWlmKCFOdW1iZXIuaXNJbnRlZ2VyKHMub2Zmc2V0KXx8IU51bWJlci5pc0ludGVnZXIocy5nZW4pfHwhcy5mcmVlJiYhcy51bmNvbXByZXNzZWQpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIGVudHJ5IGluIFhSZWYgc3Vic2VjdGlvbjogJHtpfSwgJHtufWApOzA9PT1yJiZzLmZyZWUmJjE9PT1pJiYoaT0wKTt0aGlzLmVudHJpZXNbcitpXXx8KHRoaXMuZW50cmllc1tyK2ldPXMpfWEuZW50cnlOdW09MDthLnN0cmVhbVBvcz10LnBvczthLnBhcnNlckJ1ZjE9ZS5idWYxO2EucGFyc2VyQnVmMj1lLmJ1ZjI7ZGVsZXRlIGEuZmlyc3RFbnRyeU51bTtkZWxldGUgYS5lbnRyeUNvdW50fWlmKHRoaXMuZW50cmllc1swXSYmIXRoaXMuZW50cmllc1swXS5mcmVlKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBYUmVmIHRhYmxlOiB1bmV4cGVjdGVkIGZpcnN0IG9iamVjdCIpO3JldHVybiByfXByb2Nlc3NYUmVmU3RyZWFtKGUpe2lmKCEoInN0cmVhbVN0YXRlImluIHRoaXMpKXtjb25zdHtkaWN0OnQscG9zOmF9PWUscj10LmdldCgiVyIpLGk9dC5nZXQoIkluZGV4Iil8fFswLHQuZ2V0KCJTaXplIildO3RoaXMuc3RyZWFtU3RhdGU9e2VudHJ5UmFuZ2VzOmksYnl0ZVdpZHRoczpyLGVudHJ5TnVtOjAsc3RyZWFtUG9zOmF9fXRoaXMucmVhZFhSZWZTdHJlYW0oZSk7ZGVsZXRlIHRoaXMuc3RyZWFtU3RhdGU7cmV0dXJuIGUuZGljdH1yZWFkWFJlZlN0cmVhbShlKXtjb25zdCB0PXRoaXMuc3RyZWFtU3RhdGU7ZS5wb3M9dC5zdHJlYW1Qb3M7Y29uc3RbYSxyLGldPXQuYnl0ZVdpZHRocyxuPXQuZW50cnlSYW5nZXM7Zm9yKDtuLmxlbmd0aD4wOyl7Y29uc3RbcyxvXT1uO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHMpfHwhTnVtYmVyLmlzSW50ZWdlcihvKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgWFJlZiByYW5nZSBmaWVsZHM6ICR7c30sICR7b31gKTtpZighTnVtYmVyLmlzSW50ZWdlcihhKXx8IU51bWJlci5pc0ludGVnZXIocil8fCFOdW1iZXIuaXNJbnRlZ2VyKGkpKXRocm93IG5ldyBGb3JtYXRFcnJvcihgSW52YWxpZCBYUmVmIGVudHJ5IGZpZWxkcyBsZW5ndGg6ICR7c30sICR7b31gKTtmb3IobGV0IG49dC5lbnRyeU51bTtuPG87KytuKXt0LmVudHJ5TnVtPW47dC5zdHJlYW1Qb3M9ZS5wb3M7bGV0IG89MCxjPTAsbD0wO2ZvcihsZXQgdD0wO3Q8YTsrK3Qpe2NvbnN0IHQ9ZS5nZXRCeXRlKCk7aWYoLTE9PT10KXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBYUmVmIGJ5dGVXaWR0aHMgJ3R5cGUnLiIpO289bzw8OHx0fTA9PT1hJiYobz0xKTtmb3IobGV0IHQ9MDt0PHI7Kyt0KXtjb25zdCB0PWUuZ2V0Qnl0ZSgpO2lmKC0xPT09dCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkludmFsaWQgWFJlZiBieXRlV2lkdGhzICdvZmZzZXQnLiIpO2M9Yzw8OHx0fWZvcihsZXQgdD0wO3Q8aTsrK3Qpe2NvbnN0IHQ9ZS5nZXRCeXRlKCk7aWYoLTE9PT10KXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBYUmVmIGJ5dGVXaWR0aHMgJ2dlbmVyYXRpb24nLiIpO2w9bDw8OHx0fWNvbnN0IGg9e307aC5vZmZzZXQ9YztoLmdlbj1sO3N3aXRjaChvKXtjYXNlIDA6aC5mcmVlPSEwO2JyZWFrO2Nhc2UgMTpoLnVuY29tcHJlc3NlZD0hMDticmVhaztjYXNlIDI6YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgWFJlZiBlbnRyeSB0eXBlOiAke299YCl9dGhpcy5lbnRyaWVzW3Mrbl18fCh0aGlzLmVudHJpZXNbcytuXT1oKX10LmVudHJ5TnVtPTA7dC5zdHJlYW1Qb3M9ZS5wb3M7bi5zcGxpY2UoMCwyKX19aW5kZXhPYmplY3RzKCl7ZnVuY3Rpb24gcmVhZFRva2VuKGUsdCl7bGV0IGE9IiIscj1lW3RdO2Zvcig7MTAhPT1yJiYxMyE9PXImJjYwIT09ciYmISgrK3Q+PWUubGVuZ3RoKTspe2ErPVN0cmluZy5mcm9tQ2hhckNvZGUocik7cj1lW3RdfXJldHVybiBhfWZ1bmN0aW9uIHNraXBVbnRpbChlLHQsYSl7Y29uc3Qgcj1hLmxlbmd0aCxpPWUubGVuZ3RoO2xldCBuPTA7Zm9yKDt0PGk7KXtsZXQgaT0wO2Zvcig7aTxyJiZlW3QraV09PT1hW2ldOykrK2k7aWYoaT49cilicmVhazt0Kys7bisrfXJldHVybiBufWNvbnN0IGU9L1xiKGVuZG9ianxcZCtccytcZCtccytvYmp8eHJlZnx0cmFpbGVyXHMqPDwpXGIvZyx0PS9cYihzdGFydHhyZWZ8XGQrXHMrXGQrXHMrb2JqKVxiL2csYT0vXihcZCspXHMrKFxkKylccytvYmpcYi8scj1uZXcgVWludDhBcnJheShbMTE2LDExNCw5NywxMDUsMTA4LDEwMSwxMTRdKSxpPW5ldyBVaW50OEFycmF5KFsxMTUsMTE2LDk3LDExNCwxMTYsMTIwLDExNCwxMDEsMTAyXSksbj1uZXcgVWludDhBcnJheShbNDcsODgsODIsMTAxLDEwMl0pO3RoaXMuZW50cmllcy5sZW5ndGg9MDt0aGlzLl9jYWNoZU1hcC5jbGVhcigpO2NvbnN0IHM9dGhpcy5zdHJlYW07cy5wb3M9MDtjb25zdCBvPXMuZ2V0Qnl0ZXMoKSxjPWJ5dGVzVG9TdHJpbmcobyksbD1vLmxlbmd0aDtsZXQgaD1zLnN0YXJ0O2NvbnN0IHU9W10sZD1bXTtmb3IoO2g8bDspe2xldCBmPW9baF07aWYoOT09PWZ8fDEwPT09Znx8MTM9PT1mfHwzMj09PWYpeysraDtjb250aW51ZX1pZigzNz09PWYpe2RveysraDtpZihoPj1sKWJyZWFrO2Y9b1toXX13aGlsZSgxMCE9PWYmJjEzIT09Zik7Y29udGludWV9Y29uc3QgZz1yZWFkVG9rZW4obyxoKTtsZXQgcDtpZihnLnN0YXJ0c1dpdGgoInhyZWYiKSYmKDQ9PT1nLmxlbmd0aHx8L1xzLy50ZXN0KGdbNF0pKSl7aCs9c2tpcFVudGlsKG8saCxyKTt1LnB1c2goaCk7aCs9c2tpcFVudGlsKG8saCxpKX1lbHNlIGlmKHA9YS5leGVjKGcpKXtjb25zdCB0PTB8cFsxXSxhPTB8cFsyXSxyPWgrZy5sZW5ndGg7bGV0IGksdT0hMTtpZih0aGlzLmVudHJpZXNbdF0pe2lmKHRoaXMuZW50cmllc1t0XS5nZW49PT1hKXRyeXtuZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIocy5tYWtlU3ViU3RyZWFtKHIpKX0pLmdldE9iaigpO3U9ITB9Y2F0Y2goZSl7ZSBpbnN0YW5jZW9mIFBhcnNlckVPRkV4Y2VwdGlvbj93YXJuKGBpbmRleE9iamVjdHMgLS0gY2hlY2tpbmcgb2JqZWN0ICgke2d9KTogIiR7ZX0iLmApOnU9ITB9fWVsc2UgdT0hMDt1JiYodGhpcy5lbnRyaWVzW3RdPXtvZmZzZXQ6aC1zLnN0YXJ0LGdlbjphLHVuY29tcHJlc3NlZDohMH0pO2UubGFzdEluZGV4PXI7Y29uc3QgZj1lLmV4ZWMoYyk7aWYoZil7aT1lLmxhc3RJbmRleCsxLWg7aWYoImVuZG9iaiIhPT1mWzFdKXt3YXJuKGBpbmRleE9iamVjdHM6IEZvdW5kICIke2ZbMV19IiBpbnNpZGUgb2YgYW5vdGhlciAib2JqIiwgY2F1c2VkIGJ5IG1pc3NpbmcgImVuZG9iaiIgLS0gdHJ5aW5nIHRvIHJlY292ZXIuYCk7aS09ZlsxXS5sZW5ndGgrMX19ZWxzZSBpPWwtaDtjb25zdCBtPW8uc3ViYXJyYXkoaCxoK2kpLGI9c2tpcFVudGlsKG0sMCxuKTtpZihiPGkmJm1bYis1XTw2NCl7ZC5wdXNoKGgtcy5zdGFydCk7dGhpcy5feHJlZlN0bXMuYWRkKGgtcy5zdGFydCl9aCs9aX1lbHNlIGlmKGcuc3RhcnRzV2l0aCgidHJhaWxlciIpJiYoNz09PWcubGVuZ3RofHwvXHMvLnRlc3QoZ1s3XSkpKXt1LnB1c2goaCk7Y29uc3QgZT1oK2cubGVuZ3RoO2xldCBhO3QubGFzdEluZGV4PWU7Y29uc3Qgcj10LmV4ZWMoYyk7aWYocil7YT10Lmxhc3RJbmRleCsxLWg7aWYoInN0YXJ0eHJlZiIhPT1yWzFdKXt3YXJuKGBpbmRleE9iamVjdHM6IEZvdW5kICIke3JbMV19IiBhZnRlciAidHJhaWxlciIsIGNhdXNlZCBieSBtaXNzaW5nICJzdGFydHhyZWYiIC0tIHRyeWluZyB0byByZWNvdmVyLmApO2EtPXJbMV0ubGVuZ3RoKzF9fWVsc2UgYT1sLWg7aCs9YX1lbHNlIGgrPWcubGVuZ3RoKzF9Zm9yKGNvbnN0IGUgb2YgZCl7dGhpcy5zdGFydFhSZWZRdWV1ZS5wdXNoKGUpO3RoaXMucmVhZFhSZWYoITApfWNvbnN0IGY9W107bGV0IGcscCxtPSExO2Zvcihjb25zdCBlIG9mIHUpe3MucG9zPWU7Y29uc3QgdD1uZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIocykseHJlZjp0aGlzLGFsbG93U3RyZWFtczohMCxyZWNvdmVyeU1vZGU6ITB9KTtpZighaXNDbWQodC5nZXRPYmooKSwidHJhaWxlciIpKWNvbnRpbnVlO2NvbnN0IGE9dC5nZXRPYmooKTtpZihhIGluc3RhbmNlb2YgRGljdCl7Zi5wdXNoKGEpO2EuaGFzKCJFbmNyeXB0IikmJihtPSEwKX19Zm9yKGNvbnN0IGUgb2ZbLi4uZiwiZ2VuRmFsbGJhY2siLC4uLmZdKXtpZigiZ2VuRmFsbGJhY2siPT09ZSl7aWYoIXApYnJlYWs7dGhpcy5fZ2VuZXJhdGlvbkZhbGxiYWNrPSEwO2NvbnRpbnVlfWxldCB0PSExO3RyeXtjb25zdCBhPWUuZ2V0KCJSb290Iik7aWYoIShhIGluc3RhbmNlb2YgRGljdCkpY29udGludWU7Y29uc3Qgcj1hLmdldCgiUGFnZXMiKTtpZighKHIgaW5zdGFuY2VvZiBEaWN0KSljb250aW51ZTtjb25zdCBpPXIuZ2V0KCJDb3VudCIpO051bWJlci5pc0ludGVnZXIoaSkmJih0PSEwKX1jYXRjaChlKXtwPWU7Y29udGludWV9aWYodCYmKCFtfHxlLmhhcygiRW5jcnlwdCIpKSYmZS5oYXMoIklEIikpcmV0dXJuIGU7Zz1lfWlmKGcpcmV0dXJuIGc7aWYodGhpcy50b3BEaWN0KXJldHVybiB0aGlzLnRvcERpY3Q7aWYoIWYubGVuZ3RoKWZvcihjb25zdCBlIGluIHRoaXMuZW50cmllcyl7aWYoIU9iamVjdC5oYXNPd24odGhpcy5lbnRyaWVzLGUpKWNvbnRpbnVlO2NvbnN0IHQ9dGhpcy5lbnRyaWVzW2VdLGE9UmVmLmdldChwYXJzZUludChlKSx0Lmdlbik7bGV0IHI7dHJ5e3I9dGhpcy5mZXRjaChhKX1jYXRjaHtjb250aW51ZX1yIGluc3RhbmNlb2YgQmFzZVN0cmVhbSYmKHI9ci5kaWN0KTtpZihyIGluc3RhbmNlb2YgRGljdCYmci5oYXMoIlJvb3QiKSlyZXR1cm4gcn10aHJvdyBuZXcgSW52YWxpZFBERkV4Y2VwdGlvbigiSW52YWxpZCBQREYgc3RydWN0dXJlLiIpfXJlYWRYUmVmKGU9ITEpe2NvbnN0IHQ9dGhpcy5zdHJlYW0sYT1uZXcgU2V0O2Zvcig7dGhpcy5zdGFydFhSZWZRdWV1ZS5sZW5ndGg7KXt0cnl7Y29uc3QgZT10aGlzLnN0YXJ0WFJlZlF1ZXVlWzBdO2lmKGEuaGFzKGUpKXt3YXJuKCJyZWFkWFJlZiAtIHNraXBwaW5nIFhSZWYgdGFibGUgc2luY2UgaXQgd2FzIGFscmVhZHkgcGFyc2VkLiIpO3RoaXMuc3RhcnRYUmVmUXVldWUuc2hpZnQoKTtjb250aW51ZX1hLmFkZChlKTt0LnBvcz1lK3Quc3RhcnQ7Y29uc3Qgcj1uZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIodCkseHJlZjp0aGlzLGFsbG93U3RyZWFtczohMH0pO2xldCBpLG49ci5nZXRPYmooKTtpZihpc0NtZChuLCJ4cmVmIikpe2k9dGhpcy5wcm9jZXNzWFJlZlRhYmxlKHIpO3RoaXMudG9wRGljdHx8KHRoaXMudG9wRGljdD1pKTtuPWkuZ2V0KCJYUmVmU3RtIik7aWYoTnVtYmVyLmlzSW50ZWdlcihuKSYmIXRoaXMuX3hyZWZTdG1zLmhhcyhuKSl7dGhpcy5feHJlZlN0bXMuYWRkKG4pO3RoaXMuc3RhcnRYUmVmUXVldWUucHVzaChuKTt0aGlzLiNOZT8/PW59fWVsc2V7aWYoIU51bWJlci5pc0ludGVnZXIobikpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgc3RyZWFtIGhlYWRlciIpO2lmKCEoTnVtYmVyLmlzSW50ZWdlcihyLmdldE9iaigpKSYmaXNDbWQoci5nZXRPYmooKSwib2JqIikmJihuPXIuZ2V0T2JqKCkpaW5zdGFuY2VvZiBCYXNlU3RyZWFtKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkludmFsaWQgWFJlZiBzdHJlYW0iKTtpPXRoaXMucHJvY2Vzc1hSZWZTdHJlYW0obik7dGhpcy50b3BEaWN0fHwodGhpcy50b3BEaWN0PWkpO2lmKCFpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiRmFpbGVkIHRvIHJlYWQgWFJlZiBzdHJlYW0iKX1uPWkuZ2V0KCJQcmV2Iik7TnVtYmVyLmlzSW50ZWdlcihuKT90aGlzLnN0YXJ0WFJlZlF1ZXVlLnB1c2gobik6biBpbnN0YW5jZW9mIFJlZiYmdGhpcy5zdGFydFhSZWZRdWV1ZS5wdXNoKG4ubnVtKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTtpbmZvKCIod2hpbGUgcmVhZGluZyBYUmVmKTogIitlKX10aGlzLnN0YXJ0WFJlZlF1ZXVlLnNoaWZ0KCl9aWYodGhpcy50b3BEaWN0KXJldHVybiB0aGlzLnRvcERpY3Q7aWYoIWUpdGhyb3cgbmV3IFhSZWZQYXJzZUV4Y2VwdGlvbn1nZXQgbGFzdFhSZWZTdHJlYW1Qb3MoKXtyZXR1cm4gdGhpcy4jTmU/Pyh0aGlzLl94cmVmU3Rtcy5zaXplPjA/TWF0aC5tYXgoLi4udGhpcy5feHJlZlN0bXMpOm51bGwpfWdldEVudHJ5KGUpe2NvbnN0IHQ9dGhpcy5lbnRyaWVzW2VdO3JldHVybiB0JiYhdC5mcmVlJiZ0Lm9mZnNldD90Om51bGx9ZmV0Y2hJZlJlZihlLHQ9ITEpe3JldHVybiBlIGluc3RhbmNlb2YgUmVmP3RoaXMuZmV0Y2goZSx0KTplfWZldGNoKGUsdD0hMSl7aWYoIShlIGluc3RhbmNlb2YgUmVmKSl0aHJvdyBuZXcgRXJyb3IoInJlZiBvYmplY3QgaXMgbm90IGEgcmVmZXJlbmNlIik7Y29uc3QgYT1lLm51bSxyPXRoaXMuX2NhY2hlTWFwLmdldChhKTtpZih2b2lkIDAhPT1yKXtyIGluc3RhbmNlb2YgRGljdCYmIXIub2JqSWQmJihyLm9iaklkPWUudG9TdHJpbmcoKSk7cmV0dXJuIHJ9bGV0IGk9dGhpcy5nZXRFbnRyeShhKTtpZihudWxsPT09aSlyZXR1cm4gaTtpZih0aGlzLl9wZW5kaW5nUmVmcy5oYXMoZSkpe3RoaXMuX3BlbmRpbmdSZWZzLnJlbW92ZShlKTt3YXJuKGBJZ25vcmluZyBjaXJjdWxhciByZWZlcmVuY2U6ICR7ZX0uYCk7cmV0dXJuIHRhfXRoaXMuX3BlbmRpbmdSZWZzLnB1dChlKTt0cnl7aT1pLnVuY29tcHJlc3NlZD90aGlzLmZldGNoVW5jb21wcmVzc2VkKGUsaSx0KTp0aGlzLmZldGNoQ29tcHJlc3NlZChlLGksdCk7dGhpcy5fcGVuZGluZ1JlZnMucmVtb3ZlKGUpfWNhdGNoKHQpe3RoaXMuX3BlbmRpbmdSZWZzLnJlbW92ZShlKTt0aHJvdyB0fWkgaW5zdGFuY2VvZiBEaWN0P2kub2JqSWQ9ZS50b1N0cmluZygpOmkgaW5zdGFuY2VvZiBCYXNlU3RyZWFtJiYoaS5kaWN0Lm9iaklkPWUudG9TdHJpbmcoKSk7cmV0dXJuIGl9ZmV0Y2hVbmNvbXByZXNzZWQoZSx0LGE9ITEpe2NvbnN0IHI9ZS5nZW47bGV0IGk9ZS5udW07aWYodC5nZW4hPT1yKXtjb25zdCBuPWBJbmNvbnNpc3RlbnQgZ2VuZXJhdGlvbiBpbiBYUmVmOiAke2V9YDtpZih0aGlzLl9nZW5lcmF0aW9uRmFsbGJhY2smJnQuZ2VuPHIpe3dhcm4obik7cmV0dXJuIHRoaXMuZmV0Y2hVbmNvbXByZXNzZWQoUmVmLmdldChpLHQuZ2VuKSx0LGEpfXRocm93IG5ldyBYUmVmRW50cnlFeGNlcHRpb24obil9Y29uc3Qgbj10aGlzLnN0cmVhbS5tYWtlU3ViU3RyZWFtKHQub2Zmc2V0K3RoaXMuc3RyZWFtLnN0YXJ0KSxzPW5ldyBQYXJzZXIoe2xleGVyOm5ldyBMZXhlcihuKSx4cmVmOnRoaXMsYWxsb3dTdHJlYW1zOiEwfSksbz1zLmdldE9iaigpLGM9cy5nZXRPYmooKSxsPXMuZ2V0T2JqKCk7aWYobyE9PWl8fGMhPT1yfHwhKGwgaW5zdGFuY2VvZiBDbWQpKXRocm93IG5ldyBYUmVmRW50cnlFeGNlcHRpb24oYEJhZCAodW5jb21wcmVzc2VkKSBYUmVmIGVudHJ5OiAke2V9YCk7aWYoIm9iaiIhPT1sLmNtZCl7aWYobC5jbWQuc3RhcnRzV2l0aCgib2JqIikpe2k9cGFyc2VJbnQobC5jbWQuc3Vic3RyaW5nKDMpLDEwKTtpZighTnVtYmVyLmlzTmFOKGkpKXJldHVybiBpfXRocm93IG5ldyBYUmVmRW50cnlFeGNlcHRpb24oYEJhZCAodW5jb21wcmVzc2VkKSBYUmVmIGVudHJ5OiAke2V9YCl9KHQ9dGhpcy5lbmNyeXB0JiYhYT9zLmdldE9iaih0aGlzLmVuY3J5cHQuY3JlYXRlQ2lwaGVyVHJhbnNmb3JtKGkscikpOnMuZ2V0T2JqKCkpaW5zdGFuY2VvZiBCYXNlU3RyZWFtfHx0aGlzLl9jYWNoZU1hcC5zZXQoaSx0KTtyZXR1cm4gdH1mZXRjaENvbXByZXNzZWQoZSx0LGE9ITEpe2NvbnN0IHI9dC5vZmZzZXQsaT10aGlzLmZldGNoKFJlZi5nZXQociwwKSk7aWYoIShpIGluc3RhbmNlb2YgQmFzZVN0cmVhbSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJiYWQgT2JqU3RtIHN0cmVhbSIpO2NvbnN0IG49aS5kaWN0LmdldCgiRmlyc3QiKSxzPWkuZGljdC5nZXQoIk4iKTtpZighTnVtYmVyLmlzSW50ZWdlcihuKXx8IU51bWJlci5pc0ludGVnZXIocykpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJpbnZhbGlkIGZpcnN0IGFuZCBuIHBhcmFtZXRlcnMgZm9yIE9ialN0bSBzdHJlYW0iKTtsZXQgbz1uZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIoaSkseHJlZjp0aGlzLGFsbG93U3RyZWFtczohMH0pO2NvbnN0IGM9bmV3IEFycmF5KHMpLGw9bmV3IEFycmF5KHMpO2ZvcihsZXQgZT0wO2U8czsrK2Upe2NvbnN0IHQ9by5nZXRPYmooKTtpZighTnVtYmVyLmlzSW50ZWdlcih0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYGludmFsaWQgb2JqZWN0IG51bWJlciBpbiB0aGUgT2JqU3RtIHN0cmVhbTogJHt0fWApO2NvbnN0IGE9by5nZXRPYmooKTtpZighTnVtYmVyLmlzSW50ZWdlcihhKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYGludmFsaWQgb2JqZWN0IG9mZnNldCBpbiB0aGUgT2JqU3RtIHN0cmVhbTogJHthfWApO2NbZV09dDtjb25zdCBpPXRoaXMuZ2V0RW50cnkodCk7aT8ub2Zmc2V0PT09ciYmaS5nZW4hPT1lJiYoaS5nZW49ZSk7bFtlXT1hfWNvbnN0IGg9KGkuc3RhcnR8fDApK24sdT1uZXcgQXJyYXkocyk7Zm9yKGxldCBlPTA7ZTxzOysrZSl7Y29uc3QgdD1lPHMtMT9sW2UrMV0tbFtlXTp2b2lkIDA7aWYodDwwKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBvZmZzZXQgaW4gdGhlIE9ialN0bSBzdHJlYW0uIik7bz1uZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIoaS5tYWtlU3ViU3RyZWFtKGgrbFtlXSx0LGkuZGljdCkpLHhyZWY6dGhpcyxhbGxvd1N0cmVhbXM6ITB9KTtjb25zdCBhPW8uZ2V0T2JqKCk7dVtlXT1hO2lmKGEgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKWNvbnRpbnVlO2NvbnN0IG49Y1tlXSxkPXRoaXMuZW50cmllc1tuXTtkJiZkLm9mZnNldD09PXImJmQuZ2VuPT09ZSYmdGhpcy5fY2FjaGVNYXAuc2V0KG4sYSl9aWYodm9pZCAwPT09KHQ9dVt0Lmdlbl0pKXRocm93IG5ldyBYUmVmRW50cnlFeGNlcHRpb24oYEJhZCAoY29tcHJlc3NlZCkgWFJlZiBlbnRyeTogJHtlfWApO3JldHVybiB0fWFzeW5jIGZldGNoSWZSZWZBc3luYyhlLHQpe3JldHVybiBlIGluc3RhbmNlb2YgUmVmP3RoaXMuZmV0Y2hBc3luYyhlLHQpOmV9YXN5bmMgZmV0Y2hBc3luYyhlLHQpe3RyeXtyZXR1cm4gdGhpcy5mZXRjaChlLHQpfWNhdGNoKGEpe2lmKCEoYSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKSl0aHJvdyBhO2F3YWl0IHRoaXMucGRmTWFuYWdlci5yZXF1ZXN0UmFuZ2UoYS5iZWdpbixhLmVuZCk7cmV0dXJuIHRoaXMuZmV0Y2hBc3luYyhlLHQpfX1nZXRDYXRhbG9nT2JqKCl7cmV0dXJuIHRoaXMucm9vdH19Y29uc3QgdGM9WzAsMCw2MTIsNzkyXTtjbGFzcyBQYWdleyNFZT0hMTsjUGU9bnVsbDtjb25zdHJ1Y3Rvcih7cGRmTWFuYWdlcjplLHhyZWY6dCxwYWdlSW5kZXg6YSxwYWdlRGljdDpyLHJlZjppLGdsb2JhbElkRmFjdG9yeTpuLGZvbnRDYWNoZTpzLGJ1aWx0SW5DTWFwQ2FjaGU6byxzdGFuZGFyZEZvbnREYXRhQ2FjaGU6YyxnbG9iYWxDb2xvclNwYWNlQ2FjaGU6bCxnbG9iYWxJbWFnZUNhY2hlOmgsc3lzdGVtRm9udENhY2hlOnUsbm9uQmxlbmRNb2Rlc1NldDpkLHhmYUZhY3Rvcnk6Zn0pe3RoaXMucGRmTWFuYWdlcj1lO3RoaXMucGFnZUluZGV4PWE7dGhpcy5wYWdlRGljdD1yO3RoaXMueHJlZj10O3RoaXMucmVmPWk7dGhpcy5mb250Q2FjaGU9czt0aGlzLmJ1aWx0SW5DTWFwQ2FjaGU9bzt0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZT1jO3RoaXMuZ2xvYmFsQ29sb3JTcGFjZUNhY2hlPWw7dGhpcy5nbG9iYWxJbWFnZUNhY2hlPWg7dGhpcy5zeXN0ZW1Gb250Q2FjaGU9dTt0aGlzLm5vbkJsZW5kTW9kZXNTZXQ9ZDt0aGlzLmV2YWx1YXRvck9wdGlvbnM9ZS5ldmFsdWF0b3JPcHRpb25zO3RoaXMueGZhRmFjdG9yeT1mO2NvbnN0IGc9e29iajowfTt0aGlzLl9sb2NhbElkRmFjdG9yeT1jbGFzcyBleHRlbmRzIG57c3RhdGljIGNyZWF0ZU9iaklkKCl7cmV0dXJuYHAke2F9XyR7KytnLm9ian1gfXN0YXRpYyBnZXRQYWdlT2JqSWQoKXtyZXR1cm5gcCR7aS50b1N0cmluZygpfWB9fX0jTGUoZSl7cmV0dXJuIG5ldyBQYXJ0aWFsRXZhbHVhdG9yKHt4cmVmOnRoaXMueHJlZixoYW5kbGVyOmUscGFnZUluZGV4OnRoaXMucGFnZUluZGV4LGlkRmFjdG9yeTp0aGlzLl9sb2NhbElkRmFjdG9yeSxmb250Q2FjaGU6dGhpcy5mb250Q2FjaGUsYnVpbHRJbkNNYXBDYWNoZTp0aGlzLmJ1aWx0SW5DTWFwQ2FjaGUsc3RhbmRhcmRGb250RGF0YUNhY2hlOnRoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlLGdsb2JhbENvbG9yU3BhY2VDYWNoZTp0aGlzLmdsb2JhbENvbG9yU3BhY2VDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZSxzeXN0ZW1Gb250Q2FjaGU6dGhpcy5zeXN0ZW1Gb250Q2FjaGUsb3B0aW9uczp0aGlzLmV2YWx1YXRvck9wdGlvbnN9KX0jamUoZSx0PSExKXtjb25zdCBhPWdldEluaGVyaXRhYmxlUHJvcGVydHkoe2RpY3Q6dGhpcy5wYWdlRGljdCxrZXk6ZSxnZXRBcnJheTp0LHN0b3BXaGVuRm91bmQ6ITF9KTtyZXR1cm4gQXJyYXkuaXNBcnJheShhKT8xIT09YS5sZW5ndGgmJmFbMF1pbnN0YW5jZW9mIERpY3Q/RGljdC5tZXJnZSh7eHJlZjp0aGlzLnhyZWYsZGljdEFycmF5OmF9KTphWzBdOmF9Z2V0IGNvbnRlbnQoKXtyZXR1cm4gdGhpcy5wYWdlRGljdC5nZXRBcnJheSgiQ29udGVudHMiKX1nZXQgcmVzb3VyY2VzKCl7Y29uc3QgZT10aGlzLiNqZSgiUmVzb3VyY2VzIik7cmV0dXJuIHNoYWRvdyh0aGlzLCJyZXNvdXJjZXMiLGUgaW5zdGFuY2VvZiBEaWN0P2U6RGljdC5lbXB0eSl9I19lKGUpe2lmKHRoaXMueGZhRGF0YSlyZXR1cm4gdGhpcy54ZmFEYXRhLmJib3g7Y29uc3QgdD1sb29rdXBOb3JtYWxSZWN0KHRoaXMuI2plKGUsITApLG51bGwpO2lmKHQpe2lmKHRbMl0tdFswXT4wJiZ0WzNdLXRbMV0+MClyZXR1cm4gdDt3YXJuKGBFbXB0eSwgb3IgaW52YWxpZCwgLyR7ZX0gZW50cnkuYCl9cmV0dXJuIG51bGx9Z2V0IG1lZGlhQm94KCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJtZWRpYUJveCIsdGhpcy4jX2UoIk1lZGlhQm94Iil8fHRjKX1nZXQgY3JvcEJveCgpe3JldHVybiBzaGFkb3codGhpcywiY3JvcEJveCIsdGhpcy4jX2UoIkNyb3BCb3giKXx8dGhpcy5tZWRpYUJveCl9Z2V0IHVzZXJVbml0KCl7Y29uc3QgZT10aGlzLnBhZ2VEaWN0LmdldCgiVXNlclVuaXQiKTtyZXR1cm4gc2hhZG93KHRoaXMsInVzZXJVbml0IiwibnVtYmVyIj09dHlwZW9mIGUmJmU+MD9lOjEpfWdldCB2aWV3KCl7Y29uc3R7Y3JvcEJveDplLG1lZGlhQm94OnR9PXRoaXM7aWYoZSE9PXQmJiFpc0FycmF5RXF1YWwoZSx0KSl7Y29uc3QgYT1VdGlsLmludGVyc2VjdChlLHQpO2lmKGEmJmFbMl0tYVswXT4wJiZhWzNdLWFbMV0+MClyZXR1cm4gc2hhZG93KHRoaXMsInZpZXciLGEpO3dhcm4oIkVtcHR5IC9Dcm9wQm94IGFuZCAvTWVkaWFCb3ggaW50ZXJzZWN0aW9uLiIpfXJldHVybiBzaGFkb3codGhpcywidmlldyIsdCl9Z2V0IHJvdGF0ZSgpe2xldCBlPXRoaXMuI2plKCJSb3RhdGUiKXx8MDtlJTkwIT0wP2U9MDplPj0zNjA/ZSU9MzYwOmU8MCYmKGU9KGUlMzYwKzM2MCklMzYwKTtyZXR1cm4gc2hhZG93KHRoaXMsInJvdGF0ZSIsZSl9I1VlKGUsdCl7aWYoIXRoaXMuZXZhbHVhdG9yT3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTt3YXJuKGBnZXRDb250ZW50U3RyZWFtIC0gaWdub3Jpbmcgc3ViLXN0cmVhbSAoJHt0fSk6ICIke2V9Ii5gKX1hc3luYyBnZXRDb250ZW50U3RyZWFtKCl7Y29uc3QgZT1hd2FpdCB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlKHRoaXMsImNvbnRlbnQiKTtyZXR1cm4gZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0/ZTpBcnJheS5pc0FycmF5KGUpP25ldyBTdHJlYW1zU2VxdWVuY2VTdHJlYW0oZSx0aGlzLiNVZS5iaW5kKHRoaXMpKTpuZXcgTnVsbFN0cmVhbX1nZXQgeGZhRGF0YSgpe3JldHVybiBzaGFkb3codGhpcywieGZhRGF0YSIsdGhpcy54ZmFGYWN0b3J5P3tiYm94OnRoaXMueGZhRmFjdG9yeS5nZXRCb3VuZGluZ0JveCh0aGlzLnBhZ2VJbmRleCl9Om51bGwpfWFzeW5jI1hlKGUsdCxhKXtjb25zdCByPVtdO2Zvcihjb25zdCBpIG9mIGUpaWYoaS5pZCl7Y29uc3QgZT1SZWYuZnJvbVN0cmluZyhpLmlkKTtpZighZSl7d2FybihgQSBub24tbGlua2VkIGFubm90YXRpb24gY2Fubm90IGJlIG1vZGlmaWVkOiAke2kuaWR9YCk7Y29udGludWV9aWYoaS5kZWxldGVkKXt0LnB1dChlLGUpO2lmKGkucG9wdXBSZWYpe2NvbnN0IGU9UmVmLmZyb21TdHJpbmcoaS5wb3B1cFJlZik7ZSYmdC5wdXQoZSxlKX1jb250aW51ZX1pZihpLnBvcHVwPy5kZWxldGVkKXtjb25zdCBlPVJlZi5mcm9tU3RyaW5nKGkucG9wdXBSZWYpO2UmJnQucHV0KGUsZSl9YT8ucHV0KGUpO2kucmVmPWU7ci5wdXNoKHRoaXMueHJlZi5mZXRjaEFzeW5jKGUpLnRoZW4oKGU9PntlIGluc3RhbmNlb2YgRGljdCYmKGkub2xkQW5ub3RhdGlvbj1lLmNsb25lKCkpfSksKCgpPT57d2FybihgQ2Fubm90IGZldGNoIFxgb2xkQW5ub3RhdGlvblxgIGZvcjogJHtlfS5gKX0pKSk7ZGVsZXRlIGkuaWR9YXdhaXQgUHJvbWlzZS5hbGwocil9YXN5bmMgc2F2ZU5ld0Fubm90YXRpb25zKGUsdCxhLHIsaSl7aWYodGhpcy54ZmFGYWN0b3J5KXRocm93IG5ldyBFcnJvcigiWEZBOiBDYW5ub3Qgc2F2ZSBuZXcgYW5ub3RhdGlvbnMuIik7Y29uc3Qgbj10aGlzLiNMZShlKSxzPW5ldyBSZWZTZXRDYWNoZSxvPW5ldyBSZWZTZXQ7YXdhaXQgdGhpcy4jWGUoYSxzLG8pO2NvbnN0IGM9dGhpcy5wYWdlRGljdCxsPXRoaXMuYW5ub3RhdGlvbnMuZmlsdGVyKChlPT4hKGUgaW5zdGFuY2VvZiBSZWYmJnMuaGFzKGUpKSkpLGg9YXdhaXQgQW5ub3RhdGlvbkZhY3Rvcnkuc2F2ZU5ld0Fubm90YXRpb25zKG4sdCxhLHIsaSk7Zm9yKGNvbnN0e3JlZjplfW9mIGguYW5ub3RhdGlvbnMpZSBpbnN0YW5jZW9mIFJlZiYmIW8uaGFzKGUpJiZsLnB1c2goZSk7Y29uc3QgdT1jLmNsb25lKCk7dS5zZXQoIkFubm90cyIsbCk7aS5wdXQodGhpcy5yZWYse2RhdGE6dX0pO2Zvcihjb25zdCBlIG9mIHMpaS5wdXQoZSx7ZGF0YTpudWxsfSl9YXN5bmMgc2F2ZShlLHQsYSxyKXtjb25zdCBpPXRoaXMuI0xlKGUpLG49YXdhaXQgdGhpcy5fcGFyc2VkQW5ub3RhdGlvbnMscz1bXTtmb3IoY29uc3QgZSBvZiBuKXMucHVzaChlLnNhdmUoaSx0LGEscikuY2F0Y2goKGZ1bmN0aW9uKGUpe3dhcm4oYHNhdmUgLSBpZ25vcmluZyBhbm5vdGF0aW9uIGRhdGEgZHVyaW5nICIke3QubmFtZX0iIHRhc2s6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH0pKSk7cmV0dXJuIFByb21pc2UuYWxsKHMpfWFzeW5jIGxvYWRSZXNvdXJjZXMoZSl7YXdhaXQodGhpcy4jUGU/Pz10aGlzLnBkZk1hbmFnZXIuZW5zdXJlKHRoaXMsInJlc291cmNlcyIpKTthd2FpdCBPYmplY3RMb2FkZXIubG9hZCh0aGlzLnJlc291cmNlcyxlLHRoaXMueHJlZil9YXN5bmMjcWUoZSx0KXtjb25zdCBhPWU/LmdldCgiUmVzb3VyY2VzIik7aWYoIShhIGluc3RhbmNlb2YgRGljdCYmYS5zaXplKSlyZXR1cm4gdGhpcy5yZXNvdXJjZXM7YXdhaXQgT2JqZWN0TG9hZGVyLmxvYWQoYSx0LHRoaXMueHJlZik7cmV0dXJuIERpY3QubWVyZ2Uoe3hyZWY6dGhpcy54cmVmLGRpY3RBcnJheTpbYSx0aGlzLnJlc291cmNlc10sbWVyZ2VTdWJEaWN0czohMH0pfWFzeW5jIGdldE9wZXJhdG9yTGlzdCh7aGFuZGxlcjplLHNpbms6dCx0YXNrOmEsaW50ZW50OnIsY2FjaGVLZXk6aSxhbm5vdGF0aW9uU3RvcmFnZTpjPW51bGwsbW9kaWZpZWRJZHM6ZD1udWxsfSl7Y29uc3QgZz10aGlzLmdldENvbnRlbnRTdHJlYW0oKSxwPXRoaXMubG9hZFJlc291cmNlcyhoYSksbT10aGlzLiNMZShlKSxiPXRoaXMueGZhRmFjdG9yeT9udWxsOmdldE5ld0Fubm90YXRpb25zTWFwKGMpLHk9Yj8uZ2V0KHRoaXMucGFnZUluZGV4KTtsZXQgdz1Qcm9taXNlLnJlc29sdmUobnVsbCkseD1udWxsO2lmKHkpe2NvbnN0IGU9dGhpcy5wZGZNYW5hZ2VyLmVuc3VyZURvYygiYW5ub3RhdGlvbkdsb2JhbHMiKTtsZXQgdDtjb25zdCByPW5ldyBTZXQ7Zm9yKGNvbnN0e2JpdG1hcElkOmUsYml0bWFwOnR9b2YgeSkhZXx8dHx8ci5oYXMoZSl8fHIuYWRkKGUpO2NvbnN0e2lzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkOml9PXRoaXMuZXZhbHVhdG9yT3B0aW9ucztpZihyLnNpemU+MCl7Y29uc3QgZT15LnNsaWNlKCk7Zm9yKGNvbnN0W3QsYV1vZiBjKXQuc3RhcnRzV2l0aChmKSYmYS5iaXRtYXAmJnIuaGFzKGEuYml0bWFwSWQpJiZlLnB1c2goYSk7dD1Bbm5vdGF0aW9uRmFjdG9yeS5nZW5lcmF0ZUltYWdlcyhlLHRoaXMueHJlZixpKX1lbHNlIHQ9QW5ub3RhdGlvbkZhY3RvcnkuZ2VuZXJhdGVJbWFnZXMoeSx0aGlzLnhyZWYsaSk7eD1uZXcgUmVmU2V0O3c9UHJvbWlzZS5hbGwoW2UsdGhpcy4jWGUoeSx4LG51bGwpXSkudGhlbigoKFtlXSk9PmU/QW5ub3RhdGlvbkZhY3RvcnkucHJpbnROZXdBbm5vdGF0aW9ucyhlLG0sYSx5LHQpOm51bGwpKX1jb25zdCBTPVByb21pc2UuYWxsKFtnLHBdKS50aGVuKChhc3luYyhbbl0pPT57Y29uc3Qgcz1hd2FpdCB0aGlzLiNxZShuLmRpY3QsaGEpLG89bmV3IE9wZXJhdG9yTGlzdChyLHQpO2Uuc2VuZCgiU3RhcnRSZW5kZXJQYWdlIix7dHJhbnNwYXJlbmN5Om0uaGFzQmxlbmRNb2RlcyhzLHRoaXMubm9uQmxlbmRNb2Rlc1NldCkscGFnZUluZGV4OnRoaXMucGFnZUluZGV4LGNhY2hlS2V5Oml9KTthd2FpdCBtLmdldE9wZXJhdG9yTGlzdCh7c3RyZWFtOm4sdGFzazphLHJlc291cmNlczpzLG9wZXJhdG9yTGlzdDpvfSk7cmV0dXJuIG99KSk7bGV0W2ssQyx2XT1hd2FpdCBQcm9taXNlLmFsbChbUyx0aGlzLl9wYXJzZWRBbm5vdGF0aW9ucyx3XSk7aWYodil7Qz1DLmZpbHRlcigoZT0+IShlLnJlZiYmeC5oYXMoZS5yZWYpKSkpO2ZvcihsZXQgZT0wLHQ9di5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgYT12W2VdO2lmKGEucmVmVG9SZXBsYWNlKXtjb25zdCByPUMuZmluZEluZGV4KChlPT5lLnJlZiYmaXNSZWZzRXF1YWwoZS5yZWYsYS5yZWZUb1JlcGxhY2UpKSk7aWYocj49MCl7Qy5zcGxpY2UociwxLGEpO3Yuc3BsaWNlKGUtLSwxKTt0LS19fX1DPUMuY29uY2F0KHYpfWlmKDA9PT1DLmxlbmd0aHx8ciZoKXtrLmZsdXNoKCEwKTtyZXR1cm57bGVuZ3RoOmsudG90YWxMZW5ndGh9fWNvbnN0IEY9ISEociZsKSxUPSEhKHImdSksTz0hIShyJm4pLE09ISEociZzKSxEPSEhKHImbyksUj1bXTtmb3IoY29uc3QgZSBvZiBDKShPfHxNJiZlLm11c3RCZVZpZXdlZChjLEYpJiZlLm11c3RCZVZpZXdlZFdoZW5FZGl0aW5nKFQsZCl8fEQmJmUubXVzdEJlUHJpbnRlZChjKSkmJlIucHVzaChlLmdldE9wZXJhdG9yTGlzdChtLGEscixjKS5jYXRjaCgoZnVuY3Rpb24oZSl7d2FybihgZ2V0T3BlcmF0b3JMaXN0IC0gaWdub3JpbmcgYW5ub3RhdGlvbiBkYXRhIGR1cmluZyAiJHthLm5hbWV9IiB0YXNrOiAiJHtlfSIuYCk7cmV0dXJue29wTGlzdDpudWxsLHNlcGFyYXRlRm9ybTohMSxzZXBhcmF0ZUNhbnZhczohMX19KSkpO2NvbnN0IE49YXdhaXQgUHJvbWlzZS5hbGwoUik7bGV0IEU9ITEsTD0hMTtmb3IoY29uc3R7b3BMaXN0OmUsc2VwYXJhdGVGb3JtOnQsc2VwYXJhdGVDYW52YXM6YX1vZiBOKXtrLmFkZE9wTGlzdChlKTtFfHw9dDtMfHw9YX1rLmZsdXNoKCEwLHtmb3JtOkUsY2FudmFzOkx9KTtyZXR1cm57bGVuZ3RoOmsudG90YWxMZW5ndGh9fWFzeW5jIGV4dHJhY3RUZXh0Q29udGVudCh7aGFuZGxlcjplLHRhc2s6dCxpbmNsdWRlTWFya2VkQ29udGVudDphLGRpc2FibGVOb3JtYWxpemF0aW9uOnIsc2luazppLGludGVyc2VjdG9yOm49bnVsbH0pe2NvbnN0IHM9dGhpcy5nZXRDb250ZW50U3RyZWFtKCksbz10aGlzLmxvYWRSZXNvdXJjZXModWEpLGM9dGhpcy5wZGZNYW5hZ2VyLmVuc3VyZUNhdGFsb2coImxhbmciKSxbbCwsaF09YXdhaXQgUHJvbWlzZS5hbGwoW3MsbyxjXSksdT1hd2FpdCB0aGlzLiNxZShsLmRpY3QsdWEpO3JldHVybiB0aGlzLiNMZShlKS5nZXRUZXh0Q29udGVudCh7c3RyZWFtOmwsdGFzazp0LHJlc291cmNlczp1LGluY2x1ZGVNYXJrZWRDb250ZW50OmEsZGlzYWJsZU5vcm1hbGl6YXRpb246cixzaW5rOmksdmlld0JveDp0aGlzLnZpZXcsbGFuZzpoLGludGVyc2VjdG9yOm59KX1hc3luYyBnZXRTdHJ1Y3RUcmVlKCl7Y29uc3QgZT1hd2FpdCB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlQ2F0YWxvZygic3RydWN0VHJlZVJvb3QiKTtpZighZSlyZXR1cm4gbnVsbDthd2FpdCB0aGlzLl9wYXJzZWRBbm5vdGF0aW9uczt0cnl7Y29uc3QgdD1hd2FpdCB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlKHRoaXMsIl9wYXJzZVN0cnVjdFRyZWUiLFtlXSk7cmV0dXJuIGF3YWl0IHRoaXMucGRmTWFuYWdlci5lbnN1cmUodCwic2VyaWFsaXphYmxlIil9Y2F0Y2goZSl7d2FybihgZ2V0U3RydWN0VHJlZTogIiR7ZX0iLmApO3JldHVybiBudWxsfX1fcGFyc2VTdHJ1Y3RUcmVlKGUpe2NvbnN0IHQ9bmV3IFN0cnVjdFRyZWVQYWdlKGUsdGhpcy5wYWdlRGljdCk7dC5wYXJzZSh0aGlzLnJlZik7cmV0dXJuIHR9YXN5bmMgZ2V0QW5ub3RhdGlvbnNEYXRhKGUsdCxhKXtjb25zdCByPWF3YWl0IHRoaXMuX3BhcnNlZEFubm90YXRpb25zO2lmKDA9PT1yLmxlbmd0aClyZXR1cm4gcjtjb25zdCBpPVtdLGM9W107bGV0IGw7Y29uc3QgaD0hIShhJm4pLHU9ISEoYSZzKSxkPSEhKGEmbyksZj1bXTtmb3IoY29uc3QgYSBvZiByKXtjb25zdCByPWh8fHUmJmEudmlld2FibGU7KHJ8fGQmJmEucHJpbnRhYmxlKSYmaS5wdXNoKGEuZGF0YSk7aWYoYS5oYXNUZXh0Q29udGVudCYmcil7bD8/PXRoaXMuI0xlKGUpO2MucHVzaChhLmV4dHJhY3RUZXh0Q29udGVudChsLHQsWy0xLzAsLTEvMCwxLzAsMS8wXSkuY2F0Y2goKGZ1bmN0aW9uKGUpe3dhcm4oYGdldEFubm90YXRpb25zRGF0YSAtIGlnbm9yaW5nIHRleHRDb250ZW50IGR1cmluZyAiJHt0Lm5hbWV9IiB0YXNrOiAiJHtlfSIuYCl9KSkpfWVsc2UgYS5vdmVybGF5c1RleHRDb250ZW50JiZyJiZmLnB1c2goYSl9aWYoZi5sZW5ndGg+MCl7Y29uc3QgYT1uZXcgSW50ZXJzZWN0b3IoZik7Yy5wdXNoKHRoaXMuZXh0cmFjdFRleHRDb250ZW50KHtoYW5kbGVyOmUsdGFzazp0LGluY2x1ZGVNYXJrZWRDb250ZW50OiExLGRpc2FibGVOb3JtYWxpemF0aW9uOiExLHNpbms6bnVsbCx2aWV3Qm94OnRoaXMudmlldyxsYW5nOm51bGwsaW50ZXJzZWN0b3I6YX0pLnRoZW4oKCgpPT57YS5zZXRUZXh0KCl9KSkpfWF3YWl0IFByb21pc2UuYWxsKGMpO3JldHVybiBpfWdldCBhbm5vdGF0aW9ucygpe2NvbnN0IGU9dGhpcy4jamUoIkFubm90cyIpO3JldHVybiBzaGFkb3codGhpcywiYW5ub3RhdGlvbnMiLEFycmF5LmlzQXJyYXkoZSk/ZTpbXSl9Z2V0IF9wYXJzZWRBbm5vdGF0aW9ucygpe2NvbnN0IGU9dGhpcy5wZGZNYW5hZ2VyLmVuc3VyZSh0aGlzLCJhbm5vdGF0aW9ucyIpLnRoZW4oKGFzeW5jIGU9PntpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7Y29uc3RbdCxhXT1hd2FpdCBQcm9taXNlLmFsbChbdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZURvYygiYW5ub3RhdGlvbkdsb2JhbHMiKSx0aGlzLnBkZk1hbmFnZXIuZW5zdXJlRG9jKCJmaWVsZE9iamVjdHMiKV0pO2lmKCF0KXJldHVybltdO2NvbnN0IHI9YT8ub3JwaGFuRmllbGRzLGk9W107Zm9yKGNvbnN0IGEgb2YgZSlpLnB1c2goQW5ub3RhdGlvbkZhY3RvcnkuY3JlYXRlKHRoaXMueHJlZixhLHQsdGhpcy5fbG9jYWxJZEZhY3RvcnksITEscixudWxsLHRoaXMucmVmKS5jYXRjaCgoZnVuY3Rpb24oZSl7d2FybihgX3BhcnNlZEFubm90YXRpb25zOiAiJHtlfSIuYCk7cmV0dXJuIG51bGx9KSkpO2NvbnN0IG49W107bGV0IHMsbztmb3IoY29uc3QgZSBvZiBhd2FpdCBQcm9taXNlLmFsbChpKSllJiYoZSBpbnN0YW5jZW9mIFdpZGdldEFubm90YXRpb24/KG98fD1bXSkucHVzaChlKTplIGluc3RhbmNlb2YgUG9wdXBBbm5vdGF0aW9uPyhzfHw9W10pLnB1c2goZSk6bi5wdXNoKGUpKTtvJiZuLnB1c2goLi4ubyk7cyYmbi5wdXNoKC4uLnMpO3JldHVybiBufSkpO3RoaXMuI0VlPSEwO3JldHVybiBzaGFkb3codGhpcywiX3BhcnNlZEFubm90YXRpb25zIixlKX1nZXQganNBY3Rpb25zKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJqc0FjdGlvbnMiLGNvbGxlY3RBY3Rpb25zKHRoaXMueHJlZix0aGlzLnBhZ2VEaWN0LHJlKSl9YXN5bmMgY29sbGVjdEFubm90YXRpb25zQnlUeXBlKGUsdCxhLHIsaSl7Y29uc3R7cGFnZUluZGV4Om59PXRoaXM7aWYodGhpcy4jRWUpe2NvbnN0IGU9YXdhaXQgdGhpcy5fcGFyc2VkQW5ub3RhdGlvbnM7Zm9yKGNvbnN0e2RhdGE6dH1vZiBlKWlmKCFhfHxhLmhhcyh0LmFubm90YXRpb25UeXBlKSl7dC5wYWdlSW5kZXg9bjtyLnB1c2goUHJvbWlzZS5yZXNvbHZlKHQpKX1yZXR1cm59Y29uc3Qgcz1hd2FpdCB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlKHRoaXMsImFubm90YXRpb25zIik7Zm9yKGNvbnN0IG8gb2YgcylyLnB1c2goQW5ub3RhdGlvbkZhY3RvcnkuY3JlYXRlKHRoaXMueHJlZixvLGksdGhpcy5fbG9jYWxJZEZhY3RvcnksITEsbnVsbCxhLHRoaXMucmVmKS50aGVuKChhc3luYyBhPT57aWYoIWEpcmV0dXJuIG51bGw7YS5kYXRhLnBhZ2VJbmRleD1uO2lmKGEuaGFzVGV4dENvbnRlbnQmJmEudmlld2FibGUpe2NvbnN0IHI9dGhpcy4jTGUoZSk7YXdhaXQgYS5leHRyYWN0VGV4dENvbnRlbnQocix0LFstMS8wLC0xLzAsMS8wLDEvMF0pfXJldHVybiBhLmRhdGF9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe3dhcm4oYGNvbGxlY3RBbm5vdGF0aW9uc0J5VHlwZTogIiR7ZX0iLmApO3JldHVybiBudWxsfSkpKX19Y29uc3QgYWM9bmV3IFVpbnQ4QXJyYXkoWzM3LDgwLDY4LDcwLDQ1XSkscmM9bmV3IFVpbnQ4QXJyYXkoWzExNSwxMTYsOTcsMTE0LDExNiwxMjAsMTE0LDEwMSwxMDJdKSxpYz1uZXcgVWludDhBcnJheShbMTAxLDExMCwxMDAsMTExLDk4LDEwNl0pO2Z1bmN0aW9uIGZpbmQoZSx0LGE9MTAyNCxyPSExKXtjb25zdCBpPXQubGVuZ3RoLG49ZS5wZWVrQnl0ZXMoYSkscz1uLmxlbmd0aC1pO2lmKHM8PTApcmV0dXJuITE7aWYocil7Y29uc3QgYT1pLTE7bGV0IHI9bi5sZW5ndGgtMTtmb3IoO3I+PWE7KXtsZXQgcz0wO2Zvcig7czxpJiZuW3Itc109PT10W2Etc107KXMrKztpZihzPj1pKXtlLnBvcys9ci1hO3JldHVybiEwfXItLX19ZWxzZXtsZXQgYT0wO2Zvcig7YTw9czspe2xldCByPTA7Zm9yKDtyPGkmJm5bYStyXT09PXRbcl07KXIrKztpZihyPj1pKXtlLnBvcys9YTtyZXR1cm4hMH1hKyt9fXJldHVybiExfWNsYXNzIFBERkRvY3VtZW50eyNIZT1uZXcgTWFwOyNXZT1udWxsO2NvbnN0cnVjdG9yKGUsdCl7aWYodC5sZW5ndGg8PTApdGhyb3cgbmV3IEludmFsaWRQREZFeGNlcHRpb24oIlRoZSBQREYgZmlsZSBpcyBlbXB0eSwgaS5lLiBpdHMgc2l6ZSBpcyB6ZXJvIGJ5dGVzLiIpO3RoaXMucGRmTWFuYWdlcj1lO3RoaXMuc3RyZWFtPXQ7dGhpcy54cmVmPW5ldyBYUmVmKHQsZSk7Y29uc3QgYT17Zm9udDowfTt0aGlzLl9nbG9iYWxJZEZhY3Rvcnk9Y2xhc3N7c3RhdGljIGdldERvY0lkKCl7cmV0dXJuYGdfJHtlLmRvY0lkfWB9c3RhdGljIGNyZWF0ZUZvbnRJZCgpe3JldHVybiJmIisgKythLmZvbnR9c3RhdGljIGNyZWF0ZU9iaklkKCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgY3JlYXRlT2JqSWRgIGNhbGxlZC4iKX1zdGF0aWMgZ2V0UGFnZU9iaklkKCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgZ2V0UGFnZU9iaklkYCBjYWxsZWQuIil9fX1wYXJzZShlKXt0aGlzLnhyZWYucGFyc2UoZSk7dGhpcy5jYXRhbG9nPW5ldyBDYXRhbG9nKHRoaXMucGRmTWFuYWdlcix0aGlzLnhyZWYpfWdldCBsaW5lYXJpemF0aW9uKCl7bGV0IGU9bnVsbDt0cnl7ZT1MaW5lYXJpemF0aW9uLmNyZWF0ZSh0aGlzLnN0cmVhbSl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7aW5mbyhlKX1yZXR1cm4gc2hhZG93KHRoaXMsImxpbmVhcml6YXRpb24iLGUpfWdldCBzdGFydFhSZWYoKXtjb25zdCBlPXRoaXMuc3RyZWFtO2xldCB0PTA7aWYodGhpcy5saW5lYXJpemF0aW9uKXtlLnJlc2V0KCk7aWYoZmluZChlLGljKSl7ZS5za2lwKDYpO2xldCBhPWUucGVla0J5dGUoKTtmb3IoO2lzV2hpdGVTcGFjZShhKTspe2UucG9zKys7YT1lLnBlZWtCeXRlKCl9dD1lLnBvcy1lLnN0YXJ0fX1lbHNle2NvbnN0IGE9MTAyNCxyPXJjLmxlbmd0aDtsZXQgaT0hMSxuPWUuZW5kO2Zvcig7IWkmJm4+MDspe24tPWEtcjtuPDAmJihuPTApO2UucG9zPW47aT1maW5kKGUscmMsYSwhMCl9aWYoaSl7ZS5za2lwKDkpO2xldCBhO2Rve2E9ZS5nZXRCeXRlKCl9d2hpbGUoaXNXaGl0ZVNwYWNlKGEpKTtsZXQgcj0iIjtmb3IoO2E+PTMyJiZhPD01Nzspe3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk7YT1lLmdldEJ5dGUoKX10PXBhcnNlSW50KHIsMTApO2lzTmFOKHQpJiYodD0wKX19cmV0dXJuIHNoYWRvdyh0aGlzLCJzdGFydFhSZWYiLHQpfWNoZWNrSGVhZGVyKCl7Y29uc3QgZT10aGlzLnN0cmVhbTtlLnJlc2V0KCk7aWYoIWZpbmQoZSxhYykpcmV0dXJuO2UubW92ZVN0YXJ0KCk7ZS5za2lwKGFjLmxlbmd0aCk7bGV0IHQsYT0iIjtmb3IoOyh0PWUuZ2V0Qnl0ZSgpKT4zMiYmYS5sZW5ndGg8NzspYSs9U3RyaW5nLmZyb21DaGFyQ29kZSh0KTtvYS50ZXN0KGEpP3RoaXMuI1dlPWE6d2FybihgSW52YWxpZCBQREYgaGVhZGVyIHZlcnNpb246ICR7YX1gKX1wYXJzZVN0YXJ0WFJlZigpe3RoaXMueHJlZi5zZXRTdGFydFhSZWYodGhpcy5zdGFydFhSZWYpfWdldCBudW1QYWdlcygpe2xldCBlPTA7ZT10aGlzLmNhdGFsb2cuaGFzQWN0dWFsTnVtUGFnZXM/dGhpcy5jYXRhbG9nLm51bVBhZ2VzOnRoaXMueGZhRmFjdG9yeT90aGlzLnhmYUZhY3RvcnkuZ2V0TnVtUGFnZXMoKTp0aGlzLmxpbmVhcml6YXRpb24/dGhpcy5saW5lYXJpemF0aW9uLm51bVBhZ2VzOnRoaXMuY2F0YWxvZy5udW1QYWdlcztyZXR1cm4gc2hhZG93KHRoaXMsIm51bVBhZ2VzIixlKX0jemUoZSx0PTApe3JldHVybiEhQXJyYXkuaXNBcnJheShlKSYmZS5ldmVyeSgoZT0+e2lmKCEoKGU9dGhpcy54cmVmLmZldGNoSWZSZWYoZSkpaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm4hMTtpZihlLmhhcygiS2lkcyIpKXtpZigrK3Q+MTApe3dhcm4oIiNoYXNPbmx5RG9jdW1lbnRTaWduYXR1cmVzOiBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aCByZWFjaGVkIik7cmV0dXJuITF9cmV0dXJuIHRoaXMuI3plKGUuZ2V0KCJLaWRzIiksdCl9Y29uc3QgYT1pc05hbWUoZS5nZXQoIkZUIiksIlNpZyIpLHI9ZS5nZXQoIlJlY3QiKSxpPUFycmF5LmlzQXJyYXkocikmJnIuZXZlcnkoKGU9PjA9PT1lKSk7cmV0dXJuIGEmJml9KSl9IyRlKGUsdCxhPW5ldyBSZWZTZXQpe2lmKEFycmF5LmlzQXJyYXkoZSkpZm9yKGxldCByIG9mIGUpe2lmKHIgaW5zdGFuY2VvZiBSZWYpe2lmKGEuaGFzKHIpKWNvbnRpbnVlO2EucHV0KHIpfXI9dGhpcy54cmVmLmZldGNoSWZSZWYocik7aWYoIShyIGluc3RhbmNlb2YgRGljdCkpY29udGludWU7aWYoci5oYXMoIktpZHMiKSl7dGhpcy4jJGUoci5nZXQoIktpZHMiKSx0LGEpO2NvbnRpbnVlfWlmKCFpc05hbWUoci5nZXQoIkZUIiksIlNpZyIpKWNvbnRpbnVlO2NvbnN0IGU9ci5nZXQoIlYiKTtpZighKGUgaW5zdGFuY2VvZiBEaWN0KSljb250aW51ZTtjb25zdCBpPWUuZ2V0KCJTdWJGaWx0ZXIiKTtpIGluc3RhbmNlb2YgTmFtZSYmdC5hZGQoaS5uYW1lKX19Z2V0IF94ZmFTdHJlYW1zKCl7Y29uc3R7YWNyb0Zvcm06ZX09dGhpcy5jYXRhbG9nO2lmKCFlKXJldHVybiBudWxsO2NvbnN0IHQ9ZS5nZXQoIlhGQSIpLGE9bmV3IE1hcChbInhkcDp4ZHAiLCJ0ZW1wbGF0ZSIsImRhdGFzZXRzIiwiY29uZmlnIiwiY29ubmVjdGlvblNldCIsImxvY2FsZVNldCIsInN0eWxlc2hlZXQiLCIveGRwOnhkcCJdLm1hcCgoZT0+W2UsbnVsbF0pKSk7aWYodCBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJiF0LmlzRW1wdHkpe2Euc2V0KCJ4ZHA6eGRwIix0KTtyZXR1cm4gYX1pZighQXJyYXkuaXNBcnJheSh0KXx8MD09PXQubGVuZ3RoKXJldHVybiBudWxsO2ZvcihsZXQgZT0wLHI9dC5sZW5ndGg7ZTxyO2UrPTIpe2xldCBpO2k9MD09PWU/InhkcDp4ZHAiOmU9PT1yLTI/Ii94ZHA6eGRwIjp0W2VdO2lmKCFhLmhhcyhpKSljb250aW51ZTtjb25zdCBuPXRoaXMueHJlZi5mZXRjaElmUmVmKHRbZSsxXSk7biBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJiFuLmlzRW1wdHkmJmEuc2V0KGksbil9cmV0dXJuIGF9Z2V0IHhmYURhdGFzZXRzKCl7Y29uc3QgZT10aGlzLl94ZmFTdHJlYW1zO2lmKCFlKXJldHVybiBzaGFkb3codGhpcywieGZhRGF0YXNldHMiLG51bGwpO2Zvcihjb25zdCB0IG9mWyJkYXRhc2V0cyIsInhkcDp4ZHAiXSl7Y29uc3QgYT1lLmdldCh0KTtpZihhKXRyeXtjb25zdCBlPXN0cmluZ1RvVVRGOFN0cmluZyhhLmdldFN0cmluZygpKTtyZXR1cm4gc2hhZG93KHRoaXMsInhmYURhdGFzZXRzIixuZXcgRGF0YXNldFJlYWRlcih7W3RdOmV9KSl9Y2F0Y2h7d2FybigiWEZBIC0gSW52YWxpZCB1dGYtOCBzdHJpbmcuIik7YnJlYWt9fXJldHVybiBzaGFkb3codGhpcywieGZhRGF0YXNldHMiLG51bGwpfWdldCB4ZmFEYXRhKCl7Y29uc3QgZT10aGlzLl94ZmFTdHJlYW1zO2lmKCFlKXJldHVybiBudWxsO2NvbnN0IHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IoY29uc3RbYSxyXW9mIGUpaWYocil0cnl7dFthXT1zdHJpbmdUb1VURjhTdHJpbmcoci5nZXRTdHJpbmcoKSl9Y2F0Y2h7d2FybigiWEZBIC0gSW52YWxpZCB1dGYtOCBzdHJpbmcuIik7cmV0dXJuIG51bGx9cmV0dXJuIHR9Z2V0IHhmYUZhY3RvcnkoKXtsZXQgZTt0aGlzLnBkZk1hbmFnZXIuZW5hYmxlWGZhJiZ0aGlzLmNhdGFsb2cubmVlZHNSZW5kZXJpbmcmJnRoaXMuZm9ybUluZm8uaGFzWGZhJiYhdGhpcy5mb3JtSW5mby5oYXNBY3JvRm9ybSYmKGU9dGhpcy54ZmFEYXRhKTtyZXR1cm4gc2hhZG93KHRoaXMsInhmYUZhY3RvcnkiLGU/bmV3IFhGQUZhY3RvcnkoZSk6bnVsbCl9Z2V0IGlzUHVyZVhmYSgpe3JldHVybiEhdGhpcy54ZmFGYWN0b3J5JiZ0aGlzLnhmYUZhY3RvcnkuaXNWYWxpZCgpfWdldCBodG1sRm9yWGZhKCl7cmV0dXJuIHRoaXMueGZhRmFjdG9yeT90aGlzLnhmYUZhY3RvcnkuZ2V0UGFnZXMoKTpudWxsfWFzeW5jI0dlKCl7Y29uc3QgZT1hd2FpdCB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlQ2F0YWxvZygieGZhSW1hZ2VzIik7ZSYmdGhpcy54ZmFGYWN0b3J5LnNldEltYWdlcyhlKX1hc3luYyNWZShlLHQpe2NvbnN0IGE9YXdhaXQgdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZUNhdGFsb2coImFjcm9Gb3JtIik7aWYoIWEpcmV0dXJuO2NvbnN0IHI9YXdhaXQgYS5nZXRBc3luYygiRFIiKTtpZighKHIgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm47YXdhaXQgT2JqZWN0TG9hZGVyLmxvYWQocixbIkZvbnQiXSx0aGlzLnhyZWYpO2NvbnN0IGk9ci5nZXQoIkZvbnQiKTtpZighKGkgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm47Y29uc3Qgbj1PYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5wZGZNYW5hZ2VyLmV2YWx1YXRvck9wdGlvbnMse3VzZVN5c3RlbUZvbnRzOiExfSkse2J1aWx0SW5DTWFwQ2FjaGU6cyxmb250Q2FjaGU6byxzdGFuZGFyZEZvbnREYXRhQ2FjaGU6Y309dGhpcy5jYXRhbG9nLGw9bmV3IFBhcnRpYWxFdmFsdWF0b3Ioe3hyZWY6dGhpcy54cmVmLGhhbmRsZXI6ZSxwYWdlSW5kZXg6LTEsaWRGYWN0b3J5OnRoaXMuX2dsb2JhbElkRmFjdG9yeSxmb250Q2FjaGU6byxidWlsdEluQ01hcENhY2hlOnMsc3RhbmRhcmRGb250RGF0YUNhY2hlOmMsb3B0aW9uczpufSksaD1uZXcgT3BlcmF0b3JMaXN0LHU9W10sZD17Z2V0IGZvbnQoKXtyZXR1cm4gdS5hdCgtMSl9LHNldCBmb250KGUpe3UucHVzaChlKX0sY2xvbmUoKXtyZXR1cm4gdGhpc319LHBhcnNlRm9udD0oZSxhLGkpPT5sLmhhbmRsZVNldEZvbnQocixbTmFtZS5nZXQoZSksMV0sbnVsbCxoLHQsZCxhLGkpLmNhdGNoKChlPT57d2FybihgbG9hZFhmYUZvbnRzOiAiJHtlfSIuYCk7cmV0dXJuIG51bGx9KSksZj1bXTtmb3IoY29uc3RbZSx0XW9mIGkpe2NvbnN0IGE9dC5nZXQoIkZvbnREZXNjcmlwdG9yIik7aWYoIShhIGluc3RhbmNlb2YgRGljdCkpY29udGludWU7bGV0IHI9YS5nZXQoIkZvbnRGYW1pbHkiKTtyPXIucmVwbGFjZUFsbCgvWyBdKyhcZCkvZywiJDEiKTtjb25zdCBpPXtmb250RmFtaWx5OnIsZm9udFdlaWdodDphLmdldCgiRm9udFdlaWdodCIpLGl0YWxpY0FuZ2xlOi1hLmdldCgiSXRhbGljQW5nbGUiKX07dmFsaWRhdGVDU1NGb250KGkpJiZmLnB1c2gocGFyc2VGb250KGUsbnVsbCxpKSl9YXdhaXQgUHJvbWlzZS5hbGwoZik7Y29uc3QgZz10aGlzLnhmYUZhY3Rvcnkuc2V0Rm9udHModSk7aWYoIWcpcmV0dXJuO24uaWdub3JlRXJyb3JzPSEwO2YubGVuZ3RoPTA7dS5sZW5ndGg9MDtjb25zdCBwPW5ldyBTZXQ7Zm9yKGNvbnN0IGUgb2YgZylnZXRYZmFGb250TmFtZShgJHtlfS1SZWd1bGFyYCl8fHAuYWRkKGUpO3Auc2l6ZSYmZy5wdXNoKCJQZGZKUy1GYWxsYmFjayIpO2Zvcihjb25zdCBlIG9mIGcpaWYoIXAuaGFzKGUpKWZvcihjb25zdCB0IG9mW3tuYW1lOiJSZWd1bGFyIixmb250V2VpZ2h0OjQwMCxpdGFsaWNBbmdsZTowfSx7bmFtZToiQm9sZCIsZm9udFdlaWdodDo3MDAsaXRhbGljQW5nbGU6MH0se25hbWU6Ikl0YWxpYyIsZm9udFdlaWdodDo0MDAsaXRhbGljQW5nbGU6MTJ9LHtuYW1lOiJCb2xkSXRhbGljIixmb250V2VpZ2h0OjcwMCxpdGFsaWNBbmdsZToxMn1dKXtjb25zdCBhPWAke2V9LSR7dC5uYW1lfWA7Zi5wdXNoKHBhcnNlRm9udChhLGdldFhmYUZvbnREaWN0KGEpLHtmb250RmFtaWx5OmUsZm9udFdlaWdodDp0LmZvbnRXZWlnaHQsaXRhbGljQW5nbGU6dC5pdGFsaWNBbmdsZX0pKX1hd2FpdCBQcm9taXNlLmFsbChmKTt0aGlzLnhmYUZhY3RvcnkuYXBwZW5kRm9udHModSxwKX1sb2FkWGZhUmVzb3VyY2VzKGUsdCl7cmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLiNWZShlLHQpLmNhdGNoKCgoKT0+e30pKSx0aGlzLiNHZSgpXSl9c2VyaWFsaXplWGZhRGF0YShlKXtyZXR1cm4gdGhpcy54ZmFGYWN0b3J5P3RoaXMueGZhRmFjdG9yeS5zZXJpYWxpemVEYXRhKGUpOm51bGx9Z2V0IHZlcnNpb24oKXtyZXR1cm4gdGhpcy5jYXRhbG9nLnZlcnNpb258fHRoaXMuI1dlfWdldCBmb3JtSW5mbygpe2NvbnN0IGU9e2hhc0ZpZWxkczohMSxoYXNBY3JvRm9ybTohMSxoYXNYZmE6ITEsaGFzU2lnbmF0dXJlczohMX0se2Fjcm9Gb3JtOnR9PXRoaXMuY2F0YWxvZztpZighdClyZXR1cm4gc2hhZG93KHRoaXMsImZvcm1JbmZvIixlKTt0cnl7Y29uc3QgYT10LmdldCgiRmllbGRzIikscj1BcnJheS5pc0FycmF5KGEpJiZhLmxlbmd0aD4wO2UuaGFzRmllbGRzPXI7Y29uc3QgaT10LmdldCgiWEZBIik7ZS5oYXNYZmE9QXJyYXkuaXNBcnJheShpKSYmaS5sZW5ndGg+MHx8aSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJiFpLmlzRW1wdHk7Y29uc3Qgbj0hISgxJnQuZ2V0KCJTaWdGbGFncyIpKSxzPW4mJnRoaXMuI3plKGEpO2UuaGFzQWNyb0Zvcm09ciYmIXM7ZS5oYXNTaWduYXR1cmVzPW59Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybihgQ2Fubm90IGZldGNoIGZvcm0gaW5mb3JtYXRpb246ICIke2V9Ii5gKX1yZXR1cm4gc2hhZG93KHRoaXMsImZvcm1JbmZvIixlKX1nZXQgZG9jdW1lbnRJbmZvKCl7Y29uc3R7Y2F0YWxvZzplLGZvcm1JbmZvOnQseHJlZjphfT10aGlzLHI9e1BERkZvcm1hdFZlcnNpb246dGhpcy52ZXJzaW9uLExhbmd1YWdlOmUubGFuZyxFbmNyeXB0RmlsdGVyTmFtZTphLmVuY3J5cHQ/LmZpbHRlck5hbWU/P251bGwsSXNMaW5lYXJpemVkOiEhdGhpcy5saW5lYXJpemF0aW9uLElzQWNyb0Zvcm1QcmVzZW50OnQuaGFzQWNyb0Zvcm0sSXNYRkFQcmVzZW50OnQuaGFzWGZhLElzQ29sbGVjdGlvblByZXNlbnQ6ISFlLmNvbGxlY3Rpb24sSXNTaWduYXR1cmVzUHJlc2VudDp0Lmhhc1NpZ25hdHVyZXN9O2xldCBpO3RyeXtpPWEudHJhaWxlci5nZXQoIkluZm8iKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTtpbmZvKCJUaGUgZG9jdW1lbnQgaW5mb3JtYXRpb24gZGljdGlvbmFyeSBpcyBpbnZhbGlkLiIpfWlmKCEoaSBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBzaGFkb3codGhpcywiZG9jdW1lbnRJbmZvIixyKTtmb3IoY29uc3RbZSx0XW9mIGkpe3N3aXRjaChlKXtjYXNlIlRpdGxlIjpjYXNlIkF1dGhvciI6Y2FzZSJTdWJqZWN0IjpjYXNlIktleXdvcmRzIjpjYXNlIkNyZWF0b3IiOmNhc2UiUHJvZHVjZXIiOmNhc2UiQ3JlYXRpb25EYXRlIjpjYXNlIk1vZERhdGUiOmlmKCJzdHJpbmciPT10eXBlb2YgdCl7cltlXT1zdHJpbmdUb1BERlN0cmluZyh0KTtjb250aW51ZX1icmVhaztjYXNlIlRyYXBwZWQiOmlmKHQgaW5zdGFuY2VvZiBOYW1lKXtyW2VdPXQ7Y29udGludWV9YnJlYWs7ZGVmYXVsdDpsZXQgYTtzd2l0Y2godHlwZW9mIHQpe2Nhc2Uic3RyaW5nIjphPXN0cmluZ1RvUERGU3RyaW5nKHQpO2JyZWFrO2Nhc2UibnVtYmVyIjpjYXNlImJvb2xlYW4iOmE9dDticmVhaztkZWZhdWx0OnQgaW5zdGFuY2VvZiBOYW1lJiYoYT10KX1pZih2b2lkIDA9PT1hKXt3YXJuKGBCYWQgdmFsdWUsIGZvciBjdXN0b20ga2V5ICIke2V9IiwgaW4gSW5mbzogJHt0fS5gKTtjb250aW51ZX1yLkN1c3RvbT8/PU9iamVjdC5jcmVhdGUobnVsbCk7ci5DdXN0b21bZV09YTtjb250aW51ZX13YXJuKGBCYWQgdmFsdWUsIGZvciBrZXkgIiR7ZX0iLCBpbiBJbmZvOiAke3R9LmApfXJldHVybiBzaGFkb3codGhpcywiZG9jdW1lbnRJbmZvIixyKX1nZXQgZmluZ2VycHJpbnRzKCl7Y29uc3QgZT0iXDAiLnJlcGVhdCgxNik7ZnVuY3Rpb24gdmFsaWRhdGUodCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0JiYxNj09PXQubGVuZ3RoJiZ0IT09ZX1jb25zdCB0PXRoaXMueHJlZi50cmFpbGVyLmdldCgiSUQiKTtsZXQgYSxyO2lmKEFycmF5LmlzQXJyYXkodCkmJnZhbGlkYXRlKHRbMF0pKXthPXN0cmluZ1RvQnl0ZXModFswXSk7dFsxXSE9PXRbMF0mJnZhbGlkYXRlKHRbMV0pJiYocj1zdHJpbmdUb0J5dGVzKHRbMV0pKX1lbHNlIGE9Y2FsY3VsYXRlTUQ1KHRoaXMuc3RyZWFtLmdldEJ5dGVSYW5nZSgwLDEwMjQpLDAsMTAyNCk7cmV0dXJuIHNoYWRvdyh0aGlzLCJmaW5nZXJwcmludHMiLFt0b0hleFV0aWwoYSkscj90b0hleFV0aWwocik6bnVsbF0pfWFzeW5jI0tlKGUpe2NvbnN0e2NhdGFsb2c6dCxsaW5lYXJpemF0aW9uOmEseHJlZjpyfT10aGlzLGk9UmVmLmdldChhLm9iamVjdE51bWJlckZpcnN0LDApO3RyeXtjb25zdCBlPWF3YWl0IHIuZmV0Y2hBc3luYyhpKTtpZihlIGluc3RhbmNlb2YgRGljdCl7bGV0IGE9ZS5nZXRSYXcoIlR5cGUiKTthIGluc3RhbmNlb2YgUmVmJiYoYT1hd2FpdCByLmZldGNoQXN5bmMoYSkpO2lmKGlzTmFtZShhLCJQYWdlIil8fCFlLmhhcygiVHlwZSIpJiYhZS5oYXMoIktpZHMiKSYmZS5oYXMoIkNvbnRlbnRzIikpe3QucGFnZUtpZHNDb3VudENhY2hlLmhhcyhpKXx8dC5wYWdlS2lkc0NvdW50Q2FjaGUucHV0KGksMSk7dC5wYWdlSW5kZXhDYWNoZS5oYXMoaSl8fHQucGFnZUluZGV4Q2FjaGUucHV0KGksMCk7cmV0dXJuW2UsaV19fXRocm93IG5ldyBGb3JtYXRFcnJvcigiVGhlIExpbmVhcml6YXRpb24gZGljdGlvbmFyeSBkb2Vzbid0IHBvaW50IHRvIGEgdmFsaWQgUGFnZSBkaWN0aW9uYXJ5LiIpfWNhdGNoKGEpe3dhcm4oYF9nZXRMaW5lYXJpemF0aW9uUGFnZTogIiR7YS5tZXNzYWdlfSIuYCk7cmV0dXJuIHQuZ2V0UGFnZURpY3QoZSl9fWdldFBhZ2UoZSl7Y29uc3QgdD10aGlzLiNIZS5nZXQoZSk7aWYodClyZXR1cm4gdDtjb25zdHtjYXRhbG9nOmEsbGluZWFyaXphdGlvbjpyLHhmYUZhY3Rvcnk6aX09dGhpcztsZXQgbjtuPWk/UHJvbWlzZS5yZXNvbHZlKFtEaWN0LmVtcHR5LG51bGxdKTpyPy5wYWdlRmlyc3Q9PT1lP3RoaXMuI0tlKGUpOmEuZ2V0UGFnZURpY3QoZSk7bj1uLnRoZW4oKChbdCxyXSk9Pm5ldyBQYWdlKHtwZGZNYW5hZ2VyOnRoaXMucGRmTWFuYWdlcix4cmVmOnRoaXMueHJlZixwYWdlSW5kZXg6ZSxwYWdlRGljdDp0LHJlZjpyLGdsb2JhbElkRmFjdG9yeTp0aGlzLl9nbG9iYWxJZEZhY3RvcnksZm9udENhY2hlOmEuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6YS5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTphLnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxDb2xvclNwYWNlQ2FjaGU6YS5nbG9iYWxDb2xvclNwYWNlQ2FjaGUsZ2xvYmFsSW1hZ2VDYWNoZTphLmdsb2JhbEltYWdlQ2FjaGUsc3lzdGVtRm9udENhY2hlOmEuc3lzdGVtRm9udENhY2hlLG5vbkJsZW5kTW9kZXNTZXQ6YS5ub25CbGVuZE1vZGVzU2V0LHhmYUZhY3Rvcnk6aX0pKSk7dGhpcy4jSGUuc2V0KGUsbik7cmV0dXJuIG59YXN5bmMgY2hlY2tGaXJzdFBhZ2UoZT0hMSl7aWYoIWUpdHJ5e2F3YWl0IHRoaXMuZ2V0UGFnZSgwKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgWFJlZkVudHJ5RXhjZXB0aW9uKXt0aGlzLiNIZS5kZWxldGUoMCk7YXdhaXQgdGhpcy5jbGVhbnVwKCk7dGhyb3cgbmV3IFhSZWZQYXJzZUV4Y2VwdGlvbn19fWFzeW5jIGNoZWNrTGFzdFBhZ2UoZT0hMSl7Y29uc3R7Y2F0YWxvZzp0LHBkZk1hbmFnZXI6YX09dGhpczt0LnNldEFjdHVhbE51bVBhZ2VzKCk7bGV0IHI7dHJ5e2F3YWl0IFByb21pc2UuYWxsKFthLmVuc3VyZURvYygieGZhRmFjdG9yeSIpLGEuZW5zdXJlRG9jKCJsaW5lYXJpemF0aW9uIiksYS5lbnN1cmVDYXRhbG9nKCJudW1QYWdlcyIpXSk7aWYodGhpcy54ZmFGYWN0b3J5KXJldHVybjtyPXRoaXMubGluZWFyaXphdGlvbj90aGlzLmxpbmVhcml6YXRpb24ubnVtUGFnZXM6dC5udW1QYWdlcztpZighTnVtYmVyLmlzSW50ZWdlcihyKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlBhZ2UgY291bnQgaXMgbm90IGFuIGludGVnZXIuIik7aWYocjw9MSlyZXR1cm47YXdhaXQgdGhpcy5nZXRQYWdlKHItMSl9Y2F0Y2goaSl7dGhpcy4jSGUuZGVsZXRlKHItMSk7YXdhaXQgdGhpcy5jbGVhbnVwKCk7aWYoaSBpbnN0YW5jZW9mIFhSZWZFbnRyeUV4Y2VwdGlvbiYmIWUpdGhyb3cgbmV3IFhSZWZQYXJzZUV4Y2VwdGlvbjt3YXJuKGBjaGVja0xhc3RQYWdlIC0gaW52YWxpZCAvUGFnZXMgdHJlZSAvQ291bnQ6ICR7cn0uYCk7bGV0IG47dHJ5e249YXdhaXQgdC5nZXRBbGxQYWdlRGljdHMoZSl9Y2F0Y2goYSl7aWYoYSBpbnN0YW5jZW9mIFhSZWZFbnRyeUV4Y2VwdGlvbiYmIWUpdGhyb3cgbmV3IFhSZWZQYXJzZUV4Y2VwdGlvbjt0LnNldEFjdHVhbE51bVBhZ2VzKDEpO3JldHVybn1mb3IoY29uc3RbZSxbcixpXV1vZiBuKXtsZXQgbjtpZihyIGluc3RhbmNlb2YgRXJyb3Ipe249UHJvbWlzZS5yZWplY3Qocik7bi5jYXRjaCgoKCk9Pnt9KSl9ZWxzZSBuPVByb21pc2UucmVzb2x2ZShuZXcgUGFnZSh7cGRmTWFuYWdlcjphLHhyZWY6dGhpcy54cmVmLHBhZ2VJbmRleDplLHBhZ2VEaWN0OnIscmVmOmksZ2xvYmFsSWRGYWN0b3J5OnRoaXMuX2dsb2JhbElkRmFjdG9yeSxmb250Q2FjaGU6dC5mb250Q2FjaGUsYnVpbHRJbkNNYXBDYWNoZTp0LmJ1aWx0SW5DTWFwQ2FjaGUsc3RhbmRhcmRGb250RGF0YUNhY2hlOnQuc3RhbmRhcmRGb250RGF0YUNhY2hlLGdsb2JhbENvbG9yU3BhY2VDYWNoZTp0aGlzLmdsb2JhbENvbG9yU3BhY2VDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnQuZ2xvYmFsSW1hZ2VDYWNoZSxzeXN0ZW1Gb250Q2FjaGU6dC5zeXN0ZW1Gb250Q2FjaGUsbm9uQmxlbmRNb2Rlc1NldDp0Lm5vbkJsZW5kTW9kZXNTZXQseGZhRmFjdG9yeTpudWxsfSkpO3RoaXMuI0hlLnNldChlLG4pfXQuc2V0QWN0dWFsTnVtUGFnZXMobi5zaXplKX19YXN5bmMgZm9udEZhbGxiYWNrKGUsdCl7Y29uc3R7Y2F0YWxvZzphLHBkZk1hbmFnZXI6cn09dGhpcztmb3IoY29uc3QgaSBvZiBhd2FpdCBQcm9taXNlLmFsbChhLmZvbnRDYWNoZSkpaWYoaS5sb2FkZWROYW1lPT09ZSl7aS5mYWxsYmFjayh0LHIuZXZhbHVhdG9yT3B0aW9ucyk7cmV0dXJufX1hc3luYyBjbGVhbnVwKGU9ITEpe3JldHVybiB0aGlzLmNhdGFsb2c/dGhpcy5jYXRhbG9nLmNsZWFudXAoZSk6Y2xlYXJHbG9iYWxDYWNoZXMoKX1hc3luYyNKZShlLHQsYSxyLGksbixzKXtjb25zdHt4cmVmOm99PXRoaXM7aWYoIShhIGluc3RhbmNlb2YgUmVmKXx8bi5oYXMoYSkpcmV0dXJuO24ucHV0KGEpO2NvbnN0IGM9YXdhaXQgby5mZXRjaEFzeW5jKGEpO2lmKCEoYyBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtsZXQgbD1hd2FpdCBjLmdldEFzeW5jKCJTdWJ0eXBlIik7bD1sIGluc3RhbmNlb2YgTmFtZT9sLm5hbWU6bnVsbDtpZigiTGluayI9PT1sKXJldHVybjtpZihjLmhhcygiVCIpKXtjb25zdCB0PXN0cmluZ1RvUERGU3RyaW5nKGF3YWl0IGMuZ2V0QXN5bmMoIlQiKSk7ZT0iIj09PWU/dDpgJHtlfS4ke3R9YH1lbHNle2xldCBhPWM7Zm9yKDs7KXthPWEuZ2V0UmF3KCJQYXJlbnQiKXx8dDtpZihhIGluc3RhbmNlb2YgUmVmKXtpZihuLmhhcyhhKSlicmVhazthPWF3YWl0IG8uZmV0Y2hBc3luYyhhKX1pZighKGEgaW5zdGFuY2VvZiBEaWN0KSlicmVhaztpZihhLmhhcygiVCIpKXtjb25zdCB0PXN0cmluZ1RvUERGU3RyaW5nKGF3YWl0IGEuZ2V0QXN5bmMoIlQiKSk7ZT0iIj09PWU/dDpgJHtlfS4ke3R9YDticmVha319fXQmJiFjLmhhcygiUGFyZW50IikmJmlzTmFtZShjLmdldCgiU3VidHlwZSIpLCJXaWRnZXQiKSYmcy5wdXQoYSx0KTtyLmhhcyhlKXx8ci5zZXQoZSxbXSk7ci5nZXQoZSkucHVzaChBbm5vdGF0aW9uRmFjdG9yeS5jcmVhdGUobyxhLGksbnVsbCwhMCxzLG51bGwsbnVsbCkudGhlbigoZT0+ZT8uZ2V0RmllbGRPYmplY3QoKSkpLmNhdGNoKChmdW5jdGlvbihlKXt3YXJuKGAjY29sbGVjdEZpZWxkT2JqZWN0czogIiR7ZX0iLmApO3JldHVybiBudWxsfSkpKTtpZighYy5oYXMoIktpZHMiKSlyZXR1cm47Y29uc3QgaD1hd2FpdCBjLmdldEFzeW5jKCJLaWRzIik7aWYoQXJyYXkuaXNBcnJheShoKSlmb3IoY29uc3QgdCBvZiBoKWF3YWl0IHRoaXMuI0plKGUsYSx0LHIsaSxuLHMpfWdldCBmaWVsZE9iamVjdHMoKXtyZXR1cm4gc2hhZG93KHRoaXMsImZpZWxkT2JqZWN0cyIsdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZURvYygiZm9ybUluZm8iKS50aGVuKChhc3luYyBlPT57aWYoIWUuaGFzRmllbGRzKXJldHVybiBudWxsO2NvbnN0IHQ9YXdhaXQgdGhpcy5hbm5vdGF0aW9uR2xvYmFscztpZighdClyZXR1cm4gbnVsbDtjb25zdHthY3JvRm9ybTphfT10LHI9bmV3IFJlZlNldCxpPU9iamVjdC5jcmVhdGUobnVsbCksbj1uZXcgTWFwLHM9bmV3IFJlZlNldENhY2hlO2Zvcihjb25zdCBlIG9mIGEuZ2V0KCJGaWVsZHMiKSlhd2FpdCB0aGlzLiNKZSgiIixudWxsLGUsbix0LHIscyk7Y29uc3Qgbz1bXTtmb3IoY29uc3RbZSx0XW9mIG4pby5wdXNoKFByb21pc2UuYWxsKHQpLnRoZW4oKHQ9PnsodD10LmZpbHRlcigoZT0+ISFlKSkpLmxlbmd0aD4wJiYoaVtlXT10KX0pKSk7YXdhaXQgUHJvbWlzZS5hbGwobyk7cmV0dXJue2FsbEZpZWxkczpvYmplY3RTaXplKGkpPjA/aTpudWxsLG9ycGhhbkZpZWxkczpzfX0pKSl9Z2V0IGhhc0pTQWN0aW9ucygpe3JldHVybiBzaGFkb3codGhpcywiaGFzSlNBY3Rpb25zIix0aGlzLnBkZk1hbmFnZXIuZW5zdXJlRG9jKCJfcGFyc2VIYXNKU0FjdGlvbnMiKSl9YXN5bmMgX3BhcnNlSGFzSlNBY3Rpb25zKCl7Y29uc3RbZSx0XT1hd2FpdCBQcm9taXNlLmFsbChbdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZUNhdGFsb2coImpzQWN0aW9ucyIpLHRoaXMucGRmTWFuYWdlci5lbnN1cmVEb2MoImZpZWxkT2JqZWN0cyIpXSk7cmV0dXJuISFlfHwhIXQ/LmFsbEZpZWxkcyYmT2JqZWN0LnZhbHVlcyh0LmFsbEZpZWxkcykuc29tZSgoZT0+ZS5zb21lKChlPT5udWxsIT09ZS5hY3Rpb25zKSkpKX1nZXQgY2FsY3VsYXRpb25PcmRlcklkcygpe2NvbnN0IGU9dGhpcy5jYXRhbG9nLmFjcm9Gb3JtPy5nZXQoIkNPIik7aWYoIUFycmF5LmlzQXJyYXkoZSl8fDA9PT1lLmxlbmd0aClyZXR1cm4gc2hhZG93KHRoaXMsImNhbGN1bGF0aW9uT3JkZXJJZHMiLG51bGwpO2NvbnN0IHQ9W107Zm9yKGNvbnN0IGEgb2YgZSlhIGluc3RhbmNlb2YgUmVmJiZ0LnB1c2goYS50b1N0cmluZygpKTtyZXR1cm4gc2hhZG93KHRoaXMsImNhbGN1bGF0aW9uT3JkZXJJZHMiLHQubGVuZ3RoP3Q6bnVsbCl9Z2V0IGFubm90YXRpb25HbG9iYWxzKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJhbm5vdGF0aW9uR2xvYmFscyIsQW5ub3RhdGlvbkZhY3RvcnkuY3JlYXRlR2xvYmFscyh0aGlzLnBkZk1hbmFnZXIpKX19Y2xhc3MgQmFzZVBkZk1hbmFnZXJ7Y29uc3RydWN0b3Ioe2RvY0Jhc2VVcmw6ZSxkb2NJZDp0LGVuYWJsZVhmYTphLGV2YWx1YXRvck9wdGlvbnM6cixoYW5kbGVyOmkscGFzc3dvcmQ6bn0pe3RoaXMuX2RvY0Jhc2VVcmw9ZnVuY3Rpb24gcGFyc2VEb2NCYXNlVXJsKGUpe2lmKGUpe2NvbnN0IHQ9Y3JlYXRlVmFsaWRBYnNvbHV0ZVVybChlKTtpZih0KXJldHVybiB0LmhyZWY7d2FybihgSW52YWxpZCBhYnNvbHV0ZSBkb2NCYXNlVXJsOiAiJHtlfSIuYCl9cmV0dXJuIG51bGx9KGUpO3RoaXMuX2RvY0lkPXQ7dGhpcy5fcGFzc3dvcmQ9bjt0aGlzLmVuYWJsZVhmYT1hO3IuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQmJj1GZWF0dXJlVGVzdC5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDtyLmlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkJiY9RmVhdHVyZVRlc3QuaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQ7dGhpcy5ldmFsdWF0b3JPcHRpb25zPU9iamVjdC5mcmVlemUocik7SW1hZ2VSZXNpemVyLnNldE9wdGlvbnMocik7SnBlZ1N0cmVhbS5zZXRPcHRpb25zKHIpO09wZXJhdG9yTGlzdC5zZXRPcHRpb25zKHIpO2NvbnN0IHM9ey4uLnIsaGFuZGxlcjppfTtKcHhJbWFnZS5zZXRPcHRpb25zKHMpO0ljY0NvbG9yU3BhY2Uuc2V0T3B0aW9ucyhzKTtDbXlrSUNDQmFzZWRDUy5zZXRPcHRpb25zKHMpfWdldCBkb2NJZCgpe3JldHVybiB0aGlzLl9kb2NJZH1nZXQgcGFzc3dvcmQoKXtyZXR1cm4gdGhpcy5fcGFzc3dvcmR9Z2V0IGRvY0Jhc2VVcmwoKXtyZXR1cm4gdGhpcy5fZG9jQmFzZVVybH1lbnN1cmVEb2MoZSx0KXtyZXR1cm4gdGhpcy5lbnN1cmUodGhpcy5wZGZEb2N1bWVudCxlLHQpfWVuc3VyZVhSZWYoZSx0KXtyZXR1cm4gdGhpcy5lbnN1cmUodGhpcy5wZGZEb2N1bWVudC54cmVmLGUsdCl9ZW5zdXJlQ2F0YWxvZyhlLHQpe3JldHVybiB0aGlzLmVuc3VyZSh0aGlzLnBkZkRvY3VtZW50LmNhdGFsb2csZSx0KX1nZXRQYWdlKGUpe3JldHVybiB0aGlzLnBkZkRvY3VtZW50LmdldFBhZ2UoZSl9Zm9udEZhbGxiYWNrKGUsdCl7cmV0dXJuIHRoaXMucGRmRG9jdW1lbnQuZm9udEZhbGxiYWNrKGUsdCl9Y2xlYW51cChlPSExKXtyZXR1cm4gdGhpcy5wZGZEb2N1bWVudC5jbGVhbnVwKGUpfWFzeW5jIGVuc3VyZShlLHQsYSl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgZW5zdXJlYCBjYWxsZWQiKX1yZXF1ZXN0UmFuZ2UoZSx0KXt1bnJlYWNoYWJsZSgiQWJzdHJhY3QgbWV0aG9kIGByZXF1ZXN0UmFuZ2VgIGNhbGxlZCIpfXJlcXVlc3RMb2FkZWRTdHJlYW0oZT0hMSl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgcmVxdWVzdExvYWRlZFN0cmVhbWAgY2FsbGVkIil9c2VuZFByb2dyZXNzaXZlRGF0YShlKXt1bnJlYWNoYWJsZSgiQWJzdHJhY3QgbWV0aG9kIGBzZW5kUHJvZ3Jlc3NpdmVEYXRhYCBjYWxsZWQiKX11cGRhdGVQYXNzd29yZChlKXt0aGlzLl9wYXNzd29yZD1lfXRlcm1pbmF0ZShlKXt1bnJlYWNoYWJsZSgiQWJzdHJhY3QgbWV0aG9kIGB0ZXJtaW5hdGVgIGNhbGxlZCIpfX1jbGFzcyBMb2NhbFBkZk1hbmFnZXIgZXh0ZW5kcyBCYXNlUGRmTWFuYWdlcntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdCB0PW5ldyBTdHJlYW0oZS5zb3VyY2UpO3RoaXMucGRmRG9jdW1lbnQ9bmV3IFBERkRvY3VtZW50KHRoaXMsdCk7dGhpcy5fbG9hZGVkU3RyZWFtUHJvbWlzZT1Qcm9taXNlLnJlc29sdmUodCl9YXN5bmMgZW5zdXJlKGUsdCxhKXtjb25zdCByPWVbdF07cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHI/ci5hcHBseShlLGEpOnJ9cmVxdWVzdFJhbmdlKGUsdCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpfXJlcXVlc3RMb2FkZWRTdHJlYW0oZT0hMSl7cmV0dXJuIHRoaXMuX2xvYWRlZFN0cmVhbVByb21pc2V9dGVybWluYXRlKGUpe319Y2xhc3MgTmV0d29ya1BkZk1hbmFnZXIgZXh0ZW5kcyBCYXNlUGRmTWFuYWdlcntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLnN0cmVhbU1hbmFnZXI9bmV3IENodW5rZWRTdHJlYW1NYW5hZ2VyKGUuc291cmNlLHttc2dIYW5kbGVyOmUuaGFuZGxlcixsZW5ndGg6ZS5sZW5ndGgsZGlzYWJsZUF1dG9GZXRjaDplLmRpc2FibGVBdXRvRmV0Y2gscmFuZ2VDaHVua1NpemU6ZS5yYW5nZUNodW5rU2l6ZX0pO3RoaXMucGRmRG9jdW1lbnQ9bmV3IFBERkRvY3VtZW50KHRoaXMsdGhpcy5zdHJlYW1NYW5hZ2VyLmdldFN0cmVhbSgpKX1hc3luYyBlbnN1cmUoZSx0LGEpe3RyeXtjb25zdCByPWVbdF07cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHI/ci5hcHBseShlLGEpOnJ9Y2F0Y2gocil7aWYoIShyIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pKXRocm93IHI7YXdhaXQgdGhpcy5yZXF1ZXN0UmFuZ2Uoci5iZWdpbixyLmVuZCk7cmV0dXJuIHRoaXMuZW5zdXJlKGUsdCxhKX19cmVxdWVzdFJhbmdlKGUsdCl7cmV0dXJuIHRoaXMuc3RyZWFtTWFuYWdlci5yZXF1ZXN0UmFuZ2UoZSx0KX1yZXF1ZXN0TG9hZGVkU3RyZWFtKGU9ITEpe3JldHVybiB0aGlzLnN0cmVhbU1hbmFnZXIucmVxdWVzdEFsbENodW5rcyhlKX1zZW5kUHJvZ3Jlc3NpdmVEYXRhKGUpe3RoaXMuc3RyZWFtTWFuYWdlci5vblJlY2VpdmVEYXRhKHtjaHVuazplfSl9dGVybWluYXRlKGUpe3RoaXMuc3RyZWFtTWFuYWdlci5hYm9ydChlKX19Y29uc3QgbmM9MSxzYz0yLG9jPTEsY2M9MixsYz0zLGhjPTQsdWM9NSxkYz02LGZjPTcsZ2M9ODtmdW5jdGlvbiBvbkZuKCl7fWZ1bmN0aW9uIHdyYXBSZWFzb24oZSl7aWYoZSBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9ufHxlIGluc3RhbmNlb2YgSW52YWxpZFBERkV4Y2VwdGlvbnx8ZSBpbnN0YW5jZW9mIFBhc3N3b3JkRXhjZXB0aW9ufHxlIGluc3RhbmNlb2YgUmVzcG9uc2VFeGNlcHRpb258fGUgaW5zdGFuY2VvZiBVbmtub3duRXJyb3JFeGNlcHRpb24pcmV0dXJuIGU7ZSBpbnN0YW5jZW9mIEVycm9yfHwib2JqZWN0Ij09dHlwZW9mIGUmJm51bGwhPT1lfHx1bnJlYWNoYWJsZSgnd3JhcFJlYXNvbjogRXhwZWN0ZWQgInJlYXNvbiIgdG8gYmUgYSAocG9zc2libHkgY2xvbmVkKSBFcnJvci4nKTtzd2l0Y2goZS5uYW1lKXtjYXNlIkFib3J0RXhjZXB0aW9uIjpyZXR1cm4gbmV3IEFib3J0RXhjZXB0aW9uKGUubWVzc2FnZSk7Y2FzZSJJbnZhbGlkUERGRXhjZXB0aW9uIjpyZXR1cm4gbmV3IEludmFsaWRQREZFeGNlcHRpb24oZS5tZXNzYWdlKTtjYXNlIlBhc3N3b3JkRXhjZXB0aW9uIjpyZXR1cm4gbmV3IFBhc3N3b3JkRXhjZXB0aW9uKGUubWVzc2FnZSxlLmNvZGUpO2Nhc2UiUmVzcG9uc2VFeGNlcHRpb24iOnJldHVybiBuZXcgUmVzcG9uc2VFeGNlcHRpb24oZS5tZXNzYWdlLGUuc3RhdHVzLGUubWlzc2luZyk7Y2FzZSJVbmtub3duRXJyb3JFeGNlcHRpb24iOnJldHVybiBuZXcgVW5rbm93bkVycm9yRXhjZXB0aW9uKGUubWVzc2FnZSxlLmRldGFpbHMpfXJldHVybiBuZXcgVW5rbm93bkVycm9yRXhjZXB0aW9uKGUubWVzc2FnZSxlLnRvU3RyaW5nKCkpfWNsYXNzIE1lc3NhZ2VIYW5kbGVyeyNZZT1uZXcgQWJvcnRDb250cm9sbGVyO2NvbnN0cnVjdG9yKGUsdCxhKXt0aGlzLnNvdXJjZU5hbWU9ZTt0aGlzLnRhcmdldE5hbWU9dDt0aGlzLmNvbU9iaj1hO3RoaXMuY2FsbGJhY2tJZD0xO3RoaXMuc3RyZWFtSWQ9MTt0aGlzLnN0cmVhbVNpbmtzPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5zdHJlYW1Db250cm9sbGVycz1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXM9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLmFjdGlvbkhhbmRsZXI9T2JqZWN0LmNyZWF0ZShudWxsKTthLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLHRoaXMuI1plLmJpbmQodGhpcykse3NpZ25hbDp0aGlzLiNZZS5zaWduYWx9KX0jWmUoe2RhdGE6ZX0pe2lmKGUudGFyZ2V0TmFtZSE9PXRoaXMuc291cmNlTmFtZSlyZXR1cm47aWYoZS5zdHJlYW0pe3RoaXMuI1FlKGUpO3JldHVybn1pZihlLmNhbGxiYWNrKXtjb25zdCB0PWUuY2FsbGJhY2tJZCxhPXRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbdF07aWYoIWEpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVzb2x2ZSBjYWxsYmFjayAke3R9YCk7ZGVsZXRlIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbdF07aWYoZS5jYWxsYmFjaz09PW5jKWEucmVzb2x2ZShlLmRhdGEpO2Vsc2V7aWYoZS5jYWxsYmFjayE9PXNjKXRocm93IG5ldyBFcnJvcigiVW5leHBlY3RlZCBjYWxsYmFjayBjYXNlIik7YS5yZWplY3Qod3JhcFJlYXNvbihlLnJlYXNvbikpfXJldHVybn1jb25zdCB0PXRoaXMuYWN0aW9uSGFuZGxlcltlLmFjdGlvbl07aWYoIXQpdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogJHtlLmFjdGlvbn1gKTtpZihlLmNhbGxiYWNrSWQpe2NvbnN0IGE9dGhpcy5zb3VyY2VOYW1lLHI9ZS5zb3VyY2VOYW1lLGk9dGhpcy5jb21PYmo7UHJvbWlzZS50cnkodCxlLmRhdGEpLnRoZW4oKGZ1bmN0aW9uKHQpe2kucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6YSx0YXJnZXROYW1lOnIsY2FsbGJhY2s6bmMsY2FsbGJhY2tJZDplLmNhbGxiYWNrSWQsZGF0YTp0fSl9KSwoZnVuY3Rpb24odCl7aS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTphLHRhcmdldE5hbWU6cixjYWxsYmFjazpzYyxjYWxsYmFja0lkOmUuY2FsbGJhY2tJZCxyZWFzb246d3JhcFJlYXNvbih0KX0pfSkpfWVsc2UgZS5zdHJlYW1JZD90aGlzLiNldChlKTp0KGUuZGF0YSl9b24oZSx0KXtjb25zdCBhPXRoaXMuYWN0aW9uSGFuZGxlcjtpZihhW2VdKXRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCAiJHtlfSJgKTthW2VdPXR9c2VuZChlLHQsYSl7dGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6dGhpcy5zb3VyY2VOYW1lLHRhcmdldE5hbWU6dGhpcy50YXJnZXROYW1lLGFjdGlvbjplLGRhdGE6dH0sYSl9c2VuZFdpdGhQcm9taXNlKGUsdCxhKXtjb25zdCByPXRoaXMuY2FsbGJhY2tJZCsrLGk9UHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7dGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tyXT1pO3RyeXt0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTp0aGlzLnNvdXJjZU5hbWUsdGFyZ2V0TmFtZTp0aGlzLnRhcmdldE5hbWUsYWN0aW9uOmUsY2FsbGJhY2tJZDpyLGRhdGE6dH0sYSl9Y2F0Y2goZSl7aS5yZWplY3QoZSl9cmV0dXJuIGkucHJvbWlzZX1zZW5kV2l0aFN0cmVhbShlLHQsYSxyKXtjb25zdCBpPXRoaXMuc3RyZWFtSWQrKyxuPXRoaXMuc291cmNlTmFtZSxzPXRoaXMudGFyZ2V0TmFtZSxvPXRoaXMuY29tT2JqO3JldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe3N0YXJ0OmE9Pntjb25zdCBjPVByb21pc2Uud2l0aFJlc29sdmVycygpO3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbaV09e2NvbnRyb2xsZXI6YSxzdGFydENhbGw6YyxwdWxsQ2FsbDpudWxsLGNhbmNlbENhbGw6bnVsbCxpc0Nsb3NlZDohMX07by5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTpuLHRhcmdldE5hbWU6cyxhY3Rpb246ZSxzdHJlYW1JZDppLGRhdGE6dCxkZXNpcmVkU2l6ZTphLmRlc2lyZWRTaXplfSxyKTtyZXR1cm4gYy5wcm9taXNlfSxwdWxsOmU9Pntjb25zdCB0PVByb21pc2Uud2l0aFJlc29sdmVycygpO3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbaV0ucHVsbENhbGw9dDtvLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOm4sdGFyZ2V0TmFtZTpzLHN0cmVhbTpkYyxzdHJlYW1JZDppLGRlc2lyZWRTaXplOmUuZGVzaXJlZFNpemV9KTtyZXR1cm4gdC5wcm9taXNlfSxjYW5jZWw6ZT0+e2Fzc2VydChlIGluc3RhbmNlb2YgRXJyb3IsImNhbmNlbCBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb24iKTtjb25zdCB0PVByb21pc2Uud2l0aFJlc29sdmVycygpO3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbaV0uY2FuY2VsQ2FsbD10O3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbaV0uaXNDbG9zZWQ9ITA7by5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTpuLHRhcmdldE5hbWU6cyxzdHJlYW06b2Msc3RyZWFtSWQ6aSxyZWFzb246d3JhcFJlYXNvbihlKX0pO3JldHVybiB0LnByb21pc2V9fSxhKX0jZXQoZSl7Y29uc3QgdD1lLnN0cmVhbUlkLGE9dGhpcy5zb3VyY2VOYW1lLHI9ZS5zb3VyY2VOYW1lLGk9dGhpcy5jb21PYmosbj10aGlzLHM9dGhpcy5hY3Rpb25IYW5kbGVyW2UuYWN0aW9uXSxvPXtlbnF1ZXVlKGUsbj0xLHMpe2lmKHRoaXMuaXNDYW5jZWxsZWQpcmV0dXJuO2NvbnN0IG89dGhpcy5kZXNpcmVkU2l6ZTt0aGlzLmRlc2lyZWRTaXplLT1uO2lmKG8+MCYmdGhpcy5kZXNpcmVkU2l6ZTw9MCl7dGhpcy5zaW5rQ2FwYWJpbGl0eT1Qcm9taXNlLndpdGhSZXNvbHZlcnMoKTt0aGlzLnJlYWR5PXRoaXMuc2lua0NhcGFiaWxpdHkucHJvbWlzZX1pLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmEsdGFyZ2V0TmFtZTpyLHN0cmVhbTpoYyxzdHJlYW1JZDp0LGNodW5rOmV9LHMpfSxjbG9zZSgpe2lmKCF0aGlzLmlzQ2FuY2VsbGVkKXt0aGlzLmlzQ2FuY2VsbGVkPSEwO2kucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6YSx0YXJnZXROYW1lOnIsc3RyZWFtOmxjLHN0cmVhbUlkOnR9KTtkZWxldGUgbi5zdHJlYW1TaW5rc1t0XX19LGVycm9yKGUpe2Fzc2VydChlIGluc3RhbmNlb2YgRXJyb3IsImVycm9yIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvbiIpO2lmKCF0aGlzLmlzQ2FuY2VsbGVkKXt0aGlzLmlzQ2FuY2VsbGVkPSEwO2kucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6YSx0YXJnZXROYW1lOnIsc3RyZWFtOnVjLHN0cmVhbUlkOnQscmVhc29uOndyYXBSZWFzb24oZSl9KX19LHNpbmtDYXBhYmlsaXR5OlByb21pc2Uud2l0aFJlc29sdmVycygpLG9uUHVsbDpudWxsLG9uQ2FuY2VsOm51bGwsaXNDYW5jZWxsZWQ6ITEsZGVzaXJlZFNpemU6ZS5kZXNpcmVkU2l6ZSxyZWFkeTpudWxsfTtvLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtvLnJlYWR5PW8uc2lua0NhcGFiaWxpdHkucHJvbWlzZTt0aGlzLnN0cmVhbVNpbmtzW3RdPW87UHJvbWlzZS50cnkocyxlLmRhdGEsbykudGhlbigoZnVuY3Rpb24oKXtpLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmEsdGFyZ2V0TmFtZTpyLHN0cmVhbTpnYyxzdHJlYW1JZDp0LHN1Y2Nlc3M6ITB9KX0pLChmdW5jdGlvbihlKXtpLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmEsdGFyZ2V0TmFtZTpyLHN0cmVhbTpnYyxzdHJlYW1JZDp0LHJlYXNvbjp3cmFwUmVhc29uKGUpfSl9KSl9I1FlKGUpe2NvbnN0IHQ9ZS5zdHJlYW1JZCxhPXRoaXMuc291cmNlTmFtZSxyPWUuc291cmNlTmFtZSxpPXRoaXMuY29tT2JqLG49dGhpcy5zdHJlYW1Db250cm9sbGVyc1t0XSxzPXRoaXMuc3RyZWFtU2lua3NbdF07c3dpdGNoKGUuc3RyZWFtKXtjYXNlIGdjOmUuc3VjY2Vzcz9uLnN0YXJ0Q2FsbC5yZXNvbHZlKCk6bi5zdGFydENhbGwucmVqZWN0KHdyYXBSZWFzb24oZS5yZWFzb24pKTticmVhaztjYXNlIGZjOmUuc3VjY2Vzcz9uLnB1bGxDYWxsLnJlc29sdmUoKTpuLnB1bGxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGUucmVhc29uKSk7YnJlYWs7Y2FzZSBkYzppZighcyl7aS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTphLHRhcmdldE5hbWU6cixzdHJlYW06ZmMsc3RyZWFtSWQ6dCxzdWNjZXNzOiEwfSk7YnJlYWt9cy5kZXNpcmVkU2l6ZTw9MCYmZS5kZXNpcmVkU2l6ZT4wJiZzLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtzLmRlc2lyZWRTaXplPWUuZGVzaXJlZFNpemU7UHJvbWlzZS50cnkocy5vblB1bGx8fG9uRm4pLnRoZW4oKGZ1bmN0aW9uKCl7aS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTphLHRhcmdldE5hbWU6cixzdHJlYW06ZmMsc3RyZWFtSWQ6dCxzdWNjZXNzOiEwfSl9KSwoZnVuY3Rpb24oZSl7aS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTphLHRhcmdldE5hbWU6cixzdHJlYW06ZmMsc3RyZWFtSWQ6dCxyZWFzb246d3JhcFJlYXNvbihlKX0pfSkpO2JyZWFrO2Nhc2UgaGM6YXNzZXJ0KG4sImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXIiKTtpZihuLmlzQ2xvc2VkKWJyZWFrO24uY29udHJvbGxlci5lbnF1ZXVlKGUuY2h1bmspO2JyZWFrO2Nhc2UgbGM6YXNzZXJ0KG4sImNsb3NlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyIik7aWYobi5pc0Nsb3NlZClicmVhaztuLmlzQ2xvc2VkPSEwO24uY29udHJvbGxlci5jbG9zZSgpO3RoaXMuI3R0KG4sdCk7YnJlYWs7Y2FzZSB1Yzphc3NlcnQobiwiZXJyb3Igc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXIiKTtuLmNvbnRyb2xsZXIuZXJyb3Iod3JhcFJlYXNvbihlLnJlYXNvbikpO3RoaXMuI3R0KG4sdCk7YnJlYWs7Y2FzZSBjYzplLnN1Y2Nlc3M/bi5jYW5jZWxDYWxsLnJlc29sdmUoKTpuLmNhbmNlbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZS5yZWFzb24pKTt0aGlzLiN0dChuLHQpO2JyZWFrO2Nhc2Ugb2M6aWYoIXMpYnJlYWs7Y29uc3Qgbz13cmFwUmVhc29uKGUucmVhc29uKTtQcm9taXNlLnRyeShzLm9uQ2FuY2VsfHxvbkZuLG8pLnRoZW4oKGZ1bmN0aW9uKCl7aS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTphLHRhcmdldE5hbWU6cixzdHJlYW06Y2Msc3RyZWFtSWQ6dCxzdWNjZXNzOiEwfSl9KSwoZnVuY3Rpb24oZSl7aS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTphLHRhcmdldE5hbWU6cixzdHJlYW06Y2Msc3RyZWFtSWQ6dCxyZWFzb246d3JhcFJlYXNvbihlKX0pfSkpO3Muc2lua0NhcGFiaWxpdHkucmVqZWN0KG8pO3MuaXNDYW5jZWxsZWQ9ITA7ZGVsZXRlIHRoaXMuc3RyZWFtU2lua3NbdF07YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlVuZXhwZWN0ZWQgc3RyZWFtIGNhc2UiKX19YXN5bmMjdHQoZSx0KXthd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW2Uuc3RhcnRDYWxsPy5wcm9taXNlLGUucHVsbENhbGw/LnByb21pc2UsZS5jYW5jZWxDYWxsPy5wcm9taXNlXSk7ZGVsZXRlIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbdF19ZGVzdHJveSgpe3RoaXMuI1llPy5hYm9ydCgpO3RoaXMuI1llPW51bGx9fWFzeW5jIGZ1bmN0aW9uIHdyaXRlT2JqZWN0KGUsdCxhLHtlbmNyeXB0OnI9bnVsbH0pe2NvbnN0IGk9cj8uY3JlYXRlQ2lwaGVyVHJhbnNmb3JtKGUubnVtLGUuZ2VuKTthLnB1c2goYCR7ZS5udW19ICR7ZS5nZW59IG9ialxuYCk7dCBpbnN0YW5jZW9mIERpY3Q/YXdhaXQgd3JpdGVEaWN0KHQsYSxpKTp0IGluc3RhbmNlb2YgQmFzZVN0cmVhbT9hd2FpdCB3cml0ZVN0cmVhbSh0LGEsaSk6KEFycmF5LmlzQXJyYXkodCl8fEFycmF5QnVmZmVyLmlzVmlldyh0KSkmJmF3YWl0IHdyaXRlQXJyYXkodCxhLGkpO2EucHVzaCgiXG5lbmRvYmpcbiIpfWFzeW5jIGZ1bmN0aW9uIHdyaXRlRGljdChlLHQsYSl7dC5wdXNoKCI8PCIpO2Zvcihjb25zdCByIG9mIGUuZ2V0S2V5cygpKXt0LnB1c2goYCAvJHtlc2NhcGVQREZOYW1lKHIpfSBgKTthd2FpdCB3cml0ZVZhbHVlKGUuZ2V0UmF3KHIpLHQsYSl9dC5wdXNoKCI+PiIpfWFzeW5jIGZ1bmN0aW9uIHdyaXRlU3RyZWFtKGUsdCxhKXtsZXQgcj1lLmdldEJ5dGVzKCk7Y29uc3R7ZGljdDppfT1lLFtuLHNdPWF3YWl0IFByb21pc2UuYWxsKFtpLmdldEFzeW5jKCJGaWx0ZXIiKSxpLmdldEFzeW5jKCJEZWNvZGVQYXJtcyIpXSksbz1pc05hbWUoQXJyYXkuaXNBcnJheShuKT9hd2FpdCBpLnhyZWYuZmV0Y2hJZlJlZkFzeW5jKG5bMF0pOm4sIkZsYXRlRGVjb2RlIik7aWYoci5sZW5ndGg+PTI1Nnx8byl0cnl7Y29uc3QgZT1uZXcgQ29tcHJlc3Npb25TdHJlYW0oImRlZmxhdGUiKSx0PWUud3JpdGFibGUuZ2V0V3JpdGVyKCk7YXdhaXQgdC5yZWFkeTt0LndyaXRlKHIpLnRoZW4oKGFzeW5jKCk9Pnthd2FpdCB0LnJlYWR5O2F3YWl0IHQuY2xvc2UoKX0pKS5jYXRjaCgoKCk9Pnt9KSk7Y29uc3QgYT1hd2FpdCBuZXcgUmVzcG9uc2UoZS5yZWFkYWJsZSkuYXJyYXlCdWZmZXIoKTtyPW5ldyBVaW50OEFycmF5KGEpO2xldCBjLGw7aWYobil7aWYoIW8pe2M9QXJyYXkuaXNBcnJheShuKT9bTmFtZS5nZXQoIkZsYXRlRGVjb2RlIiksLi4ubl06W05hbWUuZ2V0KCJGbGF0ZURlY29kZSIpLG5dO3MmJihsPUFycmF5LmlzQXJyYXkocyk/W251bGwsLi4uc106W251bGwsc10pfX1lbHNlIGM9TmFtZS5nZXQoIkZsYXRlRGVjb2RlIik7YyYmaS5zZXQoIkZpbHRlciIsYyk7bCYmaS5zZXQoIkRlY29kZVBhcm1zIixsKX1jYXRjaChlKXtpbmZvKGB3cml0ZVN0cmVhbSAtIGNhbm5vdCBjb21wcmVzcyBkYXRhOiAiJHtlfSIuYCl9bGV0IGM9Ynl0ZXNUb1N0cmluZyhyKTthJiYoYz1hLmVuY3J5cHRTdHJpbmcoYykpO2kuc2V0KCJMZW5ndGgiLGMubGVuZ3RoKTthd2FpdCB3cml0ZURpY3QoaSx0LGEpO3QucHVzaCgiIHN0cmVhbVxuIixjLCJcbmVuZHN0cmVhbSIpfWFzeW5jIGZ1bmN0aW9uIHdyaXRlQXJyYXkoZSx0LGEpe3QucHVzaCgiWyIpO2xldCByPSEwO2Zvcihjb25zdCBpIG9mIGUpe3I/cj0hMTp0LnB1c2goIiAiKTthd2FpdCB3cml0ZVZhbHVlKGksdCxhKX10LnB1c2goIl0iKX1hc3luYyBmdW5jdGlvbiB3cml0ZVZhbHVlKGUsdCxhKXtpZihlIGluc3RhbmNlb2YgTmFtZSl0LnB1c2goYC8ke2VzY2FwZVBERk5hbWUoZS5uYW1lKX1gKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBSZWYpdC5wdXNoKGAke2UubnVtfSAke2UuZ2VufSBSYCk7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpfHxBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpYXdhaXQgd3JpdGVBcnJheShlLHQsYSk7ZWxzZSBpZigic3RyaW5nIj09dHlwZW9mIGUpe2EmJihlPWEuZW5jcnlwdFN0cmluZyhlKSk7dC5wdXNoKGAoJHtlc2NhcGVTdHJpbmcoZSl9KWApfWVsc2UibnVtYmVyIj09dHlwZW9mIGU/dC5wdXNoKG51bWJlclRvU3RyaW5nKGUpKToiYm9vbGVhbiI9PXR5cGVvZiBlP3QucHVzaChlLnRvU3RyaW5nKCkpOmUgaW5zdGFuY2VvZiBEaWN0P2F3YWl0IHdyaXRlRGljdChlLHQsYSk6ZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0/YXdhaXQgd3JpdGVTdHJlYW0oZSx0LGEpOm51bGw9PT1lP3QucHVzaCgibnVsbCIpOndhcm4oYFVuaGFuZGxlZCB2YWx1ZSBpbiB3cml0ZXI6ICR7dHlwZW9mIGV9LCBwbGVhc2UgZmlsZSBhIGJ1Zy5gKX1mdW5jdGlvbiB3cml0ZUludChlLHQsYSxyKXtmb3IobGV0IGk9dCthLTE7aT5hLTE7aS0tKXtyW2ldPTI1NSZlO2U+Pj04fXJldHVybiBhK3R9ZnVuY3Rpb24gd3JpdGVTdHJpbmcoZSx0LGEpe2NvbnN0IHI9ZS5sZW5ndGg7Zm9yKGxldCBpPTA7aTxyO2krKylhW3QraV09MjU1JmUuY2hhckNvZGVBdChpKTtyZXR1cm4gdCtyfWZ1bmN0aW9uIHVwZGF0ZVhGQSh7eGZhRGF0YTplLHhmYURhdGFzZXRzUmVmOnQsY2hhbmdlczphLHhyZWY6cn0pe2lmKG51bGw9PT1lKXtlPWZ1bmN0aW9uIHdyaXRlWEZBRGF0YUZvckFjcm9mb3JtKGUsdCl7Y29uc3QgYT1uZXcgU2ltcGxlWE1MUGFyc2VyKHtoYXNBdHRyaWJ1dGVzOiEwfSkucGFyc2VGcm9tU3RyaW5nKGUpO2Zvcihjb25zdHt4ZmE6ZX1vZiB0KXtpZighZSljb250aW51ZTtjb25zdHtwYXRoOnQsdmFsdWU6cn09ZTtpZighdCljb250aW51ZTtjb25zdCBpPXBhcnNlWEZBUGF0aCh0KTtsZXQgbj1hLmRvY3VtZW50RWxlbWVudC5zZWFyY2hOb2RlKGksMCk7IW4mJmkubGVuZ3RoPjEmJihuPWEuZG9jdW1lbnRFbGVtZW50LnNlYXJjaE5vZGUoW2kuYXQoLTEpXSwwKSk7bj9uLmNoaWxkTm9kZXM9QXJyYXkuaXNBcnJheShyKT9yLm1hcCgoZT0+bmV3IFNpbXBsZURPTU5vZGUoInZhbHVlIixlKSkpOltuZXcgU2ltcGxlRE9NTm9kZSgiI3RleHQiLHIpXTp3YXJuKGBOb2RlIG5vdCBmb3VuZCBmb3IgcGF0aDogJHt0fWApfWNvbnN0IHI9W107YS5kb2N1bWVudEVsZW1lbnQuZHVtcChyKTtyZXR1cm4gci5qb2luKCIiKX0oci5mZXRjaElmUmVmKHQpLmdldFN0cmluZygpLGEpfWNvbnN0IGk9bmV3IFN0cmluZ1N0cmVhbShlKTtpLmRpY3Q9bmV3IERpY3Qocik7aS5kaWN0LnNldElmTmFtZSgiVHlwZSIsIkVtYmVkZGVkRmlsZSIpO2EucHV0KHQse2RhdGE6aX0pfWZ1bmN0aW9uIGdldEluZGV4ZXMoZSl7Y29uc3QgdD1bXTtmb3IoY29uc3R7cmVmOmF9b2YgZSlhLm51bT09PXQuYXQoLTIpK3QuYXQoLTEpP3RbdC5sZW5ndGgtMV0rPTE6dC5wdXNoKGEubnVtLDEpO3JldHVybiB0fWZ1bmN0aW9uIGNvbXB1dGVJRHMoZSx0LGEpe2lmKEFycmF5LmlzQXJyYXkodC5maWxlSWRzKSYmdC5maWxlSWRzLmxlbmd0aD4wKXtjb25zdCByPWZ1bmN0aW9uIGNvbXB1dGVNRDUoZSx0KXtjb25zdCBhPU1hdGguZmxvb3IoRGF0ZS5ub3coKS8xZTMpLHI9dC5maWxlbmFtZXx8IiIsaT1bYS50b1N0cmluZygpLHIsZS50b1N0cmluZygpLC4uLnQuaW5mb01hcC52YWx1ZXMoKV0sbj1NYXRoLnN1bVByZWNpc2UoaS5tYXAoKGU9PmUubGVuZ3RoKSkpLHM9bmV3IFVpbnQ4QXJyYXkobik7bGV0IG89MDtmb3IoY29uc3QgZSBvZiBpKW89d3JpdGVTdHJpbmcoZSxvLHMpO3JldHVybiBieXRlc1RvU3RyaW5nKGNhbGN1bGF0ZU1ENShzLDAscy5sZW5ndGgpKX0oZSx0KTthLnNldCgiSUQiLFt0LmZpbGVJZHNbMF0scl0pfX1hc3luYyBmdW5jdGlvbiBpbmNyZW1lbnRhbFVwZGF0ZSh7b3JpZ2luYWxEYXRhOmUseHJlZkluZm86dCxjaGFuZ2VzOmEseHJlZjpyPW51bGwsaGFzWGZhOmk9ITEseGZhRGF0YXNldHNSZWY6bj1udWxsLGhhc1hmYURhdGFzZXRzRW50cnk6cz0hMSxuZWVkQXBwZWFyYW5jZXM6byxhY3JvRm9ybVJlZjpjPW51bGwsYWNyb0Zvcm06bD1udWxsLHhmYURhdGE6aD1udWxsLHVzZVhyZWZTdHJlYW06dT0hMX0pe2F3YWl0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUFjcm9mb3JtKHt4cmVmOmUsYWNyb0Zvcm06dCxhY3JvRm9ybVJlZjphLGhhc1hmYTpyLGhhc1hmYURhdGFzZXRzRW50cnk6aSx4ZmFEYXRhc2V0c1JlZjpuLG5lZWRBcHBlYXJhbmNlczpzLGNoYW5nZXM6b30peyFyfHxpfHxufHx3YXJuKCJYRkEgLSBDYW5ub3Qgc2F2ZSBpdCIpO2lmKCFzJiYoIXJ8fCFufHxpKSlyZXR1cm47Y29uc3QgYz10LmNsb25lKCk7aWYociYmIWkpe2NvbnN0IGU9dC5nZXQoIlhGQSIpLnNsaWNlKCk7ZS5zcGxpY2UoMiwwLCJkYXRhc2V0cyIpO2Uuc3BsaWNlKDMsMCxuKTtjLnNldCgiWEZBIixlKX1zJiZjLnNldCgiTmVlZEFwcGVhcmFuY2VzIiwhMCk7by5wdXQoYSx7ZGF0YTpjfSl9KHt4cmVmOnIsYWNyb0Zvcm06bCxhY3JvRm9ybVJlZjpjLGhhc1hmYTppLGhhc1hmYURhdGFzZXRzRW50cnk6cyx4ZmFEYXRhc2V0c1JlZjpuLG5lZWRBcHBlYXJhbmNlczpvLGNoYW5nZXM6YX0pO2kmJnVwZGF0ZVhGQSh7eGZhRGF0YTpoLHhmYURhdGFzZXRzUmVmOm4sY2hhbmdlczphLHhyZWY6cn0pO2NvbnN0IGQ9ZnVuY3Rpb24gZ2V0VHJhaWxlckRpY3QoZSx0LGEpe2NvbnN0IHI9bmV3IERpY3QobnVsbCk7ci5zZXQoIlByZXYiLGUuc3RhcnRYUmVmKTtjb25zdCBpPWUubmV3UmVmO2lmKGEpe3QucHV0KGkse2RhdGE6IiJ9KTtyLnNldCgiU2l6ZSIsaS5udW0rMSk7ci5zZXRJZk5hbWUoIlR5cGUiLCJYUmVmIil9ZWxzZSByLnNldCgiU2l6ZSIsaS5udW0pO251bGwhPT1lLnJvb3RSZWYmJnIuc2V0KCJSb290IixlLnJvb3RSZWYpO251bGwhPT1lLmluZm9SZWYmJnIuc2V0KCJJbmZvIixlLmluZm9SZWYpO251bGwhPT1lLmVuY3J5cHRSZWYmJnIuc2V0KCJFbmNyeXB0IixlLmVuY3J5cHRSZWYpO3JldHVybiByfSh0LGEsdSksZj1bXSxnPWF3YWl0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlQ2hhbmdlcyhlLHQsYT1bXSl7Y29uc3Qgcj1bXTtmb3IoY29uc3RbaSx7ZGF0YTpufV1vZiBlLml0ZW1zKCkpaWYobnVsbCE9PW4mJiJzdHJpbmciIT10eXBlb2Ygbil7YXdhaXQgd3JpdGVPYmplY3QoaSxuLGEsdCk7ci5wdXNoKHtyZWY6aSxkYXRhOmEuam9pbigiIil9KTthLmxlbmd0aD0wfWVsc2Ugci5wdXNoKHtyZWY6aSxkYXRhOm59KTtyZXR1cm4gci5zb3J0KCgoZSx0KT0+ZS5yZWYubnVtLXQucmVmLm51bSkpfShhLHIsZik7bGV0IHA9ZS5sZW5ndGg7Y29uc3QgbT1lLmF0KC0xKTtpZigxMCE9PW0mJjEzIT09bSl7Zi5wdXNoKCJcbiIpO3ArPTF9Zm9yKGNvbnN0e2RhdGE6ZX1vZiBnKW51bGwhPT1lJiZmLnB1c2goZSk7YXdhaXQodT9hc3luYyBmdW5jdGlvbiBnZXRYUmVmU3RyZWFtVGFibGUoZSx0LGEscixpKXtjb25zdCBuPVtdO2xldCBzPTAsbz0wO2Zvcihjb25zdHtyZWY6ZSxkYXRhOnJ9b2YgYSl7bGV0IGE7cz1NYXRoLm1heChzLHQpO2lmKG51bGwhPT1yKXthPU1hdGgubWluKGUuZ2VuLDY1NTM1KTtuLnB1c2goWzEsdCxhXSk7dCs9ci5sZW5ndGh9ZWxzZXthPU1hdGgubWluKGUuZ2VuKzEsNjU1MzUpO24ucHVzaChbMCwwLGFdKX1vPU1hdGgubWF4KG8sYSl9ci5zZXQoIkluZGV4IixnZXRJbmRleGVzKGEpKTtjb25zdCBjPVsxLGdldFNpemVJbkJ5dGVzKHMpLGdldFNpemVJbkJ5dGVzKG8pXTtyLnNldCgiVyIsYyk7Y29tcHV0ZUlEcyh0LGUscik7Y29uc3QgbD1NYXRoLnN1bVByZWNpc2UoYyksaD1uZXcgVWludDhBcnJheShsKm4ubGVuZ3RoKSx1PW5ldyBTdHJlYW0oaCk7dS5kaWN0PXI7bGV0IGQ9MDtmb3IoY29uc3RbZSx0LGFdb2Ygbil7ZD13cml0ZUludChlLGNbMF0sZCxoKTtkPXdyaXRlSW50KHQsY1sxXSxkLGgpO2Q9d3JpdGVJbnQoYSxjWzJdLGQsaCl9YXdhaXQgd3JpdGVPYmplY3QoZS5uZXdSZWYsdSxpLHt9KTtpLnB1c2goInN0YXJ0eHJlZlxuIix0LnRvU3RyaW5nKCksIlxuJSVFT0ZcbiIpfSh0LHAsZyxkLGYpOmFzeW5jIGZ1bmN0aW9uIGdldFhSZWZUYWJsZShlLHQsYSxyLGkpe2kucHVzaCgieHJlZlxuIik7Y29uc3Qgbj1nZXRJbmRleGVzKGEpO2xldCBzPTA7Zm9yKGNvbnN0e3JlZjplLGRhdGE6cn1vZiBhKXtpZihlLm51bT09PW5bc10pe2kucHVzaChgJHtuW3NdfSAke25bcysxXX1cbmApO3MrPTJ9aWYobnVsbCE9PXIpe2kucHVzaChgJHt0LnRvU3RyaW5nKCkucGFkU3RhcnQoMTAsIjAiKX0gJHtNYXRoLm1pbihlLmdlbiw2NTUzNSkudG9TdHJpbmcoKS5wYWRTdGFydCg1LCIwIil9IG5cclxuYCk7dCs9ci5sZW5ndGh9ZWxzZSBpLnB1c2goYDAwMDAwMDAwMDAgJHtNYXRoLm1pbihlLmdlbisxLDY1NTM1KS50b1N0cmluZygpLnBhZFN0YXJ0KDUsIjAiKX0gZlxyXG5gKX1jb21wdXRlSURzKHQsZSxyKTtpLnB1c2goInRyYWlsZXJcbiIpO2F3YWl0IHdyaXRlRGljdChyLGkpO2kucHVzaCgiXG5zdGFydHhyZWZcbiIsdC50b1N0cmluZygpLCJcbiUlRU9GXG4iKX0odCxwLGcsZCxmKSk7Y29uc3QgYj1lLmxlbmd0aCtNYXRoLnN1bVByZWNpc2UoZi5tYXAoKGU9PmUubGVuZ3RoKSkpLHk9bmV3IFVpbnQ4QXJyYXkoYik7eS5zZXQoZSk7bGV0IHc9ZS5sZW5ndGg7Zm9yKGNvbnN0IGUgb2YgZil3PXdyaXRlU3RyaW5nKGUsdyx5KTtyZXR1cm4geX1jbGFzcyBQREZXb3JrZXJTdHJlYW17Y29uc3RydWN0b3IoZSl7dGhpcy5fbXNnSGFuZGxlcj1lO3RoaXMuX2NvbnRlbnRMZW5ndGg9bnVsbDt0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj1udWxsO3RoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnM9W119Z2V0RnVsbFJlYWRlcigpe2Fzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIlBERldvcmtlclN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLiIpO3RoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPW5ldyBQREZXb3JrZXJTdHJlYW1SZWFkZXIodGhpcy5fbXNnSGFuZGxlcik7cmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyfWdldFJhbmdlUmVhZGVyKGUsdCl7Y29uc3QgYT1uZXcgUERGV29ya2VyU3RyZWFtUmFuZ2VSZWFkZXIoZSx0LHRoaXMuX21zZ0hhbmRsZXIpO3RoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChhKTtyZXR1cm4gYX1jYW5jZWxBbGxSZXF1ZXN0cyhlKXt0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKGUpO2Zvcihjb25zdCB0IG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpdC5jYW5jZWwoZSl9fWNsYXNzIFBERldvcmtlclN0cmVhbVJlYWRlcntjb25zdHJ1Y3RvcihlKXt0aGlzLl9tc2dIYW5kbGVyPWU7dGhpcy5vblByb2dyZXNzPW51bGw7dGhpcy5fY29udGVudExlbmd0aD1udWxsO3RoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ9ITE7dGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ9ITE7Y29uc3QgdD10aGlzLl9tc2dIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKCJHZXRSZWFkZXIiKTt0aGlzLl9yZWFkZXI9dC5nZXRSZWFkZXIoKTt0aGlzLl9oZWFkZXJzUmVhZHk9dGhpcy5fbXNnSGFuZGxlci5zZW5kV2l0aFByb21pc2UoIlJlYWRlckhlYWRlcnNSZWFkeSIpLnRoZW4oKGU9Pnt0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZD1lLmlzU3RyZWFtaW5nU3VwcG9ydGVkO3RoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ9ZS5pc1JhbmdlU3VwcG9ydGVkO3RoaXMuX2NvbnRlbnRMZW5ndGg9ZS5jb250ZW50TGVuZ3RofSkpfWdldCBoZWFkZXJzUmVhZHkoKXtyZXR1cm4gdGhpcy5faGVhZGVyc1JlYWR5fWdldCBjb250ZW50TGVuZ3RoKCl7cmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGh9Z2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCl7cmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkfWdldCBpc1JhbmdlU3VwcG9ydGVkKCl7cmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWR9YXN5bmMgcmVhZCgpe2NvbnN0e3ZhbHVlOmUsZG9uZTp0fT1hd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO3JldHVybiB0P3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06e3ZhbHVlOmUuYnVmZmVyLGRvbmU6ITF9fWNhbmNlbChlKXt0aGlzLl9yZWFkZXIuY2FuY2VsKGUpfX1jbGFzcyBQREZXb3JrZXJTdHJlYW1SYW5nZVJlYWRlcntjb25zdHJ1Y3RvcihlLHQsYSl7dGhpcy5fbXNnSGFuZGxlcj1hO3RoaXMub25Qcm9ncmVzcz1udWxsO2NvbnN0IHI9dGhpcy5fbXNnSGFuZGxlci5zZW5kV2l0aFN0cmVhbSgiR2V0UmFuZ2VSZWFkZXIiLHtiZWdpbjplLGVuZDp0fSk7dGhpcy5fcmVhZGVyPXIuZ2V0UmVhZGVyKCl9Z2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCl7cmV0dXJuITF9YXN5bmMgcmVhZCgpe2NvbnN0e3ZhbHVlOmUsZG9uZTp0fT1hd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO3JldHVybiB0P3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06e3ZhbHVlOmUuYnVmZmVyLGRvbmU6ITF9fWNhbmNlbChlKXt0aGlzLl9yZWFkZXIuY2FuY2VsKGUpfX1jbGFzcyBXb3JrZXJUYXNre2NvbnN0cnVjdG9yKGUpe3RoaXMubmFtZT1lO3RoaXMudGVybWluYXRlZD0hMTt0aGlzLl9jYXBhYmlsaXR5PVByb21pc2Uud2l0aFJlc29sdmVycygpfWdldCBmaW5pc2hlZCgpe3JldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2V9ZmluaXNoKCl7dGhpcy5fY2FwYWJpbGl0eS5yZXNvbHZlKCl9dGVybWluYXRlKCl7dGhpcy50ZXJtaW5hdGVkPSEwfWVuc3VyZU5vdFRlcm1pbmF0ZWQoKXtpZih0aGlzLnRlcm1pbmF0ZWQpdGhyb3cgbmV3IEVycm9yKCJXb3JrZXIgdGFzayB3YXMgdGVybWluYXRlZCIpfX1jbGFzcyBXb3JrZXJNZXNzYWdlSGFuZGxlcntzdGF0aWN7InVuZGVmaW5lZCI9PXR5cGVvZiB3aW5kb3cmJiFlJiYidW5kZWZpbmVkIiE9dHlwZW9mIHNlbGYmJiJmdW5jdGlvbiI9PXR5cGVvZiBzZWxmLnBvc3RNZXNzYWdlJiYib25tZXNzYWdlImluIHNlbGYmJnRoaXMuaW5pdGlhbGl6ZUZyb21Qb3J0KHNlbGYpfXN0YXRpYyBzZXR1cChlLHQpe2xldCBhPSExO2Uub24oInRlc3QiLCh0PT57aWYoIWEpe2E9ITA7ZS5zZW5kKCJ0ZXN0Iix0IGluc3RhbmNlb2YgVWludDhBcnJheSl9fSkpO2Uub24oImNvbmZpZ3VyZSIsKGU9PnshZnVuY3Rpb24gc2V0VmVyYm9zaXR5TGV2ZWwoZSl7TnVtYmVyLmlzSW50ZWdlcihlKSYmKEt0PWUpfShlLnZlcmJvc2l0eSl9KSk7ZS5vbigiR2V0RG9jUmVxdWVzdCIsKGU9PnRoaXMuY3JlYXRlRG9jdW1lbnRIYW5kbGVyKGUsdCkpKX1zdGF0aWMgY3JlYXRlRG9jdW1lbnRIYW5kbGVyKGUsdCl7bGV0IGEscj0hMSxpPW51bGw7Y29uc3Qgbj1uZXcgU2V0LHM9Z2V0VmVyYm9zaXR5TGV2ZWwoKSx7ZG9jSWQ6byxhcGlWZXJzaW9uOmN9PWUsbD0iNS40LjE0OSI7aWYoYyE9PWwpdGhyb3cgbmV3IEVycm9yKGBUaGUgQVBJIHZlcnNpb24gIiR7Y30iIGRvZXMgbm90IG1hdGNoIHRoZSBXb3JrZXIgdmVyc2lvbiAiJHtsfSIuYCk7Y29uc3QgYnVpbGRNc2c9KGUsdCk9PmBUaGUgXGAke2V9LnByb3RvdHlwZVxgIGNvbnRhaW5zIHVuZXhwZWN0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSAiJHt0fSIsIHRodXMgYnJlYWtpbmcgZS5nLiBcYGZvci4uLmluXGAgaXRlcmF0aW9uIG9mICR7ZX1zLmA7Zm9yKGNvbnN0IGUgaW57fSl0aHJvdyBuZXcgRXJyb3IoYnVpbGRNc2coIk9iamVjdCIsZSkpO2Zvcihjb25zdCBlIGluW10pdGhyb3cgbmV3IEVycm9yKGJ1aWxkTXNnKCJBcnJheSIsZSkpO2NvbnN0IGg9bysiX3dvcmtlciI7bGV0IHU9bmV3IE1lc3NhZ2VIYW5kbGVyKGgsbyx0KTtmdW5jdGlvbiBlbnN1cmVOb3RUZXJtaW5hdGVkKCl7aWYocil0aHJvdyBuZXcgRXJyb3IoIldvcmtlciB3YXMgdGVybWluYXRlZCIpfWZ1bmN0aW9uIHN0YXJ0V29ya2VyVGFzayhlKXtuLmFkZChlKX1mdW5jdGlvbiBmaW5pc2hXb3JrZXJUYXNrKGUpe2UuZmluaXNoKCk7bi5kZWxldGUoZSl9YXN5bmMgZnVuY3Rpb24gbG9hZERvY3VtZW50KGUpe2F3YWl0IGEuZW5zdXJlRG9jKCJjaGVja0hlYWRlciIpO2F3YWl0IGEuZW5zdXJlRG9jKCJwYXJzZVN0YXJ0WFJlZiIpO2F3YWl0IGEuZW5zdXJlRG9jKCJwYXJzZSIsW2VdKTthd2FpdCBhLmVuc3VyZURvYygiY2hlY2tGaXJzdFBhZ2UiLFtlXSk7YXdhaXQgYS5lbnN1cmVEb2MoImNoZWNrTGFzdFBhZ2UiLFtlXSk7Y29uc3QgdD1hd2FpdCBhLmVuc3VyZURvYygiaXNQdXJlWGZhIik7aWYodCl7Y29uc3QgZT1uZXcgV29ya2VyVGFzaygibG9hZFhmYVJlc291cmNlcyIpO3N0YXJ0V29ya2VyVGFzayhlKTthd2FpdCBhLmVuc3VyZURvYygibG9hZFhmYVJlc291cmNlcyIsW3UsZV0pO2ZpbmlzaFdvcmtlclRhc2soZSl9Y29uc3RbcixpXT1hd2FpdCBQcm9taXNlLmFsbChbYS5lbnN1cmVEb2MoIm51bVBhZ2VzIiksYS5lbnN1cmVEb2MoImZpbmdlcnByaW50cyIpXSk7cmV0dXJue251bVBhZ2VzOnIsZmluZ2VycHJpbnRzOmksaHRtbEZvclhmYTp0P2F3YWl0IGEuZW5zdXJlRG9jKCJodG1sRm9yWGZhIik6bnVsbH19ZnVuY3Rpb24gc2V0dXBEb2MoZSl7ZnVuY3Rpb24gb25TdWNjZXNzKGUpe2Vuc3VyZU5vdFRlcm1pbmF0ZWQoKTt1LnNlbmQoIkdldERvYyIse3BkZkluZm86ZX0pfWZ1bmN0aW9uIG9uRmFpbHVyZShlKXtlbnN1cmVOb3RUZXJtaW5hdGVkKCk7aWYoZSBpbnN0YW5jZW9mIFBhc3N3b3JkRXhjZXB0aW9uKXtjb25zdCB0PW5ldyBXb3JrZXJUYXNrKGBQYXNzd29yZEV4Y2VwdGlvbjogcmVzcG9uc2UgJHtlLmNvZGV9YCk7c3RhcnRXb3JrZXJUYXNrKHQpO3Uuc2VuZFdpdGhQcm9taXNlKCJQYXNzd29yZFJlcXVlc3QiLGUpLnRoZW4oKGZ1bmN0aW9uKHtwYXNzd29yZDplfSl7ZmluaXNoV29ya2VyVGFzayh0KTthLnVwZGF0ZVBhc3N3b3JkKGUpO3BkZk1hbmFnZXJSZWFkeSgpfSkpLmNhdGNoKChmdW5jdGlvbigpe2ZpbmlzaFdvcmtlclRhc2sodCk7dS5zZW5kKCJEb2NFeGNlcHRpb24iLGUpfSkpfWVsc2UgdS5zZW5kKCJEb2NFeGNlcHRpb24iLHdyYXBSZWFzb24oZSkpfWZ1bmN0aW9uIHBkZk1hbmFnZXJSZWFkeSgpe2Vuc3VyZU5vdFRlcm1pbmF0ZWQoKTtsb2FkRG9jdW1lbnQoITEpLnRoZW4ob25TdWNjZXNzLChmdW5jdGlvbihlKXtlbnN1cmVOb3RUZXJtaW5hdGVkKCk7ZSBpbnN0YW5jZW9mIFhSZWZQYXJzZUV4Y2VwdGlvbj9hLnJlcXVlc3RMb2FkZWRTdHJlYW0oKS50aGVuKChmdW5jdGlvbigpe2Vuc3VyZU5vdFRlcm1pbmF0ZWQoKTtsb2FkRG9jdW1lbnQoITApLnRoZW4ob25TdWNjZXNzLG9uRmFpbHVyZSl9KSk6b25GYWlsdXJlKGUpfSkpfWVuc3VyZU5vdFRlcm1pbmF0ZWQoKTsoYXN5bmMgZnVuY3Rpb24gZ2V0UGRmTWFuYWdlcih7ZGF0YTplLHBhc3N3b3JkOnQsZGlzYWJsZUF1dG9GZXRjaDphLHJhbmdlQ2h1bmtTaXplOnIsbGVuZ3RoOm4sZG9jQmFzZVVybDpzLGVuYWJsZVhmYTpjLGV2YWx1YXRvck9wdGlvbnM6bH0pe2NvbnN0IGg9e3NvdXJjZTpudWxsLGRpc2FibGVBdXRvRmV0Y2g6YSxkb2NCYXNlVXJsOnMsZG9jSWQ6byxlbmFibGVYZmE6YyxldmFsdWF0b3JPcHRpb25zOmwsaGFuZGxlcjp1LGxlbmd0aDpuLHBhc3N3b3JkOnQscmFuZ2VDaHVua1NpemU6cn07aWYoZSl7aC5zb3VyY2U9ZTtyZXR1cm4gbmV3IExvY2FsUGRmTWFuYWdlcihoKX1jb25zdCBkPW5ldyBQREZXb3JrZXJTdHJlYW0odSksZj1kLmdldEZ1bGxSZWFkZXIoKSxnPVByb21pc2Uud2l0aFJlc29sdmVycygpO2xldCBwLG09W10sYj0wO2YuaGVhZGVyc1JlYWR5LnRoZW4oKGZ1bmN0aW9uKCl7aWYoZi5pc1JhbmdlU3VwcG9ydGVkKXtoLnNvdXJjZT1kO2gubGVuZ3RoPWYuY29udGVudExlbmd0aDtoLmRpc2FibGVBdXRvRmV0Y2h8fD1mLmlzU3RyZWFtaW5nU3VwcG9ydGVkO3A9bmV3IE5ldHdvcmtQZGZNYW5hZ2VyKGgpO2Zvcihjb25zdCBlIG9mIG0pcC5zZW5kUHJvZ3Jlc3NpdmVEYXRhKGUpO209W107Zy5yZXNvbHZlKHApO2k9bnVsbH19KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2cucmVqZWN0KGUpO2k9bnVsbH0pKTtuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSx0KXtjb25zdCByZWFkQ2h1bms9ZnVuY3Rpb24oe3ZhbHVlOmUsZG9uZTphfSl7dHJ5e2Vuc3VyZU5vdFRlcm1pbmF0ZWQoKTtpZihhKXtpZighcCl7Y29uc3QgZT1hcnJheUJ1ZmZlcnNUb0J5dGVzKG0pO209W107biYmZS5sZW5ndGghPT1uJiZ3YXJuKCJyZXBvcnRlZCBIVFRQIGxlbmd0aCBpcyBkaWZmZXJlbnQgZnJvbSBhY3R1YWwiKTtoLnNvdXJjZT1lO3A9bmV3IExvY2FsUGRmTWFuYWdlcihoKTtnLnJlc29sdmUocCl9aT1udWxsO3JldHVybn1iKz1lLmJ5dGVMZW5ndGg7Zi5pc1N0cmVhbWluZ1N1cHBvcnRlZHx8dS5zZW5kKCJEb2NQcm9ncmVzcyIse2xvYWRlZDpiLHRvdGFsOk1hdGgubWF4KGIsZi5jb250ZW50TGVuZ3RofHwwKX0pO3A/cC5zZW5kUHJvZ3Jlc3NpdmVEYXRhKGUpOm0ucHVzaChlKTtmLnJlYWQoKS50aGVuKHJlYWRDaHVuayx0KX1jYXRjaChlKXt0KGUpfX07Zi5yZWFkKCkudGhlbihyZWFkQ2h1bmssdCl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2cucmVqZWN0KGUpO2k9bnVsbH0pKTtpPWU9PntkLmNhbmNlbEFsbFJlcXVlc3RzKGUpfTtyZXR1cm4gZy5wcm9taXNlfSkoZSkudGhlbigoZnVuY3Rpb24oZSl7aWYocil7ZS50ZXJtaW5hdGUobmV3IEFib3J0RXhjZXB0aW9uKCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuIikpO3Rocm93IG5ldyBFcnJvcigiV29ya2VyIHdhcyB0ZXJtaW5hdGVkIil9YT1lO2EucmVxdWVzdExvYWRlZFN0cmVhbSghMCkudGhlbigoZT0+e3Uuc2VuZCgiRGF0YUxvYWRlZCIse2xlbmd0aDplLmJ5dGVzLmJ5dGVMZW5ndGh9KX0pKX0pKS50aGVuKHBkZk1hbmFnZXJSZWFkeSxvbkZhaWx1cmUpfXUub24oIkdldFBhZ2UiLChmdW5jdGlvbihlKXtyZXR1cm4gYS5nZXRQYWdlKGUucGFnZUluZGV4KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5hbGwoW2EuZW5zdXJlKGUsInJvdGF0ZSIpLGEuZW5zdXJlKGUsInJlZiIpLGEuZW5zdXJlKGUsInVzZXJVbml0IiksYS5lbnN1cmUoZSwidmlldyIpXSkudGhlbigoZnVuY3Rpb24oW2UsdCxhLHJdKXtyZXR1cm57cm90YXRlOmUscmVmOnQscmVmU3RyOnQ/LnRvU3RyaW5nKCk/P251bGwsdXNlclVuaXQ6YSx2aWV3OnJ9fSkpfSkpfSkpO3Uub24oIkdldFBhZ2VJbmRleCIsKGZ1bmN0aW9uKGUpe2NvbnN0IHQ9UmVmLmdldChlLm51bSxlLmdlbik7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygiZ2V0UGFnZUluZGV4IixbdF0pfSkpO3Uub24oIkdldERlc3RpbmF0aW9ucyIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmVuc3VyZUNhdGFsb2coImRlc3RpbmF0aW9ucyIpfSkpO3Uub24oIkdldERlc3RpbmF0aW9uIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygiZ2V0RGVzdGluYXRpb24iLFtlLmlkXSl9KSk7dS5vbigiR2V0UGFnZUxhYmVscyIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmVuc3VyZUNhdGFsb2coInBhZ2VMYWJlbHMiKX0pKTt1Lm9uKCJHZXRQYWdlTGF5b3V0IiwoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygicGFnZUxheW91dCIpfSkpO3Uub24oIkdldFBhZ2VNb2RlIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygicGFnZU1vZGUiKX0pKTt1Lm9uKCJHZXRWaWV3ZXJQcmVmZXJlbmNlcyIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmVuc3VyZUNhdGFsb2coInZpZXdlclByZWZlcmVuY2VzIil9KSk7dS5vbigiR2V0T3BlbkFjdGlvbiIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmVuc3VyZUNhdGFsb2coIm9wZW5BY3Rpb24iKX0pKTt1Lm9uKCJHZXRBdHRhY2htZW50cyIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmVuc3VyZUNhdGFsb2coImF0dGFjaG1lbnRzIil9KSk7dS5vbigiR2V0RG9jSlNBY3Rpb25zIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygianNBY3Rpb25zIil9KSk7dS5vbigiR2V0UGFnZUpTQWN0aW9ucyIsKGZ1bmN0aW9uKHtwYWdlSW5kZXg6ZX0pe3JldHVybiBhLmdldFBhZ2UoZSkudGhlbigoZT0+YS5lbnN1cmUoZSwianNBY3Rpb25zIikpKX0pKTt1Lm9uKCJHZXRBbm5vdGF0aW9uc0J5VHlwZSIsKGFzeW5jIGZ1bmN0aW9uKHt0eXBlczplLHBhZ2VJbmRleGVzVG9Ta2lwOnR9KXtjb25zdFtyLGldPWF3YWl0IFByb21pc2UuYWxsKFthLmVuc3VyZURvYygibnVtUGFnZXMiKSxhLmVuc3VyZURvYygiYW5ub3RhdGlvbkdsb2JhbHMiKV0pO2lmKCFpKXJldHVybiBudWxsO2NvbnN0IG49W10scz1bXTtsZXQgbz1udWxsO3RyeXtmb3IobGV0IGM9MCxsPXI7YzxsO2MrKylpZighdD8uaGFzKGMpKXtpZighbyl7bz1uZXcgV29ya2VyVGFzaygiR2V0QW5ub3RhdGlvbnNCeVR5cGUiKTtzdGFydFdvcmtlclRhc2sobyl9bi5wdXNoKGEuZ2V0UGFnZShjKS50aGVuKChhc3luYyB0PT50JiZ0LmNvbGxlY3RBbm5vdGF0aW9uc0J5VHlwZSh1LG8sZSxzLGkpfHxbXSkpKX1hd2FpdCBQcm9taXNlLmFsbChuKTtyZXR1cm4oYXdhaXQgUHJvbWlzZS5hbGwocykpLmZpbHRlcigoZT0+ISFlKSl9ZmluYWxseXtvJiZmaW5pc2hXb3JrZXJUYXNrKG8pfX0pKTt1Lm9uKCJHZXRPdXRsaW5lIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygiZG9jdW1lbnRPdXRsaW5lIil9KSk7dS5vbigiR2V0T3B0aW9uYWxDb250ZW50Q29uZmlnIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZW5zdXJlQ2F0YWxvZygib3B0aW9uYWxDb250ZW50Q29uZmlnIil9KSk7dS5vbigiR2V0UGVybWlzc2lvbnMiLChmdW5jdGlvbihlKXtyZXR1cm4gYS5lbnN1cmVDYXRhbG9nKCJwZXJtaXNzaW9ucyIpfSkpO3Uub24oIkdldE1ldGFkYXRhIiwoZnVuY3Rpb24oZSl7cmV0dXJuIFByb21pc2UuYWxsKFthLmVuc3VyZURvYygiZG9jdW1lbnRJbmZvIiksYS5lbnN1cmVDYXRhbG9nKCJtZXRhZGF0YSIpXSl9KSk7dS5vbigiR2V0TWFya0luZm8iLChmdW5jdGlvbihlKXtyZXR1cm4gYS5lbnN1cmVDYXRhbG9nKCJtYXJrSW5mbyIpfSkpO3Uub24oIkdldERhdGEiLChmdW5jdGlvbihlKXtyZXR1cm4gYS5yZXF1ZXN0TG9hZGVkU3RyZWFtKCkudGhlbigoZT0+ZS5ieXRlcykpfSkpO3Uub24oIkdldEFubm90YXRpb25zIiwoZnVuY3Rpb24oe3BhZ2VJbmRleDplLGludGVudDp0fSl7cmV0dXJuIGEuZ2V0UGFnZShlKS50aGVuKChmdW5jdGlvbihhKXtjb25zdCByPW5ldyBXb3JrZXJUYXNrKGBHZXRBbm5vdGF0aW9uczogcGFnZSAke2V9YCk7c3RhcnRXb3JrZXJUYXNrKHIpO3JldHVybiBhLmdldEFubm90YXRpb25zRGF0YSh1LHIsdCkudGhlbigoZT0+e2ZpbmlzaFdvcmtlclRhc2socik7cmV0dXJuIGV9KSwoZT0+e2ZpbmlzaFdvcmtlclRhc2socik7dGhyb3cgZX0pKX0pKX0pKTt1Lm9uKCJHZXRGaWVsZE9iamVjdHMiLChmdW5jdGlvbihlKXtyZXR1cm4gYS5lbnN1cmVEb2MoImZpZWxkT2JqZWN0cyIpLnRoZW4oKGU9PmU/LmFsbEZpZWxkc3x8bnVsbCkpfSkpO3Uub24oIkhhc0pTQWN0aW9ucyIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmVuc3VyZURvYygiaGFzSlNBY3Rpb25zIil9KSk7dS5vbigiR2V0Q2FsY3VsYXRpb25PcmRlcklkcyIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmVuc3VyZURvYygiY2FsY3VsYXRpb25PcmRlcklkcyIpfSkpO3Uub24oIlNhdmVEb2N1bWVudCIsKGFzeW5jIGZ1bmN0aW9uKHtpc1B1cmVYZmE6ZSxudW1QYWdlczp0LGFubm90YXRpb25TdG9yYWdlOnIsZmlsZW5hbWU6aX0pe2NvbnN0IG49W2EucmVxdWVzdExvYWRlZFN0cmVhbSgpLGEuZW5zdXJlQ2F0YWxvZygiYWNyb0Zvcm0iKSxhLmVuc3VyZUNhdGFsb2coImFjcm9Gb3JtUmVmIiksYS5lbnN1cmVEb2MoInN0YXJ0WFJlZiIpLGEuZW5zdXJlRG9jKCJ4cmVmIiksYS5lbnN1cmVEb2MoImxpbmVhcml6YXRpb24iKSxhLmVuc3VyZUNhdGFsb2coInN0cnVjdFRyZWVSb290IildLHM9bmV3IFJlZlNldENhY2hlLG89W10sYz1lP251bGw6Z2V0TmV3QW5ub3RhdGlvbnNNYXAociksW2wsaCxkLGYsZyxwLG1dPWF3YWl0IFByb21pc2UuYWxsKG4pLGI9Zy50cmFpbGVyLmdldFJhdygiUm9vdCIpfHxudWxsO2xldCB5O2lmKGMpe20/YXdhaXQgbS5jYW5VcGRhdGVTdHJ1Y3RUcmVlKHtwZGZNYW5hZ2VyOmEsbmV3QW5ub3RhdGlvbnNCeVBhZ2U6Y30pJiYoeT1tKTphd2FpdCBTdHJ1Y3RUcmVlUm9vdC5jYW5DcmVhdGVTdHJ1Y3R1cmVUcmVlKHtjYXRhbG9nUmVmOmIscGRmTWFuYWdlcjphLG5ld0Fubm90YXRpb25zQnlQYWdlOmN9KSYmKHk9bnVsbCk7Y29uc3QgZT1Bbm5vdGF0aW9uRmFjdG9yeS5nZW5lcmF0ZUltYWdlcyhyLnZhbHVlcygpLGcsYS5ldmFsdWF0b3JPcHRpb25zLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKSx0PXZvaWQgMD09PXk/bzpbXTtmb3IoY29uc3RbcixpXW9mIGMpdC5wdXNoKGEuZ2V0UGFnZShyKS50aGVuKCh0PT57Y29uc3QgYT1uZXcgV29ya2VyVGFzayhgU2F2ZSAoZWRpdG9yKTogcGFnZSAke3J9YCk7c3RhcnRXb3JrZXJUYXNrKGEpO3JldHVybiB0LnNhdmVOZXdBbm5vdGF0aW9ucyh1LGEsaSxlLHMpLmZpbmFsbHkoKGZ1bmN0aW9uKCl7ZmluaXNoV29ya2VyVGFzayhhKX0pKX0pKSk7bnVsbD09PXk/by5wdXNoKFByb21pc2UuYWxsKHQpLnRoZW4oKGFzeW5jKCk9Pnthd2FpdCBTdHJ1Y3RUcmVlUm9vdC5jcmVhdGVTdHJ1Y3R1cmVUcmVlKHtuZXdBbm5vdGF0aW9uc0J5UGFnZTpjLHhyZWY6ZyxjYXRhbG9nUmVmOmIscGRmTWFuYWdlcjphLGNoYW5nZXM6c30pfSkpKTp5JiZvLnB1c2goUHJvbWlzZS5hbGwodCkudGhlbigoYXN5bmMoKT0+e2F3YWl0IHkudXBkYXRlU3RydWN0dXJlVHJlZSh7bmV3QW5ub3RhdGlvbnNCeVBhZ2U6YyxwZGZNYW5hZ2VyOmEsY2hhbmdlczpzfSl9KSkpfWlmKGUpby5wdXNoKGEuZW5zdXJlRG9jKCJzZXJpYWxpemVYZmFEYXRhIixbcl0pKTtlbHNlIGZvcihsZXQgZT0wO2U8dDtlKyspby5wdXNoKGEuZ2V0UGFnZShlKS50aGVuKChmdW5jdGlvbih0KXtjb25zdCBhPW5ldyBXb3JrZXJUYXNrKGBTYXZlOiBwYWdlICR7ZX1gKTtzdGFydFdvcmtlclRhc2soYSk7cmV0dXJuIHQuc2F2ZSh1LGEscixzKS5maW5hbGx5KChmdW5jdGlvbigpe2ZpbmlzaFdvcmtlclRhc2soYSl9KSl9KSkpO2NvbnN0IHc9YXdhaXQgUHJvbWlzZS5hbGwobyk7bGV0IHg9bnVsbDtpZihlKXt4PXdbMF07aWYoIXgpcmV0dXJuIGwuYnl0ZXN9ZWxzZSBpZigwPT09cy5zaXplKXJldHVybiBsLmJ5dGVzO2NvbnN0IFM9ZCYmaCBpbnN0YW5jZW9mIERpY3QmJnMudmFsdWVzKCkuc29tZSgoZT0+ZS5uZWVkQXBwZWFyYW5jZXMpKSxrPWggaW5zdGFuY2VvZiBEaWN0JiZoLmdldCgiWEZBIil8fG51bGw7bGV0IEM9bnVsbCx2PSExO2lmKEFycmF5LmlzQXJyYXkoaykpe2ZvcihsZXQgZT0wLHQ9ay5sZW5ndGg7ZTx0O2UrPTIpaWYoImRhdGFzZXRzIj09PWtbZV0pe0M9a1tlKzFdO3Y9ITB9bnVsbD09PUMmJihDPWcuZ2V0TmV3VGVtcG9yYXJ5UmVmKCkpfWVsc2UgayYmd2FybigiVW5zdXBwb3J0ZWQgWEZBIHR5cGUuIik7bGV0IEY9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihnLnRyYWlsZXIpe2NvbnN0IGU9bmV3IE1hcCx0PWcudHJhaWxlci5nZXQoIkluZm8iKXx8bnVsbDtpZih0IGluc3RhbmNlb2YgRGljdClmb3IoY29uc3RbYSxyXW9mIHQpInN0cmluZyI9PXR5cGVvZiByJiZlLnNldChhLHN0cmluZ1RvUERGU3RyaW5nKHIpKTtGPXtyb290UmVmOmIsZW5jcnlwdFJlZjpnLnRyYWlsZXIuZ2V0UmF3KCJFbmNyeXB0Iil8fG51bGwsbmV3UmVmOmcuZ2V0TmV3VGVtcG9yYXJ5UmVmKCksaW5mb1JlZjpnLnRyYWlsZXIuZ2V0UmF3KCJJbmZvIil8fG51bGwsaW5mb01hcDplLGZpbGVJZHM6Zy50cmFpbGVyLmdldCgiSUQiKXx8bnVsbCxzdGFydFhSZWY6cD9mOmcubGFzdFhSZWZTdHJlYW1Qb3M/P2YsZmlsZW5hbWU6aX19cmV0dXJuIGluY3JlbWVudGFsVXBkYXRlKHtvcmlnaW5hbERhdGE6bC5ieXRlcyx4cmVmSW5mbzpGLGNoYW5nZXM6cyx4cmVmOmcsaGFzWGZhOiEhayx4ZmFEYXRhc2V0c1JlZjpDLGhhc1hmYURhdGFzZXRzRW50cnk6dixuZWVkQXBwZWFyYW5jZXM6UyxhY3JvRm9ybVJlZjpkLGFjcm9Gb3JtOmgseGZhRGF0YTp4LHVzZVhyZWZTdHJlYW06aXNEaWN0KGcudG9wRGljdCwiWFJlZiIpfSkuZmluYWxseSgoKCk9PntnLnJlc2V0TmV3VGVtcG9yYXJ5UmVmKCl9KSl9KSk7dS5vbigiR2V0T3BlcmF0b3JMaXN0IiwoZnVuY3Rpb24oZSx0KXtjb25zdCByPWUucGFnZUluZGV4O2EuZ2V0UGFnZShyKS50aGVuKChmdW5jdGlvbihhKXtjb25zdCBpPW5ldyBXb3JrZXJUYXNrKGBHZXRPcGVyYXRvckxpc3Q6IHBhZ2UgJHtyfWApO3N0YXJ0V29ya2VyVGFzayhpKTtjb25zdCBuPXM+PW5lP0RhdGUubm93KCk6MDthLmdldE9wZXJhdG9yTGlzdCh7aGFuZGxlcjp1LHNpbms6dCx0YXNrOmksaW50ZW50OmUuaW50ZW50LGNhY2hlS2V5OmUuY2FjaGVLZXksYW5ub3RhdGlvblN0b3JhZ2U6ZS5hbm5vdGF0aW9uU3RvcmFnZSxtb2RpZmllZElkczplLm1vZGlmaWVkSWRzfSkudGhlbigoZnVuY3Rpb24oZSl7ZmluaXNoV29ya2VyVGFzayhpKTtuJiZpbmZvKGBwYWdlPSR7cisxfSAtIGdldE9wZXJhdG9yTGlzdDogdGltZT0ke0RhdGUubm93KCktbn1tcywgbGVuPSR7ZS5sZW5ndGh9YCk7dC5jbG9zZSgpfSksKGZ1bmN0aW9uKGUpe2ZpbmlzaFdvcmtlclRhc2soaSk7aS50ZXJtaW5hdGVkfHx0LmVycm9yKGUpfSkpfSkpfSkpO3Uub24oIkdldFRleHRDb250ZW50IiwoZnVuY3Rpb24oZSx0KXtjb25zdHtwYWdlSW5kZXg6cixpbmNsdWRlTWFya2VkQ29udGVudDppLGRpc2FibGVOb3JtYWxpemF0aW9uOm59PWU7YS5nZXRQYWdlKHIpLnRoZW4oKGZ1bmN0aW9uKGUpe2NvbnN0IGE9bmV3IFdvcmtlclRhc2soIkdldFRleHRDb250ZW50OiBwYWdlICIrcik7c3RhcnRXb3JrZXJUYXNrKGEpO2NvbnN0IG89cz49bmU/RGF0ZS5ub3coKTowO2UuZXh0cmFjdFRleHRDb250ZW50KHtoYW5kbGVyOnUsdGFzazphLHNpbms6dCxpbmNsdWRlTWFya2VkQ29udGVudDppLGRpc2FibGVOb3JtYWxpemF0aW9uOm59KS50aGVuKChmdW5jdGlvbigpe2ZpbmlzaFdvcmtlclRhc2soYSk7byYmaW5mbyhgcGFnZT0ke3IrMX0gLSBnZXRUZXh0Q29udGVudDogdGltZT1gKyhEYXRlLm5vdygpLW8pKyJtcyIpO3QuY2xvc2UoKX0pLChmdW5jdGlvbihlKXtmaW5pc2hXb3JrZXJUYXNrKGEpO2EudGVybWluYXRlZHx8dC5lcnJvcihlKX0pKX0pKX0pKTt1Lm9uKCJHZXRTdHJ1Y3RUcmVlIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZ2V0UGFnZShlLnBhZ2VJbmRleCkudGhlbigoZT0+YS5lbnN1cmUoZSwiZ2V0U3RydWN0VHJlZSIpKSl9KSk7dS5vbigiRm9udEZhbGxiYWNrIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZm9udEZhbGxiYWNrKGUuaWQsdSl9KSk7dS5vbigiQ2xlYW51cCIsKGZ1bmN0aW9uKGUpe3JldHVybiBhLmNsZWFudXAoITApfSkpO3Uub24oIlRlcm1pbmF0ZSIsKGZ1bmN0aW9uKGUpe3I9ITA7Y29uc3QgdD1bXTtpZihhKXthLnRlcm1pbmF0ZShuZXcgQWJvcnRFeGNlcHRpb24oIldvcmtlciB3YXMgdGVybWluYXRlZC4iKSk7Y29uc3QgZT1hLmNsZWFudXAoKTt0LnB1c2goZSk7YT1udWxsfWVsc2UgY2xlYXJHbG9iYWxDYWNoZXMoKTtpPy4obmV3IEFib3J0RXhjZXB0aW9uKCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuIikpO2Zvcihjb25zdCBlIG9mIG4pe3QucHVzaChlLmZpbmlzaGVkKTtlLnRlcm1pbmF0ZSgpfXJldHVybiBQcm9taXNlLmFsbCh0KS50aGVuKChmdW5jdGlvbigpe3UuZGVzdHJveSgpO3U9bnVsbH0pKX0pKTt1Lm9uKCJSZWFkeSIsKGZ1bmN0aW9uKHQpe3NldHVwRG9jKGUpO2U9bnVsbH0pKTtyZXR1cm4gaH1zdGF0aWMgaW5pdGlhbGl6ZUZyb21Qb3J0KGUpe2NvbnN0IHQ9bmV3IE1lc3NhZ2VIYW5kbGVyKCJ3b3JrZXIiLCJtYWluIixlKTt0aGlzLnNldHVwKHQsZSk7dC5zZW5kKCJyZWFkeSIsbnVsbCl9fWdsb2JhbFRoaXMucGRmanNXb3JrZXI9e1dvcmtlck1lc3NhZ2VIYW5kbGVyfTtleHBvcnR7V29ya2VyTWVzc2FnZUhhbmRsZXJ9Ow==";
  const pdf_worker_min$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: pdf_worker_min
  }, Symbol.toStringTag, { value: "Module" }));
  exports2.PDFParse = PDFParse;
  exports2.pdf = pdf;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
}));
